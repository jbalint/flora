/* File:      flrporting.P  -- Non-standard Prolog predicates used in Flora
**
** Author(s): Michael Kifer
**
** Contact:   flora-users@lists.sourceforge.net
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2013.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**      http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
**
*/


:- compiler_options([xpp_on,spec_off]).

#include "token_defs_xsb.h"
#include "psc_defs.h"
#include "celltags_xsb.h"
#include "version.flh"
%% Forward slash is ok here, because XSB understands this even on Windows
#include "flrincludes/flora_var_attributes.flh"
#include "flrincludes/flora_porting.flh"
#include "flrincludes/flora_exceptions.flh"
#include "flrincludes/flora_characters.flh"
%% DO NOT include any other FLORA .flh files here, or else FLORA won't
%% build correctly when installed outside of the XSB tree


:- import conget/2, conset/2 from gensym.
:- import eval/2 from eval.
:- import
        %%term_type/2,
        term_psc/2,
        psc_type/2,
        slash/1,
        str_len/2,
	del_attr/2,
        file_writequoted/2,
        file_puttoken/3
   from machine.
:- import
        substring/4,
	term_to_codes/3,
        term_to_atom/3
   from string.
:- import library_directory/1 from usermod.
:- import xsb_configuration/2 from xsb_configuration.
:- import
        path_sysop/2, path_sysop/3, copyIOport/2,
        file_read_line_atom/1, file_read_line_list/1
        from file_io.

:- import
        %%close_open_tables/1,
        xsb_backtrace/1
   from machine.

:- import
        select/3,
	append/3,
        reverse/2
   from basics.

:- import banner_control/1 from banner.

:- import flora_configuration/2 from flrregistry.

:- export
        flora_write_quoted_atom/1,
        flora_write_atom_quoted_as_needed/1,
        flora_write_atom/1,
        flora_file_op/2,
        flora_file_op/3,
        flora_read_line_as_atom/1,
        flora_read_line_as_list/1,
        flora_copy_input/0,
        flora_copy_input/2,

        flora_slash/1,
        flora_running_under/1,
        flora_user_home/1,
        flora_install_dir/1,
        flora_user_floradir/1,
        flora_build_id/1,
        flora_build_date/1,
        flora_abort/0,
        flora_abort/1,
        flora_abort/2,

        flora_predicate_is_defined_lowlevel/1,

        flora_atom_length/2,
        flora_match_substring/3,
        flora_match_substring/5,
        flora_get_substring/4,
        flora_term_to_atom/2,
        flora_term_to_atom_quote/2,
        flora_concat_items/2,
        flora_concat_atoms/2,
        flora_concat_strings/2,
        flora_set_counter/2,
        flora_get_counter/2,
        flora_increment_counter/4,
        flora_cputime/1,
        flora_walltime/1,
        flora_module_path_get/1,
        flora_module_path_add/1,
        flora_module_path_remove/1,
        flora_banner_control/1,
        flora_delete_from_list/3,
        flora_double_backslash/2,
        flora_double_quotes/2,
        flora_double_backslash_and_quotes/2,
        flora_convert_backslash_to_forward/2,
        flora_convert_win_path_to_cygwin/2.


flora_term_to_atom(Term,Atom) :-
        term_to_atom(Term,Atom,[ignore_ops(canonical),quoted(false)]).
        %%fmt_write_string(AtomN,'%S',arg(Term)),
        %%Atom = AtomN.

flora_term_to_atom_quote(Term,Atom) :-
        term_to_codes(Term,[ignore_ops(canonical),quoted(true)],Codes),
	Codes=[C|_],
	(C == CH_QUOTE -> atom_codes(Atom,Codes)
	; append([CH_QUOTE|Codes],[CH_QUOTE],CodesQ),
	    atom_codes(Atom,CodesQ)
	).
        %%term_to_atom(Term,Atom,[ignore_ops(canonical),quoted(true)]).
        %%fmt_write_string(Atom,'%S',arg(Term)).

%% This concats items or any type - atoms, numbers, etc.
flora_concat_items(List,Atom) :-
        copy_term(List,List1),
	bind_vars_meaningfully(List1),
	my_concat_atom(List1,Atom,_).
/*
flora_concat_items(List,Atom) :-
        copy_term(List,List1),
        %% this is done because otherwise term_to_atom will convert
        %% every variable to _h0. With numbervars, each variable is
        %% encoded as $VAR(XYZ), with different variables getting
        %% different names, and then term_to_atom decodes them to XYZ.
        %%num_vars:numbervars(List1,0,_,[attvar(bind)]),
        flora_concat_items_aux(List1,Atom).

%% Make the most common case fast!
flora_concat_items_aux([Item1,Item2],Atom) :-
        !,
        %%term_to_atom(Item1,Item1atm,[ignore_ops(canonical),quoted(false),numbervars(true)]),
        %%term_to_atom(Item2,Item2atm,[ignore_ops(canonical),quoted(false),numbervars(true)]),
        %%atom_concat(Item1atm,Item2atm,Atom).
        fmt_write_string(AtomN, '%S%S', arg(Item1,Item2)),
        Atom = AtomN.
flora_concat_items_aux([Item|ItemList],Atom) :-
        %%term_to_atom(Item,Atom1,[ignore_ops(canonical),quoted(false),numbervars(true)]),
        fmt_write_string(Atom1, '%S', arg(Item)),
        flora_concat_items_aux(ItemList,Atom2),
        %%atom_concat(Atom1,Atom2,Atom).
        fmt_write_string(AtomN, '%S%S', arg(Atom1,Atom2)),
        Atom = AtomN.
flora_concat_items_aux([],'').
*/

/*
%% this was an experiment
:- export flora_concat_items_aux3/3, flora_concat_items_aux/2.
flora_concat_items_aux3([],Atom,Atom) :- !.
flora_concat_items_aux3([Item|ItemList],Head,Atom) :-
        fmt_write_string(Head1,'%S%s', arg(Head,Item)),
        flora_concat_items_aux3(ItemList,Head1,Atom).
*/

%% If all members are atoms, this is more efficient
%% Make the most common case fast!
flora_concat_atoms(AtomList,Atom) :- my_concat_atom(AtomList,Atom,_).
/*
flora_concat_atoms([Atom1,Atom2],Atom) :-
        !,
        %%atom_concat(Atom1,Atom2,Atom).
        fmt_write_string(AtomN, '%S%S', arg(Atom1,Atom2)),
        Atom = AtomN.
flora_concat_atoms([Atom1|AtomList],Atom) :-
        flora_concat_atoms(AtomList,Atom2),
        %%atom_concat(Atom1,Atom2,Atom).
        fmt_write_string(AtomN, '%S%S', arg(Atom1,Atom2)),
        Atom = AtomN.
flora_concat_atoms([],'').
*/

%% This concats atoms or charlists
flora_concat_strings(L,Atom) :- my_concat_atom(L,Atom,strings).
/*
flora_concat_strings([S1,S2],Atom) :-
        !,
        string_to_atom(S1,A1),
        string_to_atom(S2,A2),
        %%atom_concat(A1,A2,Atom).
        fmt_write_string(AtomN, '%S%S', arg(A1,A2)),
        Atom = AtomN.
flora_concat_strings([S1|SList],Atom) :-
        flora_concat_strings(SList,A2),
        string_to_atom(S1,A1),
        %%atom_concat(A1,A2,Atom).
        fmt_write_string(AtomN, '%S%S', arg(A1,A2)),
        Atom = AtomN.
flora_concat_strings([],'').

string_to_atom(S,A) :-
        (S == "" -> A = ''
        ; atom(S) -> S=A
        ; atom_codes(A,S)
        -> true
        ; flora_abort(['Non-string in flora_concat_strings/2: ', S])
        ).
*/
        


flora_atom_length(Atom,Length) :- str_len(Atom, Length).


flora_get_counter(Counter,Value) :- conget(Counter,Value).
flora_set_counter(Counter,Value) :- conset(Counter,Value).
flora_increment_counter(Counter,Increment,OldValue,NewValue) :-
        eval(Increment,I),
        conget(Counter,OldValue),
        NewValue is OldValue + I,
        conset(Counter,NewValue).

%% Flora wrappers for str_match in XSB's syslib/string.P
%% Checks if Substr matches Str in a given direction and at the right position
flora_match_substring(Substr,Str,Pos) :-
        str_match(Substr,Str,forward,Pos,_).
flora_match_substring(Sub,Str,Direction,Beg,End) :-
        str_match(Sub,Str,Direction,Beg,End).

%% extract substring Subst from String at positions From - To
flora_get_substring(String,From,To,Subst) :- substring(String,From,To,Subst).

flora_slash(Slash) :- slash(Slash).

flora_cputime(X) :- cputime(X).
flora_walltime(X) :- walltime(X).


%% Manipulation of module search path
%% Yap uses path/1, add_to_path/1, remove_from_path/1
flora_module_path_add(Path)    :- assert(library_directory(Path)).
flora_module_path_remove(Path) :- retractall(library_directory(Path)).

flora_module_path_get('.').
flora_module_path_get(Path) :- library_directory(Path).
flora_module_path_get(Path) :-
        xsb_configuration(libdir,LibPath), LibPath = Path.
flora_module_path_get(Path) :-
        xsb_configuration(syslibdir,SyslibPath), SyslibPath=Path.
flora_module_path_get(Path) :-
        xsb_configuration(cmplibdir,CmplibPath), CmplibPath = Path.


%% User Home
flora_user_home(Path) :- xsb_configuration(user_home,Path).

%% where Flora is installed
flora_install_dir(Path) :- flora_configuration(installdir,Path).

/*************************************************************************
  flora_user_floradir(-Dir)
*************************************************************************/
flora_user_floradir(Dir) :-
	( flora_configuration(userdir,Dir) ->
	    true
	;
	    flora_user_home(UserHome),
	    flora_slash(S),
	    %% something like $HOME/.xsb/flora-version
	    flora_build_id(Build),
	    url_encode(Build,Buildnumber),
	    flora_concat_atoms([UserHome,S,PROLOG_CUSTOM_DIR,S,flora,'-',FLORA_VERSION,'-',Buildnumber],Dir),
	    ( flora_file_op(exists,Dir) -> true
	    ;
		( flora_file_op(mkdir,Dir) -> true
		;
		    flora_abort(['startup failed: cannot create user directory: ',Dir])
		)
	    ),
	    assert(flora_configuration(userdir,Dir))
	),
	!.

%% File system-related
flora_file_op(exists,File)          :- path_sysop(exists,File).
flora_file_op(readable,File)        :- path_sysop(readable,File).
flora_file_op(writable,File)        :- path_sysop(writable,File).
flora_file_op(executable,File)      :- path_sysop(executable,File).
flora_file_op(modtime,File,Time)    :- path_sysop(modtime,File,Time).
flora_file_op(mkdir,Dir)            :- path_sysop(mkdir,Dir).
flora_file_op(rmdir,Dir)            :- path_sysop(rmdir,Dir).
flora_file_op(chdir,Dir)            :- path_sysop(chdir,Dir).
flora_file_op(cwd,Dir)              :- path_sysop(cwd,Dir).
flora_file_op(link,Srs,Dest)        :- path_sysop(link,Srs,Dest).
flora_file_op(unlink,File)          :- path_sysop(unlink,File).
flora_file_op(rm,File)              :- path_sysop(unlink,File).
flora_file_op(tmpfilename,File)     :- path_sysop(tmpfilename,File).
flora_file_op(isabsolute,File)      :- path_sysop(isabsolute,File).
flora_file_op(rename,File,ToFile)   :- path_sysop(rename,File,ToFile).
flora_file_op(basename,File,Base)   :- path_sysop(basename,File,Base).
flora_file_op(localname,File,Local)  :-
	path_sysop(basename,File,Base),
	path_sysop(extension,File,Ext),
	fmt_write_string(Local, '%s.%s', arg(Base,Ext)).
flora_file_op(extension,File,Ext)   :- path_sysop(extension,File,Ext).
flora_file_op(expand,File,Expanded) :- path_sysop(expand,File,Expanded).
flora_file_op(newerthan,File,File2) :- path_sysop(newerthan,File,File2).
flora_file_op(dirname,File,Dir)     :- path_sysop(dirname,File,Dir).
flora_file_op(copy,From,To)         :- path_sysop(copy,From,To).


%% Copies stdin to stdout
flora_copy_input :-
	seeing(StdIn),
	telling(StdOut),
	copyIOport(StdIn,StdOut).

%% From, To are file names. Variable means stdin or stdout, respectively
flora_copy_input(From,To) :-
	(var(From), !  ; seeing(OldIn), see(From)),
	(var(To), !    ; telling(OldOut), tell(To)),
	flora_copy_input,
	(var(From), !  ; seen, see(OldIn)),
	(var(To), !    ; told, tell(OldOut)).


flora_write_atom_quoted_as_needed(Atom) :-
	\+atom(Atom),
	flora_abort(['flora_write_atom_quoted_as_needed: Non-atom argument, ', Atom]).
flora_write_atom_quoted_as_needed(Atom) :-
	telling(StdOut),
	file_writequoted(StdOut,Atom).

%% Write atoms in correct form for reading. Always quote, even if not necessary
%% currently does not put quotes around, and it is not really needed.
%% But we could add  write_quotedname in emu/io_builtins_xsb.c and make
%% it do so that it will always put the quotes.
flora_write_quoted_atom(Atom) :-
	!,
	flora_write_atom_quoted_as_needed(Atom).
/*
flora_write_quoted_atom(Atom) :-
	\+atom(Atom),
	flora_abort(['flora_write_quoted_atom: Non-atom argument, ', Atom]).
flora_write_quoted_atom(Atom) :-
	atom_codes(Atom,Codes),
	put(CH_QUOTE),
	write_atom_doubling_quotes(Codes),
	put(CH_QUOTE).

write_atom_doubling_quotes([]) :- !.
write_atom_doubling_quotes([CH_QUOTE|Rest]) :-
	!,
	put(CH_QUOTE),
	put(CH_QUOTE),
	write_atom_doubling_quotes(Rest).
write_atom_doubling_quotes([Ch|Rest]) :-
	put(Ch),
	write_atom_doubling_quotes(Rest).
*/

%% Unquoted atom
flora_write_atom(Atom) :-
	telling(StdOut),
	file_puttoken(StdOut,TK_ATOM,Atom).

flora_read_line_as_atom(Str) :- file_read_line_atom(Str).
flora_read_line_as_list(Str) :- file_read_line_list(Str).


:- table flora_running_under/1.

flora_running_under(cygwin) :-
	xsb_configuration(architecture,A),
	str_sub(cygwin,A),
	!.
flora_running_under(windows) :-
	xsb_configuration(architecture,A),
	str_sub(windows,A),
	!.
flora_running_under(windows64) :-
	xsb_configuration(architecture,A),
	str_sub(windows,A),
	str_sub(x64,A),
	!.
flora_running_under(macos) :-
	xsb_configuration(architecture,A),
	str_sub(darwin,A),
	!.
flora_running_under(darwin) :-
	xsb_configuration(architecture,A),
	str_sub(darwin,A),
	!.
flora_running_under(unix) :-
	\+ flora_running_under(cygwin),
	\+ flora_running_under(windows),
	\+ flora_running_under(macos).


flora_banner_control(X) :- banner_control(X).


flora_convert_win_path_to_cygwin(WinP,CygwinP) :-
	atom_codes(WinP,WinPlist),
	WinPlist = [Letter, 0': | Rest],
	(
	  (0'a =< Letter, Letter =< 0'z)
	; (0'A =< Letter, Letter =< 0'Z)
	),
	!,
	%% Letter drive plus ":"
	convert_backslash_to_forward(Rest,NewRest),
	atom_codes(LetterAtom,[Letter]),
	atom_codes(NewRestAtom,NewRest),
	flora_concat_atoms(['/',cygdrive,'/',LetterAtom,NewRestAtom],CygwinP).
	
	%% If not a window path - leave as is
flora_convert_win_path_to_cygwin(Path,Path).


%% This one takes lists of chars
convert_backslash_to_forward([],[]) :-
	!.
convert_backslash_to_forward([CH_BACKSLASH | Back], [0'/ | Forward]) :-
	!,
	convert_backslash_to_forward(Back,Forward).
convert_backslash_to_forward([Ch | Back], [Ch | Forward]) :-
	convert_backslash_to_forward(Back,Forward).

%% This one takes atoms
flora_convert_backslash_to_forward(X,Y) :-
	atom_codes(X,XX),
	convert_backslash_to_forward(XX,YY),
	atom_codes(Y,YY).


%% Double backslashes
flora_double_backslash(Path,PathDouble) :-
	atom_codes(Path,PathLst),
	double_backslash_list(PathLst,PathLstDouble),
	atom_codes(PathDouble,PathLstDouble).

double_backslash_list([],[]).
double_backslash_list([CH_BACKSLASH|Rest], [CH_BACKSLASH,CH_BACKSLASH|DoubleRest]) :-
	!,
	double_backslash_list(Rest, DoubleRest).
double_backslash_list([Ch|Rest], [Ch|DoubleRest]) :-
	double_backslash_list(Rest, DoubleRest).


%% Double quotes
flora_double_quotes(Path,PathDouble) :-
	atom_codes(Path,PathLst),
	double_quotes_list(PathLst,PathLstDouble),
	atom_codes(PathDouble,PathLstDouble).

double_quotes_list([],[]).
double_quotes_list([CH_QUOTE|Rest], [CH_QUOTE,CH_QUOTE|DoubleRest]) :-
	!,
	double_quotes_list(Rest, DoubleRest).
double_quotes_list([Ch|Rest], [Ch|DoubleRest]) :-
	double_quotes_list(Rest, DoubleRest).


%% Double both backslash and quotes
flora_double_backslash_and_quotes(Path,PathDouble) :-
	atom_codes(Path,PathLst),
	double_backslash_and_quotes_list(PathLst,PathLstDouble),
	atom_codes(PathDouble,PathLstDouble).

double_backslash_and_quotes_list([],[]).
double_backslash_and_quotes_list([CH_BACKSLASH|Rest], [CH_BACKSLASH,CH_BACKSLASH|DoubleRest]) :-
	!,
	double_backslash_and_quotes_list(Rest, DoubleRest).
double_backslash_and_quotes_list([CH_QUOTE|Rest], [CH_QUOTE,CH_QUOTE|DoubleRest]) :-
	!,
	double_backslash_and_quotes_list(Rest, DoubleRest).
double_backslash_and_quotes_list([Ch|Rest], [Ch|DoubleRest]) :-
	double_backslash_and_quotes_list(Rest, DoubleRest).
	

flora_delete_from_list(Elt,List,NewList) :- select(Elt,List,NewList).


flora_abort :-
	xsb_backtrace(Bt),
	%% throw/1 now closes open tables, so do NOT do it here
	%%close_open_tables(abort),
	throw(FLORA_ABORT(Bt)).
flora_abort(Msg) :-
	flora_abort(Msg,FLORA_ABORT).

%% AbortType == FLORA_ABORT_NOTRACE: no backtrace will be printed
flora_abort(Msg,AbortType) :-
	is_list(Msg),
	!,
	flora_concat_items(Msg,AtomMsg),
	xsb_backtrace(Bt),
	%% throw/1 now closes open tables, so do NOT do it here
	%%close_open_tables(abort),
	ThrowMsg =.. [AbortType,AtomMsg,Bt],
	throw(ThrowMsg).
flora_abort(Msg,AbortType) :-
	xsb_backtrace(Bt),
	%% throw/1 now closes open tables, so do NOT do it here
	%%close_open_tables(abort),
	ThrowMsg =.. [AbortType,Msg,Bt],
	throw(ThrowMsg).


flora_build_id(Build) :-
    str_match(': ',FLORA_BUILD,forward,_,BStart),
    str_match('$',FLORA_BUILD,reverse,BEnd,_),
    substring(FLORA_BUILD,BStart,BEnd,BuildSub),
    atom_codes(BuildSub,Codes),
    skip_blanks(Codes,Codes1),
    extract_nonblanks(Codes1,Codes2),
    atom_codes(Build,Codes2),
    !.
flora_build_id(unknown).

flora_build_date(Date) :-
    str_match(': ',FLORA_DATE,forward,_,DStart),
    str_match('$',FLORA_DATE,reverse,DEnd,_),
    substring(FLORA_DATE,DStart,DEnd,DateSub),
    atom_codes(DateSub,Codes),
    skip_blanks(Codes,Codes1),
    reverse(Codes1,Codes2),
    skip_blanks(Codes2,Codes3),
    reverse(Codes3,Codes4),
    atom_codes(Date,Codes4),
    !.
flora_build_date(unknown).
    
skip_blanks(In,Out) :-
	(In = [CH_SPACE|Rest]
	 ->	skip_blanks(Rest,Out)
	 ;	Out = In
	).

extract_nonblanks([],[]) :- !.
extract_nonblanks([CH_SPACE|_],[]) :- !.
extract_nonblanks([Ch|RestIn],[Ch|RestOut]) :-
	extract_nonblanks(RestIn,RestOut).

%% this is a low-level check if Term is a defined predicate
%% used in flrdefeasible.fli
flora_predicate_is_defined_lowlevel(Term) :-
	%%term_type(Term, Type),
	%%Type =:= XSB_STRUCT,
	term_psc(Term, PSC),
	psc_type(PSC, NType),
	(   NType =:= T_PRED; NType =:= T_FORN; NType =:= T_DYNA ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/* 
TLS 7/99 This version is linear rather than quadratic and seems
much faster than the old one (which I must confess to writing).  Also,
this is well-behaved for memory management since it no longer uses
str_cat or str_len.

TLS: 12/03 I thought this might be more useful if I added a flatten,
	so that substrings could be passed in as lists. 
DSW: 3/04 rewritten to single pass for efficiency
*/
 
%% If Switch=strings then character strings are converted to
my_concat_atom(L,A,Switch) :-
        c_atom(L,[],AC,Switch),
        atom_codes(A,AC).

c_atom(A,L0,L,Switch) :-
        (A == []
        ->   L = L0
        ; A @= [_|_],
	    (Switch == strings -> \+is_charlist(A)
	    ; true
	    )
        ->   A = [A1|R],
            (R == []
	    ->  c_atom(A1,L0,L,Switch)
	    ;   c_atom(R,L0,L1,Switch),
		c_atom(A1,L1,L,Switch)
	    )
        ; A @= (_,_)
        ->  A = (A1,R),
            c_atom(R,L0,L1,Switch),
            c_atom(A1,L1,L,Switch)
        ; (atom(A)
	  ->  atom_codes(A,AC)
	  ;   number(A)
	  ->  number_codes(A,AC)
	  ; Switch == strings, is_charlist(A)
	  -> AC = A
	  ;   term_to_codes(A,[ignore_ops(canonical),quoted(false)],AC)
	  ),
            (L0 == []
            ->   L = AC
            ;    append(AC,L0,L)
            )
        ).


bind_vars_meaningfully(L) :-
	bind_vars_meaningfully(L,0).
bind_vars_meaningfully([],_) :- !.
bind_vars_meaningfully([X|R],N) :-
	atomic(X),
	!,
	bind_vars_meaningfully(R,N).
bind_vars_meaningfully([X|R],N) :-
	%% need to figure out how to delete other possible attributes
	del_attr(X,flrwhen),
	del_attr(X,FLDYNRULEVARCHECK),
	number_codes(N,NCode),
	atom_codes(Xname,[0'_,0'h|NCode]),
	X = Xname,
	N1 is N+1,
	bind_vars_meaningfully(R,N1).
