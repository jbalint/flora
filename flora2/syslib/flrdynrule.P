/* File:      flrdynrule.P
**
** Author(s): Chang Zhao
**
** Contact:   flora-users@lists.sourceforge.net
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2013;
**      and Vulcan, Inc., 2008-2013.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**      http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
**
*/


:- compiler_options([xpp_on]).

#include "flora_errors.flh"
#include "flora_terms.flh"
#include "flora_exceptions.flh"

#define GLOBAL_DYN_NEWPREDICATE   '_$$''''dyn_newpredicate'
#define DEFAULT_DYN_RULEID        '_$$''''default_dynruleid'

#define GLOBAL_DYN_NEWPREDICATE_COUNTER  '_$$''''global_dynnewpredicate'
#define GLOBAL_DYN_RULEID_COUNTER        '_$$''''global_dynruleid'

:- import conset/2,conget/2 from gensym.
:- import
	copy_term/2,
	reverse/2,
	memberchk/2,
	append/3,
	length/2
   from basics.
:- import assert/3 from assert.
:- import
	del_attr/2,
	get_attr/3
   from machine.

:- import
	flora_module_registry/1
   from flrregistry.
:- import
        flora_warning_line/1,
        flora_warning_line/2
   from flrprint.
:- import
        flora_abort/0,
        flora_abort/1,
        flora_abort/2,
        flora_concat_items/2,
        flora_concat_atoms/2
   from flrporting.
:- import 
	flora_patch_full_filename/1,
	flora_set_xpp_options_for_compile/1,
	flora_add_xpp_options/1,
	flora_clear_xpp_options/0,
	flora_cleanup_udf/1,
	flora_cleanup_registry/1,
	flloadtrailer/2
   from flrutils.

:- import
	flora_module_predicate/4,
	flora_decode_predicate/6
   from flrwrapper.
:- import
	flora_define_predicate/1
   from flrundefined.
:-import is_control/3 from flrdependency.
:- import
	flora_storage_check_module_name/1
   from flrstorageutils.
:- import
	flora_refresh_tables/1
   from flrtables.
:- import
	incr_flora_update_counter/0
   from flrnegation.
:- import
        conjunct_to_list/2,
        flora_bind_libmodobj/2,
        matching_rule_signature/7,
        show_rule_signature/13,
        get_canonical_form/2,
	convert_to_body_literal/2,
	convert_to_head_literal/2,
	bind_head_in_defeat_condition/2,
        flora_record_rule_signature/13,
        flora_retract_signatures/9,
	rule_signature_member/3
   from flrcanon.

:- import flora_bind_last/2 from flrtrim.

:- import
	flrterm_vars/3,
	flrnonground/1
   from flora_ground.

:- import FLLIBNEWOID/1 from flrnewoid.

:- import flora_decode_goal_as_atom/2 from flrdecode.

:- import flora_reset_export_registries/1 from flrexport.
:- import flora_reset_rule_signature/1 from flrcanon.
:- import flora_delete_all_hooks/1 from flrhooks.

:- import
	flora_adaptive_assert/1,
	flora_adaptive_retract/1
   from flrstoragebase.

:- import
	get_module_from_metafacts/2,
	clear_bool_metafacts_by_ruleid/3,
	clear_prop_metafacts_by_ruleid/3,
	clear_tag_metafacts_by_ruleid/3
   from flrdescriptor_support.


/***********************************************************************
 FLLIBNEWMODULE(+ThisModuleName,+Module)
 Create new module Module.
 Make sure that Module is bound and no module
 with the same name exists. If so, load the patch rules for the module.
 Load the default trailer into the new module.
************************************************************************/ 

FLLIBNEWMODULE(_ThisModuleName,Module) :-
	var(Module),
	!,
	flora_abort('newmodule{?modname}: uninstantiated module name in newmodule{...}',FLORA_ABORT_NOTRACE).

FLLIBNEWMODULE(_ThisModuleName,Module) :-
	flora_module_registry(Module),
	!,
	flora_abort([Module,': Module already loaded'],FLORA_ABORT_NOTRACE).

FLLIBNEWMODULE(_ThisModuleName,Module) :-
	flloadtrailer([],Module).


/***********************************************************************
 FLLIBERASEMODULE(+ThisModuleName,+Module)
 Delete a module Module.
 Make sure that Module is bound and no module
 with the same name exists. If so, load the patch rules for the module.
 Load the default trailer into the new module.
************************************************************************/ 

FLLIBERASEMODULE(_ThisModuleName,Module) :-
	var(Module),
	!,
	flora_abort('erasemodule{?modname}: uninstantiated module name in erasemodule{...}',FLORA_ABORT_NOTRACE).

FLLIBERASEMODULE(_ThisModuleName,Module) :-
	\+ flora_module_registry(Module),
	!,
	flora_abort([Module,': Module is not registered'],FLORA_ABORT_NOTRACE).

FLLIBERASEMODULE(_ThisModuleName,Module) :-
	retract(flora_module_registry(Module)),
	flora_cleanup_registry(Module),
	flora_cleanup_udf(Module),
	flora_reset_export_registries(Module),
	flora_reset_rule_signature(Module),
	flora_delete_all_hooks(Module),
	flloadtrailer([],Module),
	catch(abolish_all_tables, _, flora_warning_line(WARN_TABLED_FLLOAD,[FLLIBERASEMODULE])).
	
/***********************************************************************
 FLLIBINSERTRULE_A(+CallerModule,+RuleList)
 FLLIBINSERTRULE_Z(+CallerModule,+RuleList)
************************************************************************/ 
FLLIBINSERTRULE_A(_ThisModuleName,RuleList) :- 
        flora_bind_libmodobj(RuleList,NewRuleList),
	flora_insert_rules(FLLIBINSERTRULE_A,NewRuleList).
FLLIBINSERTRULE_Z(_ThisModuleName,RuleList) :-
        flora_bind_libmodobj(RuleList,NewRuleList),
	flora_insert_rules(FLLIBINSERTRULE_Z,NewRuleList).

/***********************************************************************
 flora_insert_rules(+InsOp,+RuleList)
 InsOp is FLLIBINSERTRULE_A or FLLIBINSERTRULE_Z
 process each element ([HeadList] :- Body) in the rule list
************************************************************************/ 
flora_insert_rules(_InsOp,[]) :- !.
flora_insert_rules(_InsOp,[H|_Tail]) :-
	var(H),
	!,
	flora_abort('uninstantiated member in the rule list of insertrule{...}',
		    FLORA_ABORT_NOTRACE).
flora_insert_rules(InsOp,[FLSYSRULEUPDATE(RuleId,FileName,DescrVarTerm,RuleNum,DescrMetaFacts,HeadList,PureBody,HV,BV,PreBody,PostBody,DefeatCond)|L]) :-
	!,
	inst_body(PureBody,InstBody),
	%% flrunify_handlers.P defines the unify handler for FLDYNRULEVARCHECK
        (get_attr(HV,FLDYNRULEVARCHECK,HVars),
	    get_attr(BV,FLDYNRULEVARCHECK,BVars)
	->
	    check_vars(HeadList,PureBody,HVars,BVars,Warns),
	    sort(Warns,SortedWarns),
	    show_warnings(SortedWarns)
	; true
	),
	del_attr(HV,FLDYNRULEVARCHECK),
	del_attr(BV,FLDYNRULEVARCHECK),
	(var(RuleId) -> new_dynruleid(RuleId)
	; true
	),
	flora_expand_and_ins_rules(RuleId,FileName,DescrVarTerm,RuleNum,InsOp,HeadList,InstBody,PreBody,PostBody,DefeatCond,ModName),
	assert_metafact_list(DescrMetaFacts,FileName,ModName),
	flora_insert_rules(InsOp,L).

%% conjunct of rules - convert to list
flora_insert_rules(InsOp,[(R,L)|Rules]) :-
	!,
	conjunct_to_list((R,L),RuleList),
	flora_insert_rules(InsOp,RuleList),
	flora_insert_rules(InsOp,Rules).
flora_insert_rules(_InsOp,[H|_Tail]) :-
	!,
	flora_decode_goal_as_atom(H,AtomH),
	flora_abort(['non-rule element in the rule list of insertrule{...}, ',
		     AtomH],FLORA_ABORT_NOTRACE).


/***********************************************************************
 flora_expand_and_ins_rules(+RuleId,+FileName,+DescrVarTerm,+RuleNum,+InsOp,+HeadList,+Body,+PreBody,+PostBody,+DefeatCond,-ModName)

 If the rule is multiheaded (length(HeadList)>1), create a new 
 predicate with all vars in the body as the arguments, and assert
 a rule with the new predicate as the head and Body as the body
 (PreBody, PostBody, and Defeat condition are attached to Body)
 Note: PreBody is what the compiler inserts in front of the body.
               It contains the rule-enabling test plus maybe something else.
       PostBody is the PostBody plus whatever we might add later
************************************************************************/ 
flora_expand_and_ins_rules(_Id,_FileName,_DescrVarTerm,_RuleNum,_InsOp,[],_Body,_PreBody,_PostBody,_DefeatCond,_MName) :- !.
flora_expand_and_ins_rules(Id,FileName,DescrVarTerm,RuleNum,InsOp,[Head],Body,PreBody,PostBody,DefeatCond,MName) :-
	!,
	%% attach delay checker to body to be asserted,
	%% but not to body in signature (the second body-argument
	(var(PostBody) -> PostBody = true
	; true
	),
	flora_insert_rule(InsOp,Id,FileName,DescrVarTerm,RuleNum,Head,Body,Body,PreBody,PostBody,DefeatCond,[],MName).

flora_expand_and_ins_rules(Id,FileName,DescrVarTerm,RuleNum,InsOp,HeadList,Body,PreBody,PostBody,DefeatCond,MName) :-
	HeadList=[H|_L],
        ( var(H) ->
            flora_abort(['uninstantiated head in dynamically inserted rule, ',
			H, ' :- ', Body],FLORA_ABORT_NOTRACE)
        ;
	    ( H=FLLIBMODLIT(_F,_Args1,MName,Caller) -> true
	    ;
	        flora_decode_predicate(H,Type,MName,_Prefix,_Wrap,Args),
		( memberchk(Type,[(hilog),flogic,neg_hilog,neg_flogic,
				  (flora),neg_flora])
		->
		    reverse(Args,[Caller|_])
                ;
                    flora_abort(['internal error: invalid head in dynamically inserted rule, ', H, ' :- ', Body])
		)
	    )
        ),
	%% check if a module name is valid during an update
	flora_storage_check_module_name(MName),
	new_dynpredicate(IntermediatePredicateName),
	%%collect_vars(Body,BodyVars),
	flrterm_vars(Body,BodyVars,0), %% 0: collect all vars
	sort(BodyVars,SortedBodyVars),
	append(SortedBodyVars,[Caller],NewP_Arguments),
	flora_module_predicate(IntermediatePredicateName,NewP_Arguments,MName,IntermediatePredicate),
	%% here we attach the delay checker and pre-body to the body
	%% of the bridge rule
	(var(PostBody) -> PostBody = true
	; true
	),
	/*
	TODO: We should move concatenation of the pre/post body + defeat
	condition for the bridge rule here.
	*/
	BridgeRule =.. [FL_IMPLYOP,IntermediatePredicate,Body],
	%% This copy-term speeds up unification with rule signatures for
	%% multi-headed rules. This is because the variables in Head/Body
	%% would be different from the variables in the head/bridge rules.
	copy_term(BridgeRule,BridgeRule1),
	flora_adaptive_assert(BridgeRule),
	flora_insert_multiheaded_rule(InsOp,Id,FileName,DescrVarTerm,RuleNum,HeadList,IntermediatePredicate,Body,PreBody,PostBody,DefeatCond,[BridgeRule1]).

/***********************************************************************
 flora_insert_multiheaded_rule(+Op,+Id,+FileName,+DescrVarTerm,+RuleNum,+HeadList,+IntermediatePredicate,+OrigBody,+PreBody,+PostBody,+DefeatCond,+BridgeRules)

 For each element H in the HeadList, call
     flora_insert_rule(Op,Id,FileName,DescrVarTerm,RuleNum,IntermedPred,Body,BodyForSignature,PreBody,PostBody,DefeatCond,[Bridge],Module)

 OrigBody - the original body of the multiheaded rule
 IntermediatePredicate - the new atom that represents the original body for each of
        the multiple heads.
        In the example below, OrigBody is r; IntermediatePredicate is newpredicateXYZ

 BridgeRules:
 A multiheaded rule like  p,q :- r is represented as
	 p :- newpredicateXYZ.
         q :- newpredicateXYZ.
         newpredicateXYZ :- r.
 The last rule is called the bridge rule.
************************************************************************/ 
flora_insert_multiheaded_rule(_InsOp,_Id,_FileName,_DescrVarTerm,_RuleNum,[],_IntermediatePredicate,_OrigBody,_PreBody,_PostBody,_DefeatCond,_BridgeRule) :- !.
flora_insert_multiheaded_rule(InsOp,Id,FileName,DescrVarTerm,RuleNum,[H|L],IntermediatePredicate,OrigBody,PreBody,PostBody,DefeatCond,BridgeRule) :-
	%% flora_insert_rule binds DefeatCond, so we copy it here first
	copy_term(DefeatCond,DefeatCond1),
	flora_insert_rule(InsOp,Id,FileName,DescrVarTerm,RuleNum,H,IntermediatePredicate,OrigBody,PreBody,PostBody,DefeatCond1,BridgeRule,_MName),
	flora_insert_multiheaded_rule(InsOp,Id,FileName,DescrVarTerm,RuleNum,L,IntermediatePredicate,OrigBody,PreBody,PostBody,DefeatCond,BridgeRule).

/***********************************************************************
 flora_insert_rule(+InsOp,+RuleId,+FileName,+DescrVarTerm,+RuleNum,+Head,+Body,+OrigBody,+PreBody,+PostBody,+DefeatCond,+BridgeRules,-ModName)

 Assert a rule with the given Head and Body, refresh tables, and define
 the head for undefinedness checking.

 If this came from a multi-headed rule (called by flora_insert_multiheaded_rule)
 then Body and OrigBody are not the same.
 Body will be the intermediate predicate used in multiheaded rules
 (newpredicateXYZ below) and OrigBody is the original body of the multiheaded
 rule. OrigBody is used here only to set up the rule signature.

 If this came from a single-headed rule then Body is the real body and OrigBody
 is the body without the delay checker. It is used only in the rule signature.

 InsOp is FLLIBINSERTRULE_A or FLLIBINSERTRULE_Z
 Head is NOT prefixed with HEADPREFIX or DYNAPREFIX or DYNZPREFIX.
 Prefixes DYNA or DYNZ prefix is added depending on the type of InsOp.

 BridgeRules:
 A multiheaded rule like  p,q :- r is represented as
	 p :- newpredicateXYZ.
         q :- newpredicateXYZ.
         newpredicateXYZ :- r.
 The last rule is called the bridge rule.
************************************************************************/ 
flora_insert_rule(_InsOp,_Id,_FileName,_DescrVarTerm,_RuleNum,Head,_Body,_OrigBody,_Pre,_Post,_DefeatCond,_BridgeRule,_MName) :-
        var(Head),
        !,
        flora_abort('uninstantiated rule head in insertrule{...}',FLORA_ABORT_NOTRACE).

flora_insert_rule(InsOp,Id,FileName,DescrVarTerm,RuleNum,Head,Body,OrigBody,PreBody,PostBody,DefeatCond,BridgeRule,Module) :-
        ( Head=FLLIBMODLIT(_F,_A1,PossibleMName,_Caller) ->
            get_canonical_form(Head,FLCANON(_Wrap,_A2,MName,InstHead,_)),
	    (var(MName) -> MName = PossibleMName ; true),
            ( var(InstHead) ->
                flora_abort('uninstantiated rule head in insertrule{...}',FLORA_ABORT_NOTRACE)
            ;
                true
            ),
	    %% check if a module name is valid during an update
	    flora_storage_check_module_name(MName)
	;
	    InstHead=Head
	),
	flora_decode_predicate(InstHead,Type,Module,_WPrefix,BaseWrap,Args),
	(atom(Module), \+ is_invalid_flogic_head(BaseWrap),
	    memberchk(Type,[(hilog),flogic,(flora)]) ->
	    ( InsOp==FLLIBINSERTRULE_A -> RealPrefix = FL_DYNAPREFIX
	    ; InsOp==FLLIBINSERTRULE_Z -> RealPrefix = FL_DYNZPREFIX
	    )
	; atom(Module), \+ is_invalid_flogic_head(BaseWrap),
	    memberchk(Type,[neg_hilog,neg_flogic,neg_flora]) ->
	    ( InsOp==FLLIBINSERTRULE_A -> RealPrefix = FL_NEGDYNAPREFIX
	    ; InsOp==FLLIBINSERTRULE_Z -> RealPrefix = FL_NEGDYNZPREFIX
	    )
        ;
            flora_abort(['internal error: invalid head in a dynamically inserted rule, ', InstHead, ' :- ', OrigBody])
	),
	flora_concat_atoms([RealPrefix,BaseWrap],Wrapper),
	flora_module_predicate(Wrapper,Args,Module,NewHead),
	%% check if a module name is valid during the update
	flora_storage_check_module_name(Module),
	%% flora_record_rule_signature will bind DefeatCond, if it isn't NULL
	(DefeatCond == FL_TRUE
	->
	    NewRule =.. [FL_IMPLYOP,NewHead,(PreBody,Body,PostBody)]
	; 
	    bind_head_in_defeat_condition(NewHead,DefeatCond),
	    NewRule =.. [FL_IMPLYOP,NewHead,(PreBody,Body,DefeatCond,PostBody)]
	),
	%% This copy-term speeds up unification with rule signatures for
	%% multi-headed rules. This is because the variables in Head/Body
	%% would be different from the variables in the head/bridge rules.
	copy_term(NewRule,NewRule1),
	convert_to_body_literal(InstHead,InstHeadB),
	%% the following line to bind FileName does not seem to be necessary
	%%(var(FileName) -> FileName = FL_DYNRULE_FICTITIOUS_FILENAME ; true),
        ( InsOp == FLLIBINSERTRULE_A ->
            flora_record_rule_signature(Id,FileName,DescrVarTerm,FL_DYNAPREFIX,Module,RuleNum,InstHeadB,OrigBody,PreBody,PostBody,DefeatCond,[NewRule1],BridgeRule)
        ;
            flora_record_rule_signature(Id,FileName,DescrVarTerm,FL_DYNZPREFIX,Module,RuleNum,InstHeadB,OrigBody,PreBody,PostBody,DefeatCond,[NewRule1],BridgeRule)
        ),
	flora_adaptive_assert(NewRule),
	flora_refresh_tables(InstHead),
	incr_flora_update_counter,
	(BaseWrap==WRAP_OBJEQL ->
	    ( flloadtrailer([FLOBJEQLDEF],Module), ! ; flora_abort)
	;
	    true
	),
        flora_define_predicate(InstHead).

/***********************************************************************
 FLLIBDELETERULE_A(+CallerModule,+RuleList)
 FLLIBDELETERULE_Z(+CallerModule,+RuleList)
 FLLIBDELETERULE(+CallerModule,+RuleList)
************************************************************************/ 
FLLIBDELETERULE_A(CallerMod,RuleList) :-
	flora_select_and_delete_rules(FLLIBDELETERULE_A,CallerMod,RuleList).
FLLIBDELETERULE_Z(CallerMod,RuleList) :-
	flora_select_and_delete_rules(FLLIBDELETERULE_Z,CallerMod,RuleList).
FLLIBDELETERULE(CallerMod,RuleList) :-
        flora_select_and_delete_rules(_DONOTCARE,CallerMod,RuleList).

/***********************************************************************
 flora_select_and_delete_rules(+DelOp,+CallerMod,+RuleList)
 InsOp is FLLIBDELETERULE_A or FLLIBDELETERULE_Z or unbound
 check the existence of all rules and delete them
************************************************************************/ 
flora_select_and_delete_rules(DelOp,CallerMod,RuleList) :-
        flora_select_rules_for_deletion(DelOp,CallerMod,RuleList,SigList,HeadList),
        flora_delete_rules(SigList),
        flora_bind_libmodobj(HeadList,BoundHeadList),
        flora_refresh_ruleheads(BoundHeadList).

/***********************************************************************
 flora_refresh_ruleheads(+HeadList)
 get rid of the possibly tabled calls to the head
************************************************************************/ 
flora_refresh_ruleheads([]) :- !.
flora_refresh_ruleheads([H|L]) :-
        flora_refresh_rulehead(H),
        flora_refresh_ruleheads(L),
	incr_flora_update_counter.

flora_refresh_rulehead(Head) :-
	%% heads might be passed in body form
	convert_to_head_literal(Head,HHead),
	flora_refresh_tables(HHead).

/***********************************************************************
 flora_select_rules_for_deletion(+DelOp,+CallerMod,+RuleList,-SigList,-HeadList)
 check if the rule exists and return matching rule signatures
************************************************************************/ 
flora_select_rules_for_deletion(_DelOp,_Mod,[],[],[]) :- !.
flora_select_rules_for_deletion(DelOp,CallerMod,[FLSYSRULEUPDATE(Id,FileName,_DescrVarTerm,_RuleNum,DescrMetaFacts,HeadList,Body,_HV,_BV,_PreBody,_PostBody,_DefeatCond)|L],SigList,HL) :-
	!,
	flora_check_multiheaded_rule(DelOp,Id,FileName,RuleMod,HeadList,Body,HSigList,HHL),
	(var(RuleMod) -> RuleMod = CallerMod ; true),
	%% Match the metafacts before deciding to delete
	call_metafact_list(DescrMetaFacts,FileName,RuleMod),
	flora_select_rules_for_deletion(DelOp,CallerMod,L,LSigList,LHL),
	append(HSigList,LSigList,SigList),
	append(HHL,LHL,HL).
%% conjunction of rules - convert to list
flora_select_rules_for_deletion(DelOp,CallerMod,[(R,L)|Rules],SigList,HL) :-
	!,
	conjunct_to_list((R,L),RuleList),
	flora_select_rules_for_deletion(DelOp,CallerMod,RuleList,HSigList,HHL),
	flora_select_rules_for_deletion(DelOp,CallerMod,Rules,RSigList,RHL),
        append(HSigList,RSigList,SigList),
        append(HHL,RHL,HL).
flora_select_rules_for_deletion(_DelOp,_Mod,[H|_Tail],_SigList,_HL) :-
	!,
	flora_decode_goal_as_atom(H,AtomH),
	flora_abort(['non-rule item ', H, ' in the rule-list of deleterule{...}, ',
		     AtomH],FLORA_ABORT_NOTRACE).

/***********************************************************************
  flora_check_multiheaded_rule(+DelOp,+Id,+FileName,+RuleMod,+HeadList,+Body,-RuleSigList,-NewHeadList)
  For multiheaded rules, check if a rule for each head component exists.
***********************************************************************/
flora_check_multiheaded_rule(_DelOp,_Id,_FN,_Mod,[],_Body,[],[]) :- !.
flora_check_multiheaded_rule(DelOp,Id,FileName,RuleMod,[H|L],Body,[HSig|LSig],[HH|LH]) :-
        flora_check_rule(DelOp,Id,FileName,RuleMod,H,Body,HSig,HH),
        flora_check_multiheaded_rule(DelOp,Id,FileName,RuleMod,L,Body,LSig,LH).

flora_check_rule(DelOp,Id,FileName,RuleMod,Head,Body,RuleSig,BoundHead) :-
        get_canonical_form(Head,FLCANON(_,_,_,HT,_)),
	convert_to_body_literal(HT,BHead),
        ( DelOp == FLLIBDELETERULE_A ->
            matching_rule_signature(Id,FileName,_DescrVarTerm,FL_DYNAPREFIX,BHead,Body,RuleSig)
        ; DelOp == FLLIBDELETERULE_Z ->
            matching_rule_signature(Id,FileName,_DescrVarTerm,FL_DYNZPREFIX,BHead,Body,RuleSig)
        ; matching_rule_signature(Id,FileName,_DescrVarTerm,_,BHead,Body,RuleSig)
        ),
	rule_signature_member(module,RuleSig,RuleMod),
        get_canonical_form(BHead,FLCANON(_,_,_,BoundHead,_)).


/***********************************************************************
  flora_delete_rules(+RuleSigList)

***********************************************************************/
flora_delete_rules([]) :- !.
%% Atr is rule_signature list
flora_delete_rules([(Id,FileName,DescrVarTerm,DynPrefix,Mod,RuleNum,Head,Body,_PreBody,_PostBody,_DefeatCond,RuleList,BridgeRule)|L]) :-
        flora_retract_rulelist(RuleList),
	%% retract signatures does not ask for DefeatCond, so it's missing below
        flora_retract_signatures(Id,FileName,DescrVarTerm,DynPrefix,Mod,Head,Body,RuleList,BridgeRule),
        ( BridgeRule==[] -> true
        ;
	    %% A multiheaded rule, say p,q :- r, is represented as p :- newpred,
	    %% q:-newpred,  newpred :- r. One might be deleting just p:-r.
	    %% If so, the bridge rule newpred:- r is still needed and the above
	    %% flora_retract_signatures/9 will not delete all the signatures
	    %% that have BridgeRule. So, we are testing if BridgeRule is still
	    %% there. If so, we do not delete BridgeRule.
            ( show_rule_signature(Id,FileName,_DescrVarTerm,DynPrefix,Mod,RuleNum,_H,_BS,_PreB,_PostB,_DefeatCond,_RL,BridgeRule) -> true
            ;
                flora_retract_rulelist(BridgeRule)
            )
        ),
	%% Delete metafacts associated with the rule
	clear_tag_metafacts_by_ruleid(Id,FileName,Mod),
	clear_bool_metafacts_by_ruleid(Id,FileName,Mod),
	clear_prop_metafacts_by_ruleid(Id,FileName,Mod),
        flora_delete_rules(L).

flora_retract_rulelist(FL_COMMA(RL1,RL2)) :-
        !,
        flora_retract_rulelist(RL1),
        flora_retract_rulelist(RL2).
flora_retract_rulelist([]) :- !.
flora_retract_rulelist([H|L]) :-
        flora_adaptive_retract(H),
        flora_retract_rulelist(L).

/***********************************************************************
 inst_body(+Body,-InstBody)
 get rid of fllibmodlit with module name already bound
************************************************************************/ 
inst_body(B,B) :-
        var(B),
        !.

inst_body(FL_COMMA(B1,B2),FL_COMMA(NB1,NB2)) :-
	!,
	inst_body(B1,NB1),
	inst_body(B2,NB2).

inst_body(FL_SEMICOLON(B1,B2),FL_SEMICOLON(NB1,NB2)) :-
	!,
	inst_body(B1,NB1),
	inst_body(B2,NB2).

inst_body(not(B),not(NB)) :-
	!,
	inst_body(B,NB).

inst_body(tnot(B),tnot(NB)) :-
	!,
	inst_body(B,NB).

inst_body(Body,NB) :-
	is_control(Body,Ctl,Branches),
	!,
	inst_list(Branches,InstBranches),
	NB =.. [Ctl|InstBranches].

inst_body(FLLIBMODLIT(F,Args,MName,Caller),Inst) :-
        !,
        get_canonical_form(FLLIBMODLIT(F,Args,MName,Caller),FLCANON(_W,_A,_M,Callable,_)),
        (var(Callable) ->
            Inst = FLLIBMODLIT(F,Args,MName,Caller)
        ;
	    flora_bind_last(Callable,Caller),
	    Callable = Inst
        ).

inst_body(Body,Body).
	
inst_list([],[]) :- !.
inst_list([H|L],[NH|NL]) :-
	inst_body(H,NH),
	inst_list(L,NL).

/***********************************************************************
 new_dynpredicate(-NewPredName)
 new_dynruleid(-NewRuleId)
************************************************************************/ 
new_dynpredicate(NewPredName) :-
	conget(GLOBAL_DYN_NEWPREDICATE_COUNTER, N),
	M is N+1,
	conset(GLOBAL_DYN_NEWPREDICATE_COUNTER, M),
	flora_concat_items([GLOBAL_DYN_NEWPREDICATE,N], NewPredName).

new_dynruleid(NewRuleId) :-
	conget(GLOBAL_DYN_RULEID_COUNTER, N),
	M is N+1,
	conset(GLOBAL_DYN_RULEID_COUNTER, M),
	%% we don't want to create lotsa strings on the heap
	%%flora_concat_items([DEFAULT_DYN_RULEID,N], NewRuleId).
	N = NewRuleId.
	%%NewRuleId is N+24.


/***********************************************************************
 check_vars(+HeadList,+Body,+NamedHeadVars,+NamedBodyVars,-Warnings)
************************************************************************/ 
check_vars(HeadList,Body,NamedHVars,NamedBVars,Warnings) :-
        %%collect_var_list(HeadList,HVars),
        %%collect_vars(Body,BVars),
        flrterm_vars(HeadList,HVars,0), %% 0: collect all vars
        flrterm_vars(Body,BVars,0),
        append(HVars,BVars,Vars),
        singleton_vars(Vars,Vars,SingletonVars),
        singleton_warning(SingletonVars,NamedHVars,NamedBVars,SWarnings),
        subtract_vars(HVars,BVars,UnboundVars),
        unbound_warning(UnboundVars,NamedHVars,UWarnings),
        append(SWarnings,UWarnings,Warnings).

singleton_vars(_AllVars,[],[]) :- !.
singleton_vars(AllVars,[H|L], [H|SL]) :-
        is_singleton(AllVars,H,0),
        !,
        singleton_vars(AllVars,L,SL).
singleton_vars(AllVars,[_H|L],SL) :-
        singleton_vars(AllVars,L,SL).

is_singleton([],_V,_Cnt) :- !.
is_singleton([H|L],V,Cnt) :-
        (H==V ->
            (Cnt==1 ->
                fail
            ;
                is_singleton(L,V,1)
            )
        ;
            is_singleton(L,V,Cnt)
        ).

singleton_warning([],_NamedHVars,_NamedBVars,[]) :- !.
singleton_warning([H|L],NamedHVars,NamedBVars,Warns) :-
        ( get_var_name(H,NamedHVars,Name) ->
            fmt_write_string(WarningStr,"singleton variable `%s' in the head of dynamically inserted rule", args(Name)),
            Warns=[WarningStr|RestWarns]
        ;
            ( get_var_name(H,NamedBVars,Name) ->
                fmt_write_string(WarningStr,"singleton variable `%s' in the body of dynamically inserted rule", args(Name)),
                Warns=[WarningStr|RestWarns]
            ;
                Warns=RestWarns
            )
        ),
        singleton_warning(L,NamedHVars,NamedBVars,RestWarns).

get_var_name(H,[N=V|NVs],Name) :-
        ( H==V ->
            Name=N
        ;
            get_var_name(H,NVs,Name)
        ).

subtract_vars([],_BVars,[]) :- !.
subtract_vars([H|L],BVars,LUV) :-
        in_list(H,BVars),
        !,
        subtract_vars(L,BVars,LUV).
subtract_vars([H|L],BVars,[H|LUV]) :-
        subtract_vars(L,BVars,LUV).

in_list(V,[H|L]) :-
        ( H==V ->
            true
        ;
            in_list(V,L)
        ).

unbound_warning([],_NamedHVars,[]) :- !.
unbound_warning([H|L],NamedHVars,Warns) :-
        ( get_var_name(H,NamedHVars,Name) ->
            fmt_write_string(WarningStr,"unsafe variable `%s' in the head of dynamically inserted rule", args(Name)),
            unbound_warning(L,NamedHVars,RestWarns),
            Warns=[WarningStr|RestWarns]
        ;
            unbound_warning(L,NamedHVars,Warns)
        ).


/***********************************************************************
 is_invalid_flogic_head(+Pred)
************************************************************************/ 
is_invalid_flogic_head(WRAP_MVDINC) :- !.
is_invalid_flogic_head(WRAP_IMVDINC) :- !.
is_invalid_flogic_head(WRAP_MVDTOLIST) :- !.
is_invalid_flogic_head(WRAP_IMVDTOLIST) :- !.


/***********************************************************************
 show_warnings(+WarningList)
 Returns the last argument, which is the caller.
************************************************************************/ 
show_warnings([]) :- !.
show_warnings([H|L]) :-
        flora_warning_line(H),
        show_warnings(L).


assert_metafact_list([],_,_) :- !.
/*
%% One can have variables in the Id and tags, so this error is invalid
%% We better check in the compiler that Id or Tag is not a pure var.
assert_metafact_list([H|_],_,_) :-
	flrnonground(H),
	!,
	flora_abort(['non-ground descriptor in insertrule{...},\n\t',
		     H],FLORA_ABORT_NOTRACE).
*/
assert_metafact_list([NULL|Rest],FileName,Mod) :-
	!,
	assert_metafact_list(Rest,FileName,Mod).
assert_metafact_list([H|T],FileName,Module) :-
	%% bind the module and filename in metafacts
	(var(FileName) -> FileName = FL_DYNRULE_FICTITIOUS_FILENAME ; true),
	(H = FL_TAG_DESCRIPTOR_META_PREDICATE(_,FileName,Module,_,_), !
	; H = FL_BOOL_DESCRIPTOR_META_PREDICATE(_,FileName,Module,_,_), !
	; H = FL_PROP_DESCRIPTOR_META_PREDICATE(_,FileName,Module,_,_,_), !
	; arg(2,H,FileName)
	),
	(is_duplicate_rule_id(H)
	-> arg(1,H,RuleId),
	    arg(2,H,RFN),
	    flora_abort(['A rule with Id `',RuleId,'+',RFN,
			 ''' is already loaded'],
			FLORA_ABORT_NOTRACE)
	;
	    flora_adaptive_assert(H),
	    assert_metafact_list(T,FileName,Module)
	).

is_duplicate_rule_id(H) :-
	functor(H,Fun,2),
	flrporting:flora_match_substring(FL_RULE_ENABLER,Fun,_),
	!,
	H.

call_metafact_list([],_,_) :- !.
call_metafact_list([NULL|Rest],FileName,Mod) :-
	!,
	call_metafact_list(Rest,FileName,Mod).
call_metafact_list([Head|Rest],FileName,Mod) :-
	functor(Head,_,Arity),
	%% We don't extract the module from FL_RULE_ENABLER/2 here. 
	%% This is the only metafact of arity 2; others are > 2.
	(Arity > 2 -> get_module_from_metafacts(Head,Mod)
	; true
	),
	arg(2,Head,FileName),
	call(Head),
	call_metafact_list(Rest,FileName,Mod).

/*
adaptive_retract_list([]) :- !.
adaptive_retract_list([H|T]) :-
	adaptive_retract(H),
	adaptive_retract_list(T).
*/

%% reset new dyn predicate and ruleid counters
?- conset(GLOBAL_DYN_NEWPREDICATE_COUNTER, 1),
   conset(GLOBAL_DYN_RULEID_COUNTER,1).
