/* File:      flrdynrule.P
**
** Author(s): Chang Zhao
**
** Contact:   flora-users@lists.sourceforge.net
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2013;
**      and Vulcan, Inc., 2008-2013.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**      http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
**
*/


:- compiler_options([xpp_on]).

#include "flora_errors.flh"
#include "flora_terms.flh"
#include "flora_exceptions.flh"

#define GLOBAL_DYN_NEWPREDICATE   '_$$''''dyn_newpredicate'
#define DEFAULT_DYN_RULEID        '_$$''''default_dynruleid'

#define GLOBAL_DYN_NEWPREDICATE_COUNTER  '_$$''''global_dynnewpredicate'
#define GLOBAL_DYN_RULEID_COUNTER        '_$$''''global_dynruleid'

#define VARHEAD_IN_DYNRULE       'variable head in dynamically inserted rule, '
#define INVALIDHEAD_IN_DYNRULE   'Flora-2 bug: invalid head in dynamically inserted rule, '

:- import conset/2,conget/2 from gensym.
:- import
	copy_term/2,
	memberchk/2,
	append/3,
	length/2
   from basics.
:- import assert/3 from assert.
:- import
	del_attr/2,
	get_attr/3
   from machine.

:- import
	flora_user_load_registry/4,
	flora_module_registry/1
   from flrregistry.
:- import
        flora_warning_line/1,
        flora_warning_line/2
   from flrprint.
:- import
        flora_abort/0,
        flora_abort/1,
        flora_abort/2,
        flora_concat_items/2,
        flora_concat_atoms/2
   from flrporting.
:- import 
	flora_patch_full_filename/1,
	flora_set_xpp_options_for_compile/1,
	flora_add_xpp_options/1,
	flora_clear_xpp_options/0,
	flora_cleanup_udf/1,
	flora_cleanup_registry/1,
	flora_get_textual_info/3,
	flloadtrailer/2
   from flrutils.

:- import
	flora_module_predicate/4,
	flora_decode_predicate/6
   from flrwrapper.
:- import
	flora_define_predicate/1
   from flrundefined.
:-import is_control/3 from flrdependency.
:- import
	flora_storage_check_module_name/1
   from flrstorageutils.
:- import
	flora_refresh_tables/1
   from flrtables.
:- import
	incr_flora_update_counter/0
   from flrnegation.
:- import
        conjunct_to_list/2,
        flora_bind_libmodobj/2,
        matching_rule_signature/7,
        show_rule_signature/13,
        get_canonical_form/2,
	convert_to_body_literal/2,
	convert_to_head_literal/2,
	bind_head_in_defeat_condition/2,
        flora_record_rule_signature/13,
	flora_record_query_signature/6,
	flora_delete_query_signature/4,
        flora_retract_signatures/9,
	rule_signature_member/3
   from flrcanon.

:- import flora_bind_last/2 from flrtrim.

:- import
	%%flrterm_vars_split/4,
	flrterm_vars/3,
	flrnonground/1
   from flora_ground.

:- import FLLIBNEWOID/1 from flrnewoid.

:- import
	flora_decode_goal_as_atom/2
   from flrdecode.

:- import flora_reset_export_registries/1 from flrexport.
:- import
	flora_reset_query_signature/1,
	flora_reset_rule_signature/1
   from flrcanon.
:- import flora_delete_all_hooks/1 from flrhooks.

:- import
	flora_adaptive_assert/1,
	flora_adaptive_retract/1
   from flrstoragebase.

:- import
	get_module_from_metafacts/2,
	extract_stmt_fileinfo_from_filespec/4,
	flora_clear_all_metafacts_by_ruleid/3
   from flrdescriptor_support.


/***********************************************************************
 FLLIBNEWMODULE(+ThisModuleName,+Module)
 Create new module Module.
 Make sure that Module is bound and no module
 with the same name exists. If so, load the patch rules for the module.
 Load the default trailer into the new module.
************************************************************************/ 

FLLIBNEWMODULE(_ThisModuleName,Module) :-
	var(Module),
	!,
	flora_abort('newmodule{?modname}: uninstantiated module name in newmodule{...}',FLORA_ABORT_NOTRACE).

FLLIBNEWMODULE(_ThisModuleName,Module) :-
	flora_module_registry(Module),
	!,
	flora_abort([Module,': module already loaded'],FLORA_ABORT_NOTRACE).

FLLIBNEWMODULE(_ThisModuleName,Module) :-
	flloadtrailer([],Module).


/***********************************************************************
 FLLIBERASEMODULE(+ThisModuleName,+Module)
 Delete a module Module.
 Make sure that Module is bound and no module
 with the same name exists. If so, load the patch rules for the module.
 Load the default trailer into the new module.
************************************************************************/ 

FLLIBERASEMODULE(_ThisModuleName,Module) :-
	var(Module),
	!,
	flora_abort('erasemodule{?modname}: uninstantiated module name',FLORA_ABORT_NOTRACE).

FLLIBERASEMODULE(_ThisModuleName,Module) :-
	\+ flora_module_registry(Module),
	!,
	flora_abort(['erasemodule{',Module,'}: module is not registered'],FLORA_ABORT_NOTRACE).

FLLIBERASEMODULE(_ThisModuleName,Module) :-
	retract(flora_module_registry(Module)),
	flora_cleanup_registry(Module),
	flora_cleanup_udf(Module),
	flora_reset_export_registries(Module),
	flora_reset_rule_signature(Module),
	flora_reset_query_signature(Module),
	flora_delete_all_hooks(Module),
	flloadtrailer([],Module),
	catch(abolish_all_tables, _, flora_warning_line(WARN_TABLED_FLLOAD,[FLLIBERASEMODULE])).
	
/*******************************************************************************
 FLLIBINSERTRULE_A(+CallerModule,+RuleList)
 FLLIBINSERTRULE_Z(+CallerModule,+RuleList)

 Note: these predicates eventually call flora_record_query_signature/6
 to insert the rule signature for DYNAMIC rules.
 This operation is different from FLLIBINSRULESIG in flrclause.P:
 FLLIBINSRULESIG inserts signatures for STATIC RULES only.
*******************************************************************************/
FLLIBINSERTRULE_A(_ThisModuleName,RuleList) :- 
        flora_bind_libmodobj(RuleList,NewRuleList),
	flora_insert_rules(FLLIBINSERTRULE_A,NewRuleList).
FLLIBINSERTRULE_Z(_ThisModuleName,RuleList) :-
        flora_bind_libmodobj(RuleList,NewRuleList),
	flora_insert_rules(FLLIBINSERTRULE_Z,NewRuleList).

/******************************************************************************
     FLLIBINSQUERYSIG(+RuleId,+File,+Module,+RuleNum,+MetaFacts,+PreLatentQuery,+LatentQuery)
     FLLIBDELQUERYSIG(+RuleId,+File,+Module,+MetaFacts,+LatentQuery)
     Insert/delete signature for latent queries
     PreLatentQuery is the stuff that compiler inserts before the LatentQuery body.
     Currently this is the rule enabling fact.
******************************************************************************/
FLLIBINSQUERYSIG(RuleId,File,Module,RuleNum,MetaFacts,PreLatentQuery,LatentQuery) :-
	%% assigning new_dynruleid/1 MUST be here!
	(var(RuleId) -> new_dynruleid(RuleId)
	; true
	),
	%% flora_assert_metafact_list/3 MUST be here!
	flora_assert_metafact_list(MetaFacts,File,Module),
	flora_record_query_signature(RuleId,File,Module,RuleNum,PreLatentQuery,LatentQuery).

FLLIBDELQUERYSIG(RuleId,File,Module,_MetaFacts,LatentQuery) :-
	flora_clear_all_metafacts_by_ruleid(RuleId,File,Module),
	flora_delete_query_signature(RuleId,File,Module,LatentQuery).

/***********************************************************************
 flora_insert_rules(+InsOp,+RuleList)
 InsOp is FLLIBINSERTRULE_A or FLLIBINSERTRULE_Z
 process each element ([HeadList] :- Body) in the rule list
************************************************************************/ 
flora_insert_rules(_InsOp,[]) :- !.
flora_insert_rules(_InsOp,[H|_Tail]) :-
	var(H),
	!,
	flora_abort('uninstantiated object in the rule list of insertrule{...}',
		    FLORA_ABORT_NOTRACE).
flora_insert_rules(InsOp,[FLSYSRULEUPDATE(RuleId,FileName,DescrVarTerm,RuleNum,DescrMetaFacts,HeadList,PureBody,HV,BV,PreBody,PostBody,DefeatCond)|L]) :-
	!,
	inst_body(PureBody,InstBody),
	%% flrunify_handlers.P defines the unify handler for FLDYNRULEVARCHECK
        (get_attr(HV,FLDYNRULEVARCHECK,HVars) -> true
	; HVars = []
	),
	(get_attr(BV,FLDYNRULEVARCHECK,BVars) -> true
	; BVars = []
	),
	del_attr(HV,FLDYNRULEVARCHECK),
	del_attr(BV,FLDYNRULEVARCHECK),
	(var(RuleId) -> new_dynruleid(RuleId)
	; true
	),

	%% flora_prepare_then_insert_rule/11 MUST come first because it binds
	%% ModName for flora_assert_metafact_list/3
	flora_prepare_then_insert_rule(RuleId,FileName,DescrVarTerm,RuleNum,InsOp,HeadList,InstBody,PreBody,PostBody,DefeatCond,ModName),
	flora_assert_metafact_list(DescrMetaFacts,FileName,ModName),

	(HVars == [], BVars == [] -> true
	; 
	    get_fullfile_name(FileName,ModName,FullFile),
	    '_$flr_check_vars'(RuleId,FullFile,HeadList,PureBody,HVars,BVars,Warns),
	    sort(Warns,SortedWarns),
	    flora_show_warnings(SortedWarns)
	),
	flora_insert_rules(InsOp,L).

flora_insert_rules(InsOp,[FLSYSINSQUERYSIG(RuleId,FileName,Module,RuleNum,DescrMetaFacts,PreBody,Body,BV)|L]) :-
	!,
	FLLIBINSQUERYSIG(RuleId,FileName,Module,RuleNum,DescrMetaFacts,PreBody,Body),
	(get_attr(BV,FLDYNRULEVARCHECK,BVars) -> true
	; BVars = []
	),
	get_fullfile_name(FileName,Module,FullFile),
	'_$flr_check_vars'(RuleId,FullFile,NULL,Body,[],BVars,Warns),
	sort(Warns,SortedWarns),
	flora_show_warnings(SortedWarns),
	flora_insert_rules(InsOp,L).

%% conjunct of rules - convert to list
flora_insert_rules(InsOp,[(R,L)|Rules]) :-
	!,
	conjunct_to_list((R,L),RuleList),
	flora_insert_rules(InsOp,RuleList),
	flora_insert_rules(InsOp,Rules).
flora_insert_rules(_InsOp,[H|_Tail]) :-
	!,
	flora_decode_goal_as_atom(H,AtomH),
	flora_abort(['a non-rule element in insertrule{...}, ',AtomH],FLORA_ABORT_NOTRACE).


/***********************************************************************
 flora_prepare_then_insert_rule(+RuleId,+FileName,+DescrVarTerm,+RuleNum,+InsOp,+HeadList,+Body,+PreBody,+PostBody,+DefeatCond,-ModName)

 If the rule is single-headed, then just insert it.

 If it is multiheaded (length(HeadList)>1), create a new predicate
 with all vars in the body as the arguments, and assert a bridge rule.
 A bridge rule has that new predicate as its head and Body as the body
 (PreBody, PostBody, and Defeat condition are eventually attached to Body)

 Note: PreBody is what the compiler inserts in front of the body.
               It contains the rule-enabling test plus maybe something else.
       PostBody is what goes after the user-specified body. For instance,
	       the delay checker.
************************************************************************/ 
flora_prepare_then_insert_rule(_Id,_FileName,_DescrVarTerm,_RuleNum,_InsOp,[],_Body,_PreBody,_PostBody,_DefeatCond,_MName) :- !.
flora_prepare_then_insert_rule(Id,FileName,DescrVarTerm,RuleNum,InsOp,[Head],Body,PreBody,PostBody,DefeatCond,MName) :-
	!,
	%% attach delay checker to body to be asserted,
	%% but not to body in signature (the second body-argument
	(var(PostBody) -> PostBody = true
	; true
	),
	flora_insert_rule(InsOp,Id,FileName,DescrVarTerm,RuleNum,Head,Body,Body,PreBody,PostBody,DefeatCond,[],MName).

flora_prepare_then_insert_rule(Id,FileName,DescrVarTerm,RuleNum,InsOp,HeadList,Body,PreBody,PostBody,DefeatCond,MName) :-
	HeadList=[H|_L],
        ( var(H) ->
	    flora_decode_goal_as_atom((H:-Body),RuleAtm),
            flora_abort([VARHEAD_IN_DYNRULE,RuleAtm],FLORA_ABORT_NOTRACE)
        ;
	    ( H=FLLIBMODLIT(_F,_Args1,MName,Caller) -> true
	    ;
	        flora_decode_predicate(H,Type,HeadMName,_Prefix,_Wrap,Args),
		MName = HeadMName,
		( memberchk(Type,[(hilog),flogic,neg_hilog,neg_flogic,
				  (flora),neg_flora])
		->
		    flora_bind_last(Args,[Caller|_])
                ;
                    flora_abort([INVALIDHEAD_IN_DYNRULE, H, ' :- ', Body])
		)
	    )
        ),
	%% check if a module name is valid during an update
	flora_storage_check_module_name(MName),
	new_dynpredicate(IntermediatePredicateName),
	flrterm_vars(Body,BodyVars,0), %% 0: collect all vars
	sort(BodyVars,SortedBodyVars),
	append(SortedBodyVars,[Caller],NewP_Arguments),
	flora_module_predicate(IntermediatePredicateName,NewP_Arguments,MName,IntermediatePredicate),
	%% here we attach the delay checker and pre-body to the body
	%% of the bridge rule
	(var(PostBody) -> PostBody = true
	; true
	),
	%% NewPredicate :- OldBody.
	BridgeRule =.. [FL_IMPLYOP,IntermediatePredicate,Body],
	%% This copy-term speeds up unification with rule signatures for
	%% multi-headed rules. This is because the variables in Head/Body
	%% would be different from the variables in the head/bridge rules.
	copy_term(BridgeRule,BridgeRule1),
	flora_adaptive_assert(BridgeRule),
	flora_insert_multiheaded_rule(InsOp,Id,FileName,DescrVarTerm,RuleNum,HeadList,IntermediatePredicate,Body,PreBody,PostBody,DefeatCond,[BridgeRule1]).

/***********************************************************************
 flora_insert_multiheaded_rule(+Op,+Id,+FileName,+DescrVarTerm,+RuleNum,+HeadList,+IntermediatePredicate,+OrigBody,+PreBody,+PostBody,+DefeatCond,+BridgeRules)

 For each element H in the HeadList, call
     flora_insert_rule(Op,Id,FileName,DescrVarTerm,RuleNum,IntermedPred,Body,BodyForSignature,PreBody,PostBody,DefeatCond,[Bridge],Module)

 OrigBody - the original body of the multiheaded rule
 IntermediatePredicate - the new atom that represents the original body for each of
        the multiple heads.
        In the example below, OrigBody is r; IntermediatePredicate is newpredicateXYZ

 BridgeRules:
 A multiheaded rule like  p,q :- r is represented as
	 p :- newpredicateXYZ.
         q :- newpredicateXYZ.
         newpredicateXYZ :- r.
 The last rule is called the bridge rule.
************************************************************************/ 
flora_insert_multiheaded_rule(_InsOp,_Id,_FileName,_DescrVarTerm,_RuleNum,[],_IntermediatePredicate,_OrigBody,_PreBody,_PostBody,_DefeatCond,_BridgeRule) :- !.
flora_insert_multiheaded_rule(InsOp,Id,FileName,DescrVarTerm,RuleNum,[H|L],IntermediatePredicate,OrigBody,PreBody,PostBody,DefeatCond,BridgeRule) :-
	%% flora_insert_rule binds DefeatCond, so we copy it here first
	copy_term(DefeatCond,DefeatCond1),
	flora_insert_rule(InsOp,Id,FileName,DescrVarTerm,RuleNum,H,IntermediatePredicate,OrigBody,PreBody,PostBody,DefeatCond1,BridgeRule,_MName),
	flora_insert_multiheaded_rule(InsOp,Id,FileName,DescrVarTerm,RuleNum,L,IntermediatePredicate,OrigBody,PreBody,PostBody,DefeatCond,BridgeRule).

/***********************************************************************
 flora_insert_rule(+InsOp,+RuleId,+FileName,+DescrVarTerm,+RuleNum,+Head,+Body,+OrigBody,+PreBody,+PostBody,+DefeatCond,+BridgeRules,-ModName)

 Assert a rule with the given Head and Body, refresh tables, and define
 the head for undefinedness checking.

 If this came from a multi-headed rule (called by flora_insert_multiheaded_rule)
 then Body and OrigBody are not the same.
 Body will be the intermediate predicate used in multiheaded rules
 (newpredicateXYZ below) and OrigBody is the original body of the multiheaded
 rule. OrigBody is used here only to set up the rule signature.

 If this came from a single-headed rule then Body is the real body and OrigBody
 is the body without the delay checker. It is used only in the rule signature.

 InsOp is FLLIBINSERTRULE_A or FLLIBINSERTRULE_Z
 Head is NOT prefixed with HEADPREFIX or DYNAPREFIX or DYNZPREFIX.
 Prefixes DYNA or DYNZ prefix is added depending on the type of InsOp.

 BridgeRules:
 A multiheaded rule like  p,q :- r is represented as
	 p :- newpredicateXYZ.
         q :- newpredicateXYZ.
         newpredicateXYZ :- r.
 The last rule is called the BRIDGE rule.
 The first two are called the HEAD rules.

 If this call comes from a single-headed rule then that rule is inserted.
 If it comes from a multiheaded rule then the HEAD rules (see above for
 a definition) are inserted. The bridge rule is inserted before that,
 in flora_prepare_then_insert_rule.
************************************************************************/ 
flora_insert_rule(_InsOp,_Id,_FileName,_DescrVarTerm,_RuleNum,H,_Body,OrigBody,_Pre,_Post,_DefeatCond,_BridgeRule,_MName) :-
        var(H),
        !,
	flora_decode_goal_as_atom((H:-OrigBody),RuleAtm),
	flora_abort([VARHEAD_IN_DYNRULE,RuleAtm],FLORA_ABORT_NOTRACE).

flora_insert_rule(InsOp,Id,FileName,DescrVarTerm,RuleNum,Head,Body,OrigBody,PreBody,PostBody,DefeatCond,BridgeRule,Module) :-
        ( Head=FLLIBMODLIT(_F,_A1,PossibleMName,_Caller) ->
            get_canonical_form(Head,FLCANON(_Wrap,_A2,MName,GenericHead,_)),
	    (var(MName) -> MName = PossibleMName ; true),
            ( var(GenericHead) ->
		flora_decode_goal_as_atom((GenericHead:-OrigBody),RuleAtm),
                flora_abort([VARHEAD_IN_DYNRULE,RuleAtm],FLORA_ABORT_NOTRACE)
            ;
                true
            ),
	    %% check if a module name is valid during an update
	    flora_storage_check_module_name(MName)
	;
	    GenericHead=Head
	),
	flora_decode_predicate(GenericHead,Type,GenModule,_WPrefix,BaseWrap,Args),
	GenModule = Module,
	(atom(Module), \+ is_invalid_flogic_head(BaseWrap),
	    memberchk(Type,[(hilog),flogic,(flora)]) ->
	    ( InsOp==FLLIBINSERTRULE_A -> RealPrefix = FL_DYNAPREFIX
	    ; InsOp==FLLIBINSERTRULE_Z -> RealPrefix = FL_DYNZPREFIX
	    )
	; atom(Module), \+ is_invalid_flogic_head(BaseWrap),
	    memberchk(Type,[neg_hilog,neg_flogic,neg_flora]) ->
	    ( InsOp==FLLIBINSERTRULE_A -> RealPrefix = FL_NEGDYNAPREFIX
	    ; InsOp==FLLIBINSERTRULE_Z -> RealPrefix = FL_NEGDYNZPREFIX
	    )
        ;
            flora_abort([INVALIDHEAD_IN_DYNRULE, GenericHead, ' :- ', OrigBody])
	),
	%% the following line to bind FileName is needed for reified rules
	(var(FileName)
	-> FileName = FL_DYNRULE_FICTITIOUS_FILENAME('<unknown>')
	;
	    true
	),
	bind_rule_enabler(PreBody,FileName,Module),
	flora_concat_atoms([RealPrefix,BaseWrap],Wrapper),
	/*
	  Difference between RealDynHead and GenericHead:
	    Generic head is what is normally found in the trailer and such.
            It is the tabled version of the predicate.
            RealDynHead is what is found in the actual dynamic rules.
            For instance,
	     FLORA_THIS_WORKSPACE(tblflapply)(p,X,[Caller,Tracer])
	     FLORA_THIS_WORKSPACE(FLDYNZPREFIX(tblflapply))(p,X,[Caller,Tracer])

	    The first is a GenericHead, the second is a RealDynHead.

	*/
	flora_module_predicate(Wrapper,Args,Module,RealDynHead),
	%% check if a module name is valid during the update
	flora_storage_check_module_name(Module),
	%% flora_record_rule_signature will bind DefeatCond, if it isn't NULL
	(DefeatCond == FL_TRUE
	->
	    %% NewRule: OrigHead :- OriginalBody
	    %%       or OrigHead :- PreBodyNewIntermedPredicate,PostBody,Defeat
	    %% RealDynHead == OrigHead + the dyna or dynz dynamic rules' prefix
	    NewRule =.. [FL_IMPLYOP,RealDynHead,(PreBody,Body,PostBody)]
	; 
	    bind_head_in_defeat_condition(RealDynHead,DefeatCond),
	    NewRule =.. [FL_IMPLYOP,RealDynHead,(PreBody,Body,DefeatCond,PostBody)]
	),
	%% This copy-term speeds up unification with rule signatures for
	%% multi-headed rules. This is because the variables in Head/Body
	%% would be different from the variables in the head/bridge rules.
	copy_term(NewRule,NewRule1),
	convert_to_body_literal(GenericHead,GenericHeadBodified),
        ( InsOp == FLLIBINSERTRULE_A ->
            flora_record_rule_signature(Id,FileName,DescrVarTerm,FL_DYNAPREFIX,Module,RuleNum,GenericHeadBodified,OrigBody,PreBody,PostBody,DefeatCond,[NewRule1],BridgeRule)
        ;
            flora_record_rule_signature(Id,FileName,DescrVarTerm,FL_DYNZPREFIX,Module,RuleNum,GenericHeadBodified,OrigBody,PreBody,PostBody,DefeatCond,[NewRule1],BridgeRule)
        ),
	flora_adaptive_assert(NewRule),
	flora_refresh_tables(GenericHead),
	incr_flora_update_counter,
	(BaseWrap==WRAP_OBJEQL ->
	    (flloadtrailer([FLOBJEQLDEF],Module), ! ; flora_abort)
	;
	    true
	),
        flora_define_predicate(GenericHead).

/***********************************************************************
 FLLIBDELETERULE_A(+CallerModule,+RuleList)
 FLLIBDELETERULE_Z(+CallerModule,+RuleList)
 FLLIBDELETERULE(+CallerModule,+RuleList)
************************************************************************/ 
FLLIBDELETERULE_A(CallerMod,RuleList) :-
	flora_select_and_delete_rules(FLLIBDELETERULE_A,CallerMod,RuleList).
FLLIBDELETERULE_Z(CallerMod,RuleList) :-
	flora_select_and_delete_rules(FLLIBDELETERULE_Z,CallerMod,RuleList).
FLLIBDELETERULE(CallerMod,RuleList) :-
        flora_select_and_delete_rules(_DONOTCARE,CallerMod,RuleList).

/***********************************************************************
 flora_select_and_delete_rules(+DelOp,+CallerMod,+RuleList)
 InsOp is FLLIBDELETERULE_A or FLLIBDELETERULE_Z or unbound
 check the existence of all rules and delete them
************************************************************************/ 
flora_select_and_delete_rules(DelOp,CallerMod,RuleList) :-
        flora_select_rules_for_deletion(DelOp,CallerMod,RuleList,SigList,HeadList),
        flora_delete_rules(SigList),
        flora_bind_libmodobj(HeadList,BoundHeadList),
        flora_refresh_ruleheads(BoundHeadList).

/***********************************************************************
 flora_refresh_ruleheads(+HeadList)
 get rid of the possibly tabled calls to the head
************************************************************************/ 
flora_refresh_ruleheads([]) :- !.
flora_refresh_ruleheads([H|L]) :-
        flora_refresh_rulehead(H),
        flora_refresh_ruleheads(L),
	incr_flora_update_counter.

flora_refresh_rulehead(Head) :-
	%% heads might be passed in body form
	convert_to_head_literal(Head,HHead),
	flora_refresh_tables(HHead).

/***********************************************************************
 flora_select_rules_for_deletion(+DelOp,+CallerMod,+RuleList,-SigList,-HeadList)
 check if the rule exists and return matching rule signatures
************************************************************************/ 
flora_select_rules_for_deletion(_DelOp,_Mod,[],[],[]) :- !.
flora_select_rules_for_deletion(DelOp,CallerMod,[FLSYSRULEUPDATE(Id,FileName,_DescrVarTerm,_RuleNum,DescrMetaFacts,HeadList,Body,_HV,_BV,_PreBody,_PostBody,_DefeatCond)|L],SigList,HL) :-
	!,
	flora_check_multiheaded_rule_in_registry(DelOp,Id,FileName,RuleMod,HeadList,Body,HSigList,HHL),
	(var(RuleMod) -> RuleMod = CallerMod ; true),
	%% Match the metafacts before deciding to delete
	call_metafact_list(DescrMetaFacts,FileName,RuleMod),
	flora_select_rules_for_deletion(DelOp,CallerMod,L,LSigList,LHL),
	append(HSigList,LSigList,SigList),
	append(HHL,LHL,HL).

%% here we delete latent query sigs right away and don't select any rules
%% by adding to SigList and HL
flora_select_rules_for_deletion(DelOp,CallerMod,[FLSYSDELQUERYSIG(Id,_FN,_Mod,DescrMetaFacts,LatentQuery)|L],SigList,HL) :-
	!,
	%% Match the metafacts before deciding to delete
	call_metafact_list(DescrMetaFacts,FileName,RuleMod),
	FLLIBDELQUERYSIG(Id,FileName,RuleMod,DescrMetaFacts,LatentQuery),
	flora_select_rules_for_deletion(DelOp,CallerMod,L,SigList,HL).

%% conjunction of rules - convert to list
flora_select_rules_for_deletion(DelOp,CallerMod,[(R,L)|Rules],SigList,HL) :-
	!,
	conjunct_to_list((R,L),RuleList),
	flora_select_rules_for_deletion(DelOp,CallerMod,RuleList,HSigList,HHL),
	flora_select_rules_for_deletion(DelOp,CallerMod,Rules,RSigList,RHL),
        append(HSigList,RSigList,SigList),
        append(HHL,RHL,HL).
flora_select_rules_for_deletion(_DelOp,_Mod,[H|_Tail],_SigList,_HL) :-
	!,
	flora_decode_goal_as_atom(H,AtomH),
	flora_abort(['a non-rule item ',H,' in deleterule{...}, ',AtomH],FLORA_ABORT_NOTRACE).

/***********************************************************************
  flora_check_multiheaded_rule_in_registry(+DelOp,+Id,+FileName,+RuleMod,+HeadList,+Body,-RuleSigList,-NewHeadList)
  For multiheaded rules, check if a rule for each head component exists
       in the rule registry.
    NewHeadList: list of the matching instances for HeadList that are
       found in the rule registry
***********************************************************************/
flora_check_multiheaded_rule_in_registry(_DelOp,_Id,_FN,_Mod,[],_Body,[],[]) :- !.
flora_check_multiheaded_rule_in_registry(DelOp,Id,FileName,RuleMod,[H|L],Body,[HSig|LSig],[HH|LH]) :-
        flora_check_rule_in_registry(DelOp,Id,FileName,RuleMod,H,Body,HSig,HH),
        flora_check_multiheaded_rule_in_registry(DelOp,Id,FileName,RuleMod,L,Body,LSig,LH).

flora_check_rule_in_registry(DelOp,Id,FileName,RuleMod,Head,Body,RuleSig,BoundHead) :-
        get_canonical_form(Head,FLCANON(_,_,_,HT,_)),
	convert_to_body_literal(HT,BHead),
        ( DelOp == FLLIBDELETERULE_A ->
            matching_rule_signature(Id,FileName,_DescrVarTerm,FL_DYNAPREFIX,BHead,Body,RuleSig)
        ; DelOp == FLLIBDELETERULE_Z ->
            matching_rule_signature(Id,FileName,_DescrVarTerm,FL_DYNZPREFIX,BHead,Body,RuleSig)
        ; matching_rule_signature(Id,FileName,_DescrVarTerm,_,BHead,Body,RuleSig)
        ),
	rule_signature_member(module,RuleSig,RuleMod),
        get_canonical_form(BHead,FLCANON(_,_,_,BoundHead,_)).


/***********************************************************************
  flora_delete_rules(+RuleSigList)

***********************************************************************/
flora_delete_rules([]) :- !.
%% Atr is rule_signature list
flora_delete_rules([(Id,FileName,DescrVarTerm,DynPrefix,Mod,RuleNum,Head,Body,_PreBody,_PostBody,_DefeatCond,RuleList,BridgeRule)|L]) :-
        flora_retract_rulelist(RuleList),
	%% retract signatures does not ask for DefeatCond, so it's missing below
        flora_retract_signatures(Id,FileName,DescrVarTerm,DynPrefix,Mod,Head,Body,RuleList,BridgeRule),
        ( BridgeRule==[] -> true
        ;
	    %% A multiheaded rule, say p,q :- r, is represented as p :- newpred,
	    %% q:-newpred,  newpred :- r. One might be deleting just p:-r.
	    %% If so, the bridge rule newpred:- r is still needed and the above
	    %% flora_retract_signatures/9 will not delete all the signatures
	    %% that have BridgeRule. So, we are testing if BridgeRule is still
	    %% there. If so, we do not delete BridgeRule.
            ( show_rule_signature(Id,FileName,_DescrVarTerm,DynPrefix,Mod,RuleNum,_H,_BS,_PreB,_PostB,_DefeatCond,_RL,BridgeRule) -> true
            ;
                flora_retract_rulelist(BridgeRule)
            )
        ),
	%% Delete metafacts associated with the rule
	flora_clear_all_metafacts_by_ruleid(Id,FileName,Mod),
        flora_delete_rules(L).

flora_retract_rulelist(FL_COMMA(RL1,RL2)) :-
        !,
        flora_retract_rulelist(RL1),
        flora_retract_rulelist(RL2).
flora_retract_rulelist([]) :- !.
flora_retract_rulelist([H|L]) :-
        flora_adaptive_retract(H),
        flora_retract_rulelist(L).

/***********************************************************************
 inst_body(+Body,-InstBody)
 get rid of fllibmodlit with module name already bound
************************************************************************/ 
inst_body(B,B) :-
        var(B),
        !.

inst_body(FL_COMMA(B1,B2),FL_COMMA(NB1,NB2)) :-
	!,
	inst_body(B1,NB1),
	inst_body(B2,NB2).

inst_body(FL_SEMICOLON(B1,B2),FL_SEMICOLON(NB1,NB2)) :-
	!,
	inst_body(B1,NB1),
	inst_body(B2,NB2).

inst_body(not(B),not(NB)) :-
	!,
	inst_body(B,NB).

inst_body(tnot(B),tnot(NB)) :-
	!,
	inst_body(B,NB).

inst_body(Body,NB) :-
	is_control(Body,Ctl,Branches),
	!,
	inst_list(Branches,InstBranches),
	NB =.. [Ctl|InstBranches].

inst_body(FLLIBMODLIT(F,Args,MName,Caller),Inst) :-
        !,
        get_canonical_form(FLLIBMODLIT(F,Args,MName,Caller),FLCANON(_W,_A,_M,Callable,_)),
        (var(Callable) ->
            Inst = FLLIBMODLIT(F,Args,MName,Caller)
        ;
	    flora_bind_last(Callable,Caller),
	    Callable = Inst
        ).

inst_body(Body,Body).
	
inst_list([],[]) :- !.
inst_list([H|L],[NH|NL]) :-
	inst_body(H,NH),
	inst_list(L,NL).

/***********************************************************************
 new_dynpredicate(-NewPredName)
 new_dynruleid(-NewRuleId)
************************************************************************/ 
new_dynpredicate(NewPredName) :-
	conget(GLOBAL_DYN_NEWPREDICATE_COUNTER, N),
	M is N+1,
	conset(GLOBAL_DYN_NEWPREDICATE_COUNTER, M),
	flora_concat_items([GLOBAL_DYN_NEWPREDICATE,N], NewPredName).

new_dynruleid(NewRuleId) :-
	conget(GLOBAL_DYN_RULEID_COUNTER, N),
	M is N+1,
	conset(GLOBAL_DYN_RULEID_COUNTER, M),
	%% we don't want to create lotsa strings on the heap
	%%flora_concat_items([DEFAULT_DYN_RULEID,N], NewRuleId).
	N = NewRuleId.
	%%NewRuleId is N+24.


/***********************************************************************
 '_$flr_check_vars'(+RuleId,+FileName,+HeadList,+Body,+NamedHeadVars,+NamedBodyVars,-Warnings)
************************************************************************/ 
'_$flr_check_vars'(RuleId,FileName,HeadList,Body,NamedHVars,NamedBVars,Warnings) :-
        flrterm_vars(HeadList,HVars,0), %% 0: collect all vars
        flrterm_vars(Body,BVars,0),
        append(HVars,BVars,Vars),
        singleton_vars(Vars,Vars,SingletonVars),
        singleton_warning(RuleId,FileName,SingletonVars,NamedHVars,NamedBVars,SWarnings),
        subtract_vars(HVars,BVars,UnboundVars),
        unbound_warning(RuleId,FileName,UnboundVars,NamedHVars,UWarnings),
        append(SWarnings,UWarnings,Warnings).

singleton_vars(_AllVars,[],[]) :- !.
singleton_vars(AllVars,[H|L], [H|SL]) :-
        is_singleton(AllVars,H,0),
        !,
        singleton_vars(AllVars,L,SL).
singleton_vars(AllVars,[_H|L],SL) :-
        singleton_vars(AllVars,L,SL).

is_singleton([],_V,_Cnt) :- !.
is_singleton([H|L],V,Cnt) :-
        (H==V ->
            (Cnt==1 -> fail
            ;
                is_singleton(L,V,1)
            )
        ;
            is_singleton(L,V,Cnt)
        ).

singleton_warning(_RuleId,_File,[],_NamedHVars,_NamedBVars,[]) :- !.
singleton_warning(RuleId,File,[H|L],NamedHVars,NamedBVars,Warns) :-
	(flora_get_textual_info(RuleId,File,Info)
	-> Info = FL_TEXTUAL_INFO_PRED(_,_,Line,_,_,_)
	; Line = '<unknown>'
	),
	extract_stmt_fileinfo_from_filespec(File,PrintableFile,_,_),
        ( get_var_name(H,NamedHVars,Name) ->
            fmt_write_string(WarningStr,'singleton variable %s in dynamically inserted rule on line %S in file %S', args(Name,Line,PrintableFile)),
            Warns=[WarningStr|RestWarns]
        ;
            ( get_var_name(H,NamedBVars,Name) ->
                fmt_write_string(WarningStr,'singleton variable %s in dynamically inserted rule on line %S in file %S', args(Name,Line,PrintableFile)),
                Warns=[WarningStr|RestWarns]
            ;
                Warns=RestWarns
            )
        ),
        singleton_warning(RuleId,File,L,NamedHVars,NamedBVars,RestWarns).

get_var_name(H,[N=V|NVs],Name) :-
        ( H==V -> Name=N
	; get_attr(H,FLDYNRULEVARCHECK,[HN=HV]), HV==V, HN==N -> Name=N
        ;
            get_var_name(H,NVs,Name)
        ).

subtract_vars([],_BVars,[]) :- !.
subtract_vars([H|L],BVars,LUV) :-
        in_list(H,BVars),
        !,
        subtract_vars(L,BVars,LUV).
subtract_vars([H|L],BVars,[H|LUV]) :-
        subtract_vars(L,BVars,LUV).

in_list(V,[H|L]) :-
        ( H==V ->
            true
        ;
            in_list(V,L)
        ).

unbound_warning(_RuleId,_File,[],_NamedHVars,[]) :- !.
unbound_warning(RuleId,File,[H|L],NamedHVars,Warns) :-
	(flora_get_textual_info(RuleId,File,Info)
	-> Info = FL_TEXTUAL_INFO_PRED(_,_,Line,_,_,_)
	; Line = '<unknown>'
	),
	extract_stmt_fileinfo_from_filespec(File,PrintableFile,_,_),
        ( get_var_name(H,NamedHVars,Name) ->
            fmt_write_string(WarningStr,'unsafe variable %s in the head of dynamically inserted rule on line %S in file %S', args(Name,Line,PrintableFile)),
            unbound_warning(RuleId,File,L,NamedHVars,RestWarns),
            Warns=[WarningStr|RestWarns]
        ;
            unbound_warning(RuleId,File,L,NamedHVars,Warns)
        ).


/***********************************************************************
 is_invalid_flogic_head(+Pred)
************************************************************************/ 
is_invalid_flogic_head(WRAP_MVDINC) :- !.
is_invalid_flogic_head(WRAP_IMVDINC) :- !.
is_invalid_flogic_head(WRAP_MVDTOLIST) :- !.
is_invalid_flogic_head(WRAP_IMVDTOLIST) :- !.


/***********************************************************************
 flora_show_warnings(+WarningList)
************************************************************************/ 
flora_show_warnings([]) :- !.
flora_show_warnings([H|L]) :-
        flora_warning_line(H),
        flora_show_warnings(L).


flora_assert_metafact_list([],_,_) :- !.
/*
%% One can have variables in the Id and tags, so this error is invalid
%% We better check in the compiler that Id or Tag is not a pure var.
flora_assert_metafact_list([H|_],_,_) :-
	flrnonground(H),
	!,
	flora_abort(['a non-ground descriptor in insertrule{...},\n\t',
		     H],FLORA_ABORT_NOTRACE).
*/
flora_assert_metafact_list([NULL|Rest],FileName,Mod) :-
	!,
	flora_assert_metafact_list(Rest,FileName,Mod).
flora_assert_metafact_list([H|T],FileName,Module) :-
	%% bind the module and filename in metafacts
	(var(FileName) -> FileName = FL_DYNRULE_FICTITIOUS_FILENAME ; true),
	(H = FL_TAG_DESCRIPTOR_META_PREDICATE(_,FileName,Module,_,_), !
	; H = FL_BOOL_DESCRIPTOR_META_PREDICATE(_,FileName,Module,_,_), !
	; H = FL_PROP_DESCRIPTOR_META_PREDICATE(_,FileName,Module,_,_,_), !
	; H = FL_RULE_ENABLER(_,FileName,Module)
	),
	(is_duplicate_rule_id(H)
	-> arg(1,H,RuleId),
	    arg(2,H,RFN),
	    flora_abort(['a rule with Id (',
			 RuleId,',',RFN,',',Module,
			 ') already exists'],
			FLORA_ABORT_NOTRACE)
	;
	    flora_adaptive_assert(H),
	    flora_assert_metafact_list(T,FileName,Module)
	).

%% we assume that the rule enabler is always first in the prebody
bind_rule_enabler((Enabler,_),File,Module) :-
	!,
	Enabler = FL_RULE_ENABLER(_,File,Module).
bind_rule_enabler(Enabler,File,Module) :-
	Enabler = FL_RULE_ENABLER(_,File,Module).

is_duplicate_rule_id(H) :-
	H = FL_RULE_ENABLER(_,_,_),
	!,
	call(H).

call_metafact_list([],_,_) :- !.
call_metafact_list([NULL|Rest],FileName,Mod) :-
	!,
	call_metafact_list(Rest,FileName,Mod).
call_metafact_list([Head|Rest],FileName,Mod) :-
	get_module_from_metafacts(Head,Mod),
	arg(2,Head,FileName),
	call(Head),
	call_metafact_list(Rest,FileName,Mod).

%% if there are multiple different (in different directories) files
%% with the same base name loaded into the same module then
%% textual info might not be correct.
get_fullfile_name(FileName,ModName,FullFile) :-
	(flora_user_load_registry(FullFile,ModName,FileName,_)
	-> true
	; FullFile = FileName
	).

/*
adaptive_retract_list([]) :- !.
adaptive_retract_list([H|T]) :-
	adaptive_retract(H),
	adaptive_retract_list(T).
*/

%% reset new dyn predicate and ruleid counters
?- conset(GLOBAL_DYN_NEWPREDICATE_COUNTER, 1),
   conset(GLOBAL_DYN_RULEID_COUNTER,1).
