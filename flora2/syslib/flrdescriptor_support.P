/* File:      flrdescriptor_support.P
**
** Author(s): Michael Kifer
**
** Contact:   flora-users@lists.sourceforge.net
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 2012-2013;
**      and Vulcan, Inc., 2012-2013.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**      http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
**
*/

:- compiler_options([xpp_on]).
#include "flora_terms.flh"
#include "flora_tabling_methods.flh"

:- import
	FL_TAG_DESCRIPTOR_META_PREDICATE/4,
	FL_BOOL_DESCRIPTOR_META_PREDICATE/4,
	FL_PROP_DESCRIPTOR_META_PREDICATE/5,
	FL_FORCED_DEFEASIBILITY_UNION/3,
	FL_RULE_ENABLER_UNION/2
   from usermod.

:- import term_arg/3 from machine.

:- import
	flora_decode_module_name/2,
	flora_modularize_atom/3
   from flrwrapper.
:- import
	flora_refresh_tables/1
   from flrtables.
:- import
	convert_to_head_literal/2,
        show_rule_signature/9
   from flrcanon.
	
:- import
	flora_adaptive_assert/1,
	flora_adaptive_retract/1
   from flrstoragebase.

:- export
	get_tag_descriptor_info/4,
	get_bool_descriptor_info/4,
	get_prop_descriptor_info/5,

	get_tag_descriptor_info_with_rulehead/5,
	get_bool_descriptor_info_with_rulehead/5,

	get_ruleid_by_tag_or_head/4,

	synonymous_tag/3,
	synonymous_tag_with_head/4,

	is_defeasible_rule/2,
	is_defeasible_tag/2,
	is_strict_rule/2,
	make_rule_defeasible/2,
	make_rule_strict/2,

	disable_rule_by_id/2,
	enable_rule_by_id/2,
	is_enabled_rule/2,
	is_disabled_rule/2,

	get_module_from_metafacts/2,

	clear_bool_metafacts_by_ruleid/2,
	clear_tag_metafacts_by_ruleid/2,
	clear_prop_metafacts_by_ruleid/2,
	flora_reset_descriptor_meta_predicates/1.


get_tag_descriptor_info(RuleId,Module,Tag,VarTerm) :-
	FL_TAG_DESCRIPTOR_META_PREDICATE(RuleId,Module,Tag,VarTerm).
get_bool_descriptor_info(RuleId,Module,BoolProp,VarTerm) :-
	FL_BOOL_DESCRIPTOR_META_PREDICATE(RuleId,Module,BoolProp,VarTerm).
get_prop_descriptor_info(RuleId,Module,PropName,PropValue,VarTerm) :-
	FL_PROP_DESCRIPTOR_META_PREDICATE(RuleId,Module,PropName,PropValue,VarTerm).


%% tabling get_tag_descriptor_info_with_rulehead/5 helps about 10%
%% but see if this works with incremental tabling
:- table get_tag_descriptor_info_with_rulehead/5 as AUXILIARY_TABLING_TYPE.
%% if Tag and Id are vars, try to index on Head
get_tag_descriptor_info_with_rulehead(RuleId,Module,Tag,Head,VarTerm) :-
	var(RuleId),
	var(Tag),
	(nonvar(Head), flora_decode_module_name(Head,HeadMod)
	-> RealMod = HeadMod
	;
	    RealMod = Module
	),
	!,
	show_rule_signature(RuleId,VarTerm,_Prefix,RealMod,Head,_Body,
			    _DefeatCond,_RuleList,_BridgeRule),
	FL_TAG_DESCRIPTOR_META_PREDICATE(RuleId,RealMod,Tag,VarTerm).
get_tag_descriptor_info_with_rulehead(RuleId,Module,Tag,Head,VarTerm) :-
	(nonvar(Head), flora_decode_module_name(Head,HeadMod)
	-> RealMod = HeadMod
	;
	    RealMod = Module
	),
	FL_TAG_DESCRIPTOR_META_PREDICATE(RuleId,RealMod,Tag,VarTerm),
	show_rule_signature(RuleId,VarTerm,_Prefix,RealMod,Head,_Body,
			    _DefeatCond,_RuleList,_BridgeRule).

%% this tabling does not help
%%:- table get_ruleid_by_tag_or_head/4 as AUXILIARY_TABLING_TYPE.
get_ruleid_by_tag_or_head(Tag,Head,Module,RuleId) :-
	nonvar(Tag),
	(nonvar(Head), flora_decode_module_name(Head,HeadMod)
	-> RealMod = HeadMod
	;
	    RealMod = Module
	),
	!,
	FL_TAG_DESCRIPTOR_META_PREDICATE(RuleId,RealMod,Tag,VarTerm),
	show_rule_signature(RuleId,VarTerm,_Prefix,RealMod,Head,_Body,
			    _DefeatCond,_RuleList,_BridgeRule).
get_ruleid_by_tag_or_head(Tag,Head,Module,RuleId) :-
	%% Tag is a var
	(nonvar(Head), flora_decode_module_name(Head,HeadMod)
	-> RealMod = HeadMod
	;
	    RealMod = Module
	),
	show_rule_signature(RuleId,VarTerm,_Prefix,RealMod,Head,_Body,
			    _DefeatCond,_RuleList,_BridgeRule),
	FL_TAG_DESCRIPTOR_META_PREDICATE(RuleId,RealMod,Tag,VarTerm).

%% this tabling does not help
%%:- table get_bool_descriptor_info_with_rulehead/5 as AUXILIARY_TABLING_TYPE.
get_bool_descriptor_info_with_rulehead(RuleId,Module,BoolProp,Head,VarTerm) :-
	nonvar(RuleId),
	(nonvar(Head), flora_decode_module_name(Head,HeadMod)
	-> RealMod = HeadMod
	;
	    RealMod = Module
	),
	!,
	FL_BOOL_DESCRIPTOR_META_PREDICATE(RuleId,RealMod,BoolProp,VarTerm),
	show_rule_signature(RuleId,VarTerm,_Prefix,RealMod,Head,_Body,
			    _DefeatCond,_RuleList,_BridgeRule).
%% if Id is a var, try to index on Head
get_bool_descriptor_info_with_rulehead(RuleId,Module,BoolProp,Head,VarTerm) :-
	(nonvar(Head), flora_decode_module_name(Head,HeadMod)
	-> RealMod = HeadMod
	;
	    RealMod = Module
	),
	show_rule_signature(RuleId,VarTerm,_Prefix,RealMod,Head,_Body,
			    _DefeatCond,_RuleList,_BridgeRule),
	FL_BOOL_DESCRIPTOR_META_PREDICATE(RuleId,RealMod,BoolProp,VarTerm).

%% synonymous_tag/3 used only in genincludes/flrdefeasible.fli
%% usually synonymous_tag_with_head/4 is used
%% Tabling either of these does not help, even slows things down a tiny bit.
synonymous_tag(Tag1,Mod,Tag2) :-
	nonvar(Tag1),
	!,
	get_tag_descriptor_info(Id,Mod,Tag1,Vars),
	get_tag_descriptor_info(Id,Mod,Tag2,Vars).
synonymous_tag(Tag1,Mod,Tag2) :-
	get_tag_descriptor_info(Id,Mod,Tag2,Vars),
	get_tag_descriptor_info(Id,Mod,Tag1,Vars).

synonymous_tag_with_head(Tag,_Mod,Tag,Head) :-
	var(Tag),
	var(Head),
	!.
synonymous_tag_with_head(Tag1,Mod,Tag2,Head) :-
	get_tag_descriptor_info_with_rulehead(Id,Mod,Tag1,Head,Vars),
	get_tag_descriptor_info_with_rulehead(Id,Mod,Tag2,Head,Vars).

%% The predicate of forced defeasibility FL_FORCED_DEFEASIBILITY_UNION
%% overrides whatever the descriptor says about defeasibility

%% is_defeasible_rule(+Id,+Mod)
:- table is_defeasible_rule/2 as AUXILIARY_TABLING_TYPE.
is_defeasible_rule(Id,Mod) :-
	FL_FORCED_DEFEASIBILITY_UNION(Id,Mod,FL_DEFEASIBLE),
	!.
is_defeasible_rule(Id,Mod) :-
	\+ FL_FORCED_DEFEASIBILITY_UNION(Id,Mod,FL_STRICT),
	get_bool_descriptor_info(Id,Mod,FL_DEFEASIBLE,_).
%% is_strict_rule(+Id,+Mod)
:- table is_strict_rule/2 as AUXILIARY_TABLING_TYPE.
is_strict_rule(Id,Mod) :-
	FL_FORCED_DEFEASIBILITY_UNION(Id,Mod,FL_STRICT),
	!.
is_strict_rule(Id,Mod) :-
	\+ FL_FORCED_DEFEASIBILITY_UNION(Id,Mod,FL_DEFEASIBLE),
	get_bool_descriptor_info(Id,Mod,FL_STRICT,_).

is_defeasible_tag(Tag,Mod) :-
	nonvar(Tag),
	!,
	get_tag_descriptor_info(Id,Mod,Tag,_VarTerm),
	is_defeasible_rule(Id,Mod).
is_defeasible_tag(Tag,Mod) :-
	is_defeasible_rule(Id,Mod),
	get_tag_descriptor_info(Id,Mod,Tag,_VarTerm).


:- import flora_abolish_table_predicate/1 from flrtables.

%% make_rule_defeasible(+Id,+Mod)
make_rule_defeasible(Id,Mod) :-
	flora_modularize_atom(FL_FORCED_DEFEASIBILITY,Mod,
			      ModularDefeasibilityPredName),
	DefeasibilityPred =.. [ModularDefeasibilityPredName,Id,_],
	(flora_adaptive_retract(DefeasibilityPred), fail ; true),
	!,
	%%arg(2,DefeasibilityPred,FL_DEFEASIBLE),
	term_arg(DefeasibilityPred,2,Flag), Flag=FL_DEFEASIBLE,
	flora_adaptive_assert(DefeasibilityPred),
	flora_abolish_table_predicate(is_defeasible_rule(Id,Mod)),
	flora_abolish_table_predicate(is_strict_rule(Id,Mod)).
%% make_rule_strict(+Id,+Mod)
make_rule_strict(Id,Mod) :-
	flora_modularize_atom(FL_FORCED_DEFEASIBILITY,Mod,
			      ModularDefeasibilityPredName),
	DefeasibilityPred =.. [ModularDefeasibilityPredName,Id,_],
	(flora_adaptive_retract(DefeasibilityPred), fail ; true),
	!,
	%%arg(2,DefeasibilityPred,FL_STRICT),
	term_arg(DefeasibilityPred,2,Flag), Flag=FL_STRICT,
	flora_adaptive_assert(DefeasibilityPred),
	flora_abolish_table_predicate(is_defeasible_rule(Id,Mod)),
	flora_abolish_table_predicate(is_strict_rule(Id,Mod)).

/*************************************************************************
       enable_rule_by_id(+Id,+Mod)
       disable_rule_by_id(+Id,+Mod)

   These assert/retract enabler metafacts for rules (static or dynamic)
   and thus have the effect similar to assert/retract, but much cheaper

   enable_rule_by_id/2 is idempotent
   disable_rule_by_id/2 fails if the rule is already disabled
*************************************************************************/
enable_rule_by_id(Id,Mod) :-
	findall(Head,
		show_rule_signature(Id,_DescrVarTerm,_Prefix,Mod,Head,_Body,
				    _DefeatCond,_RuleList,_BridgeRule),
		HeadList),
	%% refreshing all heads in a multiheaded rule
	refresh_head_list(HeadList),
	flora_modularize_atom(FL_RULE_ENABLER,Mod,ModularEnabler),
	EnablerPred =.. [ModularEnabler,Id],
	(EnablerPred -> true  % idempotent
	; flora_adaptive_assert(EnablerPred)
	).

disable_rule_by_id(Id,Mod) :-
	findall(Head,
	        show_rule_signature(Id,_DescrVarTerm,_Prefix,Mod,Head,_Body,
				    _DefeatCond,_RuleList,_BridgeRule),
		HeadList),
	%% refreshing all heads in a multiheaded rule
	refresh_head_list(HeadList),
	flora_modularize_atom(FL_RULE_ENABLER,Mod,ModularEnabler),
	EnablerPred =.. [ModularEnabler,Id],
	(\+EnablerPred -> true
	; flora_adaptive_retract(EnablerPred)
	).

refresh_head_list([]) :- !.
refresh_head_list([H|Rest]) :-
	convert_to_head_literal(H,HeadAsHead),
	flora_refresh_tables(HeadAsHead),
	refresh_head_list(Rest).


is_enabled_rule(Id,Mod) :-
	var(Mod),
	!,
	show_rule_signature(Id,_DescrVarTerm,_Prefix,Mod,_Head,_Body,
			    _DefeatCond,_RuleList,_BridgeRule),
	(FL_RULE_ENABLER_UNION(Id,Mod) -> true
	; fail
	).
is_enabled_rule(Id,Mod) :-
	flora_modularize_atom(FL_RULE_ENABLER,Mod,ModularEnabler),
	EnablerPred =.. [ModularEnabler,Id],
	show_rule_signature(Id,_DescrVarTerm,_Prefix,Mod,_Head,_Body,
			    _DefeatCond,_RuleList,_BridgeRule),
	(EnablerPred -> true
	; fail
	).

is_disabled_rule(Id,Mod) :-
	var(Mod),
	!,
	show_rule_signature(Id,_DescrVarTerm,_Prefix,Mod,_Head,_Body,
			    _DefeatCond,_RuleList,_BridgeRule),
	(FL_RULE_ENABLER_UNION(Id,Mod) -> fail
	; true
	).
is_disabled_rule(Id,Mod) :-
	flora_modularize_atom(FL_RULE_ENABLER,Mod,ModularEnabler),
	EnablerPred =.. [ModularEnabler,Id],
	show_rule_signature(Id,_DescrVarTerm,_Prefix,Mod,_Head,_Body,
			    _DefeatCond,_RuleList,_BridgeRule),
	(EnablerPred -> fail
	; true
	).

/*************************************************************************
   flora_reset_descriptor_meta_predicates(+ModuleName)

   retracts all content from meta predicates for module
*************************************************************************/
flora_reset_descriptor_meta_predicates(Mod) :-
	retractall(FL_TAG_DESCRIPTOR_META_PREDICATE(_,Mod,_,_)),
	retractall(FL_BOOL_DESCRIPTOR_META_PREDICATE(_,Mod,_,_)),
	retractall(FL_PROP_DESCRIPTOR_META_PREDICATE(_,Mod,_,_,_)),
	flora_modularize_atom(FL_RULE_ENABLER,Mod,RuleEnablerPredName),
	RuleEnabler =.. [RuleEnablerPredName,_],
	retractall(RuleEnabler).

/**************************************************************************
	clear_bool_metafacts_by_ruleid(+RuleId,+Mod)
	clear_tag_metafacts_by_ruleid(+RuleId,+Mod)
	clear_prop_metafacts_by_ruleid(+RuleId,+Mod)

  Clear all bool/tag metafacts for a given Id and module
  If no rules with this id is left ONLY THEN do we delete the metafacts.
  Otherwise, we might delete part of a multiheaded rule and this would
  eliminate the meta-facts for the rest of that rule. Eg, if the rule were
  ?X:foo[moo->?Y] :- body.
  and we are deleting ?X:foo :- body, we do not want to delete the metafacts
  yet, since the remainder, ?X[moo->?Y] :- body still needs them.
**************************************************************************/
clear_bool_metafacts_by_ruleid(RuleId,Mod) :-
	(\+show_rule_signature(RuleId,_,_,Mod,_,_,_,_,_)
	-> retractall(FL_BOOL_DESCRIPTOR_META_PREDICATE(RuleId,Mod,_,_))
	; true
	).

clear_tag_metafacts_by_ruleid(RuleId,Mod) :-
	(\+show_rule_signature(RuleId,_,_,Mod,_,_,_,_,_)
	-> retractall(FL_TAG_DESCRIPTOR_META_PREDICATE(RuleId,Mod,_,_))
	; true
	).

clear_prop_metafacts_by_ruleid(RuleId,Mod) :-
	(\+show_rule_signature(RuleId,_,_,Mod,_,_,_,_,_)
	-> retractall(FL_PROP_DESCRIPTOR_META_PREDICATE(RuleId,Mod,_,_,_))
	; true
	).

/*****************************************************************************
    Module out of metafact conjunction
*****************************************************************************/
%% case of conjunction of metafacts
get_module_from_metafacts((Meta,_RestMeta),Mod) :-
	!,
	%%arg(2,Meta,Mod).
	term_arg(Meta,2,ModVar),
	%% can't put Mod directly in term_arg/3:
	%% arg3 must be unbound while Mod may be bound
	ModVar = Mod.
%% single metafact
get_module_from_metafacts(Meta,Mod) :-
	%%arg(2,Meta,Mod).
	term_arg(Meta,2,ModVar),
	%% can't put Mod directly in term_arg/3:
	%% arg3 must be unbound while Mod may be bound
	ModVar = Mod.
