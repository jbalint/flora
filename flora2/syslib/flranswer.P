/* File:        flranswer.P
**
** Author(s): Guizhen Yang
**            Michael Kifer 
**
** Contact:   flora-users@lists.sourceforge.net
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2013.
**      and Vulcan, Inc., 2008-2013.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**      http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
**
*/


:- compiler_options([xpp_on]).

#include "char_defs.h"
#include "standard.h"
#include "flora_terms.flh"
#include "flora_status_codes.flh"

%% Request number for obtaining the delay register
#define DELAY_REG  2

%% Names of answer tries
#define FLRANSWER_TRUE_TRIE   '_$_$flora_true_answer_storage'
#define FLRANSWER_UNDEF_TRIE  '_$_$flora_undef_answer_storage'
#define FLRANSWER_FUNCTOR     answer

#define FLRANSWER_ENDBALL     flranswer_endball

:- import
	timed_call/4
   from standard.

:- import windows_os/0 from xsb_configuration.

:- import length/2 from basics.

:- import
	close_open_tables/1,
	is_acyclic/1,
	xwam_state/2
   from machine.

:- import
	flora_cputime/1,
	flora_walltime/1
   from flrporting.

:- import
	storage_insert_fact/3,
	storage_find_fact/2,
	storage_delete_all/1
   from storage.

:- import flora_builtin_datatype/1 from flrdatatype.

%%:- import flora_abolish_table_predicate/1 from flrtables.

:- import
	flora_stdfdbk_string/2,
	flora_stdfdbk_string/1,
	flora_stdfdbk_nl/0,
	flora_stdfdbk_line/1
   from flrprint.

:- import flora_call_hooks/5 from flrhooks.

:- import flora_commit_storage/0, flora_reclaim_storage_space/0 from flrutils.

:- import flora_display_feedback/1 from flrdisplay.
:- import
	flora_display_submode/1,
	flora_set_display_submode/1
   from flrdecode.

:- import
	flora_handle_trace/0,
	flora_handle_notrace/0,
	flora_switch/1
   from flrdebugger.

:- import
	flora_runtime_limits_registry/3
   from flrregistry.

:- import
	FLORA_DELAY_CHECKER/2
   from usermod.


/********************************************************************/
fllibshellans(Gs,NVs) :-
	flora_switch(all),
	!,
	catch(flora_print_all(Gs,NVs),FLRANSWER_ENDBALL,flora_end_of_answer_handler),
	!,
	%% to release XSB stack
	fail.

fllibshellans(Gs,NVs) :-
	catch(flora_print_one(Gs,NVs),FLRANSWER_ENDBALL,flora_end_of_answer_handler),
	!,
	%% to release XSB stack
	fail.

flora_end_of_answer_handler :-
	flora_reclaim_storage_space.


/********************************************************************/
fllibprogramans(Gs,NVs) :-
	catch(flora_print_all(Gs,NVs),FLRANSWER_ENDBALL,flora_end_of_answer_handler),
	!,
	%% to release XSB stack
	fail.
/*
%% The business of getting just one answer from a program query 
%% needs to be thought out.
fllibprogramans(Gs,NVs) :-
	flora_switch(all),
	!,
	flora_print_all(Gs,NVs),
	!,
	fail.

fllibprogramans(Gs,NVs) :-
	flora_print_one(Gs,NVs),
	!,
	fail.
*/


/********************************************************************
  NVs is a list of output variables
  Gs is a list of goals to evaluate

  This always fails so that the XSB stack will be released.
********************************************************************/
flora_print_all(Gs,NVs) :-
	NVs == [],
	!,
	flora_cputime(T0),
	flora_walltime(WT0),

	flora_call_hooks(_Mod,QUERYHOOK,Gs,before,AroundHookLink),

	%% Sometimes this may pick up XWamState>0 even if there is XWamState=0
	%% Not sure how to avoid this without findall, but we don't want to
	%% findall Gs if NVs==[], since this might result in multiple calls
	(catch(flora_call(Gs,NVs,XWamState),
	       Exception,
	       flranswer_one_answer_query_errhandler(Exception,Gs,AroundHookLink)
	      ),
	    flora_call_hooks(_Mod,QUERYHOOK,Gs,after,AroundHookLink)
	->
	    (
	      flora_cputime(T1),
	      flora_walltime(WT1),
	      T is T1-T0,
	      WT is WT1-WT0,
	      ( flora_switch(chatter) ->
		  flora_stdfdbk_string('~nElapsed (CPU) time ~w (~w) seconds~n',
				       [WT,T])
	      ; true
	      ),
	      flora_write_Yes_or_Unknown(XWamState)
	    )
	;
	    flora_cputime(T1),
	    flora_walltime(WT1),
	    T is T1-T0,
	    WT is WT1-WT0,
	    ( flora_switch(chatter) ->
		flora_stdfdbk_string('~nElapsed (CPU) time ~w (~w) seconds~n',
				     [WT,T])
	    ; true
	    ),
	    flora_write_No
	),
	throw(FLRANSWER_ENDBALL).

flora_print_all(Gs,NVs) :-
	flora_cputime(T0),
	flora_walltime(WT0),
	%% Construct a temporary trie-indexed predicate, FL_QUERY_PREDICATE
	%% All answers are asserted into that predicate.
	%% Since it is trie-indexed, duplicates are deleted.
	%% Reason: some answer lists might have thousands and
	%% millions of items, which takes a long time to sort. Sometimes
	%% sort runs out of memory and crashes XSB. 
	%% Having a trie-asserted query predicate adds a very small
	%% penalty to each query, but overall speeds up 
	%% returning the answers, and sometimes avoids crashes.
	QueryTemplate =.. [FL_QUERY_PREDICATE|NVs],
	length(NVs,QueryArity),
	dynamic(FL_QUERY_PREDICATE/QueryArity),
	index(FL_QUERY_PREDICATE/QueryArity,trie),
	
	flora_call_hooks(_Mod,QUERYHOOK,QueryTemplate,before,AroundHookLink),
	catch(
	      flora_findall((NVs,XWamState),
			    (flora_call(Gs,NVs,XWamState),
				/*
				 Do not use \+QueryTemplate:  if we have q(a)
				   and q(X) where the first is true and the
				   secod undefined then we will not get one of
				   them.
				    Note: we can get q(?X) undefined
				    due to the U-not case of naf.
				*/
				%%(\+ QueryTemplate -> assert(QueryTemplate))
				assert(QueryTemplate)
			    ),
			    TempL
			   ),
	      Exception,
	      flranswer_all_answers_query_errhandler(Exception,QueryTemplate,AroundHookLink)
	     ),
	flora_cputime(T1),
	flora_walltime(WT1),
	T is T1-T0,
	WT is WT1-WT0,
	flora_call_hooks(_Mod,QUERYHOOK,QueryTemplate,after,AroundHookLink),
	abolish(FL_QUERY_PREDICATE/QueryArity),
	sort(TempL,L),
	( L = [] ->
	    ( flora_switch(chatter) ->
		flora_stdfdbk_string('~nElapsed (CPU) time ~w (~w) seconds~n',
				     [WT,T])
	    ;
		true
	    ),
	    flora_write_No
	;
	    flora_display_submode(DisplMode),
	    flora_set_display_submode(answer),
	    flora_write_matches(L,0,NumOfSolutions),
	    flora_set_display_submode(DisplMode),
	    ( flora_switch(chatter) ->
		flora_stdfdbk_string('~n~w solution(s) in ~w seconds~n', [NumOfSolutions,T])
	    ;
		true
	    ),
	    flora_write_Yes
	),
	%% throw to close open tables
	throw(FLRANSWER_ENDBALL).


/********************************************************************/
flora_print_one(Gs,NVs) :-
	NVs == [],
	!,
	(flora_call(Gs,NVs,XWamState)
	->
	    flora_write_Yes_or_Unknown(XWamState)
	;
	    flora_write_No
	),
	%% throw to close open tables
	throw(FLRANSWER_ENDBALL).

flora_print_one(Gs,NVs) :-
	( flora_call(Gs,NVs,XWamState),
	    flora_set_display_submode(answer),
	    flora_write_pairs(NVs,XWamState),
	    flora_set_display_submode(default),
	    flora_fail_unless_return
	;
	    flora_write_No
	),
	%% throw to close open tables
	throw(FLRANSWER_ENDBALL).


/********************************************************************/
/*
flora_if_then_else(Condition,Then,_Else) :-
	call(Condition),
	call(Then).

flora_if_then_else(_Condition,_Then,Else) :-
	call(Else).
*/


/********************************************************************/
%% If the user types RETURN, then succeed. Otherwise, assume the user wants
%% more answers, so fail in order to provide another answer.
flora_fail_unless_return :- 
	get_code(C),
	(C =:= CH_NEWLINE; C =:= CH_EOF_P), !,
	flora_write_Yes.
flora_fail_unless_return :- flora_fail_unless_return, fail.


/********************************************************************/
flora_write_Yes :- flora_stdfdbk_line('~nYes~n').
flora_write_No  :- flora_stdfdbk_line('~nNo~n').
flora_write_Yes_or_Unknown(XWamState) :-
	(XWamState =:= 0 -> flora_stdfdbk_line('~nYes~n')
	; flora_stdfdbk_line('~nYes  - undefined~n')
	).

/********************************************************************/
%% Hookup to the Flora debugger
%% flora_call is a wrapper around XSB call
%% Used only in top-level queries
%% If XWamState = 0, the answer is true. Otherwise: undefined
flora_call(Goal,_NVs,XWamState) :- 
    	flora_handle_trace,
	( flora_runtime_limits_registry(timeout,Time,Handler)
	->
	    arg(1,Handler,Goal),
	    timed_call(Goal,Time,Handler,nesting)
	;
	    call(Goal)
	),
	FL_SILENT_ISACYCLIC(Goal),
	flora_ground:flrterm_vars_split(Goal, _RegVars, AttrVars,0),
	FLORA_DELAY_CHECKER(AttrVars,[]),
	%% xwam_state MUST be after FLORA_DELAY_CHECKER to get correct state
	xwam_state(DELAY_REG,XWamState),
	%%DBGOUTLN(final_xwam_state=XWamState+Goal),
	flora_commit_storage,
	flora_handle_end_of_call.

flora_call(_Goal,_NVs,_XWamState) :-
	flora_handle_notrace,
	fail.

FL_SILENT_ISACYCLIC(X) :- is_acyclic(X).

/********************************************************************/
flora_write_matches([],Count,Count).

flora_write_matches([(M,XWamState)|Ms],InCount,OutCount) :-
	flora_write_pairs(M,XWamState),
	MidCount is InCount+1,
	flora_stdfdbk_nl,
	flora_skip_identical_answers(M,Ms,PureMs),
	flora_write_matches(PureMs,MidCount,OutCount).


flora_write_pairs([],_).

flora_write_pairs([N=V|NVs],XWamState) :-
	flora_stdfdbk_nl,
	flora_stdfdbk_string('~w = ',[N]),
	flora_display_feedback(V),
	flora_write_if_undefined(XWamState),
	flora_write_pairs(NVs,XWamState).

flora_write_if_undefined(XWamState) :-
	(XWamState =:= 0 -> true
	; flora_stdfdbk_string('  - undefined')
	).

%% skip answers matching M in sorted list. Return the skipped list
/*
   Without this pruning, the following can happen:
   p(1) :- \true.
   p(1) :- \undefined.
   ?- p(?X).
   X = 1
   X = 1 - undefined
*/
flora_skip_identical_answers(_M,[],[]) :- !.
flora_skip_identical_answers(M,[(MM,_XwamState)|Rest],Out) :-
	subsumes:variant(M,MM),
	!,
	flora_skip_identical_answers(M,Rest,Out).
flora_skip_identical_answers(_M,List,List).

/********************************************************************/
%% This turns off trace, so that flora internal stuff done after a
%% subgoal call won''t be traced. However, on backtracking, this turns
%% trace on and fails, thereby allowing to backtrack over the previous
%% subgoal.
flora_handle_end_of_call :- flora_handle_notrace.
flora_handle_end_of_call :- flora_handle_trace, fail.

/********************************************************************/

/********************************************************************
    filters to get rid of some classes
********************************************************************/

flora_noncomposite_class(C) :-
	C \= (_;C1), var(C1), C \= (C2;_), var(C2),
	C \= (_,C3), var(C3), C \= (C4,_), var(C4),
	C \= (_ - C5), var(C5), C \= (C6 - _), var(C6).

flora_nonbuiltin_class(C) :- \+flora_builtin_datatype(C).


%% clean up after query, if error
flranswer_all_answers_query_errhandler(Exception,QueryTemplate,AroundHookLink) :-
	flora_call_hooks(_Mod,QUERYHOOK,QueryTemplate,after,AroundHookLink),
	flora_reclaim_storage_space,
	retractall(QueryTemplate),
	throw(Exception).

flranswer_all_answers_query_errhandler_collect(Exception,QueryTemplate,AroundHookLink) :-
	flora_call_hooks(_Mod,QUERYHOOK,QueryTemplate,after,AroundHookLink),
	flora_reclaim_storage_space,
	storage_delete_all(FLRANSWER_TRUE_TRIE),
	storage_delete_all(FLRANSWER_UNDEF_TRIE),
	throw(Exception).

flranswer_one_answer_query_errhandler(Exception,QueryTemplate,AroundHookLink) :-
	flora_call_hooks(_Mod,QUERYHOOK,QueryTemplate,after,AroundHookLink),
	flora_reclaim_storage_space,
	throw(Exception).


%% to silence the tracer
flora_findall(X,Y,Z) :- findall(X,Y,Z).


/****************************************************************************
TODO: rewrite flora_print_all using this more efficient predicate

      flora_collect_all(+Goal,+NameVarPairList,?TrueAnswers,?UndefinedAnswers,?Exception)

      Goal:            a reified goal
      NameVarPairList: a list of the form
                       [VarName1=val1, VarName2=val2,...]
      TrueAnswers/UndefinedAnswers:
                       lists of Prolog terms of the form
                       answer(Var1=val1,Var2=val2,...),
		       one for true answers and one for the undefined ones.

      If either TrueAnswers or UndefinedAnswers is a nonvar, then the
      corresponding argument is not touched. This is provided in order to
      minimize communication over slow links, like HTTP or sockets, in case
      either true or undefined answers are not required.

      This predicate always succeeds. If the query has no answers,
      both TrueAnswers and UndefinedAnswers are bound to [] 
      (unless they were bound at the call time; in this case,
      they retain their original bindings).

      This is used for other applications that wish to call
      FLORA-2 and get all results
*****************************************************************************/
flora_collect_all(Gs,NVs,TrueAns,UndefAns,Exception) :-
	NVs == [],
	!,
	flora_call_hooks(_Mod,QUERYHOOK,Gs,before,AroundHookLink),
	(catch(flora_call(Gs,NVs,XWamState),
	       Exception,
	       flranswer_one_answer_query_errhandler(Exception,
						     Gs,
						     AroundHookLink)
	      ),
	    close_open_tables(cleanup),
	    (XWamState=:=0
	    -> storage_insert_fact(FLRANSWER_TRUE_TRIE,FLRANSWER_FUNCTOR,_)
	    ; storage_insert_fact(FLRANSWER_UNDEF_TRIE,FLRANSWER_FUNCTOR,_)
	    ),
	    fail
	; true
	),
	(var(TrueAns)
	-> flora_findall(X,storage_find_fact(FLRANSWER_TRUE_TRIE,X),TrueAns)
	; true
	),
	(var(UndefAns)
	-> flora_findall(X,storage_find_fact(FLRANSWER_UNDEF_TRIE,X),UndefAns)
	; true
	),
	flora_call_hooks(_Mod,QUERYHOOK,Gs,after,AroundHookLink),
	flora_reclaim_storage_space,
	storage_delete_all(FLRANSWER_TRUE_TRIE),
	storage_delete_all(FLRANSWER_UNDEF_TRIE).


flora_collect_all(Gs,NVs,TrueAns,UndefAns,Exception) :-
	%% All answers are asserted into temp tries for true/undefined answers.
	%% Since these are tries, duplicates are deleted.
	%% Rationale: some answer lists might have hundreds of thousands
	%% items, which takes a long time to collect and sort.
	%% Sometimes sorting runs out of memory and crashes XSB. 
	%% Dealing with tries adds a very small overhead to each query, but
	%% overall speeds up returning the answers and often avoids crashes.
	QueryTemplate =.. [FLRANSWER_FUNCTOR|NVs],
	
	flora_call_hooks(_Mod,QUERYHOOK,QueryTemplate,before,AroundHookLink),
	catch(
	      (flora_call(Gs,NVs,XWamState),
		  (XWamState=:=0
		  -> storage_insert_fact(FLRANSWER_TRUE_TRIE,QueryTemplate,_)
		  ; storage_insert_fact(FLRANSWER_UNDEF_TRIE,QueryTemplate,_)
		  ),
		  fail
	      ; true
	      ),
	      Exception,
	      flranswer_all_answers_query_errhandler_collect(Exception,
							     QueryTemplate,
							     AroundHookLink)
	     ),
	(var(Exception) ->  Exception = FLORA_NORMAL
	; true
	),
	close_open_tables(cleanup),
	(var(TrueAns)
	-> flora_findall(X,storage_find_fact(FLRANSWER_TRUE_TRIE,X),TrueAns1),
	    sort(TrueAns1,TrueAns)
	; true
	),
	(var(UndefAns)
	-> flora_findall(X,storage_find_fact(FLRANSWER_UNDEF_TRIE,X),UndefAns1),
	    sort(UndefAns1,UndefAns)
	; true
	),
	flora_call_hooks(_Mod,QUERYHOOK,QueryTemplate,after,AroundHookLink),
	flora_reclaim_storage_space,
	storage_delete_all(FLRANSWER_TRUE_TRIE),
	storage_delete_all(FLRANSWER_UNDEF_TRIE).

