/* File:        flrdecode.P  -- Decoder; used for human-readability
**
** Author(s): Michael Kifer
**
** Contact:   flora-users@lists.sourceforge.net
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2013;
**      Vulcan, Inc., 2008-2013.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**      http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
**
*/


:- compiler_options([xpp_on]).

#include "flrheader.flh"
#include "flora_terms.flh"
#include "flora_porting.flh"
#include "flora_characters.flh"



:- import
	length/2,
	flatten/2
   from basics.

:- import
	goal_cut_untrans/2
   from standard.

:- import
	flora_decode_predicate/6,
	flora_unscramble_atom/2,
        is_flora_callable_literal/1
    from flrwrapper.
:- import
	flora_modular_prlgdef/2,
	flora_modular_prlgdef/3,
	flora_prlgdef_repl/4,
	flora_prlgdef/2
   from flrprolog.
:- import flora_opdef/3 from flroperator.
:- import
	flora_delayed_builtin_literal/2,
	flora_delayed_sensor_literal/3
   from FLDELAYSUPPORTMOD.

:- import
	flora_printable_type_representation/2,
	flora_parsed_datatypelist/2
   from flrdatatype.

:- import
	flora_abort/1,
	flora_concat_items/2,
	flora_concat_atoms/2,
	flora_get_substring/4,
	flora_match_substring/5
   from flrporting.

:- import flora_unwrap_truthvalued_call/2 from usermod.
:- import
	FLORA_NAF_PREDICATE/1,
	FLORA_NAF_PREDICATE/4,
	flora_unwrap_negation/2
   from flrnegation.

:- import term_variables/2 from constraintLib.
:- import
	del_attr/2
   from machine.

%%:- import flora_warning_line/2 from flrprint.

:- import flrtrim_last/2 from flora_ground.

:- export 
	flora_decode_goal_as_list/2,
	flora_decode_goal_as_atom/2,
	flora_decode_goal_as_atom_substitute_vars/2,
	flora_decode_oid_as_list/2,
	flora_decode_oid_as_atom/2,
	flora_decode_oid_as_atom_substitute_vars/2,
	flora_write_goal/1,
	flora_write_goal/2,
	flora_write_goal_substitute_vars/1,
	flora_write_goal_substitute_vars/2,
	flora_write_oid/1,
	flora_write_oid/2,
	flora_write_oid_substitute_vars/1,
	flora_write_oid_substitute_vars/2,
	flora_write_fact/1,
	flora_write_fact/2,
	flora_write_rule_head/1,
	flora_write_rule_head/2,
	flora_write_rule_body/1,
	flora_write_rule_body/2.

:- export
	flora_set_display_mode/1,
	flora_set_display_submode/1,
	flora_escape_atom/2,
	flora_display_mode/1,
	flora_display_symbol/2.

:- dynamic display_mode/1, display_submode/1.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% flora_write_goal %%%%%%%%%%%%%%%%%%%%%%%%%%%

flora_write_goal(Stream,Goal) :-
	flora_decode_goal(Goal,Code,0),
	flatten(Code,FlatCode),
	write_flat_code(Stream,FlatCode).

%% Write to the currently open output stream
flora_write_goal(Goal) :-
	telling(Stream),
	flora_write_goal(Stream,Goal).

flora_write_goal_substitute_vars(Stream,Goal) :-
	flora_decode_goal_as_atom_substitute_vars(Goal,Code),
	write(Stream,Code).

%% Write to the currently open output stream
flora_write_goal_substitute_vars(Goal) :-
	telling(Stream),
	flora_write_goal_substitute_vars(Stream,Goal).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% flora_write_oid %%%%%%%%%%%%%%%%%%%%%%%%%%%
	
flora_write_oid(Stream,Goal) :-
	flora_decode_oid(Goal,Code),
	flatten(Code,FlatCode),
	write_flat_code(Stream,FlatCode).

%% Write to the currently open output stream
flora_write_oid(Goal) :-
	telling(Stream),
	flora_write_oid(Stream,Goal).

flora_write_oid_substitute_vars(Stream,Goal) :-
	flora_decode_oid_as_atom_substitute_vars(Goal,Code),
	write(Stream,Code).

%% Write to the currently open output stream
flora_write_oid_substitute_vars(Goal) :-
	telling(Stream),
	flora_write_oid_substitute_vars(Stream,Goal).
			
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% flora_write_fact %%%%%%%%%%%%%%%%%%%%%%%%%%%

flora_write_fact(Stream,Goal) :-
	flora_decode_fact(Goal,Code,0),
	flatten(Code,FlatCode),
	write_flat_code_without_ws(Stream,FlatCode).

%% Write to the currently open output stream
flora_write_fact(Goal) :-
	telling(Stream),
	flora_write_fact(Stream,Goal).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% flora_write_rule_head %%%%%%%%%%%%%%%%%%%%%%%%%%%

flora_write_rule_head(Stream,Goal) :-
	flora_decode_goal(Goal,Code,0),
	flatten(Code,FlatCode),
	write_flat_code_without_ws(Stream,FlatCode).

%% Write to the currently open output stream
flora_write_rule_head(Goal) :-
	telling(Stream),
	flora_write_rule_head(Stream,Goal).
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% flora_write_rule_body %%%%%%%%%%%%%%%%%%%%%%%%%%%

flora_write_rule_body(Stream,Goal) :-
	flora_decode_goal(Goal,Code,0),
	flatten(Code,FlatCode),
	write_flat_code(Stream,FlatCode).

%% Write to the currently open output stream
flora_write_rule_body(Goal) :-
	telling(Stream),
	flora_write_rule_body(Stream,Goal).
		


write_flat_code(_,[]) :- !.
write_flat_code(Stream,[H|T]) :-
	nonvar(H),
	H = [_|_],
	!,
	write_flat_code(Stream,H),
	write_flat_code(Stream,T).
/*
write_flat_code(Stream,[H|T]) :-
	!,	
	(var(H) ->
	   write(Stream,FL_VARSYM),
	   write(Stream,H)	      
	 ;
	 write(Stream,H)
	),
	write_flat_code(Stream,T).
*/
write_flat_code(Stream,[H|T]) :-
	!,	
	write(Stream,H),
	write_flat_code(Stream,T).

write_flat_code_without_ws(_,[]) :- !.

write_flat_code_without_ws(Stream,[H|T]) :-
	nonvar(H),
	H = [_|_],
	!,
	write_flat_code_without_ws(Stream,H),
	write_flat_code_without_ws(Stream,T).

write_flat_code_without_ws(Stream,[H|T]) :-	
	!,
	(H == FL_AT -> 
	   write(Stream,'');
	   (
	    (var(H) ->
	      write(Stream,FL_VARSYM),
	      write(Stream,H)	      
	    ;
		write(Stream,H)
	    ),
	     write_flat_code_without_ws(Stream,T)
	   )
	).
		


%%%%%%%%%%%%%%%%%%%%%%%% flora_decode_goal_as_atom/2 %%%%%%%%%%%%%%%%%%%%%%%%%%%
flora_decode_goal_as_atom(Goal,CodeAtom) :-
	flora_decode_goal_as_list(Goal,Code),
	flora_concat_items(Code,CodeAtom).

flora_decode_goal_as_atom_substitute_vars(Goal,CodeAtom) :-
	copy_term(Goal,Goal1),
	term_variables(Goal1,Vars),
	bind_vars_meaningfully(Vars),
	flora_decode_goal_as_atom(Goal1,CodeAtom).

%%%%%%%%%%%%%%%%%%%%%%%% flora_decode_goal_as_list/2 %%%%%%%%%%%%%%%%%%%%%%%%%%%
flora_decode_goal_as_list(Goal,FlatCode) :-
	flora_decode_goal(Goal,Code,0),
	flatten(Code,FlatCode).

%%%%%%%%%%%%%%%%%%%%%%%% flora_decode_oid_as_atom/2 %%%%%%%%%%%%%%%%%%%%%%%%%%%
flora_decode_oid_as_atom(Goal,CodeAtom) :-
	flora_decode_oid_as_list(Goal,Code),
	flora_concat_items(Code,CodeAtom).

flora_decode_oid_as_atom_substitute_vars(Goal,CodeAtom) :-
	copy_term(Goal,Goal1),
	term_variables(Goal1,Vars),
	bind_vars_meaningfully(Vars),
	flora_decode_oid_as_atom(Goal1,CodeAtom).

%%%%%%%%%%%%%%%%%%%%%%%% flora_decode_oid_as_list/2 %%%%%%%%%%%%%%%%%%%%%%%%%%%
flora_decode_oid_as_list(Goal,FlatCode) :-
	flora_decode_oid(Goal,Code),
	flatten(Code,FlatCode).

%%%%%%%%%%%%%%%%%%%%% flora_decode_fact(+Call,-Code,+Depth) %%%%%%%%%%%%%%%%%
%% Returns a (possibly nested) list of atoms whose concatenation           %%
%% represents a readable representation of Fact                            %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	

flora_decode_fact(CallIn,Code,Depth) :-
	goal_cut_untrans(CallIn,Call),
	classify_call(Call,Type,Basename,ArgList,Module),
	Depth1 is Depth+1,
	( Type == (tabled_hilog)
	-> decode_tabled_hilog_call_without_trimming_last_arg(Basename,ArgList,Module,Code,0,Depth1)
        ; Type == (neg_tabled_hilog)
        -> decode_negated_tabled_hilog_call_non_trim_last(Basename,ArgList,Module,Code,0,Depth1)
        ; Type == (nontabled_hilog)
        -> decode_nontabled_hilog_call_non_trim_last(Basename,ArgList,Module,Code,0,Depth1)
	; Type == (flogic)
	-> decode_molecule(Basename,ArgList,Module,Code,0,Depth1)
	; Type == (neg_flogic)
	-> decode_negated_molecule(Basename,ArgList,Module,Code,0,Depth1)
	),
	!.

	
%%%%%%%%%%%%%%%%%%%%% flora_decode_goal(+Goal,-Code,+Depth) %%%%%%%%%%%%%%%%%
%% Returns a (possibly nested) list of atoms whose concatenation           %%
%% represents a readable representation of Goal                            %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

flora_decode_goal(CallIn,[FL_VARSYM,CallIn],_Depth) :-
	var(CallIn),
	!.
flora_decode_goal(CallIn,Code,Depth) :-
	%% goal_cut_untrans gets rid of various irregularities like ';;'/2
	goal_cut_untrans(CallIn,Call),
	classify_call(Call, Type,Basename,ArgList,Module),
	(Type = (basefact,CallType)
	-> Code = ['_isbasefact(', [RestCode], ')']
	;  Code = RestCode, Type = CallType
	),
	Depth1 is Depth+1,
	( CallType == (hilog_term)
	-> decode_hilog_term(Basename,ArgList,RestCode,1,Depth1)
	; CallType == (tabled_hilog)
	-> decode_tabled_hilog_call(Basename,ArgList,Module,RestCode,0,Depth1)
	; CallType == (neg_tabled_hilog)
	-> decode_negated_tabled_hilog_call(Basename,ArgList,Module,RestCode,0,Depth1)
        ; CallType == (nontabled_hilog)
        -> decode_nontabled_hilog_call(Basename,ArgList,Module,RestCode,0,Depth1)
	; CallType == (flogic)
	-> decode_molecule(Basename,ArgList,Module,RestCode,0,Depth1)
	; CallType == (neg_flogic)
	-> decode_negated_molecule(Basename,ArgList,Module,RestCode,0,Depth1)
	; CallType == (inheritance)
	-> decode_molecule(Basename,ArgList,Module,MolCode,0,Depth1),
	    RestCode = ['(Trying to derive by inheritance) '|MolCode]
	; CallType == (explicit_definition)
	-> decode_molecule(Basename,ArgList,Module,MolCode,0,Depth1),
	    RestCode = ['(Checking explicit definition for method) '|MolCode]
	; CallType == (dynhead_before)
	-> decode_molecule(Basename,ArgList,Module,MolCode,0,Depth1),
	    RestCode = ['(Trying to derive via dynamic before-rules) '|MolCode]
	; CallType == (neg_dynhead_before)
	-> decode_negated_molecule(Basename,ArgList,Module,MolCode,0,Depth1),
	    RestCode = ['(Trying to derive via dynamic before-rules) '|MolCode]
	; CallType == (dynhead_after)
	-> decode_molecule(Basename,ArgList,Module,MolCode,0,Depth1),
	    RestCode = ['(Trying to derive via dynamic after-rules) '|MolCode]
	; CallType == (neg_dynhead_after)
	-> decode_negated_molecule(Basename,ArgList,Module,MolCode,0,Depth1),
	    RestCode = ['(Trying to derive via dynamic after-rules) '|MolCode]
	),
	!.


%% The rest are classified as Prolog. These can be real prolog terms
%% or Flora primitives like insert{...}, throw{...}, etc.
%% Even if a call is a prolog call, its arguments can be Flora stuff, so
%% decode_literal_internal/3 processes them accordingly.
flora_decode_goal(CallIn,Code,Depth) :-
	Depth1 is Depth+1,
	decode_literal_internal(CallIn,Code,0,Depth1),
	!.

%% Debugging
flora_decode_goal(CallIn,_,_) :-
	abort(['FLORA-2 internal bug. ',CallIn,': flora_decode_goal/2 failed to decode']).


%%%%%%%%%%%%%%%%%%%% flora decode oid %%%%%%%%%%%%%%%%%%%%%%%
%% Call is an oid, although it may be a reified term.
flora_decode_oid(Call,Code) :-
	decode_literal_internal(Call,Code,1,0).



%%%%%%%%%%%%%%%%%%%% decode_head %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
decode_head(Head,HeadCode,Depth) :-
	Depth1 is Depth+1,
	(is_list(Head)
	-> decode_list_add_separator(Head,HeadCode,flora_decode_goal(_,_,Depth1),', ')
	; flora_decode_goal(Head,HeadCode,Depth1)
	).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Decoding molecule %%%%%%%%%%%%%%%%%%%%%%%%%
decode_negated_molecule(Wrapper,ComponentList,Module,[ReifyStart,'neg ',[MolCode|WCode],ReifyEnd],Level,Depth) :-
	decode_molecule(Wrapper,ComponentList,Module,[ReifyStart,[MolCode|WCode],ReifyEnd],Level,Depth).

%% Level=0: top level; Level=1: reified predicate/molecule argument of a functor
decode_molecule(Wrapper,ComponentList,Module,[ReifyStart,[NegCode,MolCode|WCode],ReifyEnd],Level,Depth) :-
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	Depth1 is Depth+1,
	(flora_match_substring(FLBodyPREFIX,Wrapper,forward,0,End)
	->  NegCode = ''
	; flora_match_substring(FLNEGBodyPREFIX,Wrapper,forward,0,End)
	-> NegCode='neg '
	; flora_match_substring(FLNEGPREFIX,Wrapper,forward,0,End)
	-> NegCode='neg '
	; NegCode = '', End=0
	),
	flora_get_substring(Wrapper,End,_,BaseWrapper),
	decode_list_as_list(ComponentList,ComponentListCode,decode_literal_internal(_,_,1,Depth1)),
	decode_molecule_base(BaseWrapper,ComponentListCode,MolCode),
	workspace_code(Module,WCode).

%% Wrapper, Args, Code
decode_molecule_base(WRAP_MVD, [O,M,V|_], [O,'[',M,' -> ',V,']']).
decode_molecule_base(WRAP_MVDDEF, [O,M|_], [O,'.',M,'[',']']).
decode_molecule_base(WRAP_IMVD, [O,M,V|_], [O,'[',M,' *-> ',V,']']).
decode_molecule_base(WRAP_IMVDDEF, [O,M|_], [O,'!',M,'[',']']).
decode_molecule_base(WRAP_MVDSIG, [O,M,V|_], [O,'[',M,' => ',V,']']).
decode_molecule_base(WRAP_MVDSIGDEF, [O,M|_], [O,'[',M,' => ()]']).
decode_molecule_base(WRAP_IMVDSIG, [O,M,V|_], [O,'[',M,' *=> ',V,']']).
decode_molecule_base(WRAP_IMVDSIGDEF, [O,M|_], [O,'[',M,' *=> ()]']).
decode_molecule_base(WRAP_BOOLSIG, [O,P|_], [O,'[',' => ',P,']']).
decode_molecule_base(WRAP_IBOOLSIG, [O,P|_], [O,'[',' *=> ',P,']']).
decode_molecule_base(WRAP_TRANSIG, [O,P|_], [O,'[',' =>% ',P,']']).
decode_molecule_base(WRAP_ITRANSIG, [O,P|_], [O,'[',' *=>% ',P,']']).
decode_molecule_base(WRAP_MVDCON, [O,M,L,U|_], [O,'[',M,'{',L,Symbol,U,'}=>?]']) :-
	flora_display_symbol(cardinality,Symbol).
decode_molecule_base(WRAP_IMVDCON, [O,M,L,U|_], [O,'[',M,'{',L,Symbol,U,'}*=>?]']) :-
	flora_display_symbol(cardinality,Symbol).
decode_molecule_base(WRAP_MVDCONDEF, [O,M,L,U|_], [O,'[',M,'{',L,Symbol,U,'}=>?]']) :-
	flora_display_symbol(cardinality,Symbol).
decode_molecule_base(WRAP_IMVDCONDEF, [O,M,L,U|_], [O,'[',M,'{',L,Symbol,U,'}*=>?]']) :-
	flora_display_symbol(cardinality,Symbol).
decode_molecule_base(WRAP_MVDINC, [O,M,V|_], [O,'[',M,' +>> ',V,']']).
decode_molecule_base(WRAP_IMVDINC, [O,M,V|_], [O,'[',M,' *+>> ',V,']']).
decode_molecule_base(WRAP_MVDTOLIST, [O,M,V|_], [O,'[',M, ' ->-> ',V,']']).
decode_molecule_base(WRAP_IMVDTOLIST, [O,M,V|_], [O,'[',M, ' *->-> ',V,']']).
decode_molecule_base(WRAP_ISA, [O,C|_], [O,Symbol,C]) :-
	flora_display_symbol(isa,Symbol).
decode_molecule_base(WRAP_SUB, [Sub,Sup|_], [Sub,Symbol,Sup]) :-
	flora_display_symbol(sub,Symbol).
decode_molecule_base(WRAP_EXISTS, [O|_], [O,'[',']']).
%% boolean method
decode_molecule_base(WRAP_METH, [O,P|_], [O,'[',P,']']).
%% inheritable boolean method
decode_molecule_base(WRAP_IMETH, [O,P|_], [O,'[*',P,']']).
%% procedural boolean method
decode_molecule_base(WRAP_TRAN, [O,P|_], [O,'[%',P,']']).

decode_molecule_base(WRAP_OBJEQL, [O1,O2|_], [O1,' :=: ',O2]).

%%%%%%%%%%%%%%%%%%%%% Decode HiLog Call %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Level=0: top level; Level=1: reified predicate argument of a functor
decode_nontabled_hilog_call(HiLogPred,Args,WS,[ReifyStart,'%',Code,ReifyEnd],Level,Depth) :-
        decode_tabled_hilog_call(HiLogPred,Args,WS,[ReifyStart,Code,ReifyEnd],Level,Depth).

decode_negated_tabled_hilog_call(HiLogPred,Args,WS,[ReifyStart,'neg ',Code,ReifyEnd],Level,Depth) :-
        decode_tabled_hilog_call(HiLogPred,Args,WS,[ReifyStart,Code,ReifyEnd],Level,Depth).

decode_tabled_hilog_call(HiLogPred,Args,WS,[ReifyStart,Code,ReifyEnd],Level,Depth) :-
	((Level==0; var(WS))
	-> ReifyStart='',ReifyEnd=''
	; ReifyStart='${',ReifyEnd='}'
	),
	Depth1 is Depth+1,
	decode_literal_internal(HiLogPred,HiLogPredCode,1,Depth1),
	Code = [HiLogPredCode|RestCode1],
	%% var(WS), Level>0 means it is hilog term, not predicate
	(var(WS), Level > 0
	-> Args = ArgsTruncated
	;
	    flrtrim_last(Args,ArgsTruncated)
	),
	(ArgsTruncated == []
	-> ((nonvar(WS) ; Level==0), atom(HiLogPred) % top level proposition & a == a()
	   -> RestCode1 = RestCode2
	   ; RestCode1 = ['(',')'|RestCode2]
	   )
	;
	    decode_list_add_separator(ArgsTruncated,ArgCode1,decode_literal_internal(_,_,1,Depth1),FL_COMMA),
	    RestCode1 = ['(',ArgCode1,')'|RestCode2]
	),
	(nonvar(WS)
	-> workspace_code(WS,WSCode),
	    RestCode2 = WSCode
	; RestCode2 = []
	).
	

decode_nontabled_hilog_call_non_trim_last(HiLogPred,Args,WS,[ReifyStart,'%',Code,ReifyEnd], Level,Depth) :-
        decode_tabled_hilog_call_without_trimming_last_arg(HiLogPred,Args,WS,[ReifyStart,Code,ReifyEnd],Level,Depth).

decode_negated_tabled_hilog_call_non_trim_last(HiLogPred,Args,WS,[ReifyStart,'neg ',Code,ReifyEnd], Level,Depth) :-
        decode_tabled_hilog_call_without_trimming_last_arg(HiLogPred,Args,WS,[ReifyStart,Code,ReifyEnd],Level,Depth).
	
decode_tabled_hilog_call_without_trimming_last_arg(HiLogPred,Args,WS,[ReifyStart,Code,ReifyEnd],Level,Depth) :-
	((Level==0; var(WS))
	-> ReifyStart='',ReifyEnd=''
	; ReifyStart='${',ReifyEnd='}'
	),
	Depth1 is Depth+1,
	decode_literal_internal(HiLogPred,HiLogPredCode,1,Depth1),
	Code = [HiLogPredCode|RestCode1],
		
	(Args == []
	-> ((nonvar(WS) ; Level==0), atom(HiLogPred) % top level proposition & a == a()
	   -> RestCode1 = RestCode2
	   ; RestCode1 = ['(',')'|RestCode2]
	   )
	;
	    decode_list_add_separator(Args,ArgCode1,decode_literal_internal(_,_,1,Depth1),FL_COMMA),
	    RestCode1 = ['(',ArgCode1,')'|RestCode2]
	),
	(nonvar(WS)
	-> workspace_code(WS,WSCode),
	    RestCode2 = WSCode
	; RestCode2 = []
	).	

decode_hilog_term(HiLogPred,Args,Code,Level,Depth) :-
	Depth1 is Depth+1,
	decode_literal_internal(HiLogPred,HiLogPredCode,1,Depth1),
	Code = [HiLogPredCode|RestCode1],
	(Args == []
	-> (Level==0
	   -> RestCode1 = RestCode2
	   ; RestCode1 = ['(',')'|RestCode2]
	   )
	;
	    decode_list_add_separator(Args,ArgCode1,decode_literal_internal(_,_,1,Depth1),FL_COMMA),
	    RestCode1 = ['(',ArgCode1,')'|RestCode2]
	),
	RestCode2 = [].


%%%%%%%%%%%%%%%%%%%%%% Decode Prolog Call %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

decode_prolog_call([FLLIBNAFDELAY,[Call],1],_WS,Code,Depth) :-
	!,
	Depth1 is Depth+1,
	decode_literal_internal(Call,Code,1,Depth1).
decode_prolog_call([FLLIBDELAYEDLITERAL,[FL_UNDEFEATED,_,_,[Call|_]],4],_WS,[Code, ' /* testing defeasibility of rule */'],Depth) :-
	!,
	decode_literal_internal(Call,Code,0,Depth).
%% other cases of FLLIBDELAYEDLITERAL
decode_prolog_call([FLLIBDELAYEDLITERAL,[F,_,_,Args],4],_WS,Code,Depth) :-
	length(Args,N),
	flora_delayed_builtin_literal(F,N),
	!,
	Depth1 is Depth+1,
	decode_builtin(F,N,Args,Code,Depth1).
decode_prolog_call([FLLIBDELAYEDLITERAL,[F,_,_,Args],4],_WS,[Code, ' /* sensor */'],Depth) :-
	length(Args,N),
	N2 is N-2,
	(F = _:F2, flora_delayed_sensor_literal((F2,_),N2,_)
	; flora_unscramble_atom(F,F2), flora_delayed_sensor_literal(F2,N2,_)
	),
	!,
	Args = [_,_|Args2],
	Depth1 is Depth+1,
	decode_builtin(F2,N2,Args2,Code,Depth1).

decode_prolog_call([':',[FLDELAYSUPPORTMOD,Term],2],_WS,Code,Depth) :-
	Term =.. [FLLIBDELAYEDLITERAL,FL_DELAYQUANT,_,_,[QuantType,Cond,Goal]],
	!,
	NewTerm = FL_DELAYQUANT(QuantType,Cond,Goal),
	Depth1 is Depth+1,
	decode_literal_internal(NewTerm,Code,1,Depth1).
decode_prolog_call([':',[FLDELAYSUPPORTMOD,Term],2],_WS,Code,Depth) :-
	Term =.. [FLLIBNAFDELAY|Args],
	Args = [Call],
	!,
	Depth1 is Depth+1,
	decode_literal_internal(Call,Code,1,Depth1).
decode_prolog_call([':',[FLDELAYSUPPORTMOD,Term],2],_WS,Code,Depth) :-
	Term =.. [FLLIBDELAYEDLITERAL|Args],
	!,
	Args = [F,_,_,Args1],
	Depth1 is Depth+1,
	decode_builtin(F,2,Args1,Code1,Depth1),
	(flora_delayed_builtin_literal(F,2) -> Code = Code1
	; Code = [Code1, ' /* delayed literal */']
	).
%% ignore flora_execute_delayed_literals
decode_prolog_call([':',[FLDELAYSUPPORTMOD,Term],2],_WS,[],_Depth) :-
	Term =.. [FLORA_DELAY_CHECKER|_],
	!.
%% ignore FL_SILENT_EQUAL
decode_prolog_call([FL_SILENT_EQUAL,_,2],_WS,[],_Depth) :-
	!.
%% prolog call mod:p(args) 
decode_prolog_call([':',[Module,Term],2],WS,Code,Depth) :-
	!,
	Term =.. [F|Args],
	functor(Term,_,Arity),
	workspace_prolog_code(F,Arity,Module,WS,PrlgSuffixCode),
	escape(F,EscF),
	(Args == []
	->  Code = ['${',EscF,PrlgSuffixCode,'}']
	;
	    Depth1 is Depth+1,
	    decode_list_add_separator(Args,ArgsCode,decode_literal_internal(_,_,1,Depth1),FL_COMMA),
	    Code = ['${',EscF,'(',ArgsCode,')',PrlgSuffixCode,'}']
	).
	
%% neg-negated regular prolog call (for negatable modularized prolog preds)
decode_prolog_call([neg(F),Args,Arity],WS,Code,Depth) :-
        escape(F,EscF),
	workspace_prolog_code(F,Arity,_,WS,PrlgSuffixCode),
	(Args == []
	->  Code = ['${neg ',EscF,PrlgSuffixCode,'}']
	;
	    Depth1 is Depth+1,
	    decode_list_add_separator(Args,ArgsCode,decode_literal_internal(_,_,1,Depth1),FL_COMMA),
	    Code = ['${neg ',EscF,'(',ArgsCode,')', PrlgSuffixCode, '}']
	).

%% udf_hilog_predicate(Call,_,Var) is not printed. Instead, Var is bound to Call
%% This is needed because this Var is used in other parts of displayed answers,
%% so we want to show what those answers really are.
decode_prolog_call([UDFHILOGPREDICATENAME,[Call,_,Var],_Arity],_WS,[],_Depth) :-
	!,
	Call=Var.

%% flora prolog-style builtin: declared as flora_prlg in flrprolog.P
decode_prolog_call([F,Args,Arity],_WS,Code,Depth) :-
	(is_prolog(F,Arity) ; is_synonym_op(F,Arity)),
	!,
	Depth1 is Depth+1,
	decode_builtin(F,Arity,Args,Code,Depth1).

%% regular prolog call
decode_prolog_call([F,Args,Arity],WS,Code,Depth) :-
        escape(F,EscF),
	workspace_prolog_code(F,Arity,_,WS,PrlgSuffixCode),
	(Args == []
	->  Code = ['${',EscF,PrlgSuffixCode, '}']
	;
	    Depth1 is Depth+1,
	    decode_list_add_separator(Args,ArgsCode,decode_literal_internal(_,_,1,Depth1),FL_COMMA),
	    Code = ['${',EscF,'(',ArgsCode,')', PrlgSuffixCode, '}']
	).

revert_synonym(Synonym,Name) :-
	(flrsynonym:flora_op_synonym(Name,Synonym) -> true ; Name = Synonym).
decode_builtin(F,0,_,[EscF],_Depth) :-
	revert_synonym(F,FF),
	escape(FF,EscF), !.
decode_builtin(F,1,[Arg],Code,Depth) :-
	!,
	revert_synonym(F,FF),
	Depth1 is Depth+1,
        escape(FF,EscF),
	workspace_prolog_code(F,1,_,_WS,PrlgSuffixCode),
	decode_literal_internal(Arg,ArgCode,1,Depth1),
	( is_unary_op(F)
	%% This deals with unary ops and prints them as op arg
	-> Code = [EscF,' ',ArgCode]
	; Code = [EscF,'(',ArgCode,')',PrlgSuffixCode]
	).
%% This deals with binary ops
decode_builtin(F,2,[Arg1,Arg2],Code,Depth) :-
	!,
	revert_synonym(F,FF),
        escape(FF,EscF),
	Depth1 is Depth+1,
	decode_literal_internal(Arg1,Arg1Code,1,Depth1),
	decode_literal_internal(Arg2,Arg2Code,1,Depth1),
	(is_binary_op(F)
	->  Code = [Arg1Code, ' ', EscF, ' ', Arg2Code]
	;   Code = [EscF,'(',Arg1Code,FL_COMMA,Arg2Code,')']
	).
decode_builtin(F,_,Args,[EscF,'(',ArgsCode,')', PlgCode],Depth) :-
	Depth1 is Depth+1,
	revert_synonym(F,FF),
        escape(FF,EscF),
	decode_list_add_separator(Args,ArgsCode,decode_literal_internal(_,_,1,Depth1),FL_COMMA),
	PlgCode = '@_prolog'.

standard_plain_prolog_functor(P,A) :- flora_prlgdef(P,A).
standard_plain_prolog_functor(P,A) :- flora_prlgdef_repl(P,A,_,_).
standard_plain_prolog_functor(P,A) :- flora_delayed_builtin_literal(P,A).
standard_modular_prolog_functor(P,A) :- flora_modular_prlgdef(P,A).
standard_modular_prolog_functor(P,A,M) :- flora_modular_prlgdef(P,A,M).


%%%%%%%%%%%%%%%%%%%%%% IF %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

decode_if_statement([Cond,Then],['if (',CondCode,') then (',ThenCode,')']) :-
	flora_decode_goal(Cond,CondCode,0),
	flora_decode_goal(Then,ThenCode,0).
decode_if_statement([Cond,Then,Else],['if (',CondCode,') then (',ThenCode,') else (',ElseCode,')']) :-
	flora_decode_goal(Cond,CondCode,0),
	flora_decode_goal(Then,ThenCode,0),
	flora_decode_goal(Else,ElseCode,0).

%%%%%%%%%%%%%%%%%%%%%% UNLESS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

decode_unless(Cond,Action,['unless (',CondCode,') do (',ActionCode,')']) :-
	flora_decode_goal(Cond,CondCode,0),
	flora_decode_goal(Action,ActionCode,0).


%%%%%%%%%%%%%%%%%%%%%% WHILE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

decode_while(LoopType,Cond,Action,['while (',CondCode,') ',LoopType,' (',ActionCode,')']) :-
	flora_decode_goal(Cond,CondCode,0),
	flora_decode_goal(Action,ActionCode,0).

%%%%%%%%%%%%%%%%%%%%%% UNTIL %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

decode_until(LoopType,Action,Cond,[LoopType,' (',ActionCode,') until (',CondCode,')']) :-
	flora_decode_goal(Action,ActionCode,0),
	flora_decode_goal(Cond,CondCode,0).


%%%%%%%%%%%%%%%%%%%%% Updates %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

is_update_call(FLLIBINSERT, FL_INSERT).
is_update_call(FLLIBINSERTALL, FL_INSERTALL).
is_update_call(FLLIBBTINSERT, FL_BTINSERT).
is_update_call(FLLIBBTINSERTALL, FL_BTINSERTALL).
is_update_call(FLLIBDELETE, FL_DELETE).
is_update_call(FLLIBDELETEALL, FL_DELETEALL).
is_update_call(FLLIBBTDELETE, FL_BTDELETE).
is_update_call(FLLIBBTDELETEALL, FL_BTDELETEALL).
is_update_call(FLLIBERASE, FL_ERASE).
is_update_call(FLLIBERASEALL, FL_ERASEALL).
is_update_call(FLLIBBTERASE, FL_BTERASE).
is_update_call(FLLIBBTERASEALL, FL_BTERASEALL).
is_update_call(FLLIBINSERTRULE_A, FL_INSERTRULE_A).
is_update_call(FLLIBINSERTRULE_Z, FL_INSERTRULE_Z).
is_update_call(FLLIBDELETERULE_A, FL_DELETERULE_A).
is_update_call(FLLIBDELETERULE_Z, FL_DELETERULE_Z).
is_update_call(FLLIBDELETERULE, FL_DELETERULE).

%% Level=0: top level;
%% Level=1: reified predicate/molecule argument of a functor
decode_update(UpdName,
	      [UpdLiterals],
	      [ReifyStart,UpdName,'{',UpdLiteralsCode,'}',ReifyEnd],
	      Level) :-
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	decode_update_literals(UpdLiterals,UpdLiteralsCode).

decode_update(UpdName,
	      [UpdLiterals,Query],
	      [ReifyStart,UpdName,'{',UpdLiteralsCode,'| ',QueryCode,'}',ReifyEnd],
	      Level) :-
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	decode_literal_internal(Query,QueryCode,0,0),
	decode_update_literals(UpdLiterals,UpdLiteralsCode).

%% decodes lists of update literals [FLSYSDBUPDATE(Lit,_Storage,_Module),...]
decode_update_literals([],[]) :- !.
decode_update_literals([H|L],[H|LCode]) :-
        var(H),
        !,
        decode_update_literals(L,LCode).
decode_update_literals([FLSYSDBUPDATE(Lit,_Storage,_Module)|T],[LitCode,Comma|TCode]) :-
	!,
	decode_literal_internal(Lit,LitCode,0,0),
	(T == [] -> Comma = '' ; Comma = ', '),
	decode_update_literals(T,TCode).
decode_update_literals([FLSYSRULEUPDATE(Id,_DescrVarTerm,_DescrMetaFacts,Head,Body,_,_,_PreBody,_PostBody,_DefeatCond)|T],
		       [[RuleIdCode, HeadCode,' :- ', BodyCode],Comma|TCode])
      :-
	!,
	(is_void(Id) -> RuleIdCode = ''
	;
	    flora_decode_oid(Id,IdCode),
	    RuleIdCode = ['@!{', IdCode, '} ']
	),
	decode_head(Head,HeadCode,0),
        decode_literal_internal(Body,BodyCode,0,0),
	(T == [] -> Comma = '' ; Comma = ', '),
	decode_update_literals(T,TCode).
decode_update_literals([H|T],[HCode|TCode]) :-
	H= FLLIBMODLIT(_,_,_,_),
	!,
	decode_literal_internal(H,HCode,0,0),
	decode_update_literals(T,TCode).

decode_update_literals([Lit|T],[LitCode,Comma|TCode]) :-
	decode_literal_internal(Lit,LitCode,0,0),
	(T == [] -> Comma = '' ; Comma = ', '),
	decode_update_literals(T,TCode).


%%%%%%%%%%%%%%%%%%%%% Aggregate Ops %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Level=0: top level; Level=1: reified predicate/molecule argument of a functor
decode_aggregate(AggName,AggVar,GrpVarList,Query,AggResult,
		 [ReifyStart,AggResultCode,' = ',AggName,
		  '{',AggVar,GrpVarListCode,'| ',QueryCode,'}',ReifyEnd],
		 Level) :-
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	decode_literal_internal(AggResult,AggResultCode,0,0),
	(GrpVarList==[]
	-> GrpVarListCode = ''
	;  decode_list_add_separator(GrpVarList,InterimCode,=(_,_),FL_COMMA),
	    GrpVarListCode = ['[',InterimCode,']']
	),
	decode_literal_internal(Query,QueryCode,0,0).

is_aggregate_call(FLLIBMIN,FL_MIN).
is_aggregate_call(FLLIBMAX,FL_MAX).
is_aggregate_call(FLLIBSUM,FL_SUM).
is_aggregate_call(FLLIBAVG,FL_AVG).
is_aggregate_call(FLLIBCOUNT,FL_COUNT).
is_aggregate_call(FLLIBCOLLECTSET,FL_COLLECTSET).
is_aggregate_call(FLLIBCOLLECTBAG,FL_COLLECTBAG).

%%%%%%%%%%%%%%%%%%%%%% Decode canonical form of a call %%%%%%%%%%%%%%%%%%%

decode_canon(FLCANON(_,_,_,Callable), Decoding,Depth) :-
	nonvar(Callable),
	!,
	Depth1 is Depth+1,
	flora_decode_goal(Callable,Decoding,Depth1).

decode_canon(FLCANON(InTerm,_,_Callable), Decoding,Depth) :-
	var(InTerm),
	!,
	Depth1 is Depth+1,
	flora_decode_goal(InTerm,Decoding,Depth1).

decode_canon(FLCANON(Wrap,Args,Mod,_Callable), Decoding,Depth) :-
	nonvar(Wrap),
	is_list(Args),
	!,
        %% FLCANON wraps only predicates but no terms
        ( var(Mod) -> flrtrim_last(Args,TrimmedArgs); Args=TrimmedArgs ),
	InTerm =.. [Wrap|TrimmedArgs],
	Depth1 is Depth+1,
	flora_decode_goal(InTerm,DecodedInTerm,Depth1),
	workspace_code(Mod,ModCode),
	Decoding = [DecodedInTerm,ModCode].

%% If this happens then need to debug
decode_canon(Canon,Canon,_Depth).


%%%%%%%%%%%%%%%%%%%%% Flora built-in primitives foo{...} %%%%%%%%%%%%%%%%%
decode_primitive(BuiltinName,ArgsCode,
		 [ReifyStart,BuiltinName,'{',ArgsCode,'}',ReifyEnd],
		 Level) :-
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}').


%%%%%%%%%%%%%%%%%%%%%%%%%% Decode list as commalist %%%%%%%%%%%%%%%%%%
%% Takes a list, applies transformation ConversionCall(In,Out)      %%
%% and produces a list of the results separated by a separator      %%
%% The last arg specifies the separator between list items          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
decode_list_add_separator([],[],_,_) :- !.
decode_list_add_separator([L|R],[CodeL,'| ',CodeR],ConversionCall,_Separator) :-
	var(R),
	!,
	copy_term(ConversionCall,ConversionCall1),
	arg(1,ConversionCall1,L),
	call(ConversionCall1),
	arg(2,ConversionCall1,CodeL),
	arg(1,ConversionCall,R),
	call(ConversionCall),
	arg(2,ConversionCall,CodeR).

decode_list_add_separator([L],[CodeL],ConversionCall,_Separator) :-
	!,
	arg(1,ConversionCall,L),
	call(ConversionCall),
	arg(2,ConversionCall,CodeL).
decode_list_add_separator([L|R],[CodeL,'| ',CodeR],ConversionCall,_Separator) :-
	R \= .(_,_),
	!,
	copy_term(ConversionCall,ConversionCall1),
	arg(1,ConversionCall1,L),
	call(ConversionCall1),
	arg(2,ConversionCall1,CodeL),
	arg(1,ConversionCall,R),
	call(ConversionCall),
	arg(2,ConversionCall,CodeR).
decode_list_add_separator([L|R],[CodeL,Separator|CodeR],ConversionCall,Separator) :-
	copy_term(ConversionCall,ConversionCall1),
	arg(1,ConversionCall,L),
	call(ConversionCall),
	arg(2,ConversionCall,CodeL),
	decode_list_add_separator(R,CodeR,ConversionCall1,Separator).

%%%%%%%%%%%%%%%%%%%%%%%%%% decode list of goals as list %%%%%%%%%%%%%%%
%% Takes a list, applies transformation ConversionCall(In,Out)       %%
%% to each member and produces a list of the results                 %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
decode_list_as_list([],[],_) :- !.
decode_list_as_list([G|GoalList],[GCode|GoalCodeList],ConversionCall) :-
	copy_term(ConversionCall,ConversionCall1),
	arg(1,ConversionCall,G),
	call(ConversionCall),
	arg(2,ConversionCall,GCode),
	decode_list_as_list(GoalList,GoalCodeList,ConversionCall1).

/*
%%%%%%%%%%%%%%%%%%%%%%%%%% Decode commalist as commalist %%%%%%%%%%%%%
%% Takes a commalist (G1,G2,G3,...), applies transformation         %%
%% ConversionCall(In,Out) and produces a list of the results        %%
%% by a separator given in the last argument                        %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
decode_commalist_add_separator((G1,G2),[CodeG1,Separator|CodeG2],ConversionCall,Separator) :-
	!,
	copy_term(ConversionCall,ConversionCall1),
	arg(1,ConversionCall,G1),
	call(ConversionCall),
	arg(2,ConversionCall,CodeG1),
	(var(G2) -> G2=CodeG2
	; decode_commalist_add_separator(G2,CodeG2,ConversionCall1,Separator)
	).

decode_commalist_add_separator(G,CodeG,ConversionCall,_Separator) :-
	!,
	arg(1,ConversionCall,G),
	call(ConversionCall),
	arg(2,ConversionCall,CodeG).
*/
	
%%%%%%%%%%%%%%%%%%%%%%%%%%% workspace_code %%%%%%%%%%%%%%%%%%%%%%%%%%%%
workspace_code(WS,WSCode) :-
	%%(((WS==FLORA_DEFAULT_WORKSPACE);(WS==FL_THISMODULE);(WS==FL_INVALIDMODULE))
	(WS==FL_INVALIDMODULE -> WSCode = []
	; WSCode = ['@',WS]
	).

%% if Module is a variable then no prolog module
%% WS is the module for modularized Prolog predicates
workspace_prolog_code(F,Arity,Module,WS,Code) :-
	(
	  standard_modular_prolog_functor(F,Arity) -> Code = ['@',WS]
	; standard_modular_prolog_functor(F,Arity,WS) -> Code = ['@',WS]
	; standard_plain_prolog_functor(F,Arity) -> Code = ''
	; var(Module) -> Code = '@_prolog'
	; Code = ['@_prolog(',Module,')']
	).

%%%%%%%%%%%%%%%%%%%%%%%%%%% Decode anonymous OID %%%%%%%%%%%%%%%%%%%%%%
decode_anon_oid(NewOid,Code) :-
	atom(NewOid),
	(flora_match_substring(FL_NEWOID_PREFIX,NewOid,forward,0,Pos), !
	; flora_match_substring(FL_NEWOID_DYNPREFIX,NewOid,forward,0,Pos)
	),
	flora_display_symbol(skolem,Symbol),
	(flora_match_substring('|',NewOid,forward,_,Pos1) ->
	    (flora_match_substring('''',NewOid,reverse,Pos2,_), Pos1 < Pos2, !
	    ; true
	    ),
	    flora_get_substring(NewOid,Pos1,Pos2,OidNumber),
	    (flora_display_submode(answer) ->
		Code = [NewOid, '  (', Symbol, OidNumber, ')']
	    ;  Code = [Symbol,OidNumber]
	    )
	;
	    (flora_display_submode(answer) ->
		Code = [NewOid, '  (', Symbol, ')']
	    ;  Code = [Symbol]
	    )
	).



%%%%%%%%%%%%%%%%%%%%%% Classifier %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
classify_call(Call,Type,Basename,ArgList,Module) :-
	flora_decode_predicate(Call,Type1,Module,Prefix,Basename1,ArgList1),
	%% The following debugging statement helps weed out
	%% calls that should be suppressed by the debugger
	/*
	writeln(2,('Decodecall: ',Call,Type1,Module,Prefix,Basename1,ArgList1)),
	*/
	(Type1 == (flora)
	-> (Prefix==FL_INHERITANCEPREFIX
	   -> Basename = Basename1, Type = (inheritance), ArgList = ArgList1

	   ; Prefix==FL_LOCALPREFIX
	   -> Basename = Basename1, Type = (explicit_definition), ArgList = ArgList1
	   
	   ; Prefix==FL_DYNAPREFIX % This is actually hidden (possible future use)
	   -> Basename = Basename1, Type = (dynhead_before), ArgList = ArgList1
	   ; Prefix==FL_DYNZPREFIX % This is actually hidden (possible future use)
	   -> Basename = Basename1, Type = (dynhead_after), ArgList = ArgList1
	   ; Prefix==FL_NEGDYNAPREFIX % This is actually hidden (possible future use)
	   -> Basename = Basename1, Type = (neg_dynhead_before), ArgList = ArgList1
	   ; Prefix==FL_NEGDYNZPREFIX % This is actually hidden (possible future use)
	   -> Basename = Basename1, Type = (neg_dynhead_after), ArgList = ArgList1
	   ; Basename1 = WRAP_DIFFOBJEQL
	   -> Basename = WRAP_OBJEQL, ArgList = ArgList1,
	       (Prefix = FLNEGPREFIX -> Type = (neg_flogic)
	       ; Type = (flogic))


	   ;   %% must be a hilog predicate derivative formed by specialization
	       %% such as FLORA_PREFIX'usermod''main''flapply_#303'
	       flora_concat_atoms([WRAP_NONTABLED_HILOG,'_'],Prefix)
	   ->  Type = (nontabled_hilog), ArgList1 = [Basename | ArgList]
	   ;   %% must be a hilog predicate derivative formed by specialization
	       %% such as FLORA_PREFIX'usermod''main''tblflapply_#303'
	       flora_concat_atoms([WRAP_TABLED_HILOG,'_'],Prefix)
	   ->  Type = (tabled_hilog), ArgList1 = [Basename | ArgList]
	   ;   flora_concat_atoms([FLNEGPREFIX(WRAP_TABLED_HILOG),'_'],Prefix)
	   ->  Type = (neg_tabled_hilog), ArgList1 = [Basename | ArgList]
	   ; Type = Type1, Basename = Basename1, ArgList = ArgList1
	   )
	; Type1 == (neg_flora)
	-> Type = Type1, ArgList = ArgList1, Basename = Basename1
	; Type1 == (prolog), Basename1 = flora_db_find_base,
	    Call = flora_db_find_base(Trie,RealCall),
	    flora_match_substring(FLORA_PREFIX,Trie,forward,0,_)
	->  %% Checking against base facts
	    flora_decode_predicate(RealCall,TrieCallType,Module,_,Basename2,ArgList2),
	    (TrieCallType == (hilog), Basename2==WRAP_NONTABLED_HILOG
	    -> RealType = (nontabled_hilog), ArgList2 = [Basename | ArgList]
	    ; TrieCallType == (hilog), Basename2==WRAP_TABLED_HILOG
	    -> RealType = (tabled_hilog), ArgList2 = [Basename | ArgList]
	    ; TrieCallType == (neg_hilog), Basename2==WRAP_TABLED_HILOG
	    -> RealType = (neg_tabled_hilog), ArgList2 = [Basename | ArgList]
	    ; RealType = TrieCallType,
		ArgList = ArgList2, Basename = Basename2
	    ),
	    Type = (basefact,RealType)
	; Type1 == (prolog), Basename1==WRAP_HILOG
	%% Hilog term that is not a hilog predicate
	->  Type = (hilog_term), ArgList1 = [Basename | ArgList]
        ; Type1 == (hilog), Basename1==WRAP_NONTABLED_HILOG
        ->  Type = (nontabled_hilog), ArgList1 = [Basename | ArgList]
        ; Type1 == (hilog), Basename1==WRAP_TABLED_HILOG
        ->  Type = (tabled_hilog), ArgList1 = [Basename | ArgList]
        ; Type1 == (neg_hilog), Basename1==WRAP_TABLED_HILOG
        ->  Type = (neg_tabled_hilog), ArgList1 = [Basename | ArgList]
	; Type = Type1, Basename = Basename1, ArgList = ArgList1
	),
	%%writeln(2,('Decodecall2: ',Call,Type,Module,Basename)),
	!.


%%%%%%%%%%%%%%%%%%%% internal decode goal util %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Prevent loops on infinite terms
decode_literal_internal(_Call,['...'],_Level,Depth) :-
	Depth > 500,
	!.

%% special data types like _iri and _string
decode_literal_internal(Term, Code, _Level, _Depth) :-
	atom(Term),
	flora_printable_type_representation(Term,[TypeName,TypeLit]),
	!,
	flora_display_type_name(TypeName,DisplayTypename),
	Code = ['"',TypeLit,'"',FL_DATATYPE_CONNECTOR,DisplayTypename].

%% Level=0: top level; Level=1: reified predicate/molecule arg of a functor
decode_literal_internal(Call,Code,_Level,_Depth) :-
	(atomic(Call);var(Call)),
	!,
	(atom(Call), flora_decode_predicate(Call,_,WS,_,Basename,_),
            escape(Basename,EscBasename),
	    nonvar(WS), nonvar(EscBasename)
	->  workspace_code(WS,WSCode),
	    Code = [EscBasename|WSCode]
	; decode_anon_oid(Call,OidCode)
	->  Code = OidCode
	;   Call == []
	->  Code = ['[',']']
	;   escape(Call,EscCall), Code = [EscCall]
	).

decode_literal_internal('_$VAR'(VarName),[VarName],_Level,_Depth) :-
	!.

%% data types
decode_literal_internal(FL_DATATYPE(Term,Type), Code, Level,Depth) :-
        !,
	(var(Term)
	->
	    flora_display_type_name(Type,DisplayTypename),
	    Code = ['?', Term, FL_DATATYPE_CONNECTOR, DisplayTypename]
	; Term = '_$VAR'(VT)
	->
	    flora_display_type_name(Type,DisplayTypename),
	    Code = [VT, FL_DATATYPE_CONNECTOR, DisplayTypename]
	;
	    flora_printable_type_representation(Term,[TypeName,TypeLit]),
	    flora_display_type_name(TypeName,DisplayTypename),
	    (flora_parsed_datatypelist(TypeLit,LitList)
	    ->
		decode_literal_internal(LitList,TypeLitDecoded,Level,Depth),
		Code = [TypeLitDecoded,FL_DATATYPE_CONNECTOR,DisplayTypename]
	    ;
		Code = ['"',TypeLit,'"',FL_DATATYPE_CONNECTOR,DisplayTypename]
	    )
	).

decode_literal_internal(FLLIBNEWMODULE(_ThisModule,NewModuleName),
			[ReifyStart,FL_NEWMODULE,'{',NewModuleName,'}',ReifyEnd],
			Level,_Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}').

%% Case of Something = Var
decode_literal_internal((NameOrVar FL_UNIVEQ Var),[NameCode,' = ',Var],_Level,_Depth) :-
	var(Var),
	(var(NameOrVar), NameCode=NameOrVar
	; atom(NameOrVar), escape(NameOrVar,NameCode)
	),
	!.

%% This occurs when you have hilog-lit@Module, where Module is a var
decode_literal_internal(FLLIBMODLIT(HlgWrapper,Args,Module,_Caller),Code,Level,Depth) :-
	(HlgWrapper == WRAP_NONTABLED_HILOG
	; HlgWrapper == FLBodyPREFIX(WRAP_NONTABLED_HILOG)
	),
	%% Don't increment nesting level
	nonvar(Args),
	!,
	Args = [Basename|ArgList],
	Depth1 is Depth+1,
	(var(Module) ->
	    flrtrim_last(ArgList,TrimmedArgs),
	    %% Invoke decode_hilog_term with Level=0, since this is
	    %% supposed to be a predicate
	    decode_hilog_term(Basename,TrimmedArgs,TermCode,0,Depth1),
	    workspace_code(Module,ModuleCode),
	    TCode = ['${',TermCode, ModuleCode,'}']
	;
	    decode_nontabled_hilog_call(Basename,ArgList,Module,TCode,Level,Depth1)
	),
        (TCode = ['${'|_] ->
	    Code = TCode
        ;
            Code = ['%',TCode]
        ).

decode_literal_internal(FLLIBMODLIT(WRAP_NONTABLED_HILOG,Args,Module,_Caller),
			[FLLIBMODLIT(WRAP_NONTABLED_HILOG,Args,Module,_Caller),
			 PlgCode],
			_Level,_Depth) :-
	!,
	PlgCode = '@_prolog'.

decode_literal_internal(FLLIBMODLIT(HlgWrapper,Args,Module,_Caller),Code,Level,Depth) :-
	(HlgWrapper == WRAP_TABLED_HILOG, !
	; HlgWrapper == FLNEGPREFIX(WRAP_TABLED_HILOG), !
	; HlgWrapper == FLBodyPREFIX(WRAP_TABLED_HILOG), !
	; HlgWrapper == FLNEGBodyPREFIX(WRAP_TABLED_HILOG)
	),
	%% Don't increment nesting level
	nonvar(Args),
	!,
	Args = [Basename|ArgList],
	Depth1 is Depth+1,
	(var(Module) ->
	    flrtrim_last(ArgList,TrimmedArgs),
	    %% Invoke decode_hilog_term with Level=0, since this is
	    %% supposed to be a predicate
	    decode_hilog_term(Basename,TrimmedArgs,TermCode,0,Depth1),
	    workspace_code(Module,ModuleCode),
	    Code = ['${',TermCode, ModuleCode,'}']
	;
	    decode_tabled_hilog_call(Basename,ArgList,Module,Code,Level,Depth1)
	).

decode_literal_internal(FLLIBMODLIT(WRAP_TABLED_HILOG,Args,Module,_Caller),
			[FLLIBMODLIT(WRAP_TABLED_HILOG,Args,Module,_Caller),
			 PlgCode],
			_Level,_Depth) :-
	!,
	PlgCode = '@_prolog'.


%% This occurs when you have ?X@..., i.e., the literal part is a variable
decode_literal_internal(FLLIBMODLIT(LibmodWrap,Args,Module,_Caller),
			[ReifyStart,Modifier,ArgCode,ModuleCode,ReifyEnd],
			Level,Depth) :-
	(LibmodWrap == FL_LIBMOD -> Modifier = '', !
	; LibmodWrap == FL_NEGLIBMOD -> Modifier = 'neg ', !
	; LibmodWrap == FL_TRANSLIBMOD -> Modifier = '%'
	),
	!,
	%% Don't increment nesting level
	((var(Args) ; atomic(Args))
	-> ArgCode = Args, workspace_code(Module,ModuleCode),
	   (Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}')
        ; (Args = FLLIBMODLIT(_,_,_,_); is_flora_callable_literal(Args)) ->
	    (Modifier == ''
            -> ReifyStart='',ReifyEnd='',ModuleCode='', NewLevel = Level
	    ; % Modifier = neg: Push neg under reification
		ReifyStart='${',ReifyEnd='}',ModuleCode='', NewLevel = 0
	    ),
	    Depth1 is Depth+1,
            decode_literal_internal(Args,ArgCode,NewLevel,Depth1)
	;
	   (Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	    Depth1 is Depth+1,
	    decode_literal_internal(Args,ArgCode,Level,Depth1),
	    workspace_code(Module,ModuleCode)
	).

%% This occurs when you have flogic-lit@Module, where Module is a var
decode_literal_internal(FLLIBMODLIT(Basename,Args,Module,_Caller),Code,Level,Depth) :-
	!,
	Depth1 is Depth+1,
	%% Don't increment nesting level
	decode_molecule(Basename,Args,Module,Code,Level,Depth1).


%% This occurs when you have hilog-lit@Module, where Module is a var
decode_literal_internal(FLLIBMODOBJ(_HeadBodyContext,_HeadBodyContext,WRAP_NONTABLED_HILOG,Args,Module,_Caller,ResultObj),
			['(',ResCode,'=','${',Code,'})'],Level,Depth) :-
	nonvar(Args),
	!,
	Args = [Basename|ArgList],
	Depth1 is Depth+1,
	(var(Module) ->
	    flrtrim_last(ArgList,TrimmedArgs),
	    decode_hilog_term(Basename,TrimmedArgs,TermCode,Level,Depth1),
	    workspace_code(Module,ModuleCode),
	    Code = ['%', TermCode, ModuleCode]
	;
	    decode_tabled_hilog_call(Basename,ArgList,Module,TCode,0,Depth1),
            (TCode = ['${'|Rest] -> Code = ['${','%'|Rest]; Code = ['%',TCode])
	),
	decode_literal_internal(ResultObj,ResCode,1,Depth1).

decode_literal_internal(FLLIBMODOBJ(_HeadBodyContext,WRAP_NONTABLED_HILOG,Args,Module,_Caller,ResultObj),
			['(', ResCode,' = ${%',ArgCode,ModuleCode, '})'],_Level,Depth) :-
        !,
	Depth1 is Depth+1,
	decode_literal_internal(Args,ArgCode,1,Depth1),
	decode_literal_internal(ResultObj,ResCode,1,Depth1),
	workspace_code(Module,ModuleCode).

%% This occurs when you have hilog-lit@Module, where Module is a var
decode_literal_internal(FLLIBMODOBJ(_HeadBodyContext,WRAP_TABLED_HILOG,Args,Module,_Caller,ResultObj),
			['(', ResCode,'=','${',Code,'})'],Level,Depth) :-
	nonvar(Args),
	!,
	Args = [Basename|ArgList],
	Depth1 is Depth+1,
	(var(Module) ->
	    flrtrim_last(ArgList,TrimmedArgs),
	    decode_hilog_term(Basename,TrimmedArgs,TermCode,Level,Depth1),
	    workspace_code(Module,ModuleCode),
	    Code = [TermCode, ModuleCode]
	;
	    decode_tabled_hilog_call(Basename,ArgList,Module,Code,0,Depth1)
	),
	decode_literal_internal(ResultObj,ResCode,1,Depth1).


decode_literal_internal(FLLIBMODOBJ(_HeadBodyContext,WRAP_TABLED_HILOG,Args,Module,_Caller,ResultObj),
			['(', ResCode,' = ${',Lparen,ArgCode,Lparen,ModuleCode,'})'],_Level,Depth) :-
	!,
	Depth1 is Depth+1,
	decode_literal_internal(Args,ArgCode,1,Depth1),
	decode_literal_internal(ResultObj,ResCode,1,Depth1),
	workspace_code(Module,ModuleCode),
	(ModuleCode == [] -> Lparen = '', Rparen = ''
	; Lparen = '(', Rparen = ')'
	).


%% This occurs when you have X@..., i.e., the literal part is a variable
decode_literal_internal(FLLIBMODOBJ(_HeadBodyContext,LibmodWrap,Args,Module,_Caller,ResultObj),
			['(',ResCode, '=', '${',Lparen,Modifier,ArgCode,Rparen,ModuleCode,'})'],
			_Level,Depth) :-
	(LibmodWrap == FL_LIBMOD -> Modifier = '', !
	; LibmodWrap == FL_NEGLIBMOD -> Modifier = 'neg ', !
	; LibmodWrap == FL_TRANSLIBMOD -> Modifier = '%'
	),
	!,
	Depth1 is Depth+1,
	((var(Args) ; atomic(Args)) -> ArgCode = Args
	;  decode_literal_internal(Args,ArgCode,0,Depth1)
	),
	decode_literal_internal(ResultObj,ResCode,1,Depth1),
	workspace_code(Module,ModuleCode),
	(ModuleCode == [] -> Lparen = '', Rparen = ''
	; Lparen = '(', Rparen = ')'
	).

%% This occurs when we have flogic-lit@Module, where Module is a var
decode_literal_internal(FLLIBMODOBJ(_HeadBodyContext,Basename,Args,Module,_Caller,ResultObj),
			['(',ResCode,'=',Code,')'],_Level,Depth) :-
	!,
	Depth1 is Depth+1,
	%% Don't increment nesting level
	decode_molecule(Basename,Args,Module,Code,1,Depth1),
	decode_literal_internal(ResultObj,ResCode,1,Depth1).

decode_literal_internal(FLCANON(X,Y,Mod,Callable,_TF), Code,_Level,Depth) :-
	!,
	Depth1 is Depth+1,
	decode_canon(FLCANON(X,Y,Mod,Callable), Code,Depth1).


decode_literal_internal(FLLIBREFRESH(_ThisModule,GoalList),Code,Level,Depth) :-
	!,
	Depth1 is Depth+1,
	decode_list_add_separator(GoalList,GLCode,decode_literal_internal(_,_,0,Depth1),', '),
	decode_primitive(FL_REFRESH,GLCode,Code,Level).

decode_literal_internal(FLLIBCATCH(Call,Catcher,Handler),Code,Level,Depth) :-
	Depth1 is Depth+1,
	decode_literal_internal(Call,CallCode,0,Depth1),
	decode_literal_internal(Catcher,CatcherCode,0,Depth1),
	decode_literal_internal(Handler,HandlerCode,0,Depth1),
	decode_primitive(FL_CATCH,[CallCode,FL_COMMA,CatcherCode,FL_COMMA,HandlerCode],Code,Level).

decode_literal_internal(FLLIBTHROW(Catcher),Code,Level, Depth) :-
	Depth1 is Depth+1,
	decode_literal_internal(Catcher,CatcherCode,0,Depth1),
	decode_primitive(FL_THROW,CatcherCode,Code,Level).

decode_literal_internal(P2H_PREDICATE(Prolog,Hilog,_,_),Code,Level,Depth) :-
	Depth1 is Depth+1,
	decode_literal_internal(Prolog,PrologCode,0,Depth1),
	decode_literal_internal(Hilog,HilogCode,0,Depth1),
	decode_primitive(FL_P2H,[PrologCode,FL_COMMA,HilogCode],Code,Level).

decode_literal_internal(FLLIBIFTHENELSE(_Mod,Cond,Then,Else,_L,_F),[ReifyStart,Code,ReifyEnd],Level,_Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	decode_if_statement([Cond,Then,Else],Code).

decode_literal_internal(FLLIBIFTHEN(_Mod,Cond,Then,_L,_F),[ReifyStart,Code,ReifyEnd],Level,_Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	decode_if_statement([Cond,Then],Code).

decode_literal_internal(FLLIBUNLESSDO(_Mod,Cond,Action,_L,_F),[ReifyStart,Code,ReifyEnd],Level,_Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	decode_unless(Cond,Action,Code).

decode_literal_internal(FLLIBWHILEDO(_Mod,Cond,Action,_L,_F),[ReifyStart,Code,ReifyEnd],Level,_Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	decode_while('do',Cond,Action,Code).

decode_literal_internal(FLLIBWHILELOOP(_Mod,Cond,Action,_L,_F),[ReifyStart,Code,ReifyEnd],Level,_Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	decode_while('loop',Cond,Action,Code).

decode_literal_internal(FLLIBDOUNTIL(_Mod,Action,Cond,_L,_F),[ReifyStart,Code,ReifyEnd],Level,_Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	decode_until('do',Action,Cond,Code).

decode_literal_internal(FLLIBLOOPUNTIL(_Mod,Action,Cond,_L,_F),[ReifyStart,Code,ReifyEnd],Level,_Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	decode_until('loop',Action,Cond,Code).


decode_literal_internal(FLLIBNEWOID(Id),[ReifyStart,'newoid{',Id,'}',ReifyEnd],Level,_Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}').

decode_literal_internal(FLLIBTRUTHVALUE(Call,Truth),[ReifyStart,TruthCode,'{',CallCode,'}',ReifyEnd],Level,Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	Depth1 is Depth+1,
	flora_unwrap_truthvalued_call(Call,Unwrapped),
	decode_literal_internal(Unwrapped,CallCode,0,Depth1),
	Truth=TruthCode.

%% _load(...) in the form of [...]
decode_literal_internal(FLLIBLOAD([Arg],_,_,_),[ReifyStart,'_load(',LoadCode,')',ReifyEnd],Level,_Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	(Arg = '>>'(File,Module)
	-> LoadCode = [File,'>>',Module]
	;  LoadCode = Arg
	).

decode_literal_internal(FLLIBUNIVEQFORM(Left,Right),
		     [ReifyStart,LeftCode,' ',FL_UNIVEQFORM,' ',RightCode,ReifyEnd],
		     Level,Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	Depth1 is Depth+1,
	decode_literal_internal(Left,LeftCode,0,Depth1),
	decode_literal_internal(Right,RightCode,0,Depth1).

decode_literal_internal(FL_DELAYQUANT(QuantType,Cond,Goal),
			[ReifyStart,QuantType,'(',CondCode,')^',GoalCode,ReifyEnd],
			Level,Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	Depth1 is Depth+1,
	decode_literal_internal(Cond,CondCode,0,Depth1),
	decode_literal_internal(Goal,GoalCode,0,Depth1).

%% var commalist - protects the next two clauses from meaningless unification
decode_literal_internal((L,R),[ReifyStart,'(',[LCode,', '|RCode],')',ReifyEnd],Level,Depth) :-
	(var(L) ; var(R)),
	!,
	ReifyStart='',ReifyEnd='',
	Depth1 is Depth+1,
	decode_literal_internal(L,LCode,Level,Depth1),
	decode_literal_internal(R,RCode,Level,Depth1).

%% Case of prolog term in a module Module:Predicare(args)
decode_literal_internal((Call FL_METAUNIV [Pred|Args], ModCall = Module:Call, call(ModCall)), Code, _Level, Depth) :-
	atom(Module),
	!,
	Term =.. [Pred|Args],
	decode_prolog_call([':',[Module,Term],2],_WS,Code,Depth).

%% Call prolog predicate in a different module; must be before commalist
%% We loose the module name in decoding. Case of =..
decode_literal_internal((X FL_METAUNIV _List, call(X)),
			[ReifyStart,'call(',Code,')',ReifyEnd],
			Level,
			Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	Depth1 is Depth+1,
	decode_literal_internal(X,Code,0,Depth1).

%% Aggregates should be handled before commalists
decode_literal_internal(Call,Code,Level,_Depth) :-
	compound(Call),
	Call =.. [AggLib,AggVar,GrpVarList,Query,AggResultVar],
	is_aggregate_call(AggLib,AggName),
	!,
	decode_aggregate(AggName,AggVar,GrpVarList,Query,AggResultVar,Code,Level).
decode_literal_internal((Call, AggResultVar=InterimResultVar),Code,Level,_Depth) :-
	compound(Call),
	Call =.. [AggLib,AggVar,GrpVarList,Query,InterimResultVar],
	is_aggregate_call(AggLib,AggName),
	!,
	decode_aggregate(AggName,AggVar,GrpVarList,Query,AggResultVar,Code,Level).

%% commalist
decode_literal_internal((L,R),Code,Level,Depth) :-
	!,
	%%(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	ReifyStart='',ReifyEnd='',
	Depth1 is Depth+1,
	decode_literal_internal(L,LCode,Level,Depth1),
	decode_literal_internal(R,RCode,Level,Depth1),
	(RCode == [] -> Code = [ReifyStart,LCode,ReifyEnd]
	; LCode == [] -> Code = [ReifyStart,RCode,ReifyEnd]
	; Code = [ReifyStart,'(',[LCode,', '|RCode],')',ReifyEnd]
	).

%% list
decode_literal_internal(Call,['[', ']'],_Level,_Depth) :-
	Call == [],
	!.
decode_literal_internal(Call,['"', Code, '"'],_Level,_Depth) :-
	is_charlist(Call),
	!,
        escape(Call,EscCall),
	atom_codes(Code,EscCall).
decode_literal_internal('.'(H,T),['[',Code,']'],Level,Depth) :-
	!,
	Depth1 is Depth+1,
	decode_list_add_separator('.'(H,T),Code,decode_literal_internal(_,_,Level,Depth1),', ').
decode_literal_internal(FL_SEMICOLON(L,R),Code,Level,Depth) :-
	!,
	Depth1 is Depth+1,
	%%(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	ReifyStart='',ReifyEnd='',
	decode_literal_internal(L,LCode,Level,Depth1),
	decode_literal_internal(R,RCode,Level,Depth1),
	(RCode == [] -> Code = [ReifyStart,LCode,ReifyEnd]
	; LCode == [] -> Code = [ReifyStart,RCode,ReifyEnd]
	; Code = [ReifyStart,'(',LCode,'; ',RCode,')',ReifyEnd]
	).

/*
%% This is no longer necessary, since goal_cut_untrans/2 gets rid of ;;/2
decode_literal_internal(';;'(L,R),[ReifyStart,'(',LCode,'; ',RCode,')',ReifyEnd],Level,Depth) :-
	!,
	Depth1 is Depth+1,
	%%(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	ReifyStart='',ReifyEnd='',
	decode_literal_internal(L,LCode,Level,Depth1),
	decode_literal_internal(R,RCode,Level,Depth1).
*/

%% Can this happen?
decode_literal_internal('-->'(Call1,Call2),[ReifyStart,Call1Code,' --> ',Call2Code,ReifyEnd],Level,Depth) :-
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	Depth1 is Depth+1,
	decode_literal_internal(Call1,Call1Code,Level,Depth1),
	decode_literal_internal(Call2,Call2Code,Level,Depth1).

%% call(...), tnot(...), not(...), \+ (...)
decode_literal_internal(FLORA_NAF_PREDICATE(Subcall),[ReifyStart,'(','naf ',SubcallCode,')',ReifyEnd],Level,Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	Depth1 is Depth+1,
	flora_unwrap_negation(Subcall,Unwrapped),
	flora_decode_goal(Unwrapped,SubcallCode,Depth1).
decode_literal_internal(FLORA_NAF_PREDICATE(Subcall,_,_,_),[ReifyStart,'(','naf ',SubcallCode,')',ReifyEnd],Level,Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	Depth1 is Depth+1,
	flora_unwrap_negation(Subcall,Unwrapped),
	flora_decode_goal(Unwrapped,SubcallCode,Depth1).
decode_literal_internal(tnot(Subcall),[ReifyStart,'naf ',SubcallCode,ReifyEnd],_Level,Depth) :-
	!,
	%%(Level==0 -> ReifyStart='',ReifyEnd=''; ReifyStart='${',ReifyEnd='}'),
	ReifyStart='', ReifyEnd='',
	Depth1 is Depth+1,
	flora_unwrap_negation(Subcall,Unwrapped),
	flora_decode_goal(Unwrapped,SubcallCode,Depth1).

%% The case when Call = FLORA_THIS_WORKSPACE(FL_TABLED_UNNUMBER_CALL)(Unwrapped)
decode_literal_internal(Call,[ReifyStart,'(naf ',UnwrappedCode,')',ReifyEnd],Level,Depth) :-
	flora_unwrap_negation(Call,Unwrapped),
	Call \== Unwrapped,
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	Depth1 is Depth+1,
	(var(Unwrapped) -> UnwrappedCode='_Var'
	; flora_decode_goal(Unwrapped,UnwrappedCode,Depth1)
	).

decode_literal_internal(not(Subcall),[ReifyStart,'\+ ',SubcallCode,ReifyEnd],_Level,Depth) :-
	!,
	%%(Level==0 -> ReifyStart='',ReifyEnd=''; ReifyStart='${',ReifyEnd='}'),
	ReifyStart='', ReifyEnd='',
	Depth1 is Depth+1,
	flora_decode_goal(Subcall,SubcallCode,Depth1).
decode_literal_internal('\+'(Subcall),[ReifyStart,'\+ ',SubcallCode,ReifyEnd],_Level,Depth) :-
	!,
	%%(Level==0 -> ReifyStart='',ReifyEnd=''; ReifyStart='${',ReifyEnd='}'),
	ReifyStart='', ReifyEnd='',
	Depth1 is Depth+1,
	flora_decode_goal(Subcall,SubcallCode,Depth1).

decode_literal_internal(FLLIBHYPOTHETICAL(Op,Call),[ReifyStart,Op,' ',CallCode,ReifyEnd],_Level,Depth) :-
	!,
	ReifyStart='', ReifyEnd='',
	Depth1 is Depth+1,
	flora_decode_goal(Call,CallCode,Depth1).

decode_literal_internal(call(Subcall),[ReifyStart,'call(',SubcallCode,')',ReifyEnd],Level,Depth) :-
	!,
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	Depth1 is Depth+1,
	flora_decode_goal(Subcall,SubcallCode,Depth1).

decode_literal_internal(FLSYSRULEUPDATE(Id,_DescrVarTerm,_DescrMetaFacts,Head,Body,_,_,_PreBody,_PostBody,_DefeatCond),
			[ReifyStart,RuleIdCode,HeadCode, ' :- ', BodyCode, ReifyEnd],
			Level, Depth) :-
	!,
	(is_void(Id) -> RuleIdCode = ''
	;
	    flora_decode_oid(Id,IdCode),
	    RuleIdCode = ['@!{', IdCode, '} ']
	),
	(Level==0 -> ReifyStart='',ReifyEnd='' ; ReifyStart='${',ReifyEnd='}'),
	Depth1 is Depth+1,
	decode_head(Head,HeadCode,Depth1),
	flora_decode_goal(Body,BodyCode,Depth1).

%% An update
decode_literal_internal(Call,Code,Level,_Depth) :-
	compound(Call),
	Call =.. [UpdPred,_ThisMofule,UpdLiterals|Query],
	is_update_call(UpdPred,UpdName),
	!,
	(Query==[]
	-> 
	    decode_update(UpdName,[UpdLiterals],Code,Level)
	; Query = [RealQuery],
	    decode_update(UpdName,[UpdLiterals,RealQuery],Code,Level)
	).

decode_literal_internal(CallIn,Code,Level,Depth) :-
	%% goal_cut_untrans gets rid of various irregularities like ';;'/2
	goal_cut_untrans(CallIn,Call),
	(\+callable(Call)
	-> flora_abort([Call,': Ill-formed HiLog term in decode_literal_internal/3'])
	;
	    Depth1 is Depth+1,
	    classify_call(Call,Type,BasenameOrPred,Args,WS),
	    (Type == (hilog_term)
	    -> decode_hilog_term(BasenameOrPred,Args,Code,Level,Depth1)
	    ; Type == (tabled_hilog)
	    ->
		decode_tabled_hilog_call(BasenameOrPred,Args,WS,Code,Level,Depth1)
	    ; Type == (neg_tabled_hilog)
	    ->
		decode_negated_tabled_hilog_call(BasenameOrPred,Args,WS,Code,Level,Depth1)
            ; Type == (nontabled_hilog)
            -> decode_nontabled_hilog_call(BasenameOrPred,Args,WS,Code,Level,Depth1)
	    ; Type == (prolog)
	    ->  functor(Call,Functor,Arity),
		decode_prolog_call([Functor,Args,Arity],WS,Code,Depth1)
	    ; Type == (flogic)
	    -> decode_molecule(BasenameOrPred,Args,WS,Code,Level,Depth1)
	    ; Type == (neg_flogic)
	    -> decode_negated_molecule(BasenameOrPred,Args,WS,Code,Level,Depth1)
	    ; Type == (flora), length(Args,Arity),
		%% need to get rid of the Caller argument
		Arity1 is Arity-1,
		(flora_modular_prlgdef(BasenameOrPred,Arity1)
		; flora_modular_prlgdef(BasenameOrPred,Arity1,WS)
		)
	    ->  flrtrim_last(Args,Args1),
		decode_prolog_call([BasenameOrPred,Args1,Arity1],WS,Code,Depth1)
	    ; Type == (neg_flora)
	    -> %% need to get rid of the Caller argument
		length(Args,Arity), Arity1 is Arity-1, flrtrim_last(Args,Args1),
		decode_prolog_call([neg(BasenameOrPred),Args1,Arity1],WS,Code,Depth1)
	    ;	%% cannot decode
		%%flora_warning_line('~w: decode_literal_internal/3 failed to decode', [Call]),
		flora_concat_items([Call], Code1),
		Code = [Code1]
	    )
	).



/*
%% Keep for now in case we decide to be sophisticated and print true var names
%% Extracts and writes variables from the list [=(name,internalVar), ...]
%% or from the list [internalVar, internalVar, ...]
flora_write_vars(V) :- V== [], !.
flora_write_vars([V|Rest]) :- 
	var(V), !, flora_write_vars(V,Rest).
flora_write_vars([=(_N,V)|Rest]) :- 
    	!, flora_write_vars(V,Rest).

flora_write_vars(V,Rest) :-
	write(V),
	(Rest == [] -> true
	 ; write(FL_COMMA), flora_write_vars(Rest)
	).
*/

/****************************************************************************
* flora_escape_atom(+Text1, -Text2)
* escape(+Text1, -Text2)
* for strings, replace every occurency of \ with \\ so that \n is printed
* as it is instead of being interpreted
* ****************************************************************************/
flora_escape_atom(Atom, Quoted) :-
	atom(Atom),
	atom_codes(Atom,Codes),
	escape(Codes, Escaped,needs_quoting),
	atom_codes(EscapedAtm,Escaped),
	%%flora_concat_atoms(['''',EscapedAtm,''''],Quoted).
	Quoted = EscapedAtm.

escape(NL,['?', NL]) :-
        var(NL),
        !.

escape(Atom,Code) :-
        atom(Atom),
        !,
	%%fmt_write_string(Atom1,'%S',arg(Atom)), % workaround for XSB bug
        atom_codes(Atom,Str),
        escape(Str,EscStr,Flag),
	atom_codes(NA,EscStr),
        ( Flag == needs_quoting, is_not_op(NA)
	-> Code = ['''',NA,'''']
	; EscStr = [Ch|_], Ch >= CH_0, Ch =< CH_9  %% quote if starts with digit
	-> Code = ['''',NA,'''']
	;
	    Code = NA
	).

escape(L,NL) :- is_list(L), !, escape(L,NL,_Flag).

%% Neither list nor atom - don't do anything
escape(L,L) :- !.
        
escape([],[],_Flag) :- !.

escape([H|L],[CH_BACKSLASH,HC|EL],needs_quoting) :-
        special_character(H,HC),
        !,
        escape(L,EL,_Flag).
escape([CH_BACKSLASH,CH_QUOTE|L],[CH_QUOTE,CH_QUOTE|EL],needs_quoting) :-
	flora_display_mode(flora),
	!,
	escape(L,EL,_).
/*
escape([CH_BACKSLASH,CH_QUOTE|L],[CH_BACKSLASH,CH_QUOTE|EL],needs_quoting) :-
	flora_display_mode(silk),
	!,
	escape(L,EL,_).
*/
escape([CH_QUOTE|L],[CH_QUOTE,CH_QUOTE|EL],needs_quoting) :-
	flora_display_mode(flora),
	!,
	escape(L,EL,_).
/*
escape([CH_QUOTE|L],[CH_BACKSLASH,CH_QUOTE|EL],needs_quoting) :-
	flora_display_mode(silk),
	!,
	escape(L,EL,_).
*/
%% Backslash before special character is escaped: '\\n' is internally 
%% translated as \ n and is printed as '\\n'
escape([CH_BACKSLASH,H|L],[CH_BACKSLASH,CH_BACKSLASH,H|EL],needs_quoting) :-
        special_character(_,H),
        !,
        escape(L,EL,_Flag).
escape([CH_BACKSLASH,H|L],[CH_BACKSLASH,CH_BACKSLASH|HEL],needs_quoting) :-
        special_character(H,_),
        !,
        escape([H|L],HEL,_Flag).
escape([CH_BACKSLASH,CH_BACKSLASH|L],[CH_BACKSLASH,CH_BACKSLASH|EL],needs_quoting) :-
        !,
        escape([CH_BACKSLASH|L],EL,_Flag).
escape([H|L],[H|EL],Flag) :-
	(needs_quoting(H) -> Flag = needs_quoting, NewFlag = _
	; NewFlag = Flag
	),
        escape(L,EL,NewFlag).

/****************************************************************************
 special_character(+C, -NC)
 recognize special characters \a, \b, \t, \n, \v, \f, \r
 ****************************************************************************/
special_character(CH_ALARM, CH_a) :- !.
special_character(CH_BACKSPACE,CH_b) :- !.
special_character(CH_TAB,CH_t) :- !.
special_character(CH_NEWLINE,CH_n) :- !.
special_character(CH_VERTAB,CH_v) :- !.
special_character(CH_FORMFEED,CH_f) :- !.
special_character(CH_RETURN,CH_r) :- !.

needs_quoting(Ch) :-
	(Ch < CH_0; Ch > CH_9), %% we should really quote numbers for safety
	(Ch < CH_a; Ch > CH_z),
	(Ch < CH_A; Ch > CH_Z),
	Ch \= CH_UNDERSCORE.

is_void(X) :-
	(X == NULL ; var(X)),
	!.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Display mode stuff
%%  Currently the only display mode is: flora
%%  Other modes are disabled now, but keeping this stuff in case we reuse
%%  this infrastructure for something else
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
flora_set_display_mode(Mode) :-
	valid_display_mode(Mode),
	!,
	(retract(display_mode(_)), ! ; true),
	assert(display_mode(Mode)).
flora_set_display_mode(Mode) :-
	flora_abort(['Invalid FLORA-2 display mode: ', Mode]).
flora_set_display_submode(Mode) :-
	valid_display_submode(Mode),
	!,
	(retract(display_submode(_)), ! ; true),
	assert(display_submode(Mode)).
flora_set_display_submode(Mode) :-
	flora_abort(['Invalid FLORA-2 display submode: ', Mode]).

%%valid_display_mode(silk).
valid_display_mode(flora).

valid_display_submode(answer).
valid_display_submode(default).

flora_display_mode(Mode) :- display_mode(Mode), !.
flora_display_mode(flora) :- \+ display_mode(_).
flora_display_submode(Mode) :- display_submode(Mode), !.
flora_display_submode(flora) :- \+ display_submode(_).

flora_display_symbol(SymType,Symbol) :-
	flora_display_mode(Mode),
	display_table(SymType,Mode,Symbol).

display_table(isa,flora,':').
display_table(sub,flora,'::').
display_table(terminator,flora,'.').
display_table(skolem,flora,'_#').
display_table(cardinality,flora,':').

flora_display_type_name(SymType,Typename) :-
	flora_display_mode(Mode),
	display_datatype_name(SymType,Mode,Typename).

%% display_datatype_name(Type,Mode,CanonName)
display_datatype_name(Type,flora,Type) :- !.


%% bind variables to ?A,?B,?C, etc.
bind_vars_meaningfully(L) :-
	bind_vars_meaningfully(L,0).

bind_vars_meaningfully([],_) :- !.
bind_vars_meaningfully([X|R],N) :-
	atomic(X),
	!,
	bind_vars_meaningfully(R,N).
bind_vars_meaningfully([X|R],N) :-
	%% need to figure out how to delete other possible attributes
	del_attr(X,when),
	del_attr(X,FLDYNRULEVARCHECK),
	Code is N mod 26 + 0'A,
	atom_codes(Xname,[0'?,Code]),
	X = '_$VAR'(Xname),
	N1 is N+1,
	bind_vars_meaningfully(R,N1).

is_unary_op(F) :-
	(flora_opdef(_,fx,F); flora_opdef(_,fy,F)),
	!.
is_binary_op(F) :-
	(flora_opdef(_,xfx,F); flora_opdef(_,yfx,F); flora_opdef(_,xfy,F)),
	!.
is_not_op(NA) :- \+ flora_opdef(_,_,NA).

is_synonym_unary_op(F) :-
	(flrsynonym:flora_op_synonym(F,Synonym) -> true ; F = Synonym),
	is_unary_op(Synonym).
is_synonym_binary_op(F) :-
	(flrsynonym:flora_op_synonym(F,Synonym) -> true ; F = Synonym),
	is_binary_op(Synonym).
is_synonym_op(F,1) :- is_synonym_unary_op(F).
is_synonym_op(F,2) :- is_synonym_binary_op(F).

is_prolog(F,Arity) :-
	(flora_prlgdef(F,Arity) ; flora_prlgdef_repl(F,Arity,_,_)),
	!.
