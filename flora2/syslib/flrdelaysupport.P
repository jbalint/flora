/* File:      flrdelaysupport.P
**
** Author(s): Michael Kifer
**
** Contact:   flora-users@lists.sourceforge.net
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 2011-2013;
**      and Vulcan, Inc., 2011-2013.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**      http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
**
*/

:- compiler_options([xpp_on]).


#include "flora_terms.flh"
#include "flora_porting.flh"
#include "flora_exceptions.flh"

%%:- import term_variables/2 from constraintLib.
:- import get_trigger_goal/2 from constraintLib.

:- import
	%%flrtrim_last/2,
	%%flrground/1,
	flrterm_vars/3,
	%% this one separates regular from attributed vars
	flrterm_vars_split/4
   from flora_ground.
:- import
	flora_abort/1,
	flora_abort/2
   from flrporting.

:- import is_strict_rule/2 from flrdescriptor_support.

%%:- import member/2 from basics.
:- import flora_decode_goal_as_atom_substitute_vars/2 from flrdecode.
:- import flora_error_line/2 from flrprint.
:- import
	call0/1,
	term_arg/3,
	is_cyclic/1,
	get_attr/3,
	del_attr/2
   from machine.

:- import flora_when/2 from flrutils.

%%:- import flora_decode_predicate/6 from flrwrapper.

:- dynamic delay_spec_to_predicate/6.
:- index(delay_spec_to_predicate/6,[1,5]).
:- dynamic delayed_sensor/3.
:- index(delayed_sensor/3,trie).

:- dynamic experimental/1.

:- export
	FLORA_DELAY_CHECKER/2,
	FLLIBDELAYEDLITERAL/4,
	FLLIBDEFEATDELAY/6,
	FLLIBNAFDELAY/1,
	FLLIBRECORDSENSORS/2.
:- export
	flora_register_sensor/2,
	flora_delayed_literal/3,
	flora_delayed_builtin_literal/2,
	flora_delayed_sensor_literal/3.

:- export
	enable_experiment/1,
	disable_experiment/1.

:- export strip_delay/2.


%% MK: test_mode/1: support for testing. Need something more general, like
%% catch. But catch does not work in  a usual way, as delayed literals
%% are slipped from under catch/3, so catch/3 applies vacuously to when/2.
:- dynamic test_mode/1.
:- export set_test_mode.
:- export clear_test_mode.

set_test_mode :- assert(test_mode(debug)). 
clear_test_mode :- retract(test_mode(debug)). 


/*******    Wrappers for builtins    ********/
FLLIBDELAYEDLITERAL(Builtin,FileN,Line,Args) :-
	delay_spec_to_predicate(Builtin,FileN,Line,Args,Call,Condition_pre),
	%% sometimes statically created delay conditions need postprocessing
	make_delay_condition(Builtin,Args,Condition_pre,Condition),
	!,
	%% If Condition is ground, no point in using when/2.
	%% This speeds up cases where args are mostly ground.
	%% E.g., argumentation theories become faster by some 10%
	(ground(Condition) -> Call
	; flora_when(Condition,Call)
	).

%% Delay wrapper for the FL_UNDEFEATED condition
%% _File,_Line,_VarnameList - not used currently:
%% we are not issuing nongroundedness errors
FLLIBDEFEATDELAY(_File,_Line,DefeatCond,DynHead,VarList,_VarnameList) :-
	term_arg(DefeatCond,1,RuleId),
	term_arg(DefeatCond,4,Module),
	(is_strict_rule(RuleId,Module) -> true
	; is_cyclic(DefeatCond) -> fail
	%% Not checking for groundedness
	;
	    flrterm_vars(DynHead,DynVars,1),
	    (ground((DynVars,VarList)) -> DefeatCond
	    ; flora_when(ground((VarList,DynVars)),DefeatCond)
	    )
	).

FLLIBNAFDELAY(Goal) :-
	(experimental(delay_naf) ->
	    term_arg(Goal,2,Vars),
	    flora_when(ground(Vars),Goal)
	;
	    Goal
	).

/******************** Actual definitions of builtins ***********************/

/********************* Action to be executed for WRAP_DIFFOBJEQL ***********/
flora_diffojbeql_action(X,Y,_Call) :- 
	var(X),
	var(Y),
	!,
	fail.
flora_diffojbeql_action(_X,_Y,Call) :- 
	Call.


/*
%% Not used. May use later if we decide to issue nongroundedness errors again.
%% Currently, nongroundedness will result in truth value = u
issue_nongroundedness_error(_,_,[],[]) :- !.
issue_nongroundedness_error(File,Line,[Var|VarList],[VarName|VarnameList]) :-
	(ground(Var) -> issue_nongroundedness_error(File,Line,VarList,VarnameList)
	; flora_abort(['in file ', File, ' on line ', Line, ': ',
		       'argument ?', VarName,
		       ' is not ground during invocation of defeasible rule'],
		      FLORA_ABORT_NOTRACE
		     )
	).

check_dynamic_rule_head_for_groundedness(File,Line,DynHead) :-
	(flrground(DynHead) -> true
	; flora_abort(['in file ', File, ' on line ', Line, ': rule head ',
		       'is not ground during invocation of defeasible rule, ',
		       DynHead],
		      FLORA_ABORT_NOTRACE
		     )
	).
*/


%% !=
flora_unequal_builtin(File,Line,X,Y) :-
	(var(X) -> builtin_instantiation_error(File,Line,1,FL_C_UNEQUAL,unbound,X,Y)
	; var(Y) -> builtin_instantiation_error(File,Line,2,FL_C_UNEQUAL,unbound,X,Y)
	; X \= Y
	).

/*
%% Not delaying that one: too dangerous to delay non-logical builtin,
%% as it violates natural causality in if-statements
%% ==, i.e., FL_EQ. Causes no errors
flora_identical_builtin(_File,_Line,X,Y) :- X == Y.
*/

%% !==: FL_C_NOTSAME. Causes no errors
flora_notidentical_builtin(_File,_Line,X,Y) :- X \== Y.

%% >
flora_greaterthan_builtin(File,Line,X,Y) :-
	(\+ground(X) -> builtin_instantiation_error(File,Line,1,FL_GT,'non-ground',X,Y)
	; \+ground(Y) -> builtin_instantiation_error(File,Line,2,FL_GT,'non-ground',X,Y)
	; catch(X > Y,_,builtin_instantiation_error(File,Line,FL_GT,'non-numeric value',X,Y))
	).

%% >=
flora_greaterequal_builtin(File,Line,X,Y) :-
	(\+ground(X) -> builtin_instantiation_error(File,Line,1,FL_EQGT,'non-ground',X,Y)
	; \+ground(Y) -> builtin_instantiation_error(File,Line,2,FL_EQGT,'non-ground',X,Y)
	; catch(X >= Y,_,builtin_instantiation_error(File,Line,FL_EQGT,'non-numeric value',X,Y))
	).

%% <
flora_lessthan_builtin(File,Line,X,Y) :-
	(\+ground(X) -> builtin_instantiation_error(File,Line,1,FL_LT,'non-ground',X,Y)
	; \+ground(Y) -> builtin_instantiation_error(File,Line,2,FL_LT,'non-ground',X,Y)
	; catch(X < Y,_,builtin_instantiation_error(File,Line,FL_LT,'non-numeric value',X,Y))
	).

%% =<
flora_lessequal_builtin(File,Line,X,Y) :-
	(\+ground(X) -> builtin_instantiation_error(File,Line,1,FL_EQLT,'non-ground',X,Y)
	; \+ground(Y) -> builtin_instantiation_error(File,Line,2,FL_EQLT,'non-ground',X,Y)
	; catch(X =< Y,_,builtin_instantiation_error(File,Line,FL_EQLT,'non-numeric value',X,Y))
	).

%% =:=
flora_mathequal_builtin(File,Line,X,Y) :-
	(\+ground(X) -> builtin_instantiation_error(File,Line,1,FL_MATHEQ,'non-ground',X,Y)
	; \+ground(Y) -> builtin_instantiation_error(File,Line,2,FL_MATHEQ,'non-ground',X,Y)
	; catch(X =:= Y,_,builtin_instantiation_error(File,Line,FL_MATHEQ,'non-numeric value',X,Y))
	).

%% =\=
flora_mathnotequal_builtin(File,Line,X,Y) :-
	(\+ground(X) -> builtin_instantiation_error(File,Line,1,FL_MATHNOTEQ,'non-ground',X,Y)
	; \+ground(Y) -> builtin_instantiation_error(File,Line,2,FL_MATHNOTEQ,'non-ground',X,Y)
	; catch(X =\= Y,_,builtin_instantiation_error(File,Line,FL_MATHNOTEQ,'non-numeric value',X,Y))
	).

%% is/2
flora_arith_IS_builtin(File,Line,X,Y) :-
	(
	  \+ground(Y) -> builtin_instantiation_error(File,Line,2,FL_IS,'non-ground',X,Y)
	;
	  catch(X is Y,_,builtin_instantiation_error(File,Line,FL_IS,'non-numeric value',X,Y))
	).


%%%%%%%%%%%%%%%%%% Type Builtins %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% =:=
flora_number_builtin(File,Line,X) :-
	(var(X) -> builtin_instantiation_error(File,Line,'_isnumber','unbound',X)
	; number(X)
	).
flora_integer_builtin(File,Line,X) :-
	(var(X) -> builtin_instantiation_error(File,Line,'_isinteger','unbound',X)
	; integer(X)
	).
flora_float_builtin(File,Line,X) :-
	(var(X) -> builtin_instantiation_error(File,Line,'_isfloat','unbound',X)
	; float(X)
	).
%% currently like number/1
flora_decimal_builtin(File,Line,X) :-
	(var(X) -> builtin_instantiation_error(File,Line,'_isdecimal','unbound',X)
	; number(X)
	).
flora_atom_builtin(File,Line,X) :-
	(var(X) -> builtin_instantiation_error(File,Line,'_isatom','unbound',X)
	; atom(X)
	).
flora_compound_builtin(File,Line,X) :-
	(var(X) -> builtin_instantiation_error(File,Line,'_iscompound','unbound',X)
	; X = FL_DATATYPE(_,_) -> fail
	; compound(X)
	).
flora_atomic_builtin(File,Line,X) :-
	(var(X) -> builtin_instantiation_error(File,Line,'_isatomic','unbound',X)
	; atomic(X)
	).

flora_islist_builtin(File,Line,X) :-
	(var(X) -> builtin_instantiation_error(File,Line,'_islist','unbound',X)
	; is_list(X)
	).
flora_ischarlist_builtin(File,Line,X) :-
	(var(X) -> builtin_instantiation_error(File,Line,'_ischarlist','unbound',X)
	; is_charlist(X)
	).

flora_delay_quantifier(_File,_Line,[FL_WISH,_Condition,Goal]) :-
	!,
	Goal.

flora_delay_quantifier(_File,_Line,[FL_MUST,Condition,Goal]) :-
	Condition,
	!,
	Goal.

%% The next two are error cases
flora_delay_quantifier(File,Line,[FL_MUST,Condition,Goal]) :-
	test_mode(debug),
	!,
	flora_decode_goal_as_atom_substitute_vars(Goal,GoalAtm),
	flora_decode_goal_as_atom_substitute_vars(Condition,CondAtm),
	flora_error_line('in file ~w, line ~w: unsatisfied must-condition.~n\tGoal: ~w~n\tCondition: ~w',
			 [File,Line,GoalAtm,CondAtm]).

flora_delay_quantifier(File,Line,[FL_MUST,Condition,Goal]) :-
	flora_decode_goal_as_atom_substitute_vars(Goal,GoalAtm),
	flora_decode_goal_as_atom_substitute_vars(Condition,CondAtm),
	flora_abort(['in file ', File, ', line ', Line, ': ',
		     'unsatisfied must-condition.',
		     '\n\tGoal: ', GoalAtm,
		     '\n\tCondition: ', CondAtm],
		    FLORA_ABORT_NOTRACE).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

FLORA_DELAY_CHECKER(InstantiatedBodyVars,HeadVars) :-
	extract_triggers_and_execute_all(InstantiatedBodyVars,HeadVars),
	%% this cut is needed to release stack.
	%% otherwise, lots of warnings about stack overflow
	!.

%% scan all vars repeatedly, eliminating attributed vars,
%% until no more attributed vars left. Execute attached triggers on the way.
extract_triggers_and_execute_all(AllVars,HeadVars) :-
	is_acyclic(AllVars),
	flrterm_vars_split(AllVars, RegVars, AttrVars,0), %% 1: ignore vars in negation
	(AttrVars == [] -> true
	; extract_triggers_and_execute(AttrVars,HeadVars),
	    extract_triggers_and_execute_all(RegVars,HeadVars)
	).

extract_triggers_and_execute([],_HeadVars) :- !.
extract_triggers_and_execute([Var|RestBodyVars],HeadVars) :-
	get_var_triggers(Var,HeadVars,Triggers),
	!,
	call_trigger_list(Triggers),
	extract_triggers_and_execute(RestBodyVars,HeadVars).

get_var_triggers(Var,HeadVars,Triggers) :-
	(aliased_to_head(Var,HeadVars) -> Triggers = []
	; get_attr(Var,when,Triggers)
	->  %% remove attrs to avoid delayed lit calling itself repeatedly
	    %% during its own work (eg, if it instantiates a when-variable)
	    del_attr(Var,when)
	; Triggers = []
	),
	!.

/*
get_all_triggers(BodyVars,HeadVars,Triggers) :-
	get_all_triggers(BodyVars,HeadVars,Triggers,[]).
get_all_triggers([],_HeadVars,Triggers,Triggers) :- !.
get_all_triggers([Var|Rest],HeadVars,NewTrigs,OldTrigs) :-
	(aliased_to_head(Var,HeadVars) -> NewTrigs = OldTrigs
	; get_attr(Var,when,Trigs)
	->  %% remove attrs to avoid delayed lit calling itself repeatedly
	    %% during its own work (eg, if it instantiates a when-variable)
	    NewTrigs = [Trigs|RestNewTrigs],
	    del_attr(Var,when)
	; NewTrigs = RestNewTrigs
	),
	!,
	get_all_triggers(Rest,HeadVars,RestNewTrigs,OldTrigs).
*/

aliased_to_head(V,[H|_HV]):- V == H, !.
aliased_to_head(V,[_|H]):- aliased_to_head(V,H).

call_trigger_list([]) :- !.
/*
%% Now the arg is a proper list, not a list of lists
call_trigger_list([Trigger|Rest]) :-
	%% trigger list can actually be a list of lists
	is_list(Trigger),
	!,
	call_trigger_list(Trigger),
	call_trigger_list(Rest).
*/
call_trigger_list([Trigger|Rest]) :-
	%% a trigger has the form trigger_NAME(VarList,Goal)
	(get_trigger_goal(Trigger,Goal) ->
	    %% check that call is an intended one, i.e., 
	    %% satisfies the template delayed_pred_template/1
	    delayed_pred_template(Goal),
	    call0(Goal)
	; %% if no acceptable goal associated with trigger, just continue
	    true
	),
	call_trigger_list(Rest).

/*
%% this is now in constraintLib.P
:- import
	trigger_ground/2, trigger_nonvar/2, trigger/2, check_disj/2
   from constraintLib.
get_trigger_goal(trigger_nonvar(_,Trigger),Goal) :-
	!,
	get_trigger_goal(Trigger,Goal).
get_trigger_goal(trigger_ground(_,Trigger),Goal) :-
	!,
	get_trigger_goal(Trigger,Goal).
get_trigger_goal(trigger(_,Trigger),Goal) :-
	!,
	get_trigger_goal(Trigger,Goal).
get_trigger_goal(check_disj(Det,Trigger),Goal) :-
	!,
	%% note: if Det is nonvar, the trigger's goal has already been used
	%% so we just fail
	var(Det),
	Det = (-),
	get_trigger_goal(Trigger,Goal).
get_trigger_goal(Trigger,Trigger).
*/


%% For binary builtins
builtin_instantiation_error(File,Line,ArgNo,Builtin,Message,Arg1,Arg2) :-
	fmt_write_string(S, '%S %S %S', args(Arg1,Builtin,Arg2)),
	flora_abort(['in file ',File,' on line ',Line,': ',
		     'instantiation error in builtin: ', S,
		     '; ', Message, ' argument ', ArgNo],
		    FLORA_ABORT_NOTRACE
		   ).
builtin_instantiation_error(File,Line,Builtin,Message,Arg1,Arg2) :-
	fmt_write_string(Str, '%S %S %S', args(Arg1,Builtin,Arg2)),
	flora_abort(['in file ',File,' on line ',Line,': ',
		     'instantiation error in builtin: ', Str,
		     '; ', Message, ' in one of the arguments'],
		    FLORA_ABORT_NOTRACE
		   ).

%% For unary builtins
builtin_instantiation_error(File,Line,Builtin,Message,Arg) :-
	fmt_write_string(Str, '%S(%S)', args(Builtin,Arg)),
	flora_abort(['in file ',File,' on line ',Line,': ',
		     'instantiation error in builtin: ', Str,
		     '; ', Message, ' argument'],
		    FLORA_ABORT_NOTRACE
		   ).



delayed_pred_template(Template) :- delay_spec_to_predicate(_,_,_,_,Template,_).

%% The first two args in sensor declaration are file name and line number
flora_register_sensor(SensorCall,DelayCondition) :-
	decompose_sensor_call(SensorCall,SensorSymbol,Module,FileName,Line,AllArgs),
	flora_register_delay(sensor,Module:SensorSymbol,FileName,Line,AllArgs,SensorCall,DelayCondition).

%% register builtin
flora_register_delay(builtin,BuiltinSymbol,FileName,Line,ArgList,Call,DelayCondition) :-
	!,
	(\+delay_spec_to_predicate(BuiltinSymbol,FileName,Line,ArgList,Call,DelayCondition)
	-> assert(delay_spec_to_predicate(BuiltinSymbol,FileName,Line,ArgList,Call,DelayCondition))
	; true  %% silently ignore, if duplicate
	).

%% register sensor
flora_register_delay(sensor,SensorSymbol,FileName,Line,ArgList,Call,DelayCondition) :-
	!,
	strip_usermod(SensorSymbol,Stripped),
	(\+delay_spec_to_predicate(Stripped,FileName,Line,ArgList,Call,DelayCondition)
	-> assert(delay_spec_to_predicate(Stripped,FileName,Line,ArgList,Call,DelayCondition))
	; true %% silently ignore, if duplicate
	).

flora_register_delay(SensorType,_,_,_,_,_,_) :-
	    flora_abort(['flora_register_delay: unknown sensor type, ',SensorType]).


?-
    flora_register_delay(builtin,WRAP_DIFFOBJEQL,F,L,
			 [X,Y,DiffObjEqlCall],
			 flora_diffojbeql_action(X,Y,DiffObjEqlCall),
			 (nonvar(X) ; nonvar(Y))),

   %% builtins
   flora_register_delay(builtin,FL_C_UNEQUAL,F,L,[X,Y],
			flora_unequal_builtin(F,L,X,Y),
			(nonvar(X),nonvar(Y))), 
   flora_register_delay(builtin,FL_GT,F,L,[X,Y],
			flora_greaterthan_builtin(F,L,X,Y),
			(ground([X,Y]))),
   /*
   %% too dangerous to delay non-logical builtins like "="
   flora_register_delay(builtin,FL_EQ,F,L,[X,Y],
			flora_identical_builtin(F,L,X,Y),
			(ground(X),ground(Y))),
   */
   flora_register_delay(builtin,FL_C_NOTSAME,F,L,[X,Y],
			flora_notidentical_builtin(F,L,X,Y),
			(ground([X,Y]))),
   flora_register_delay(builtin,FL_EQGT,F,L,[X,Y],
			flora_greaterequal_builtin(F,L,X,Y),
			(ground([X,Y]))),
   flora_register_delay(builtin,FL_LT,F,L,[X,Y],
			flora_lessthan_builtin(F,L,X,Y),
			(ground([X,Y]))),
   flora_register_delay(builtin,FL_EQLT,F,L,[X,Y],
			flora_lessequal_builtin(F,L,X,Y),
			(ground([X,Y]))), 
   flora_register_delay(builtin,FL_MATHEQ,F,L,[X,Y],
			flora_mathequal_builtin(F,L,X,Y),
			(ground([X,Y]))), 
   flora_register_delay(builtin,FL_MATHNOTEQ,F,L,[X,Y],
			flora_mathnotequal_builtin(F,L,X,Y),
			(ground(X),ground(Y))),
   flora_register_delay(builtin,FL_IS_INTERNAL,F,L,[X,Y],
			flora_arith_IS_builtin(F,L,X,Y),
			(ground(Y))),

   flora_register_delay(builtin,'_isnumber',F,L,[X],
			flora_number_builtin(F,L,X),
			(nonvar(X))),
   flora_register_delay(builtin,'_isinteger',F,L,[X],
			flora_integer_builtin(F,L,X),
			(nonvar(X))),
   flora_register_delay(builtin,'_isdecimal',F,L,[X],
			flora_decimal_builtin(F,L,X),
			(nonvar(X))),
   flora_register_delay(builtin,'_isfloat',F,L,[X],
			flora_float_builtin(F,L,X),
			(nonvar(X))),
   flora_register_delay(builtin,'_isatom',F,L,[X],
			flora_atom_builtin(F,L,X),
			(nonvar(X))),
   flora_register_delay(builtin,'_iscompound',F,L,[X],
			flora_compound_builtin(F,L,X),
			(nonvar(X))),
   flora_register_delay(builtin,'_isatomic',F,L,[X],
			flora_atomic_builtin(F,L,X),
			(nonvar(X))),
   flora_register_delay(builtin,'_islist',F,L,[X],
			flora_islist_builtin(F,L,X),
			(nonvar(X))),
   flora_register_delay(builtin,'_ischarlist',F,L,[X],
			flora_ischarlist_builtin(F,L,X),
			(nonvar(X))),

   /*
   %% These should be deleted when we switch to _atom and such names
   flora_register_delay(builtin,number,F,L,[X],
			flora_number_builtin(F,L,X),
			(nonvar(X))),
   flora_register_delay(builtin,integer,F,L,[X],
			flora_integer_builtin(F,L,X),
			(nonvar(X))),
   flora_register_delay(builtin,float,F,L,[X],
			flora_float_builtin(F,L,X),
			(nonvar(X))),
   flora_register_delay(builtin,atom,F,L,[X],
			flora_atom_builtin(F,L,X),
			(nonvar(X))),
   flora_register_delay(builtin,compound,F,L,[X],
			flora_compound_builtin(F,L,X),
			(nonvar(X))),
   flora_register_delay(builtin,atomic,F,L,[X],
			flora_atomic_builtin(F,L,X),
			(nonvar(X))),
   %% The above should be deleted when we switch to _atom and such names
   */

   flora_register_delay(builtin,FL_DELAYQUANT,F,L,[Quant,Condition,Goal],
			flora_delay_quantifier(F,L,[Quant,Condition,Goal]),
			Condition),

   %% Add more builtins here
   true.


%% make_delay_condition is not used now, but keep it just in case
%% catchall
make_delay_condition(_,_,Cond,Cond).



%% We do not add delayed builtin for NAF and NOT:
%% they are treated specially in the compiler
delayed_builtin(FL_C_UNEQUAL,2)    :- !.
%%delayed_builtin(FL_EQ,2)         :- !.
delayed_builtin(FL_C_NOTSAME,2)    :- !.
delayed_builtin(FL_GT,2)           :- !.
delayed_builtin(FL_EQGT,2)         :- !.
delayed_builtin(FL_LT,2)           :- !.
delayed_builtin(FL_EQLT,2)         :- !.
delayed_builtin(FL_MATHEQ,2)       :- !.
delayed_builtin(FL_MATHNOTEQ,2)    :- !.
delayed_builtin(FL_IS_INTERNAL,2)  :- !.


flora_delayed_literal(X,Y,_) :- delayed_builtin(X,Y), !.
flora_delayed_literal(X,Y,FlMod) :- delayed_sensor(X,Y,FlMod).
flora_delayed_builtin_literal(X,Y) :- delayed_builtin(X,Y).
flora_delayed_sensor_literal(X,Y,FlMod) :-
	atom(X),
	!,
	delayed_sensor(X,Y,FlMod).
flora_delayed_sensor_literal((X,PlMod),Y,FlMod) :-
	delayed_sensor(PlMod:X,Y,FlMod).

%% For sensors we use all arguments in delay_spec_to_predicate/6
decompose_sensor_call(SensorCall,SensorSymbol,Module,FileName,Line,[FileName,Line|RestArgs]) :-
	(SensorCall = ':'(Module,ModulelessCall) ->
	    ModulelessCall =.. [SensorSymbol,FileName,Line|RestArgs]
	; SensorCall =.. [SensorSymbol,FileName,Line|RestArgs],
	    Module = usermod
	).

record_delayed_sensor(SensorSymbol,Arity,FloraMod) :-
	strip_usermod(SensorSymbol,Stripped),
	assert(delayed_sensor(Stripped,Arity,FloraMod)).

FLLIBRECORDSENSORS(_,[]) :- !.
FLLIBRECORDSENSORS(FloraMod,[Sensor|SensorList]) :-
	(Sensor = (Name,Mod)/Arity
	-> record_delayed_sensor(Mod:Name,Arity,FloraMod)
	; Sensor = Name/Arity -> record_delayed_sensor(Name,Arity,FloraMod)
	),
	FLLIBRECORDSENSORS(FloraMod,SensorList).

strip_usermod(SensorSymbol,Stripped) :-
	SensorSymbol = usermod:Stripped -> true
	; Stripped = SensorSymbol.

%% strip the delaying machinery.
%% identity if not delayed
%% Only strips FLLIBDELAYEDLITERAL and FLLIBNAFDELAY.
%% Others (FLLIBDEFEATDELAY) do not occur in user code
strip_delay(':'(FLDELAYSUPPORTMOD,PreStripped),Stripped) :-
	strip_delay(PreStripped,Stripped),
	PreStripped \= Stripped,
	!.
strip_delay(PreStripped,Stripped) :-
	(functor(PreStripped,FLLIBNAFDELAY,_) -> arg(1,PreStripped,Stripped)
	; functor(PreStripped,FLLIBDELAYEDLITERAL,_) -> arg(4,PreStripped,Stripped)
	),
	!.
strip_delay(Stripped,Stripped).


/*
flora_term_variables(Term, Vars) :-
	get_significant_vars(Term, Vars, []).

get_significant_vars(Term, Vh, Vt) :-
	(var(Term)
	 ->	Vh = [Term | Vt]
	; Term = FLORA_NAF_PREDICATE(Call,_FreeVars,_Line,_File)
	-> get_significant_vars(Call,Vh,Vt)
	; flora_decode_predicate(Term,CallType,_,_,_,Args),
	    (CallType == prolog ->
		TrueArgs = Args
	    ;
		flrtrim_last(Args,TrueArgs)
	    ),
	    get_significant_vars_aux(TrueArgs,Vh,Vt)
	).
get_significant_vars_aux([], V, V).
get_significant_vars_aux([T|Ts], Vh, Vt) :-
	get_significant_vars(T, Vh, Vm),
	get_significant_vars_aux(Ts, Vm, Vt).
*/

enable_experiment(X) :- assert(experimental(X)).
disable_experiment(X) :-
	(ground(X) -> retract(experimental(X))
	; retractall(experimental(X))
	).

%%experimental(delay_naf).
