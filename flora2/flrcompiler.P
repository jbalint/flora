/* File:      flrcompiler.P  -- The Flora Compiler
**
** Author(s): Guizhen Yang, Michael Kifer
**
** Contact:   flora-users@lists.sourceforge.net
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2013;
**      and Vulcan, Inc., 2008-2013.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**      http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
**
*/


:- compiler_options([xpp_on]).

%%#define SHOW_COMPILE_INPUT
%%#define SHOW_COMPILE_OUTPUT
%%#define SHOW_COMPILE_ADD_INPUT
%%#define SHOW_COMPILE_ADD_OUTPUT

#include "flora_errors.flh"
#include "flora_terms.flh"
#include "flora_porting.flh"
#include "flora_exceptions.flh"
#include "flora_status_codes.flh"
#include "flora_characters.flh"

#define NEWVAR	        	 newvar
#define NEWDONTCAREVAR	       	 newdontcarevar
#define NEWEXISTENTIALVAR      	 newexistentialvar
#define NEWCALLERVAR	       	 newcallervar
#define SKOLEMSYMVAR	       	 skolemsymvar
#define NEWUDFPREDVAR	         newudfpredvar
#define NEWPREDICATE_COUNTER   	 '_$$''''global_newpredicate_counter'
#define NEWPREDICATE_SYM       	 '_$$''''newpredicate'
#define NEWOID                   FL_NEWOID_SYM
#define RULE_NUM                 rule_num
#define DEFAULT_RULE_ID          '_$$''''default_ruleid'
#define TMPDIRECT                tmpdirect
#define NEWOID_COUNT        	 FL_NEWOID_PREFIX
#define LIBOPTION	         liboption
#define PERMAOPTION	         permaoption
#define COMPILATION_CONTEXT	 compcontext
#define DYNRULE_VARLIST          dynrule_varlist

#define BODYLITERAL         	 1
#define HEADLITERAL         	 2

%% used in an error message
#define ERRLINE_NO               ' on line '

%% ruleoid is used for numbered anonymous oid generation
:- dynamic ruleoid(_,_,_).
:- index(ruleoid/3,0).
:- dynamic LIBOPTION(_,_).
:- index(LIBOPTION/2,trie).
%% do NOT use trie indexing for PERMAOPTION. We rely on duplicates
:- dynamic PERMAOPTION(_).

%%:- dynamic TMPDIRECT(_).

:- dynamic COMPILATION_CONTEXT(_).
:- index(COMPILATION_CONTEXT/1,trie).

:- dynamic DYNRULE_VARLIST(_,_).
:- dynamic symbol(_,_,_,_,_,_,_).
:- dynamic nowarn_symbol(_,_,_,_,_).
:- dynamic symbol_warnings_flag(_).


/****************************************************************************
  utilities
****************************************************************************/
is_flrule(FLRULE(Head,Body),Head,Body).
is_flfact(FLFACT(Head),Head).
is_flquery(FLQUERY(Body),Body).
%% latent queries
is_fllatent_query(FLLATENTQUERY(Body),Body).
is_fldirective(FLDIRECTIVE(DirectList,I),DirectList,I).
is_flannotated_construct(FLANNOTATEDCONSTRUCT(Descriptor,MainPartOfRule),Descriptor,MainPartOfRule).
is_fludfunction(FLUDF(Function,Body,ReturnValue),Function,Body,ReturnValue).
is_fludfunctionfact(FLUDFFACT(Function,Value),Function,Value).
%% udfunction_struct causes flrcoder.P to record UDF definitions in the registry
%% so that we could abolish all new_udf_predicate_XXX on reloading modules. This
%% is done in flora_cleanup_udf/1, which is called from flrutils:flora_flload/2
udfunction_struct(Name,N,UDFCode,PredName,PredCode,PRUDFDEFINITION(Name,N,UDFCode,PredName,PredCode)).

is_fludfsymbol(FLUDFSYM(ParserTerm),ParserTerm).
is_flsensorsymbol(FLSENSORSYM(ParserTerm),ParserTerm).
is_flprlgsymbol(FLPRLGSYM(ParserTerm),ParserTerm).

is_fldescriptor(FLDESCRIPTOR(IdConstruct,Type,Index),IdConstruct,Type,Index).

is_flexport_list(FLEXPORT_LIST(Term),Term).
is_flexport(FLEXPORT(Term,Modules,IsUpdatable),Term,Modules,IsUpdatable).
is_flexport(FLEXPORT(DynamicModule,Term,Modules,IsUpdatable),DynamicModule,Term,Modules,IsUpdatable).

is_fldynrule(FLDYNRULE(Head,Body,DescriptorList),Head,Body,DescriptorList).

is_flopdef(FLOPDEF(P,A,O),P,A,O).
is_flprolog_directive(FLPROLOG(List,Idx),List,Idx).
is_flindex(FLINDEX(A,P),A,P).
is_fltabledirect(FLTABLE(List,Idx),List,Idx).
is_flnontabled_module(FLNONTABLEDMOD).
is_flsensordirect(FLSENSOR(SensCall,DelayCond),SensCall,DelayCond).
is_flusesensordirect(FLUSESENSOR(List,Idx),List,Idx).
is_flusefunctiondirect(FLUSEFUNCTION(List,Idx),List,Idx).
is_flsemantics(FLSEMANTICS(A),A).
is_flsetsemantics(FLSETSEMANTICS(A),A).
is_flcmpopt(FLCMPOPT(OptList),OptList).

is_flstopdelay(FLSTOPDELAY(Vars,I),Vars,I).
is_flstopdelay(FLSTOPDELAY(I),I).

is_fldefeasible(FLDEFEASIBLE(Module),Module).

is_fldefeasible_rule_default(FLDEFEASIBLE_RULE_DEFAULT).
is_flstrict_rule_default(FLSTRICT_RULE_DEFAULT).

is_verbatim(FLVERBATIM(Instruction),Instruction).
is_suppress_rulesigns(FLSUPPRESS_RULESIGNS).

is_flprefixdef(FLPREFIXDEF(PrefixName,PrefixStr),PrefixName,PrefixStr).

is_importmodule(FLIMPORTMOD(Module),Module).

is_flignoredep(FLIGNOREDEP(PredList),PredList).

is_flsymbolcontext(FLSYMBOLCONTEXT(PredList),PredList).

is_flconjunct(FLCONJUNCT(L,R),L,R).
is_fldisjunct(FLDISJUNCT(L,R),L,R).

is_flplgnaf(FLPLGNAF(Goal),Goal).
is_flrulelognaf(FLRULELOGNAF(Goal),Goal).
is_flneg(FLNEG(Goal,Idx),Goal,Idx).
is_default_negation(Term,Goal,FL_RULELOGNAF) :- is_flrulelognaf(Term,Goal), !.
is_default_negation(Term,Goal,FL_PLGNAF)  :- is_flplgnaf(Term,Goal).

is_fllogicquantifier(FLQUANTIFIER(Quant,VarNames,FormulaCode,Idx),
		     Quant,VarNames,FormulaCode,Idx).
is_fldelayquant(FLDELAYQUANTIFIER(Quant,Condition,Goal,Index),
		Quant,Condition,Goal,Index).


is_flhypothetical(FLHYPOTHETICAL(Op,Goal,Index),Op,Goal,Index).

is_flload(FLLOAD(LoadList),LoadList).

is_flconstraint(FLCONSTRAINT(ConstrBody),ConstrBody).

is_flemptyterm(FLEMPTYTERM(_Index)).

%% @module
is_flworkspace(FLWORKSPACE(P,WS),P,WS).
%% (dynrule)@module
is_flruleworkspace(FLRULEWORKSPACE(R,WS),R,WS).

detach_flworkspace(ParserTerm,ParserTermSansWS,WS) :-
	is_flworkspace(ParserTerm,ParserTermSansWS,WS),
	!.
detach_flworkspace(ParserTerm,ParserTermSansWS,WS) :-
	is_flruleworkspace(ParserTerm,ParserTermSansWS,WS),
	!.
/*
%% Not needed
detach_flworkspace(ParserTerm,ParserTermSansWS,WS) :-
	is_flneg(ParserTerm,Goal,Idx),
	!,
	detach_flworkspace(Goal,GoalSansWS,WS),
	is_flneg(ParserTermSansWS,GoalSansWS,Idx).
*/
detach_flworkspace(ParserTerm,ParserTerm,FL_THISMODULE).

%% P@_M
is_flfloralib(FLFLORALIB(P,M),P,M).
%% _M - the workspace itself
is_flfloralib(FLFLORALIB(Mod), Mod).

%% @_prolog(M) and @_prolog
is_flplib(FLPLIB(P,M),P,M).
is_flplib(FLPLIB(P),P).
flplib_struct(Goal,FLPLIB(Goal)).       %% from the parser
%% @_prologall and @_prologall(module)
%% Make sure the coder writes P2H_PREDICATE/4 as prolog
is_flpliball(FLPLIBALL(P),P) :-
	flora_define_prolog(P2H_PREDICATE,4).
is_flpliball(FLPLIBALL(P,M),P,M) :-
	flora_define_prolog(P2H_PREDICATE,4).

is_flifthenelse(FLIFTHENELSE(Cond,Then,Else),Cond,Then,Else).
is_flifthen(FLIFTHEN(Cond,Then),Cond,Then).

%% Meta ~
is_fluniveqform(FLUNIVEQFORM(Left,Right),Left,Right).
%% Meta =..
is_flmetauniv(FLMETAUNIV(Left,Right),Left,Right).
%% -->>: Prolog ->
is_flprologifthen(FLPROLOGIFTHEN(Left,Right),Left,Right).

is_reifyop(FLREIFYOP(Formula),Formula).

%% Control constructs while-do, while-loop, loop-until, do-until,unless-do
is_flcontrolconstruct(FLWHILEDO(Cond,Action),FLLIBWHILEDO,Cond,Action).
is_flcontrolconstruct(FLWHILELOOP(Cond,Action),FLLIBWHILELOOP,Cond,Action).
is_flcontrolconstruct(FLDOUNTIL(Cond,Action),FLLIBDOUNTIL,Cond,Action).
is_flcontrolconstruct(FLLOOPUNTIL(Cond,Action),FLLIBLOOPUNTIL,Cond,Action).
is_flcontrolconstruct(FLUNLESSDO(Cond,Action),FLLIBUNLESSDO,Cond,Action).

is_flterm(FLTERM(Funct,Arity,Args),Funct,Arity,Args) :-
	\+is_fltransactionalatom(Funct,_),
	\+is_fltransactionalterm(Funct,_,_,_),
	\+is_fltransactionalpredspec(Funct,_).
is_fltransactionalterm(FLTRANSACTIONALTERM(Func,N,Args),Func,N,Args) :- !.
is_fltransactionalterm(FLTERM(Term,Arity,Args),Funct,Arity,Args) :-
	is_fltransactionalpredspec(Term,Funct),
	!.
is_fltransactionalterm(FLTERM(Term,Arity,Args),Term,Arity,Args) :-
	is_fltransactionalterm(Term,_,_,_),
	!.
is_fltransactionalterm(FLTERM(F,Arity,Args),F,Arity,Args) :-
	is_fltransactionalatom(F,_).

is_flterm_or_flatom(Term,Funct,Arity,Args) :-
	is_flterm(Term,Funct,Arity,Args),
	!.
is_flterm_or_flatom(Atom,Atom,0,[]) :-
	is_flatom(Atom,_).

is_flarith(FLARITH(Expr),Expr).

is_flinsert(FLINSERT(Op,List,Cond),Op,List,Cond).
is_flinsert(FLINSERT(Op,List),Op,List).
is_fldelete(FLDELETE(Op,List,Cond),Op,List,Cond).
is_fldelete(FLDELETE(Op,List),Op,List).

is_fltablerefresh(FLREFRESH(List),List).

is_fltruthvalue(FLTRUTHVALUE(Formula,Op),Formula,Op).

is_fltag_primitive(FLTAGPRIMITIVE(Descriptor,HeadList),Descriptor,HeadList).
is_flprefixprimitive(FLPREFIXPRIMITIVE(Prefix,Expansion,Module),Prefix,Expansion,Module).

is_flclause(FLCLAUSE(Head,Body),Head,Body).
is_flclause(FLCLAUSE(Mode,Head,Body),Mode,Head,Body).
is_flannotated_clause_stmt(FLANNOTATEDCLAUSE(Descriptor,Head,Body),Descriptor,Head,Body).
is_flannotated_clause_stmt(FLANNOTATEDCLAUSE(Descriptor,Mode,Head,Body),Descriptor,Mode,Head,Body).
is_flcallmetafacts(FLCALLMETAFACTS(MF,Idx),MF,Idx).

is_flcatch(FLCATCH(Goal,Error,Handler),Goal,Error,Handler).
is_flthrow(FLTHROW(Error),Error).
is_flp2h(FLP2H(Prolog,Hilog),Prolog,Hilog).

is_flcallermodule(FLCALLERMODULE(Op,Var),Op,Var).
%% Op needed for newmodule/erasemodule only because of its position information 
is_flnewmodule(FLNEWMODULE(Op,Module),Op,Module).
is_flerasemodule(FLERASEMODULE(Op,Module),Op,Module).
is_flupdaterule(FLUPDATERULE(Op,RuleList),Op,RuleList).

is_flsimpleprimitive(FLSIMPLEPRIMITIVE(PrimName,Args),PrimName,Args).

is_flaggregate(FLAGGREGATE(Op,V,GV,Sort,Goal),Op,V,GV,Sort,Goal).

%% Binary relationship, like : or ::
is_flbirelate(FLBIRELATE(Obj1,RelType,Obj2),Obj1,RelType,Obj2).
is_flobjspec(FLOBJSPEC(Obj,Spec),Obj,Spec).
%% Represents object reference: O.M, O!M. RefType is ->, *->, ...
is_flobjref(FLOBJREF(Obj,RefType,Att),Obj,RefType,Att).

%% RefType represents the arrow type: ->, *->, ->, =>>, ...
is_flmvdattspec(FLMVDATTSPEC(Att,RefType,Val),Att,RefType,Val).
is_flsigattspec(FLSIGATTSPEC(Att,RefType,Val),Att,RefType,Val).
is_flsigattconspec(FLSIGATTCONSPEC(Att,Constr,RefType,Val),Att,Constr,RefType,Val).
is_flsigconstr(FLSIGCONSTR(Lower,Upper),Lower,Upper).
is_flincattspec(FLINCATTSPEC(Att,RefType,Val),Att,RefType,Val).
is_fltolistattspec(FLTOLISTATTSPEC(Att,RefType,Val),Att,RefType,Val).
is_flboolsig(FLBOOLSIG(Att,RefType),Att,RefType).
is_fliboolsig(FLIBOOLSIG(Att,RefType),Att,RefType).
is_fltransig(FLTRANSIG(Att,RefType),Att,RefType).
is_flitransig(FLITRANSIG(Att,RefType),Att,RefType).

is_fltranspec(FLTRANSPEC(QN),Tran) :- 
	is_fltransactionalpredspec(QN,Tran),
	!.
is_fltranspec(FLTRANSPEC(Tran),Tran) :- !.

is_fltranspec(FLMETHSPEC(Meth),Tran) :-
	is_fltransactionalpredspec(Meth,Tran),
	!.
is_fltranspec(FLMETHSPEC(QN),QN) :- 
	is_fltransactionalatom(QN,_),
	!.
is_fltranspec(FLMETHSPEC(QN),QN) :- 
	is_fltransactionalterm(QN,_,_,_),
	!.

is_flmethspec(FLMETHSPEC(Meth),Meth) :-
	\+is_fltransactionalterm(Meth,_,_,_),
	\+is_fltransactionalpredspec(Meth,_),
	\+is_fltransactionalatom(Meth,_).
is_flimethspec(FLIMETHSPEC(IMeth),IMeth).

is_fltransactionalpredspec(FLTRANSACTIONALPREDSPEC(QN),QN).

is_flobjeql(FLOBJEQL(O1,O2),O1,O2).
is_flcut(FLCUT(I),I).

%% constructs like O[X=Y], O[X>Y], O[!], O[true], O[false], are compiled as
%% X=Y, !, true, etc.
is_flpassthru(FLPASSTRU(O),O).

%% basic building blocks
is_flatom(FLATOM(Atom,_I),Atom) :- 
	\+ is_fltransactionalatom(Atom,_),
	!.
is_flatom(FLATOM(Atom,Index),Atom,Index) :- 
	\+ is_fltransactionalatom(Atom,_),
	!.
get_flatom_name(Atom,Name) :- is_flatom(Atom,Name), !.
get_flatom_name(Atom,Name) :- is_flbuiltin_identifier(Atom,Name), !.
get_flatom_name(Atom,Atom) :- atom(Atom).

is_fltransactionalatom(FLTRANSACTIONALATOM(Atom,_I),Atom).
is_flnumber(FLNUMBER(Number,_I),Number).
%% transactional numbers are used only in :- index %arity-argument
is_fltransactionalnumber(FLTRANSACTIONALNUMBER(Number,_I),Number).
is_flstring(FLSTRING(String,_I),String).
is_fltransactionalstring(FLTRANSACTIONALSTRING(String,_I),String).
is_fltoken(FLTOKEN(Token,I),Token,I).
%% this can be _#Number or _?Letter or _@!
is_fltoken(FLTOKEN(Token,Suffix,I),Token,Suffix,I).

is_fldatatype(FLDATATYPE(Sort,Literal,Index),Sort,Literal,Index).
is_fltransactionaldatatype(FLTRANSACTIONALPREDSPEC(FLDATATYPE(Sort,Literal,Index)),Sort,Literal,Index).
is_fldatatypelist(DTListVal,List) :-
        nonvar(DTListVal),
        DTListVal = FLDATATYPELIST(List).


is_flbuiltin_identifier(FLBUILTIN_IDENTIFIER(Builtin,_I),Builtin).
is_flbuiltin_identifier(FLBUILTIN_IDENTIFIER(Builtin,I),Builtin,I).

is_flvariable(FLVAR(Name,Index),Name,Index).
is_anonymous_flvariable(FLVAR(FL_ANON_VAR,I),I).
is_fltransactionalvariable(FLTRANSACTIONALVAR(Name,Index),Name,Index).
is_fllist(FLLIST(L,T,I),L,T,I).

is_fldelayedliteral(FLDELAYEDLITERAL(Op,Args),Op,Args).
is_fldelayedliteral(FLDELAYEDLITERAL(Op,Args,Mod),Op,Args,Mod).

is_isaspecop(FL_ISA).
is_subspecop(FL_SUB).
is_mvdrefop(FL_MVD).
is_imvdrefop(FL_INHERIMVD).
is_mvdspecop(FL_MVDARROW).
is_imvdspecop(FL_INMVDARROW).
is_mvdsigspecop(FL_MVDSIGARROW).
is_mvdincspecop(FL_ALLINARROW).
is_imvdincspecop(FL_INALLINARROW).
is_mvdtolistspecop(FL_TOLISTARROW).
is_imvdtolistspecop(FL_INTOLISTARROW).
is_imvdsigspecop(FL_INMVDSIGARR).


%% For postprocessing dynrules that were stuch inside insert{...} or delete{...}
is_prdynrule(PRDYNRULE(Head,Body,HVars,BVars,PreBody,PostBody,Descriptor),
	     Head,Body,HVars,BVars,PreBody,PostBody,Descriptor).

is_fltermdescriptor(FLTERMDESCRIPTOR(Funct,Arity),Funct,N) :-
	is_flnumber(Arity,N),!.
is_fltermdescriptor(FLTERMDESCRIPTOR(Funct,Arity),Funct,FL_STAR) :-
	is_anonymous_flvariable(Arity,_Idx),!.
is_fltransactionaltermdescriptor(FLTRANSACTIONALTERMDESCRIPTOR(Funct,Arity),Funct,N) :-
	is_flnumber(Arity,N),!.
is_fltransactionaltermdescriptor(FLTRANSACTIONALTERMDESCRIPTOR(Funct,Arity),Funct,FL_STAR) :-
	is_anonymous_flvariable(Arity,_Idx),!.
/****************************************************************************
  approx_flindex(+ParserTerm,-Index)

  Ideally, this procedure should always succeed with a meaningful index,
  since the input is a structure from the parser and corresponds to a
  piece of text in the program file.
****************************************************************************/
approx_flindex(FLATOM(_Atom,I),I)              :- !.
approx_flindex(FLTRANSACTIONALATOM(_Atom,I),I) :- !.
approx_flindex(FLBUILTIN_IDENTIFIER(_Id,I),I)  :- !.
approx_flindex(FLDATATYPE(_Type,_Sort,I),I)    :- !.
approx_flindex(FLNUMBER(_Number,I),I)          :- !.
approx_flindex(FLTRANSACTIONALNUMBER(_N,I),I)  :- !.
approx_flindex(FLSTRING(_String,I),I)          :- !.
approx_flindex(FLTRANSACTIONALSTRING(_S,I),I)  :- !.
approx_flindex(FLTOKEN(_Token,I),I)            :- !.
approx_flindex(FLTOKEN(_Token,_Suffix,I),I)    :- !.
approx_flindex(FLVAR(_Name,I),I)               :- !.
approx_flindex(FLTRANSACTIONALVAR(_Var,I),I)   :- !.
approx_prindex(FLLIST(List,_T,I),J)  :- !, (I>0 -> I=J; approx_flindex(List,J)).
approx_flindex(FLTERM(F,_,_),I)                :- !, approx_flindex(F,I).
approx_flindex(FLTRANSACTIONALTERM(F,_,_),I)   :- !, approx_flindex(F,I).

approx_flindex(FLBIRELATE(Obj1,_Rel,_O),I)  :- !, approx_flindex(Obj1,I).
approx_flindex(FLOBJSPEC(Obj,_Spec),I)      :- !, approx_flindex(Obj,I).
approx_flindex(FLOBJREF(Obj,_Ref,_Att),I)   :- !, approx_flindex(Obj,I).
approx_flindex(FLMETHSPEC(Meth),I)          :- !, approx_flindex(Meth,I).
approx_flindex(FLIMETHSPEC(Meth),I)         :- !, approx_flindex(Meth,I).
approx_flindex(FLTRANSPEC(Meth),I)          :- !, approx_flindex(Meth,I).
approx_flindex(FLBOOLSIG(Att,_),I)          :- !, approx_flindex(Att,I).
approx_flindex(FLIBOOLSIG(Att,_),I)         :- !, approx_flindex(Att,I).
approx_flindex(FLTRANSIG(Att,_),I)          :- !, approx_flindex(Att,I).
approx_flindex(FLITRANSIG(Att,_),I)         :- !, approx_flindex(Att,I).
approx_flindex(FLMVDATTSPEC(Att,_,_),I)     :- !, approx_flindex(Att,I).
approx_flindex(FLSIGATTSPEC(Att,_,_),I)     :- !, approx_flindex(Att,I).
approx_flindex(FLSIGATTCONSPEC(A,_,_,_),I)  :- !, approx_flindex(A,I).
approx_flindex(FLINCATTSPEC(Att,_,_),I)     :- !, approx_flindex(Att,I).
approx_flindex(FLTOLISTATTSPEC(Att,_,_),I)  :- !, approx_flindex(Att,I).
approx_flindex(FLOBJEQL(Obj,_),I)           :- !, approx_flindex(Obj,I).

approx_flindex([Obj|_],I)                   :- !, approx_flindex(Obj,I).

approx_flindex(FLIFTHEN(Cond,_Then),I)      :- !, approx_flindex(Cond,I).
approx_flindex(FLIFTHENELSE(Cond,_,_),I)    :- !, approx_flindex(Cond,I).
approx_flindex(FLWHILEDO(Cond,_),I)         :- !, approx_flindex(Cond,I).
approx_flindex(FLWHILELOOP(Cond,_),I)       :- !, approx_flindex(Cond,I).
approx_flindex(FLDOUNTIL(Cond,_),I)         :- !, approx_flindex(Cond,I).
approx_flindex(FLLOOPUNTIL(Cond,_),I)       :- !, approx_flindex(Cond,I).
approx_flindex(FLUNLESSDO(Cond,_),I)        :- !, approx_flindex(Cond,I).

approx_flindex(FLCONJUNCT(First,_),I)       :- !, approx_flindex(First,I).
approx_flindex(FLDISJUNCT(First,_),I)       :- !, approx_flindex(First,I).
approx_flindex(FLRULE(Head,_),I)            :- !, approx_flindex(Head,I).
approx_flindex(FLDYNRULE(Head,_,_),I)       :- !, approx_flindex(Head,I).
approx_flindex(FLUPDATERULE(_,Rule),I)      :- !, approx_flindex(Rule,I).
approx_flindex(FLFACT(Head),I)              :- !, approx_flindex(Head,I).
approx_flindex(FLQUERY(Body),I)             :- !, approx_flindex(Body,I).
approx_flindex(FLDIRECTIVE(_Dir,I),I)       :- !.
approx_flindex(FLTAGPRIMITIVE(Labl,_),I)    :- !, approx_flindex(Labl,I).

approx_flindex(FLANNOTATEDCLAUSE(_,_,H,_),I)   :- !, approx_flindex(H,I).
approx_flindex(FLANNOTATEDCLAUSE(_,H,_),I)     :- !, approx_flindex(H,I).
approx_flindex(FLCLAUSE(_,Head,_),I)        :- !, approx_flindex(Head,I).
approx_flindex(FLCLAUSE(Head,_),I)          :- !, approx_flindex(Head,I).
approx_flindex(FLUNIVEQFORM(Left,_),I)      :- !, approx_flindex(Left,I).
approx_flindex(FLMETAUNIV(Left,_),I)        :- !, approx_flindex(Left,I).
approx_flindex(FLAGGREGATE(Op,_,_,_),I)     :- !, approx_flindex(Op,I).
approx_flindex(FLCONSTRAINT(C),I)           :- !, approx_flindex(C,I).
approx_flindex(FLANNOTATEDCONSTRUCT(Descr,_),I)  :- !, approx_flindex(Descr,I).
approx_flindex(FLDESCRIPTOR(_,_,I),I)       :- !.
approx_flindex(FLCALLMETAFACTS(_,I),I)      :- !.

approx_flindex(FLREIFYOP(Form),I)             :- !, approx_flindex(Form,I).
approx_flindex(FLTRUTHVALUE(Form,_),I)        :- !, approx_flindex(Form,I).
approx_flindex(FLPLIB(P,_M),I)                :- !, approx_flindex(P,I).
approx_flindex(FLPLIB(P),I)                   :- !, approx_flindex(P,I).
approx_flindex(FLPLIBALL(P,_M),I)             :- !, approx_flindex(P,I).
approx_flindex(FLPLIBALL(P),I)                :- !, approx_flindex(P,I).
approx_flindex(FLFLORALIB(P,_M),I)            :- !, approx_flindex(P,I).
approx_flindex(FLWORKSPACE(P,_WS),I)          :- !, approx_flindex(P,I).
approx_flindex(FLCONSTRAINT(C),I)             :- !, approx_flindex(C,I).

approx_flindex(FLLATENTQUERY(C),I)            :- !, approx_flindex(C,I).

approx_flindex(FLUDF(Fun,_,_),I)              :- !, approx_flindex(Fun,I).
approx_flindex(FLUDFFACT(Fun,_),I)            :- !, approx_flindex(Fun,I).

approx_flindex(FLINSERT(Op,_List,_Cond),I)    :- !, approx_flindex(Op,I).
approx_flindex(FLINSERT(Op,_List),I)          :- !, approx_flindex(Op,I).
approx_flindex(FLDELETE(Op,_List,_Cond),I)    :- !, approx_flindex(Op,I).
approx_flindex(FLDELETE(Op,_List),I)          :- !, approx_flindex(Op,I).

approx_flindex(FLLOAD(List),I)                :- !, approx_flindex(List,I).

approx_flindex(FLDELAYEDLITERAL(Op,_),I)      :- !, approx_flindex(Op,I).
approx_flindex(FLDELAYEDLITERAL(Op,_,_),I)    :- !, approx_flindex(Op,I).
approx_flindex(FLRULELOGNAF(G),I)             :- !, approx_flindex(G,I).
approx_flindex(FLPLGNAF(G),I)                 :- !, approx_flindex(G,I).
approx_flindex(FLNEG(_G,I),I)                 :- !.
approx_flindex(FLQUANTIFIER(_Quant,_,_,I),I)  :- !.
approx_flindex(_,NO_INDEX)  :- !.


/****************************************************************************
  approx_prindex(+ParserTerm,-Index)

  Same as approx_flindex, but for compiled code

  Ideally, this procedure should always succeed with a meaningful index,
  since the input is a structure from the parser and corresponds to a
  piece of text in the program file.
****************************************************************************/
approx_prindex(PRATOM(_Atom,I),I)                  :- !.
approx_prindex(PRATOMLIT(_Atom,I),I)               :- !.
approx_prindex(PRTRANSACTIONALATOMLIT(_Atom,I),I)  :- !.
approx_prindex(PRBUILTIN_IDENTIFIER(_Id,I),I)      :- !.
approx_prindex(PRNUMBER(_Number,I),I)              :- !.
approx_prindex(PRTRANSACTIONALNUMBER(_N,I),I)      :- !.
approx_prindex(PRSTRING(_String,I),I)              :- !.
approx_prindex(PRVARIABLE(_Name,I),I)              :- !.
approx_prindex(PRTRANSACTIONALVARIABLE(_Var,I),I)  :- !.
approx_prindex(PRLIST(List,_T,I),J)  :- !, (I>0 -> I=J; approx_prindex(List,J)).
approx_prindex(PRNEWOID(_,I),I)                    :- !.
approx_prindex(PRCUT(I),I)                         :- !.
approx_prindex(PRMODULARIZEDATOM(_Form,I),I)       :- !.
approx_prindex(PRMODULARIZEDATOM(_Form,_,I),I)     :- !.

approx_prindex(PRDATATYPE(_Type,_Sort,I),I)        :- !.
approx_prindex(PRDATATYPELIST(Lit),I)              :- !, approx_prindex(Lit,I).

approx_prindex(PRTERM(F,_,_),I)                    :- !, approx_prindex(F,I).
approx_prindex(PRTERMLIT(F,_,_),I)                 :- !, approx_prindex(F,I).
approx_prindex(PRTRANSACTIONALTERMLIT(F,_,_),I)    :- !, approx_prindex(F,I).

approx_prindex(PRISA(Obj,_,_),I)              :- !, approx_prindex(Obj,I).
approx_prindex(PRSUB(Obj,_,_),I)              :- !, approx_prindex(Obj,I).
approx_prindex(PREXISTS(Obj,_),I)             :- !, approx_prindex(Obj,I).
approx_prindex(PRMVD(Obj,_,_,_),I)            :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVD(Obj,_,_,_),I)           :- !, approx_prindex(Obj,I).
approx_prindex(PRMVDDEF(Obj,_,_),I)           :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVDDEF(Obj,_,_),I)          :- !, approx_prindex(Obj,I).
approx_prindex(PRMVDSIG(Obj,_,_,_),I)         :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVDSIG(Obj,_,_,_),I)        :- !, approx_prindex(Obj,I).
approx_prindex(PRMVDSIGDEF(Obj,_,_),I)        :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVDSIGDEF(Obj,_,_),I)       :- !, approx_prindex(Obj,I).
approx_prindex(PRMVDCON(Obj,_,_,_,_),I)       :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVDCON(Obj,_,_,_,_),I)      :- !, approx_prindex(Obj,I).
approx_prindex(PRMVDCONDEF(Obj,_,_,_,_,_),I)  :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVDCONDEF(Obj,_,_,_,_,_),I) :- !, approx_prindex(Obj,I).
approx_prindex(PRMVDTOLIST(Obj,_,_,_),I)      :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVDTOLIST(Obj,_,_,_),I)     :- !, approx_prindex(Obj,I).
approx_prindex(PRMVDINC(Obj,_,_,_),I)         :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVDINC(Obj,_,_,_),I)        :- !, approx_prindex(Obj,I).
approx_prindex(PRMETH(Meth,_,_),I)            :- !, approx_prindex(Meth,I).
approx_prindex(PRIMETH(Meth,_,_),I)           :- !, approx_prindex(Meth,I).
approx_prindex(PRTRAN(Meth,_,_),I)            :- !, approx_prindex(Meth,I).
approx_prindex(PRBOOLSIG(Att,_,_),I)          :- !, approx_prindex(Att,I).
approx_prindex(PRIBOOLSIG(Att,_,_),I)         :- !, approx_prindex(Att,I).
approx_prindex(PRTRANSIG(Att,_,_),I)          :- !, approx_prindex(Att,I).
approx_prindex(PRITRANSIG(Att,_,_),I)         :- !, approx_prindex(Att,I).
approx_prindex(PROBJEQL(Obj,_,_),I)           :- !, approx_prindex(Obj,I).

approx_prindex([Obj|_],I)                     :- !, approx_prindex(Obj,I).

approx_prindex(PRAND(First,Second),I)         :- !,
	(approx_prindex(First,I), I \= NO_INDEX
	-> true
	; approx_prindex(Second,I)).
approx_prindex(PROR(First,Second),I)          :- !,
	(approx_prindex(First,I), I \= NO_INDEX
	-> true
	; approx_prindex(Second,I)).
approx_prindex(PRRULE(Head,_),I)              :- !, approx_prindex(Head,I).
approx_prindex(PRDYNRULE(Head,_,_,_,_,_),I)   :- !, approx_prindex(Head,I).
approx_prindex(PRFACT(Head),I)                :- !, approx_prindex(Head,I).
approx_prindex(PRREIFY(F),I)                  :- !, approx_prindex(F,I).
approx_prindex(PRQUERY(Body),I)               :- !, approx_prindex(Body,I).
approx_prindex(PRDIRECTIVE(Direct),I)         :- !, approx_prindex(Direct,I).
approx_prindex(PRCONSTRAINT(C),I)             :- !, approx_prindex(C,I).

approx_prindex(FLORASYSLIB(NO_INDEX,_,_,Args),I) :- !, approx_prindex(Args,I).
approx_prindex(FLORASYSLIB(Idx,_,_,_),Idx)       :- !.

approx_prindex(PROLOGTERM(F,_,_),I)           :- !, approx_prindex(F,I).
approx_prindex(PROLOGTERM(F,_,_,_),I)         :- !, approx_prindex(F,I).
approx_prindex(PROLOGLIBLIT(P),I)             :- !, approx_prindex(P,I).
approx_prindex(PRFLORALIB(P),I)               :- !, approx_prindex(P,I).
approx_prindex(PRFDBSTORAGE(P),I)             :- !, approx_prindex(P,I).
approx_prindex(PRWORKSPACE(P,_WS),I)          :- !, approx_prindex(P,I).
approx_prindex(PRWORKSPACETERM(WS),I)         :- !, approx_prindex(WS,I).

approx_prindex(PRRULELOGNAF(G),I)             :- !, approx_prindex(G,I).
approx_prindex(PRPLGNAF(G),I)                 :- !, approx_prindex(G,I).
approx_prindex(PRNEG(G),I)                    :- !, approx_prindex(G,I).
approx_prindex(PRQUANTIFIER(Form,_,_),I)      :- !, approx_prindex(Form,I).


/****************************************************************************
  encoding utilities
****************************************************************************/
rule_struct(Head,Body,PRRULE(Head,Body)).
fact_struct(Head,PRFACT(Head)).
query_struct(Goal,PRQUERY(Goal)).
directive_struct(Direct,PRDIRECTIVE(Direct)).

%% Descriptor is a tripple: (DescrIdCode,DescrVarsTerm,MetaFactDiffList,DefeatConditionCode)
dynrule_struct(Head,Body,HVars,BVars,PreBody,PostBody,Descriptor,PRDYNRULE(Head,Body,HVars,BVars,PreBody,PostBody,Descriptor)) :-
	report_option(FLSYSLIB(FLLIBINSERTRULE_A),NO_INDEX).

reify_struct(Formula,PRREIFY(Formula)) :-
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX).

%% We use this import directive support mechanism for @_prolog(module)
%%import_struct(F,N,M,PRIMPORT(F,N,M)).
cmpopt_struct(OptList,PRCMPOPT(OptList)).
ignoredep_struct(SpecList,PRIGNOREDEP(SpecList)).

%%empty module list, all modules allowed
export_struct(TermList,Code) :-
	florasyslib_struct(_Index,FLLIBEXPORT,_N,[TermList],Code).

%% :- importmodule foo.
importmodule_struct(Module,PRIMPORTMOD(Module)).

defeasible_struct(Module,PRDEFEASIBLE(Module)).

verbatim_struct(Instruction,PRVERBATIM(Instruction)).
table_directive_struct(SpecList,PRTABLE(SpecList)).


is_prconjunct(PRAND(L,R),L,R).
is_prdisjunct(PROR(L,R),L,R).

/****************************************************************************
  conjunct_struct(+Goal1,+Goal2,-Code)
  disjunct_struct(+Goal1,+Goal2,-Code)
  naf_struct_prolog(+Goal,-Code)
  naf_struct_flora(+Goal,-Code)
  neg_struct(+Goal,+Idx,-Code,-Status)
  head_neg_struct(+Goal,+Idx,-Code,-Status)
****************************************************************************/
conjunct_struct(Goal1,Goal2,Goal2) :-
	%% NULL and FL_TRUE are both dummy code that is ignored
	(Goal1 == NULL ; Goal1 == FL_TRUE),
	!.
conjunct_struct(Goal1,Goal2,Goal1) :-
	(Goal2 == NULL ; Goal2 == FL_TRUE),
	!.
conjunct_struct(Goal1,Goal2,PRAND(Goal1,Goal2)).

disjunct_struct(Goal1,Goal2,PROR(Goal1,Goal2)).

quantifier_struct(QuantifierType,FormCode,FreVarObjs,
		  PRQUANTIFIER(QuantifierType,FormCode,FreVarObjs)).
is_prquantifier(PRQUANTIFIER(QuantifierType,FormCode,FreVarObjs),
		QuantifierType,FormCode,FreVarObjs).

%% \+
naf_struct_prolog(Goal,PRPLGNAF(Goal)).
%% naf
pure_naf_struct_flora(Goal,FreeVars,PRRULELOGNAF(WrappedGoal,FreeVars,Line,CurrFileName)) :-
	code_line_and_file_by_prterm(Goal,Line,CurrFileName),
	modularized_pratom_struct(FL_TABLED_UNNUMBER_CALL,NO_INDEX,FunCode),
	prologterm_struct(FunCode,1,[Goal],WrappedGoal).
%% We can optimize this by passing free variables list. If the list is empty,
%% we won't delay
naf_struct_flora(Goal,FreeVars,Code) :-
	pure_naf_struct_flora(Goal,FreeVars,PureNAFcode),
	%% delay default negation
	delay_naf_struct(PureNAFcode,Code).

%% delay struct
delay_struct(Index,DelayOp,Args,Code) :-
	code_line_and_file_by_index(Index,Line,CurrFileName),
	list_struct(Args,[],CodeList),
	%% this never gives out errors, so no need for file/nline args
	prologterm_struct(FLLIBDELAYEDLITERAL,4,
			  [DelayOp,CurrFileName,Line,CodeList],
			  Code).

delay_defeat_struct(Index,DefeatCond,Headvars,HeadvarNames,DynHead,Code) :-
	code_line_and_file_by_index(Index,Line,CurrFileName),
	prologterm_struct(FLLIBDEFEATDELAY,6,
			  [CurrFileName,Line,
			   DefeatCond,DynHead,
			   Headvars,HeadvarNames],
			  Code).

delay_naf_struct(PureNAFcode,Code) :-
	prologterm_struct(FLLIBNAFDELAY,1,[PureNAFcode],
			  Code).

neg_struct(PRAND(Goal1,Goal2),Idx,PRAND(Goal1,Struct2),Status) :-
	is_body_neg_passthrough_literal(Goal1),
	!,
	neg_struct(Goal2,Idx,Struct2,Status).

neg_struct(PRAND(Goal1,Goal2),Idx,PRAND(Struct1,Goal2),Status) :-
	is_body_neg_passthrough_literal(Goal2),
	!,
	neg_struct(Goal1,Idx,Struct1,Status).

%% unlike naf, neg can appear in the head
neg_struct(PRAND(Goal1,Goal2),Idx,PROR(Struct1,Struct2),Status) :-
	neg_struct(Goal1,Idx,Struct1,S),
	( no_errors_found(S) -> 
	   neg_struct(Goal2,Idx,Struct2,Status)
	;  Status = S
	).
neg_struct(PROR(Goal1,Goal2),Idx,PRAND(Struct1,Struct2),Status) :-
	neg_struct(Goal1,Idx,Struct1,S),
	( no_errors_found(S) -> 
	   neg_struct(Goal2,Idx,Struct2,Status)
	;  Status = S
	).
%% double negation
neg_struct(PRNEG(Goal),_Idx,Goal,[]) :- !.

/*
neg_struct(Goal,Idx,_,[Err]) :-
	is_unimplemented_neg_negatable_literal(Goal),
	!,
	compiling_error(Idx,UNIMPLEMENTED_NEG,Err).
*/
neg_struct(Goal,Idx,_,[Err]) :-
	\+is_body_neg_negatable_literal(Goal),
	!,
	compiling_error(Idx,ILLEGAL_NEGBODY,Err).

%% :- prolog predicate: workspaced and not
neg_struct(Goal,_Idx,Code,[]) :-
	(  workspace_struct(L,WS,Goal),
	    is_prologterm(L,Struct,Arity,Args),
	    is_modularized_pratom(Struct,Atom,Idx),
	    (is_pratom(WS,Mod,_) ; is_prbuiltin_identifier(WS,Mod,_))
	->
	    %% to check if this is a negatable prolog, reduce arity by 1:
	    %% modularized prolog has one extra caller argument
	    Arity1 is Arity-1,
	    flora_negatable_prlgdef(Atom,Arity1,NegAtm),
	    modularized_pratom_struct(NegAtm,Mod,Idx,FCode),
	    prologterm_struct(FCode,Arity,Args,Code)
	; is_prologterm(Goal,Struct,Arity,Args),
	    is_modularized_pratom(Struct,Atom,Idx)
	->
	    %% to check if this is a negatable prolog, reduce arity by 1:
	    %% modularized prolog has one extra caller argument
	    Arity1 is Arity-1,
	    flora_negatable_prlgdef(Atom,Arity1,NegAtm),
	    modularized_pratom_struct(NegAtm,Idx,FCode),
	    prologterm_struct(FCode,Arity,Args,Code)
	).

neg_struct(Goal,_Idx,Code,[]) :-
	(workspace_struct(PRNEG(L),WS,Goal)
	-> workspace_struct(L,WS,Code) % double negation
	;  workspace_struct(L,WS,Goal)
	-> workspace_struct(PRNEG(L),WS,Code)
	; is_florasyslib_struct(Goal,Idx,FLLIBMODLIT,N,Args)
	-> florasyslib_struct(Idx,FLNEGLIBMODLIT,N,Args,Code)
	; is_florasyslib_struct(Goal,Idx,FLLIBMODOBJ,N,Args)
	-> florasyslib_struct(Idx,FLNEGLIBMODOBJ,N,Args,Code)
	; is_florasyslib_struct(Goal,Idx,FLNEGLIBMODLIT,N,Args)
	-> florasyslib_struct(Idx,FLLIBMODLIT,N,Args,Code)
	; is_prvariable(Goal,_VarName,Idx),
	    has_context(goal_reification)
	-> % When variable is negated under ~, as in ?X ~ neg ?Y.
	    thismodule_struct(ThisModule),
	    body_caller_info_structure(ThisModule,CallerInfo),
	    %% ...:-...,neg ?X, is compiled into
	    %%    FLLIBMODLIT(neg_libmod_wrapper,X,FL_INVALIDMODULE,CallerInfo)
	    atomobj_struct(FL_INVALIDMODULE,Mod),
	    florasyslib_struct(Idx,FLNEGLIBMODLIT,3,[Goal,Mod,CallerInfo],Code)
	;   Code = PRNEG(Goal)
	).

%% double negation
head_neg_struct(PRNEG(Goal),_Idx,Goal,[]) :- !.

head_neg_struct(Goal,Idx,Code,Status) :-
	%% Normally Goal is a single literal. It can also be a conjunction
	%% where the second conjunct is a cardinality constraint in a signature.
	%% In the latter case, the constraint is ignored.
	%% Any other conjunction is an error.
	conjunct_struct(Goal1,Goal2,Goal),
	ignorable_negated_head_conjunct(Goal2),
	!,
	head_neg_struct(Goal1,Idx,Code,Status).
	
head_neg_struct(Goal,Idx,Code,Status) :-
	workspace_struct(L,WS,Goal),
	!,
	head_neg_struct(L,Idx,Code1,Status),
	( no_errors_found(Status) -> workspace_struct(Code1,WS,Code)
	;
	    true
	).

head_neg_struct(Goal,_Idx,NegGoal,[]) :-
	is_prologterm(Goal,Struct,Arity,Args),
	is_modularized_pratom(Struct,Atom,Idx),
	%% to check if this is a negatable prolog, reduce arity by 1:
	%% modularized prolog has one extra caller argument
	Arity1 is Arity-1,
	flora_negatable_prlgdef(Atom,Arity1,NegAtm),
	modularized_pratom_struct(NegAtm,Idx,FCode),
	prologterm_struct(FCode,Arity,Args,NegGoal),
	!.
head_neg_struct(Goal,_Idx,PRNEG(Goal),[]) :-
	is_head_neg_negatable_literal(Goal),
	!.

head_neg_struct(Goal,Idx,Code,[]) :-
	is_prvariable(Goal,_VarName,_Idx),
	!,
	%% When variable is neg-negated (inside an update op)
	head_caller_info_structure(CallerInfo),
	atomobj_struct(FL_INVALIDMODULE,Mod),
	florasyslib_struct(Idx,FLNEGLIBMODLIT,3,[Goal,Mod,CallerInfo],Code).

head_neg_struct(Goal,_Idx,Code,[]) :-
	is_florasyslib_struct(Goal,Idx,FLNEGLIBMODLIT,N,Args),
	!,
	florasyslib_struct(Idx,FLLIBMODLIT,N,Args,Code).

head_neg_struct(_Goal,Idx,_Code,[Err]) :-
	compiling_error(Idx,ILLEGAL_NEGHEAD,Err).


ignorable_negated_head_conjunct(Goal) :-
	(is_prmvdcondef(Goal) ; is_primvdcondef(Goal)),
	!.
ignorable_negated_head_conjunct(Goal) :-
	workspace_struct(L,_WS,Goal),
	ignorable_negated_head_conjunct(L).


/****************************************************************************
  conjunct_code(+GoalList,-Code)

  Takes a list of goals and constructs a conjunct:
        prand(G1, prand(G2, G3))
  Discards NULLs
  If all are NULLs, returns NULL.
****************************************************************************/
conjunct_code([],Goal) :-
	!,
	generate_prolog_liblit(FL_TRUE,0,[],Goal).
conjunct_code([Goal],Goal) :- !.

%% DON't include the case FL_TRUE here!
conjunct_code([NULL|GList],ConjGoal) :- !, conjunct_code(GList,ConjGoal).

conjunct_code([Goal|GList],ConjGoal) :-
	conjunct_code(GList,ConjGoalTail),
	!,
	( ConjGoalTail == NULL -> ConjGoal=Goal
	%% DON't include the case FL_TRUE here!
	;
	  conjunct_struct(Goal,ConjGoalTail,ConjGoal)
	).


/****************************************************************************
  encoding routines

  Note: Only primitive structures (atoms, variables, numbers, strings, lists,
        newoids, and cuts) encode the index to the corresponding textual
        information. The compiler directives do not encode any textual
        information. However, not all primitive structures have a meaningful
        index, for instance, new variables that are generated for an oid
        reference. In this case, an index is approximated. In some other
        cases, an atom is generated to encode an internal structure. So there
        is no meaningful index. Then the macro NO_INDEX is encoded as a
        place holder. No textual information should be inferred from the
        NO_INDEX value.
****************************************************************************/
%% atomobj_struct/2
atomobj_struct(FLATOM(Atm,I),PRATOM(Atm,I)) :- !.
atomobj_struct(FLBUILTIN_IDENTIFIER(Atm,I),PRATOM(Atm,I)) :- !.
%%atomobj_struct(FLMODULARIZEDATOM(Atm,I),PRMODULARIZEDATOM(Atm,I)) :- !.
atomobj_struct(Atm,PRATOM(Atm,NO_INDEX)) :- atomic(Atm).
%% atomobj_struct/3
atomobj_struct(Atm,Index,PRATOM(Atm,Index)).

%% A prolog atom that has FLORA-2 prefix and workspace in it.
%% This one is for THIS_WORKSPACE
modularized_pratom_struct(Atom,Idx,PRMODULARIZEDATOM(Atom,Idx)).
%%  Mod is expected to be an atom
modularized_pratom_struct(Atom,Mod,Idx,PRMODULARIZEDATOM(Atom,Mod,Idx)).

%%modularized_flatom_struct(Atom,Idx,FLMODULARIZEDATOM(Atom,Idx)).

is_modularized_pratom(PRMODULARIZEDATOM(Atom,Idx),Atom,Idx) :- !.
is_modularized_pratom(PRMODULARIZEDATOM(Atom,_Mod,Idx),Atom,Idx) :- !.

%%is_modularized_flatom(FLMODULARIZEDATOM(Atom,Idx),Atom,Idx).

scrambled_atom_struct(Atom,Idx,Struct) :-
	flora_scramble_atom(Atom,ScrambledA),
	atomobj_struct(ScrambledA,Idx,Struct).

transactionalatomobj_struct(FLTRANSACTIONALATOM(Atom,I),PRATOM(Atom,I)) :- !.


atomlit_struct(_Context,FLATOM(Atom,I),Code) :-
	flora_prlgdef(Atom,0),
	!,
	atomobj_struct(Atom,I,AtomCode),
	prologterm_struct(AtomCode,0,[],Code).
atomlit_struct(Context,FLATOM(Atom,I),Code) :-
	flora_modular_prlgdef(Atom,0),
	!,
	splice_in_caller_argument(Context,[],Args),
	modularized_pratom_struct(Atom,I,FunCode),
	prologterm_struct(FunCode,1,Args,Code).
atomlit_struct(_Context,FLATOM(Atom,I),Code) :-
	flora_prlgdef(Atom,0,Mod),
	!,
	atomobj_struct(Atom,I,AtomCode),
	prologterm_struct(AtomCode,0,[],Mod,Code).
atomlit_struct(_Context,FLATOM(Atom,I),Code) :-
	flora_prlgdef_repl(Atom,0,ReplacementAtm,Mod),
	!,
	atomobj_struct(ReplacementAtm,I,AtomCode),
	prologterm_struct(AtomCode,0,[],Mod,Code).
atomlit_struct(_Context,FLBUILTIN_IDENTIFIER(Atom,I),Code) :-
	flora_prlgdef(Atom,0),
	!,
	builtin_identifier_struct(FLBUILTIN_IDENTIFIER(Atom,I),AtomCode),
	prologterm_struct(AtomCode,0,[],Code).
atomlit_struct(Context,FLBUILTIN_IDENTIFIER(Atom,I),Code) :-
	flora_modular_prlgdef(Atom,0),
	!,
	splice_in_caller_argument(Context,[],Args),
	modularized_pratom_struct(Atom,I,FunCode),
	prologterm_struct(FunCode,1,Args,Code).
atomlit_struct(_Context,FLBUILTIN_IDENTIFIER(Atom,I),Code) :-
	flora_prlgdef(Atom,0,Mod),
	!,
	builtin_identifier_struct(FLBUILTIN_IDENTIFIER(Atom,I),AtomCode),
	prologterm_struct(AtomCode,0,[],Mod,Code).
atomlit_struct(_Context,FLBUILTIN_IDENTIFIER(Atom,I),Code) :-
	flora_prlgdef_repl(Atom,0,ReplacementAtm,Mod),
	!,
	builtin_identifier_struct(FLBUILTIN_IDENTIFIER(ReplacementAtm,I),AtomCode),
	prologterm_struct(AtomCode,0,[],Mod,Code).
atomlit_struct(Context,FLATOM(Atom,I),PRATOMLIT([Atom,Caller],I)) :-
	!,
	determine_caller_info(Context,Caller).
atomlit_struct(Context,FLBUILTIN_IDENTIFIER(Atom,I),PRATOMLIT([Atom,Caller],I)) :-
	!,
	determine_caller_info(Context,Caller).
%% This is for the cases of an atomic literal like "abcd"^^foo
atomlit_struct(Context,Atomspec,PRATOMLIT([Atomspec,Caller],Idx)) :-
	is_prdatatype(Atomspec,_,_,Idx),
	determine_caller_info(Context,Caller).

transactionalatomlit_struct(Context,FLTRANSACTIONALATOM(Atom,I),PRTRANSACTIONALATOMLIT([Atom,Caller],I)) :-
	!,
	determine_caller_info(Context,Caller).
%% This is for the case of an atomic literal like %"abcd"^^foo
transactionalatomlit_struct(Context,Atomspec,PRTRANSACTIONALATOMLIT([Atomspec,Caller],Idx)) :-
	is_prdatatype(Atomspec,_,_,Idx),
	determine_caller_info(Context,Caller).

numobj_struct(FLNUMBER(Number,I),PRNUMBER(Number,I)) :- !.
numobj_struct(Number,PRNUMBER(Number,NO_INDEX)) :- number(Number).
numobj_struct(Number,Idx,PRNUMBER(Number,Idx)) :- number(Number).

%% transactional numbers are used only in :- index %arity-argument
transactionalnumobj_struct(FLTRANSACTIONALNUMBER(Number,I),PRTRANSACTIONALNUMBER(Number,I)).

%% decompile prvar to flvar
prvar_to_flvar_struct(PRVARIABLE(Name,Index),FLVAR(Name,Index)).
%% decompile prvar list  to flvar list 
prvar_to_flvar_struct_list([], []) :- !.
prvar_to_flvar_struct_list([Var|Rest], [FlVar|FlRest]) :-
	prvar_to_flvar_struct(Var,FlVar),
	prvar_to_flvar_struct_list(Rest,FlRest).

flvar_struct_change_index(FLVAR(Name,_Index),FlIndex,FLVAR(Name,FlIndex)).

varobj_struct(FLVAR(Name,Index),PRVARIABLE(Name,Index)) :- !.
varobj_struct(Name,PRVARIABLE(Name,NO_INDEX)).
varobj_struct(Name,Index,PRVARIABLE(Name,Index)).

transactionalvar_struct(Name,Index,PRTRANSACTIONALVARIABLE(Name,Index)).

strobj_struct(FLSTRING(String,I),PRSTRING(String,I)).
transactionalstrobj_struct(FLTRANSACTIONALSTRING(String,I),PRSTRING(String,I)).

datatypeobj_struct(FLDATATYPE(Type,Lit,Idx),
		   PRDATATYPE(TypeCode,LitCode,OutIdx),
		   Status) :-
	!,
	compile_body_pathexp(Type,FL_THISMODULE,TypeCode,_,_,[],_),
	(is_flvariable(Lit,VarName,VarIdx)
	->  add_underscore(VarName,InDataTypeVarName),
	    varobj_struct(InDataTypeVarName,VarIdx,LitCode),
	    OutIdx = VarIdx, Status = NO_ERRORS
	; is_fldatatypelist(Lit,ListOfLits)
	-> compile_datatype_list(ListOfLits,LitCode0,Status),
	    datatypelistobj_struct(LitCode0,LitCode),
	    OutIdx=Idx
	;
	    LitCode = Lit, OutIdx=Idx, Status = NO_ERRORS
	).
datatypeobj_struct(FLTRANSACTIONALPREDSPEC(DTspec),Code,Status) :-
	!,
	datatypeobj_struct(DTspec,Code,Status).

datatypelistobj_struct(ListLit,PRDATATYPELIST(ListLit)).


builtin_identifier_struct(FLBUILTIN_IDENTIFIER(Builtin,I),
			  PRBUILTIN_IDENTIFIER(Builtin,I)).

newoid_struct(Oid,Index,PRNEWOID(Oid,Index)).
cut_struct(Index,PRCUT(Index)).
special_variable_struct(Type,PRSPECIALVAR(Type)).

list_struct(List,Term,Index,PRLIST(List,Term,Index)).
list_struct(List,Term,PRLIST(List,Term,NO_INDEX)).

workspace_struct(P,WS,PRWORKSPACE(P,WS)).
is_prworkspace(PRWORKSPACE(P,WS),P,WS).
newpredicate_struct(Name,N,Args,PRNEWPRED(Name,N,Args)).
thismodule_struct(PRTHISMODULE(PRTHISMODULE)).

%% TODO: check if we actually need to wrap this with PRWORKSPACETERM
workspaceterm_struct(WS,PRWORKSPACETERM(WSTerm)) :-
	compile_workspace_term(WS,WSTerm).

%% Compiles both user and system workspace terms
compile_workspace_term(WS, CompiledWS) :-
	(is_flatom(WS,_Atom,_I) -> atomobj_struct(WS,CompiledWS)
	; is_flvariable(WS,_Var,_I) -> varobj_struct(WS,CompiledWS)
	; is_fltoken(WS,FL_THISMODULE,_) -> thismodule_struct(CompiledWS)
	; WS == FL_THISMODULE -> thismodule_struct(CompiledWS)
	; is_flfloralib(WS,Mod) -> 
	    compile_workspace_term(Mod,WS1),
	    floralib_struct(WS1, CompiledWS) 
	; %% WS may come already compiled as a system workspace or as a var
	    (floralib_struct(_, WS) ; is_prvariable(WS))
	-> WS = CompiledWS
	; flora_error_line('[Compiler] BUG: Invalid workspace term, ~w', [WS]),
	    throw(FLORA_TOP_LEVEL)
	),
	!.

%% For dynamic rules - workspace of the rule: (rule)@WS
%% Otherwise - current module.
%% Used in rule BODIES
%% Used only in determine_caller_info/2
body_caller_info_structure(CallerInfo) :-
	has_context(dynruleworkspace(WSTerm)),
	!,
	body_caller_info_structure(WSTerm,CallerInfo).
body_caller_info_structure(CallerInfo) :-
	has_context(goal_reification),
	\+ has_context(rule_reification),
	!,
	new_caller_prvariable(NO_INDEX,WSTerm),
	%% with this, reification in the head doesn't unify with the body
	%%thismodule_struct(WSTerm), 
	body_caller_info_structure(WSTerm,CallerInfo).
body_caller_info_structure(CallerInfo) :-
	thismodule_struct(WSTerm),
	!,
	body_caller_info_structure(WSTerm,CallerInfo).

body_caller_info_structure(CalleModule,CallerInfo) :-
	caller_tracing_code(body,TracingCode),
	list_struct([CalleModule,TracingCode],[],CallerInfo).


%% Represents the special variable, which appears in the rule HEAD, that is
%% bound to the caller name 
head_caller_info_structure(Caller) :-
	%% In the head of dynamic rules
	has_context(compiling_dynrule(_)),
	!,
	dyn_caller_var_struct(CallerStruct),
	caller_tracing_code(head,TracingCode),
	list_struct([CallerStruct,TracingCode], [], Caller).
%% In the HEAD of static rules
head_caller_info_structure(Caller) :-
	callermod_var_structure(CallerStruct),
	caller_tracing_code(head,TracingCode),
	list_struct([CallerStruct,TracingCode], [], Caller).

%% This is used when we want variables in the tracing part of the caller info
var_caller_info_structure(CalleModule,CallerInfo) :-
	caller_tracing_code(vars,TracingCode),
	list_struct([CalleModule,TracingCode],[],CallerInfo).

callermod_var_structure(Struct) :-
	%% In the head of dynamic rules
	has_context(compiling_dynrule(_)),
	!,
	dyn_caller_var_struct(Struct).
%% In the head of static rules
callermod_var_structure(Struct) :- caller_var_struct(Struct).

caller_var_struct(PRCALLERVAR(PRCALLERVAR)).
dyn_caller_var_struct(PRDYNCALLERVAR(PRDYNCALLERVAR)).
filename_in_ruleid_struct(PRFILENAMEINRULEIDVAR(PRFILENAMEINRULEIDVAR)).

%% Context =  head/body/vars
caller_tracing_code(Context,TracingCode) :-
	(has_permaoption(no_trace_info) ->
	    new_caller_prvariable(NO_INDEX,TracingCode)
	%% next line tests what happens if we have no variables in tracing into
	%%; true -> atomobj_struct(dummy,TracingCode)
	;
	    ( has_context(compiling_dynrule(DescrIdCode)), Context\==vars,
		\+ has_context(goal_reification),
		\+ has_context(compiling_update_literals)
	    ; has_context(compiling_rule(DescrIdCode)), Context\==vars,
		\+ has_context(goal_reification),
		\+ has_context(compiling_update_literals)
	    ; %% Context = vars or is not a (rule, reification, or update)
		new_caller_prvariable(NO_INDEX,DescrIdCode)
	    ),
	    !,
	    atomobj_struct(FL_TRACING,TraceFunCode),
	    new_caller_prvariable(NO_INDEX,CalledRuleVar),
	    (Context == body ->
		prologterm_struct(TraceFunCode,2,[CalledRuleVar,DescrIdCode],TracingCode)
	    ;
		prologterm_struct(TraceFunCode,2,[DescrIdCode,CalledRuleVar],TracingCode)
	    )
	).


thisstorage_struct(fdb,PRTHISFDBSTORAGE(PRTHISFDBSTORAGE)).
%% support for checking undefinedness
thisstorage_struct(fld,PRTHISFLDSTORAGE(PRTHISFLDSTORAGE)).

floralib_struct(WS,PRFLORALIB(WS)).
storage_struct(WS,PRFDBSTORAGE(WS)).

%% Construct caller info for a literal.
%% Different caler info is created for body and head.
%% This form is used for cases when a literal can be both in the head and
%% in the body. In that case, Context is passed to tell which form to use.
%% When we know if we are in the head or in the body, we use
%% body_caller_info_structure/1 or head_caller_info_structure/1 directly.
determine_caller_info(Context,Caller) :-
	(Context==BODYLITERAL -> body_caller_info_structure(Caller)
	; Context==HEADLITERAL -> head_caller_info_structure(Caller)
	%% debug
	; flora_error_line('[Compiler] BUG: No caller type exists for this context, ~w', [Context]),
	    throw(FLORA_TOP_LEVEL)
	),
	!.
splice_in_caller_argument(Context,Args,NewArgs) :-
	determine_caller_info(Context,Caller),
	%% TODO: see if we can get rid of flattening
	flatten([Args,Caller],NewArgs).

%% special treatment of _overrides/2/4, _opposes/2/4, _cancel/1/2,
%% and stuff declared as :- prolog or :- table
termlit_struct(Context,FObj,N,ObjList,Code) :-
	(is_pratom(FObj,AtomName,Idx)
	; is_prbuiltin_identifier(FObj,AtomName,Idx)
	),
	flora_modular_prlgdef(AtomName,N),
	!,
	splice_in_caller_argument(Context,ObjList,Args),
	N1 is N+1,
	modularized_pratom_struct(AtomName,Idx,FunCode),
	prologterm_struct(FunCode,N1,Args,Code).

%% for things that have prolog name replacement
termlit_struct(_Context,FObj,N,ObjList,Code) :-
	(is_pratom(FObj,AtomName)
	; is_prbuiltin_identifier(FObj,AtomName)
	),
	( has_permaoption(defsensor(AtomName,N)) ->
	    compile_sensor_literal(_,FObj,N,ObjList,Code)
	; has_permaoption(defsensor(AtomName,N,PrlgModName)) ->
	    compile_sensor_literal(PrlgModName,FObj,N,ObjList,Code)
	; has_permaoption(atomreplacement(AtomName,N,_)) ->
	    termlit_replacement(FObj,N,NewFObj),
	    prologterm_struct(NewFObj,N,ObjList,Code)
	; flora_prlgdef(AtomName,N) ->
	    %%termlit_replacement(FObj,N,NewFObj),
	    %%prologterm_struct(NewFObj,N,ObjList,Code)
	    prologterm_struct(FObj,N,ObjList,Code)
	; flora_prlgdef(AtomName,N,Mod)
	-> prologterm_struct(FObj,N,ObjList,Mod,Code)
	),
	!.
termlit_struct(_Context,FObj,N,ObjList,Code) :-
	is_pratom(FObj,AtomName,Idx),
	flora_prlgdef_repl(AtomName,N,ReplacementAtm,Mod),
	!,
	is_pratom(ReplFObj,ReplacementAtm,Idx),
	prologterm_struct(ReplFObj,N,ObjList,Mod,Code).

termlit_struct(_Context,FObj,N,ObjList,Code) :-
	is_prbuiltin_identifier(FObj,AtomName,Idx),
	flora_prlgdef_repl(AtomName,N,ReplacementAtm,Mod),
	!,
	is_prbuiltin_identifier(ReplFObj,ReplacementAtm,Idx),
	prologterm_struct(ReplFObj,N,ObjList,Mod,Code).

termlit_struct(Context,FObj,N,ObjList,PRTERMLIT(FObj,N1,Args)) :-
	splice_in_caller_argument(Context,ObjList,Args),
	length(Args,N1),
	!,
	%% latent queries - debug
	(N1 is N+1, !
	; flora_error_line('[Compiler] BUG: Assertion N=N1 failed in termlit structure: Obj=~w, Arity=~w, Args=~w, Context=~w',
			   [FObj,N,ObjList,Context]),
	    throw(FLORA_TOP_LEVEL)
	).

transactionaltermlit_struct(Context,FObj,N,ObjList,PRTRANSACTIONALTERMLIT(FObj,N1,Args)) :-
	splice_in_caller_argument(Context,ObjList,Args),
	length(Args,N1),
	!,
	%% latent queries - debug
	(N1 is N+1, !
	; flora_error_line('[Compiler] BUG: Assertion N=N1 failed in transactionaltermlit structure: Obj=~w, Arity=~w, Args=~w, Context=~w',
			   [FObj,N,ObjList,Context]),
	    throw(FLORA_TOP_LEVEL)
	).


caller_binding_code(Binding,Code) :-
	callermod_var_structure(CallerVar),
	atomobj_struct(FL_SILENT_EQUAL,EqCode),
	prologterm_struct(EqCode,2,[CallerVar,Binding],Code).


/*
is_prtermlit(PRTERMLIT(Obj,_,_),I) :- approx_prindex(Obj,I).
is_prtermlit(PRATOMLIT(_Obj,I),I).

is_prtransactionallit(PRTRANSACTIONALTERMLIT(O,_,_),I) :- approx_prindex(O,I).
is_prtransactionallit(PRTRANSACTIONALATOMLIT(_,I),I).
is_prtransactionallit(PRTRAN(_,Obj,_),I) :- approx_prindex(Obj,I).

has_prtransactionallit([],_) :- !, fail.
has_prtransactionallit([H|_],Idx) :-
	is_prtransactionallit(H,Idx),
	!.
has_prtransactionallit([_|Rest],Idx) :-
	has_prtransactionallit(Rest,Idx).
*/

has_prologlit([],_) :- !, fail.
has_prologlit([H|Rest],Idx) :-
	(prologterm_atom_arity(H,Atm,_) -> approx_prindex(Atm,Idx)
	; has_prologlit(Rest,Idx)
	),
	!.


/*
   attach_workspace(+InCode,+WS,-WSCode,-Status)

   Attaches workspace code to InCode. Takes into account various cases
   WSCode is where the final code is produced.
*/
attach_workspace(InCode,WS,WSCode,Status) :- 
	(WS == FL_THISMODULE -> WSCode = InCode, Status = []
	; is_modularizedprologterm(InCode) ->
	    (is_flvariable(WS,_,Idx)
	    -> compiling_error(Idx,NO_PROLOG_WITH_VARMODULE,Err),
		Status = [Err]
	    ;
		workspacelit_struct(InCode,WS,WSCode),
		Status = NO_ERRORS
	    )
	;   is_prologterm(InCode) ->
	    %% If prolog term occurs under the scope of a FLORA-2 module, 
	    %% ignore the module
	    WSCode = InCode,
	    Status = NO_ERRORS
	;
	    workspacelit_struct(InCode,WS,WSCode),
	    Status = NO_ERRORS
	),
	!.

%% sometimes P might already be compiled and have a workspace.
%% Eg, if it came as head_neg_struct.
workspacelit_struct(P,_WS,Code) :-
	is_prworkspace(P,_,_),
	!,
	Code = P.
workspacelit_struct(P,WS,Code) :-
	thismodule_struct(ThisModuleName),
	(is_flvariable(WS,WSVarName,Index)
	->
	    varobj_struct(WSVarName,Index,WSVarCode),
	    body_caller_info_structure(ThisModuleName,CallerInfo),
	    %% a call to a Flora user module
	    florasyslib_struct(Index,FLLIBMODLIT,3,[P,WSVarCode,CallerInfo],Code)

	%% X@module or X@_module
        %% or %X@module or %X@_module
	; (is_prvariable(P,_,Index); is_prtransactionalvariable(P,_,Index))
	->
	    compile_workspace_term(WS,WSCode),
	    body_caller_info_structure(ThisModuleName,CallerInfo),
	    %% a call to a module
	    florasyslib_struct(Index,FLLIBMODLIT,3,[P,WSCode,CallerInfo],Code)

	; is_flatom(WS,WSAtom,Index) ->
	    atomobj_struct(WSAtom,Index,WSCode),
	    workspace_struct(P,WSCode,Code)

	%%; (WS == FL_THISMODULE ; is_fltoken(WS,FL_THISMODULE,_)) ->
	; is_fltoken(WS,FL_THISMODULE,_) ->
	    thismodule_struct(WSCode),
	    workspace_struct(P,WSCode,Code)
	;
	    %% a Flora system module
	    workspace_struct(P,WS,Code)
	),
	!.

%% This is used in situations where a workspace
%% term appears inside a predicate or a molecule,
%% e.g., p(foo@?Mod) or a[b->foo@?Mod] or ?X = abc#cde@?Mod
%% or ?Pred@ws or ?Pred@?Mod
workspaceobj_struct(P,WS,Object,Code) :-
	thismodule_struct(ThisModuleName),
	(is_flvariable(WS,WSVarName,Index) ->
	    varobj_struct(WSVarName,Index,WSVarCode),
	    new_prvariable(Index,Object),
	    body_caller_info_structure(ThisModuleName,CallerInfo),
	    %% code to construct the object for foo@X in arg position,
	    %% i.e., p(foo@X)
	    florasyslib_struct(Index,FLLIBMODOBJ,5,[FL_BODY,P,WSVarCode,CallerInfo,Object],Code)

	; is_prvariable(P,_,Index)
	->
	    compile_workspace_term(WS,WSCode),
	    new_prvariable(Index,Object),
	    body_caller_info_structure(ThisModuleName,CallerInfo),
	    %% code to construct the object for X@... in arg position,
	    %% i.e., p(X@...)
	    florasyslib_struct(Index,FLLIBMODOBJ,5,[FL_BODY,P,WSCode,CallerInfo,Object],Code)

	; is_flatom(WS,WSAtom,Index) ->
	    atomobj_struct(WSAtom,Index,WSCode),
	    workspace_struct(P,WSCode,Object),
	    Code=NULL

	%%; (WS == FL_THISMODULE ; is_fltoken(WS,FL_THISMODULE,_)) ->
	; is_fltoken(WS,FL_THISMODULE,_) ->
	    thismodule_struct(WSCode),
	    workspace_struct(P,WSCode,Object),
	    Code=NULL
	;
	  %% a Flora system module
	  Code=NULL,
	  workspace_struct(P,WS,Object)
	),
	!.

prologterm_struct(F,N,Args,PROLOGTERM(F,N,Args)).
%% This is used for prolog terms like goo(...)@_prolog(module)
%% when we encode them as module:goo. This is in addition to 
%% :- import goo from module. When XSB allows the notation foo:bar
%% in assert/retract, the :- module feature will be deprecated.
prologterm_struct(F,N,Args,Module,PROLOGTERM(F,N,Args)) :-
	var(Module),
	!.
prologterm_struct(F,N,Args,Module,PROLOGTERM(F,N,Args,ModuleCode)) :-
	atomobj_struct(Module,ModuleCode).

prologliblit_struct(PrologTerm,PROLOGLIBLIT(PrologTerm)).

is_prologterm(Term)    :- is_prologterm(Term,_,_,_), !.
is_prologterm(Term)    :- is_prologterm(Term,_,_,_,_).

is_modularizedprologterm(Term) :-
	is_prologterm(Term,Fun,_N,_Args),
	is_modularized_pratom(Fun,_,_).

prologterm_atom_arity(Term,Atom,Arity) :-
	is_prologterm(Term,Struct,Arity,_),
	is_modularized_pratom(Struct,Atom,_).
prologterm_atom_arity(Term,Atom,Arity) :- is_prologterm(Term,Atom,Arity,_), !.
prologterm_atom_arity(Term,Atom,Arity) :- is_prologterm(Term,Atom,Arity,_,_).

flprologlib_atom_arity(ParserTerm,Atm,Arity) :-
	is_flplib(ParserTerm,FLterm),
	is_flterm(FLterm,Funct,Arity,_),
	get_flatom_name(Funct,Atm).
flprologlib_atom_arity_mod(ParserTerm,Atm,Arity,Mod) :-
	is_flplib(ParserTerm,FLterm,Mod),
	is_flterm(FLterm,Funct,Arity,_),
	get_flatom_name(Funct,Atm).
%% returns functor object, not its name
flprologlib_functor(ParserTerm,Funct) :-
	(is_flplib(ParserTerm,FLterm) ; is_flplib(ParserTerm,FLterm,_)),
	!,
	is_flterm(FLterm,Funct,_,_).
flprologlib_call(ParserTerm,FLterm) :-
	(is_flplib(ParserTerm,FLterm) ; is_flplib(ParserTerm,FLterm,_)),
	!.

%% Not all Flora system libraries encode textual information. Only
%% the ones for aggregates and DB updates
florasyslib_struct(F,N,Args,FLORASYSLIB(NO_INDEX,F,N,Args)) :-
	report_option(FLSYSLIB(F),NO_INDEX).
florasyslib_struct(Index,F,N,Args,FLORASYSLIB(Index,F,N,Args)) :-
	report_option(FLSYSLIB(F),Index).

is_florasyslib_struct(FLORASYSLIB(I,F,N,Args), I,F,N,Args).

termobj_struct(FObj,N,ObjList,Code) :-
	(is_pratom(FObj,AtomName)
	; is_prbuiltin_identifier(FObj,AtomName)
	),
	(flora_prlgdef(AtomName,N)
	-> prologterm_struct(FObj,N,ObjList,Code)
	; flora_prlgdef(AtomName,N,Mod)
	-> prologterm_struct(FObj,N,ObjList,Mod,Code)
	),
	!.
termobj_struct(FObj,N,ObjList,Code) :-
	is_pratom(FObj,AtomName,Idx),
	flora_prlgdef_repl(AtomName,N,ReplacementAtm,Mod),
	!,
	is_pratom(ReplFObj,ReplacementAtm,Idx),
	prologterm_struct(ReplFObj,N,ObjList,Mod,Code).
termobj_struct(FObj,N,ObjList,Code) :-
	is_prbuiltin_identifier(FObj,AtomName,Idx),
	flora_prlgdef_repl(AtomName,N,ReplacementAtm,Mod),
	!,
	is_prbuiltin_identifier(ReplFObj,ReplacementAtm,Idx),
	prologterm_struct(ReplFObj,N,ObjList,Mod,Code).
termobj_struct(FObj,N,ObjList,PRTERM(FObj,N,ObjList)).

%% catch{...,...,...}
catch_struct(Goal,Error,Handler,Code) :-
	florasyslib_struct(FLLIBCATCH,3,[Goal,Error,Handler],Code).

%% throw{...}
throw_struct(Error,Code) :-
	florasyslib_struct(FLLIBTHROW,1,[Error],Code).

%% true{...}, false{...}, unknown{...}. Opname is FL_TRUE, FL_FALSE, FL_UNKNOWN
truthvalue_struct(Formula,Opname,Code) :-
	modularized_pratom_struct(FL_TRUTHVALUE_TABLED_CALL,NO_INDEX,FunCode),
	prologterm_struct(FunCode,1,[Formula],WrappedFormula),
	florasyslib_struct(FLLIBTRUTHVALUE,2,[WrappedFormula,Opname],Code).

tagprimitive_struct(Descriptor,Module,Code) :-
	approx_prindex(Descriptor,Index),
	florasyslib_struct(Index,FLLIBTAGPRIMITIVE,2,[Descriptor,Module],Code).

prefixprimitive_struct(Prefix,Expansion,Module,Code) :-
	florasyslib_struct(FLLIBPREFIXPRIMITIVE,3,[Prefix,Expansion,Module],Code).

%% p2h{...}
p2h_struct(Prolog,Hilog,Code) :-
	atomobj_struct(P2H_PREDICATE,P2HCode),
	%%prologterm_struct(P2HCode,4,[Prolog,Hilog,WRAP_HILOG,P2H_DONOT_UNIFY_VARS],Code).
	/* Previously we used P2H_DONOT_UNIFY_VARS here, but this meant that,
	   for example     ?- write(f(?X,?X))@_prologall.
           will print the two versions of ?Y as different vars.
           Do not know why P2H_DONOT_UNIFY_VARS was used here before.
	*/
	prologterm_struct(P2HCode,4,[Prolog,Hilog,WRAP_HILOG,P2H_UNIFY_VARS],Code).

insert_struct(Op,List,Cond,Code) :-
	%% Index denotes the textual information for the insert
	%% operator and represents the textual information for the
	%% entire insert statement.
	is_flatom(Op,OpAtom,Index),
	insert_syslib(OpAtom,Lib),
	florasyslib_struct(Index,Lib,2,[List,Cond],Code).

insert_struct(Op,List,Code) :-
	%% Index denotes the textual information for the insert
	%% operator and represents the textual information for the
	%% entire insert statement.
	is_flatom(Op,OpAtom,Index),
	insert_syslib(OpAtom,Lib),
	florasyslib_struct(Index,Lib,1,[List],Code).

delete_struct(Op,List,Cond,Code) :-
	%% Index denotes the textual information for the delete
	%% operator and represents the textual information for the
	%% entire delete statement.
	is_flatom(Op,OpAtom,Index),
	delete_syslib(OpAtom,Lib),
	florasyslib_struct(Index,Lib,2,[List,Cond],Code).

delete_struct(Op,List,Code) :-
	%% Index denotes the textual information for the delete
	%% operator and represents the textual information for the
	%% entire delete statement.
	is_flatom(Op,OpAtom,Index),
	delete_syslib(OpAtom,Lib),
	florasyslib_struct(Index,Lib,1,[List],Code).

table_refresh_struct(List,Code) :-
	florasyslib_struct(FLLIBREFRESH,1,[List],Code).

clause_struct(Id,DescrVarTerm,MetaFacts,Mode,HeadList,Body,Code) :-
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
	florasyslib_struct(FLLIBCLAUSE,6,[Id,DescrVarTerm,MetaFacts,Mode,HeadList,Body],Code).

insert_rulesig_struct(HeadList,Body,PreBody,PostBody,(DescrIdCode,DescrVarsTerm,DefeatCond),Newpred,Code) :-
	thismodule_struct(WS),
	get_current_compile_file(File),
	(approx_prindex(DescrIdCode,Idx), Idx > 0 -> true
	; approx_prindex(HeadList,Idx)
	),
	flora_token_rulenum(Idx,RuleNum), %% rulenum within file
	florasyslib_struct(FLLIBINSRULESIG,11,[DescrIdCode,File,DescrVarsTerm,WS,RuleNum,HeadList,Body,PreBody,PostBody,DefeatCond,Newpred],Code).

insert_syslib(FL_INSERT,FLLIBINSERT) :- !.
insert_syslib(FL_INSERTALL,FLLIBINSERTALL) :- !.

insert_syslib(FL_BTINSERT,FLLIBBTINSERT) :- !.
insert_syslib(FL_BTINSERTALL,FLLIBBTINSERTALL) :- !.

delete_syslib(FL_DELETE,FLLIBDELETE) :-
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
	!.
delete_syslib(FL_DELETEALL,FLLIBDELETEALL) :-
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
	!.
delete_syslib(FL_ERASE,FLLIBERASE) :-
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
	!.
delete_syslib(FL_ERASEALL,FLLIBERASEALL) :-
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
	!.

delete_syslib(FL_BTDELETE,FLLIBBTDELETE) :- !.
delete_syslib(FL_BTDELETEALL,FLLIBBTDELETEALL) :- !.
delete_syslib(FL_BTERASE,FLLIBBTERASE) :- !.
delete_syslib(FL_BTERASEALL,FLLIBBTERASEALL) :- !.

updaterule_syslib(FL_INSERTRULE,FLLIBINSERTRULE_Z) :- 
        !.
updaterule_syslib(FL_INSERTRULE_A,FLLIBINSERTRULE_A) :- 
        !.
updaterule_syslib(FL_INSERTRULE_Z,FLLIBINSERTRULE_Z) :- 
        !.
updaterule_syslib(FL_DELETERULE_A,FLLIBDELETERULE_A) :- 
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
        !.
updaterule_syslib(FL_DELETERULE_Z,FLLIBDELETERULE_Z) :- 
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
        !.
updaterule_syslib(FL_DELETERULE,FLLIBDELETERULE) :- 
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
        !.

is_fldeleteruleop(FL_DELETERULE_A) :- !.
is_fldeleteruleop(FL_DELETERULE_Z) :- !.
is_fldeleteruleop(FL_DELETERULE) :- !.

aggregate_struct(Op,V,GV,B,Object,Code) :-
	%% Index denotes the textual information for the aggregate
	%% operator and represents the textual information for the
	%% entire aggregate statement.
	is_flatom(Op,OpAtom,Index),
	aggregate_syslib(OpAtom,Lib),
	new_prvariable(Index,Object),
	( GV == [] -> florasyslib_struct(Index,Lib,3,[V,B,Object],Code)
	;
	  florasyslib_struct(Index,Lib,4,[V,GV,B,Object],Code)
        ),
	!.
aggregate_struct(Op,V,GV,SortCode,B,Object,Code) :-
	%% Index denotes the textual information for the aggregate
	%% operator and represents the textual information for the
	%% entire aggregate statement.
	is_flatom(Op,OpAtom,Index),
	aggregate_syslib_sorted(OpAtom,Lib),
	new_prvariable(Index,Object),
	( GV == [] ->
	    florasyslib_struct(Index,Lib,4,[V,SortCode,B,Object],Code)
	;
	  florasyslib_struct(Index,Lib,5,[V,GV,SortCode,B,Object],Code)
        ),
	!.

aggregate_syslib(FL_MIN,FLLIBMIN) :- !.
aggregate_syslib(FL_MAX,FLLIBMAX) :- !.
aggregate_syslib(FL_SUM,FLLIBSUM) :- !.
aggregate_syslib(FL_AVG,FLLIBAVG) :- !.
aggregate_syslib(FL_COUNT,FLLIBCOUNT) :- !.
aggregate_syslib(FL_COLLECTSET,FLLIBCOLLECTSET) :- !.
aggregate_syslib(FL_COLLECTBAG,FLLIBCOLLECTBAG) :- !.
aggregate_syslib(FL_SET,FLLIBCOLLECTSET) :- !.
aggregate_syslib(FL_BAG,FLLIBCOLLECTBAG) :- !.

aggregate_syslib_sorted(FL_COLLECTSET,FLLIBSETSORTBY) :- !.
aggregate_syslib_sorted(FL_COLLECTBAG,FLLIBBAGSORTBY) :- !.
aggregate_syslib_sorted(FL_SET,FLLIBSETSORTBY) :- !.
aggregate_syslib_sorted(FL_BAG,FLLIBBAGSORTBY) :- !.

hypothetical_struct(Op,Goal,Index,Code) :-
	hypothetical_syslib(Op,Lib), %% Op is a plain atom, not flatom
	florasyslib_struct(Index,Lib,2,[Op,Goal],Code).

hypothetical_syslib(FL_POSSIBLE,FLLIBHYPOTHETICAL)      :- !.
hypothetical_syslib(FL_IMPOSSIBLE,FLLIBHYPOTHETICAL)    :- !.

objexists_struct(Context,Obj,PREXISTS(Obj,Caller)) :-
	determine_caller_info(Context,Caller).

birelate_struct(LiteralContext,Obj1,RelType,Obj2,Code) :-
	( is_isaspecop(RelType) ->
	    isaspec_struct(LiteralContext,Obj1,Obj2,Code)
	; is_subspecop(RelType) ->
	  subspec_struct(LiteralContext,Obj1,Obj2,Code)
        ),
	!.

isaspec_struct(Context,Obj1,Obj2,PRISA(Obj1,Obj2,Caller)) :-
	determine_caller_info(Context,Caller).

subspec_struct(Context,Obj1,Obj2,PRSUB(Obj1,Obj2,Caller)) :-
	determine_caller_info(Context,Caller).


sigattspec_struct(LiteralContext,Object,AttObj,RefType,ValObj,Code) :-
	( is_mvdsigspecop(RefType) ->
	    mvdsigspec_struct(LiteralContext,Object,AttObj,ValObj,Code)

	; is_imvdsigspecop(RefType) ->
	    imvdsigspec_struct(LiteralContext,Object,AttObj,ValObj,Code)

        ),
	!.


%% cardinality constraints in the body
sigattconstr_struct(LiteralContext,Object,AttObj,LowerObj,UpperObj,RefType,Code) :-
	( is_mvdsigspecop(RefType) ->
	    mvdcon_struct(LiteralContext,Object,AttObj,LowerObj,UpperObj,Code) 

	; is_imvdsigspecop(RefType) ->
	    imvdcon_struct(LiteralContext,Object,AttObj,LowerObj,UpperObj,Code) 
	),
	!.


%% cardinality constraints in the head
sigattcondef_struct(LiteralContext,Object,AttObj,LowerObj,UpperObj,RefType,ValObj,Code) :-
	( is_mvdsigspecop(RefType) ->
	    mvdcondef_struct(LiteralContext,Object,AttObj,LowerObj,UpperObj,ValObj,Code) 

	; is_imvdsigspecop(RefType) ->
	    imvdcondef_struct(LiteralContext,Object,AttObj,LowerObj,UpperObj,ValObj,Code) 
	),
	!.

mvdsigspec_struct(Context,Object,AttObj,ValObj,PRMVDSIG(Object,AttObj,ValObj,Caller)) :-
	determine_caller_info(Context,Caller).
imvdsigspec_struct(Context,Object,AttObj,ValObj,PRIMVDSIG(Object,AttObj,ValObj,Caller)) :-
	determine_caller_info(Context,Caller).

%% This is for cardinality constraints in the body
mvdcon_struct(Context,Object,AttObj,LowerObj,UpperObj,PRMVDCON(Object,AttObj,LowerObj,UpperObj,Caller)) :-
	determine_caller_info(Context,Caller).
imvdcon_struct(Context,Object,AttObj,LowerObj,UpperObj,PRIMVDCON(Object,AttObj,LowerObj,UpperObj,Caller)) :-
	determine_caller_info(Context,Caller).

%% This is for cardinality constraints in the head
mvdcondef_struct(Context,Object,AttObj,LowerObj,UpperObj,ValObj,PRMVDCONDEF(Object,AttObj,LowerObj,UpperObj,ValObj,Caller)) :-
	determine_caller_info(Context,Caller).
imvdcondef_struct(Context,Object,AttObj,LowerObj,UpperObj,ValObj,PRIMVDCONDEF(Object,AttObj,LowerObj,UpperObj,ValObj,Caller)) :-
	determine_caller_info(Context,Caller).

is_prmvdcondef(PRMVDCONDEF(_Object,_AttObj,_LowerObj,_UpperObj,_Type,_Caller)).
is_primvdcondef(PRIMVDCONDEF(_Object,_AttObj,_LowerObj,_UpperObj,_Type,_Caller)).

boolsig_struct(Context,Object,AttObj,PRBOOLSIG(Object,AttObj,Caller)):-
	determine_caller_info(Context,Caller).
iboolsig_struct(Context,Object,AttObj,PRIBOOLSIG(Object,AttObj,Caller)):-
	determine_caller_info(Context,Caller).

transig_struct(Context,Object,AttObj,PRTRANSIG(Object,AttObj,Caller)):-
	determine_caller_info(Context,Caller).
itransig_struct(Context,Object,AttObj,PRITRANSIG(Object,AttObj,Caller)):-
	determine_caller_info(Context,Caller).


%% This is for ->, *-> when the attribute is defined,
%% but its value is empty set
mvdattdef_struct(LiteralContext,Object,AttObj,RefType,Code) :-
	( is_mvdspecop(RefType) ->
	    mvddef_struct(LiteralContext,Object,AttObj,Code)
	;
	  is_imvdspecop(RefType) ->
	    imvddef_struct(LiteralContext,Object,AttObj,Code)
        ),
	!.

%% This is for =>, *=>, when the attribute is defined,
%% but its value is empty set
sigattdef_struct(LiteralContext,Object,AttObj,RefType,Code) :-
	( is_mvdsigspecop(RefType) ->
	    mvdsigdef_struct(LiteralContext,Object,AttObj,Code)

	; is_imvdsigspecop(RefType) ->
	    imvdsigdef_struct(LiteralContext,Object,AttObj,Code)

        ),
	!.


mvddef_struct(Context,Object,AttObj,PRMVDDEF(Object,AttObj,Caller)) :-
	determine_caller_info(Context,Caller).
imvddef_struct(Context,Object,AttObj,PRIMVDDEF(Object,AttObj,Caller)) :-
	determine_caller_info(Context,Caller).
mvdsigdef_struct(Context,Object,AttObj,PRMVDSIGDEF(Object,AttObj,Caller)) :-
	determine_caller_info(Context,Caller).
imvdsigdef_struct(Context,Object,AttObj,PRIMVDSIGDEF(Object,AttObj,Caller)) :-
	determine_caller_info(Context,Caller).

mvdattspec_struct(LiteralContext,Object,AttObj,RefType,ValObj,Code) :-
	( is_mvdspecop(RefType) ->
	    mvdspec_struct(LiteralContext,Object,AttObj,ValObj,Code)

	; is_imvdspecop(RefType) ->
	    imvdspec_struct(LiteralContext,Object,AttObj,ValObj,Code)
        ),
	!.

mvdspec_struct(Context,Object,AttObj,ValObj,PRMVD(Object,AttObj,ValObj,Caller)) :-
	determine_caller_info(Context,Caller).
imvdspec_struct(Context,Object,AttObj,ValObj,PRIMVD(Object,AttObj,ValObj,Caller)) :-
	determine_caller_info(Context,Caller).

%% for +>> and *+>>
%% appears only in the rule body
incattspec_struct(Object,AttObj,RefType,ValObj,Code) :-
	( is_mvdincspecop(RefType) ->
	    mvdincspec_struct(Object,AttObj,ValObj,Code)
	;
	  is_imvdincspecop(RefType) ->
	  imvdincspec_struct(Object,AttObj,ValObj,Code)
        ),
	!.

%% +>>
%% appears only in the rule body
mvdincspec_struct(Object,AttObj,ValObj,PRMVDINC(Object,AttObj,ValObj,CallerInfo)) :-
	thismodule_struct(ThisModule),
	body_caller_info_structure(ThisModule,CallerInfo).
%% *+>>
%% appears only in the rule body
imvdincspec_struct(Object,AttObj,ValObj,PRIMVDINC(Object,AttObj,ValObj,CallerInfo)) :-
	thismodule_struct(ThisModule),
	body_caller_info_structure(ThisModule,CallerInfo).

%% ->->, *->->
%% appears only in the rule body
tolistattspec_struct(Object,AttObj,RefType,ValObj,Code) :-
	( is_mvdtolistspecop(RefType) ->
	    mvdtolistspec_struct(Object,AttObj,ValObj,Code)
	;
	  is_imvdtolistspecop(RefType) ->
	  imvdtolistspec_struct(Object,AttObj,ValObj,Code)
        ),
	!.

mvdtolistspec_struct(Object,AttObj,ValObj,PRMVDTOLIST(Object,AttObj,ValObj,CallerInfo)) :-
	thismodule_struct(ThisModule),
	body_caller_info_structure(ThisModule,CallerInfo).
imvdtolistspec_struct(Object,AttObj,ValObj,PRIMVDTOLIST(Object,AttObj,ValObj,CallerInfo)) :-
	thismodule_struct(ThisModule),
	body_caller_info_structure(ThisModule,CallerInfo).

%% This is called when someting like a.b[] is compiled.
body_objref_struct(Obj,RefType,Att,Index,Val,Code) :-
	%% Index is the approximate textual information
	%% for the new variable that represents an oid.
	%% Here we use existential variables so that if we get something like
	%% naf bill.has(moo)[type->bar] then the var corresponding to
	%% bill.has(moo) will be treated as existential and so there will not be
	%% a delay because of its unboundedness.
	new_existential_prvariable(Index,Val),
	( is_mvdrefop(RefType) ->
	    mvdspec_struct(BODYLITERAL,Obj,Att,Val,Code)
	;
	  is_imvdrefop(RefType) ->
	    imvdspec_struct(BODYLITERAL,Obj,Att,Val,Code)
        ),
	!.

%% if it is the same with body_objref_struct, combine them later
head_objref_struct(Obj,RefType,Att,Index,Val,Code) :-
	new_prvariable(Index,Val), 
        ( is_mvdrefop(RefType) -> 	 
            mvdspec_struct(HEADLITERAL,Obj,Att,Val,Code) 	 
        ; 	 
          is_imvdrefop(RefType) -> 	 
	    imvdspec_struct(HEADLITERAL,Obj,Att,Val,Code) 	 
        ),
	!. 	 
 	 

methspec_struct(Context,Obj,Meth,PRMETH(Obj,Meth,Caller)) :-
	determine_caller_info(Context,Caller).
imethspec_struct(Context,Obj,IMeth,PRIMETH(Obj,IMeth,Caller)) :-
	determine_caller_info(Context,Caller).
transpec_struct(Context,Obj,Tran,PRTRAN(Obj,Tran,Caller)) :-
	determine_caller_info(Context,Caller).

objeql_struct(Context,O1,O2,PROBJEQL(O1,O2,Caller)) :-
	determine_caller_info(Context,Caller).


ifthenelse_struct(Cond,Then,Else,Code) :-
	code_line_and_file_by_prterm(Cond,Line,CurrFileName),
	thismodule_struct(ThisMod),
	florasyslib_struct(FLLIBIFTHENELSE,6,[ThisMod,Cond,Then,Else,Line,CurrFileName],Code).

ifthen_struct(Cond,Then,Code) :-
	code_line_and_file_by_prterm(Cond,Line,CurrFileName),
	thismodule_struct(ThisMod),
	florasyslib_struct(FLLIBIFTHEN,5,[ThisMod,Cond,Then,Line,CurrFileName],Code).

%% encoding of control constructs
controlconstruct_struct(CondCode,ActionCode,Wrapper,Code) :-
	code_line_and_file_by_prterm(CondCode,Line,CurrFileName),
	thismodule_struct(ThisMod),
	florasyslib_struct(Wrapper,5,[ThisMod,CondCode,ActionCode,Line,CurrFileName],Code).

univeqform_struct(Left,Right,Code) :-
	florasyslib_struct(FLLIBUNIVEQFORM,2,[Left,Right],Code).

%% This handles both ~.. and =..
%% These predicates are defined identically. The only difference is that
%% the LHS arg of ~.. is compiled as meta, while in =.. it is compiled as oid
metauniv_struct(Left,Right,Code) :-
	florasyslib_struct(FLLIBMETAUNIV,2,[Left,Right],Code).

constraint_struct(ConstrCode,PRCONSTRAINT(ConstrCode)).


/****************************************************************************
  reset_newpredicate/0
  new_predicate(-Name)
****************************************************************************/
reset_newpredicate :- flora_set_counter(NEWPREDICATE_COUNTER,1).

new_predicate(Name) :-
	flora_increment_counter(NEWPREDICATE_COUNTER,1,OldVal,_NewVal),
	flora_concat_items([NEWPREDICATE_SYM,OldVal],Name).

/****************************************************************************
  reset_default_ruleid/0
  current_default_ruleid(-Name)
****************************************************************************/
reset_default_ruleid :- flora_set_counter(DEFAULT_RULE_ID,1).

increment_default_ruleid :-
	flora_increment_counter(DEFAULT_RULE_ID,1,_,_).
current_default_ruleid(RuleId) :-
	flora_get_counter(DEFAULT_RULE_ID,RuleId).


/****************************************************************************
  flora_reset_newudfpredvar/0
  flora_newudfpredvar_obj(+VarPrefix,+Index,-CompiledVarObj)
****************************************************************************/
flora_reset_newudfpredvar :- flora_set_counter(NEWUDFPREDVAR,1).

flora_newudfpredvar_obj(Index,VarObj) :-
	flora_increment_counter(NEWUDFPREDVAR,1,OldVal,_NewVal),
	varobj_struct(OldVal,Index,VarObj).

/****************************************************************************
  flora_reset_newvar/0
  flora_new_varobj(+VarPrefix,+Index,-CompiledVarObj)
  new_prvariable(+Index,-CompiledVarObj)
****************************************************************************/
flora_reset_newvar :- flora_set_counter(NEWVAR,1).

%% This 3-argument version is provided for other parts of the compiler,
%% such as flrundefined.P, which need to generate vars.
%% VarPrefix makes sure that names don't clash.
flora_new_varobj(VarPrefix,Index,VarObj) :-
	flora_increment_counter(NEWVAR,1,OldVal,_NewVal),
	flora_concat_items([VarPrefix,OldVal],Name),
	varobj_struct(Name,Index,VarObj).

flora_new_transactionalvarobj(VarPrefix,Index,VarObj) :-
	flora_increment_counter(NEWVAR,1,OldVal,_NewVal),
	flora_concat_items([VarPrefix,OldVal],Name),
	transactionalvar_struct(Name,Index,VarObj).

new_prvariable(Index,VarObj) :-
	flora_new_varobj(NEWVAR,Index,VarObj).
new_dontcare_prvariable(Index,VarObj) :-
	flora_new_varobj(NEWDONTCAREVAR,Index,VarObj).
new_caller_prvariable(Index,VarObj) :-
	flora_new_varobj(NEWCALLERVAR,Index,VarObj).
new_existential_prvariable(Index,VarObj) :-
	flora_new_varobj(NEWEXISTENTIALVAR,Index,VarObj).
%% creates new transactional variable
new_dontcare_prtransactionalvar(Index,VarObj) :-
	flora_new_transactionalvarobj(NEWDONTCAREVAR,Index,VarObj).

prvariable_for_numbered_skolem(Index,SkolemNumber,VarObj) :-
	flora_concat_items([SKOLEMSYMVAR,SkolemNumber],Name),
	varobj_struct(Name,Index,VarObj).


new_prvarlist(0,[]) :- !.

new_prvarlist(N,[VarObj|L]) :-
	new_prvariable(NO_INDEX,VarObj),
	M is N-1,
	new_prvarlist(M,L).

new_flvariable(Index,FlVar,NewPrvar) :-
	new_prvariable(Index,NewPrvar),
	prvar_to_flvar_struct(NewPrvar,FlVar).

/****************************************************************************
  reset_newoid/0
  new_oidobj(+Index,-OidObject)
****************************************************************************/
reset_newoid :- flora_set_counter(NEWOID_COUNT,1).

new_oidobj(Index,OidObject) :-
	flora_increment_counter(NEWOID_COUNT,1,OldVal,_NewVal),
	flora_concat_items([NEWOID,OldVal],Name),
	newoid_struct(Name,Index,OidObject).

/*************************************************************************
  new_oidobj(+OidNumStr,+Index,-OidObject)
*************************************************************************/
new_oidobj(OidNumStr,Index,OidObject) :-
	( ruleoid(OidNumStr,_,Count)
	-> Count_new is Count+1,
	    %% TODO: see if we can replace assert/retract with conget/conset
	    retract(ruleoid(OidNumStr,_,Count)),
	    asserta(ruleoid(OidNumStr,Index,Count_new))
	;  asserta(ruleoid(OidNumStr,Index,1))
	), 
	!,
	flora_get_counter(RULE_NUM, RuleNum), 
        flora_concat_items([NEWOID,RuleNum,'|',OidNumStr],Name),
	newoid_struct(Name,Index,OidObject).

/*************************************************************************
  new_dynoidobj(+Index,-OidObject)
  new_dynoidobj(+OidNumStr,+Index,-OidObject)
  These generate dynamic new oids for use in the shell
*************************************************************************/
new_dynoidobj(Index,OidObject) :-
	gensym:gensym(FL_NEWOID_DYNSYM,Name),
	newoid_struct(Name,Index,OidObject).
new_dynoidobj(OidNumStr,Index,OidObject) :-
	flora_concat_atoms([FL_NEWOID_DYNSYM,'|',OidNumStr],Name),
	newoid_struct(Name,Index,OidObject).
	


clear_ruleoid :- flora_retractall_substitute(ruleoid(_,_,_)).

/****************************************************************************
  reset_rulenum

****************************************************************************/
reset_rulenum :- flora_set_counter(RULE_NUM,1).
increment_rule_number :- flora_increment_counter(RULE_NUM,1,_,_).

/****************************************************************************
  collect_prvars(+CompilerTerm,-Vars)
  collect_prvars(+CompilerTerm,-Vars,-TailVars)
  collects all variables in a *compiled* term (or a list of terms).
  Returns a list Vars.

****************************************************************************/
collect_prvars(Term,Vars) :-
	collect_prvars(Term,Vs,[]),
	%%sort(Vs,Vars).
	Vs=Vars. %% sorting does nothing here

collect_prvars([],Vars,Vars) :- !.
collect_prvars(Term,Vars,Vars) :-
	(var(Term); atomic(Term)),
	!.
collect_prvars([H|L],Vars,TVars) :-
	!,
	collect_prvars(H,Vars,LVars),
	collect_prvars(L,LVars,TVars).
collect_prvars(Term,[Term|Vars],Vars) :-
	is_prvariable(Term),
	!.
collect_prvars(Term,[Head|Vars],Vars) :-
	is_prtransactionalvariable(Term,Name,Index),
	!,
        is_prvariable(Head,Name,Index).

collect_prvars(Term,Vars,Vars) :-
	( is_pratom(Term,_);
	  is_prnumber(Term);
	  is_prstring(Term);
	  is_prbuiltin_identifier(Term,_);
	  is_prtransactionalnumber(Term,_,_)
        ),
	!.
collect_prvars(Term,NewVars,Vars) :-
	is_prdatatype(Term,_Sort,Lit,_),
	!,
	(is_prvariable(Lit,_Name,_Indx) -> NewVars = [Lit|Vars]
	; is_list(Lit) -> collect_prvars(Lit,NewVars,Vars)
	; is_prdatatypelist(Lit,LitList) -> collect_prvars(LitList,NewVars,Vars)
	; NewVars=Vars
	),
	!.
collect_prvars(Term,Vars,TVars) :-
	Term =.. [_F|L],
	collect_prvars(L,Vars,TVars).


/****************************************************************************
  error and warning messages
****************************************************************************/
compiling_error(Index,Mesg,error(Index,ErrMsg)) :-
	is_list(Mesg),
	!,
	flora_concat_atoms(Mesg,ErrMsg).
compiling_error(Index,Mesg,error(Index,Mesg)).

compiling_warning(Index,Mesg,warning(Index,ErrMsg)) :-
	is_list(Mesg),
	!,
	flora_concat_atoms(Mesg,ErrMsg).
compiling_warning(Index,Mesg,warning(Index,Mesg)).


/****************************************************************************
  collect_flvars(+ParserTermOrList,-Vars)
  collects all occurrences of variables in a *parser* term (or a list of parser
  terms) into the list Vars.

  collect_flvars(+ParserTerm,-Vars,-TailVars)
****************************************************************************/
collect_flvars(ParserTermOrList,Vars) :-
	collect_flvars(ParserTermOrList,Vars,[]).

collect_flvars([],Vars,Vars) :- !.
collect_flvars(ParserTerm,Vars,Vars) :-
	var(ParserTerm),
	!.
collect_flvars(ParserTerm,Vars,Vars) :-
	atomic(ParserTerm),
	!.
collect_flvars([H|L],Vars,TVars) :-
	!,
	collect_flvars(H,Vars,LVars),
	collect_flvars(L,LVars,TVars).

collect_flvars(ParserTerm,[ParserTerm|Vars],Vars) :-
	is_flvariable(ParserTerm,_Name,_Index),
	!.

collect_flvars(ParserTerm,[NewParserTerm|Vars],Vars) :-
	is_fltransactionalvariable(ParserTerm,Name,Index),
	!,
        is_flvariable(NewParserTerm,Name,Index).

collect_flvars(ParserTerm,Vars,Vars) :-
	( is_flatom(ParserTerm,_Atom);
	  is_flnumber(ParserTerm,_Number);
	  is_flstring(ParserTerm,_String);
	  is_flbuiltin_identifier(ParserTerm,_Ident);
          is_fltransactionalatom(ParserTerm,_Atom);
	  is_fltransactionalnumber(ParserTerm,_Number);
	  is_fltransactionalstring(ParserTerm,_String);
	  is_fltoken(ParserTerm,_Token,_I);
	  is_fltoken(ParserTerm,_Token,_Suffix,_I) 
        ),
	!.

collect_flvars(ParserTerm,NewVars,Vars) :-
	is_fldatatype(ParserTerm,_Sort,Lit,_Index),
	!,
        (is_flvariable(Lit,_Name,_Indx) -> NewVars = [Lit|Vars]
	; is_list(Lit) -> collect_flvars(Lit,NewVars,Vars)
	; is_fldatatypelist(Lit,ListLit) -> collect_flvars(ListLit,NewVars,Vars)
	;  NewVars=Vars
	),
	!.

collect_flvars(ParserTerm,Vars,TVars) :-
	is_fllogicquantifier(ParserTerm,_,VarNames,FormulaCode,_Idx),
	!,
	collect_flvars(FormulaCode,Vars1,TVars),
	subtract_varnames_from_vars(Vars1,VarNames,Vars).

collect_flvars(ParserTerm,Vars,TVars) :-
	ParserTerm =.. [_F|L],
	collect_flvars(L,Vars,TVars).


/****************************************************************************
  collect_prdatatypevars(+ParserTermOrList,-DTVarsCode)

  Collects all occurrences of datatype variable terms in a parser term 
  (or a list of parser terms) into the list Vars.
****************************************************************************/
collect_prdatatypevars(CompilerTermOrList,Vars) :-
	collect_prdatatypevars(CompilerTermOrList,Vars,[]).

collect_prdatatypevars([],Vars,Vars) :- !.

collect_prdatatypevars([H|L],Vars,TVars) :-
	!,
	collect_prdatatypevars(H,Vars,LVars),
	collect_prdatatypevars(L,LVars,TVars).

%% If there is a variable in data type  ... ?Y^^type ... 
%% then create ?Y = FL_DATATYPE(Sort,?_Y) and collect all these
collect_prdatatypevars(CompilerTermOrList,NewVars,Vars) :-
	is_prdatatype(CompilerTermOrList,TypeCode,VarCode,_Index),
	!,
	%% TODO: get rid of the appends here!
        (is_prvariable(VarCode,VarName,VarIdx)
	-> strip_underscore(VarName,UsrGivenVarName),
	    %% create ?_Y =?__Y^^type
	    varobj_struct(UsrGivenVarName,VarIdx,UsrGivenVarCode),
	    is_prdatatype(DataTypeVarStruct,TypeCode,VarCode,NO_INDEX),
	    atomobj_struct(FL_UNIVEQ,UnivEQCode),
	    prologterm_struct(UnivEQCode,2,[UsrGivenVarCode,DataTypeVarStruct],
			      DatatypeVarCode),
	    NewVars = [DatatypeVarCode|Vars]
	; is_list(VarCode)
	-> collect_prdatatypevars(VarCode,AddlVars),
	    append(AddlVars,Vars,NewVars)
	; is_prdatatypelist(VarCode,ListOfLits)
	-> collect_prdatatypevars(ListOfLits,AddlVars),
	    append(AddlVars,Vars,NewVars)
	;  NewVars=Vars
	),
	!.


collect_prdatatypevars(CompilerTermOrList,Vars,TVars) :-
	CompilerTermOrList =.. [_F|L],
	collect_prdatatypevars(L,Vars,TVars).


strip_underscore(Atom,NewAtom) :-
	%%atom_codes(Atom,[_|NewAtomChars]),
	%%atom_codes(NewAtom,NewAtomChars).
	substring(Atom,1,_,NewAtom).

add_underscore(Atom,NewAtom) :-
	%%atom_codes(Atom,AtomChars),
	%%atom_codes(NewAtom,[CH_UNDERSCORE|AtomChars]).
	flora_concat_atoms(['_',Atom],NewAtom).


/****************************************************************************
  subtract_vars(+VarList1,+VarList2,-VarList)
  subtract_varnames_from_vars(+VarList1,+VarNameList2,-VarList)

  subtracts VarList2 from VarList1.
  Both VarList1 and VarList2 must be of the same type: parser vars
  or compiler vars. VarNameList2 is a list of names of vars.
  The result is a list of variables whose names do not appear in VarsList2
  or VarNameList2.
  Anonymous variables are considered as distinct names and are not subtracted.
****************************************************************************/
%% subtract_vars/3: subtract flvars from flvars or prvars from prvars
subtract_vars([],_,[]) :- !.
subtract_vars(L,[],L) :- !.

subtract_vars([H|T],L,Res) :-
	( %% construct X as H, but with variable index
	  is_flvariable(H,N,_) -> is_flvariable(X,N,_)
	; is_fltransactionalvariable(H,N,_) -> is_fltransactionalvariable(X,N,_)
	; is_prvariable(H,N,_) -> is_prvariable(X,N,_)
	; is_prtransactionalvariable(H,N,_) -> is_prtransactionalvariable(X,N,_)
	),
	!,
	subtract_vars(T,L,V),
	!,
	(N \== FL_ANON_VAR, memberchk(X,L) -> Res = V
	; Res = [H|V]
	),
	!.

%% subtract_varnames_from_vars/3: subtract var names from flvars or prvars
subtract_varnames_from_vars([],_,[]) :- !.
subtract_varnames_from_vars(L,[],L) :- !.

subtract_varnames_from_vars([H|T],L,Res) :-
	( is_flvariable(H,N,_I)
	; is_fltransactionalvariable(H,N,_I)
	; is_prvariable(H,N,_I)
	; is_prtransactionalvariable(H,N,_I)
	),
	!,
	(var(T) -> V = T
	; subtract_varnames_from_vars(T,L,V)
	),
	(N \== FL_ANON_VAR, memberchk(N,L) -> Res = V
	; Res = [H|V]
	),
	!.


/*****************************************************************************
     vars_contains(+VarList1,+VarList2)
     Checks if VarList1 contains VarList2 up to indices.
     VarList1,VarList2 are assumed to be sorted and of the same kind
*****************************************************************************/
vars_contains(_,[]) :- !.
vars_contains([H1|T1],[H2|T2]) :-
	( is_flvariable(H1,N,_), is_flvariable(H2,N,_)
	; is_fltransactionalvariable(H1,N,_), is_fltransactionalvariable(H2,N,_)
	; is_prvariable(H1,N,_), is_prvariable(H2,N,_)
	; is_prtransactionalvariable(H1,N,_), is_prtransactionalvariable(H2,N,_)
	),
	!,
	N \== FL_ANON_VAR,
	vars_contains(T1,T2).


/*****************************************************************************
             remove_caller_vars(+InList,-OutList)
             remove_prvars(+InList,-OutList)
      Removes all the do not care variables from InList.
      InList can be a list of parser or compiler vars.
*****************************************************************************/
/*
remove_fldontcare_vars([],[]) :- !.
remove_fldontcare_vars([H|T1],T2) :-
	( is_flvariable(H,FL_ANON_VAR,_I)
	; is_fltransactionalvariable(H,FL_ANON_VAR,_I)
	),
	!,
	remove_fldontcare_vars(T1,T2).
remove_fldontcare_vars([H|T1],[H|T2]) :-
	remove_fldontcare_vars(T1,T2).
*/

remove_prvars(_,[],[]) :- !.
remove_prvars(Prefix,[H|T1],T2) :-
	%% new vars are all prvar structures
	( is_prvariable(H,Var,_I)
	; is_prtransactionalvariable(H,Var,_I)
	),
	%% must be before the cut!!!
	str_sub(Prefix,Var,0), %% starts with Prefix
	!,
	remove_prvars(Prefix,T1,T2).
remove_prvars(Prefix,[H|T1],[H|T2]) :-
	remove_prvars(Prefix,T1,T2).

/*
remove_prdontcare_vars(InVars,OutVars) :-
	remove_prvars(NEWDONTCAREVAR,InVars,OutVars).
*/
remove_caller_vars(InVars,OutVars) :-
	remove_prvars(NEWCALLERVAR,InVars,OutVars).

remove_existential_vars(InVars,OutVars) :-
	remove_prvars(NEWEXISTENTIALVAR,InVars,OutVars).

remove_prdontcare_and_caller_vars(In,Out) :-
	remove_prvars(NEWDONTCAREVAR,In,Intermed),
	remove_prvars(NEWCALLERVAR,Intermed,Out).


/****************************************************************************
  collect_name_var_pairs(+ParserTerm,-QueryVars)
  collects all the queryable variables (those that do not start with an
  underscore) in a parser term (or a list of parser terms) into a list
  of Name=Var constructs.

  indexvars(+SortedNameVars,-IndexVars)
  namevars(+SortedIndexVars,-QueryVars)
****************************************************************************/
collect_name_var_pairs(ParserTerm,QueryVars) :-
	collect_flvars(ParserTerm,NameVs),
	%% Sorting eliminated duplicate vars so that, for example,
	%% Name-Var code in compile_query will have 1 pair per var name.
	%% So, each var will be printed only once in the asnwers in the shell.
	sort(NameVs,SortedNameVs),
	indexvars(SortedNameVs,IndexVs),
	keysort(IndexVs,SortedIndexVs),
	namevars(SortedIndexVs,QueryVars).


%% creates a list of vars of the form [Idx-Name,Idx-Name,...]
indexvars([],[]) :- !.
indexvars([T|L],Vars) :-
	(is_flvariable(T,Name,I) ; is_fltransactionalvariable(T,Name,I)),
	!,
	( %%flora_match_substring(FL_ANON_VAR,Name,0)
	    flratom_char_code(Name,0,CH_ANON_VAR)
	-> indexvars(L,Vars)
	;
          Vars=[I-Name|Vs],
	  remove_named_flvar(L,Name,VL),
	  indexvars(VL,Vs)
        ),
	!.


% an Index-VarName list and creates a list of items ?Name = Varobj.
%% This is used in queries to describe the variable bindings
namevars([],[]) :- !.
namevars([Index-Name|L],[NV|NVs]) :-
	varobj_struct(Name,Index,VCode),
	%% prepend '?' to var names in query answers
	flora_concat_atoms(['?',Name],NewName),
	atomobj_struct(NewName,Index,NCode),
	atomobj_struct(FL_UNIVEQ,FCode),
	prologterm_struct(FCode,2,[NCode,VCode],NV),
	namevars(L,NVs).


/****************************************************************************
  singleton_flvars(+SortedVarsList,-SingletonVars)
  collects all the singleton variables in SortedVarsList into SingletonVars.
  Singleton variables collected here exclude those
  beginning with a underscore and the anonymous.

  remove_named_flvar(+SortedVarsList,+VarName,-Vars)
  Remove variable named Name from SortedVarsList

  remove_dupflvars(+SortedVarsList,-Vars)
  Remove duplicates of variables in SortedVarsList
****************************************************************************/
singleton_flvars([],[]) :- !.

singleton_flvars([V|L],[V|Vs]) :-
	( is_flvariable(V,FL_ANON_VAR,_I)
	; is_fltransactionalvariable(V,FL_ANON_VAR,_I)
	),
	!,
	singleton_flvars(L,Vs).

singleton_flvars([V],[V]) :- !.

singleton_flvars([V1,V2|L],Vars) :-
	( ( is_flvariable(V1,Name,_), is_flvariable(V2,Name,_)
	  ; is_fltransactionalvariable(V1,Name,_),
	      is_fltransactionalvariable(V2,Name,_)
	  )
	-> remove_named_flvar(L,Name,Vs),
	    singleton_flvars(Vs,Vars)
        ;
	  Vars=[V1|Vs],
	  singleton_flvars([V2|L],Vs)
        ),
	!.


%% Removes variables named Name from a sorted list of vars.
%% The var to be removed can be at the top or not at all
remove_named_flvar([V|L],Name,Vars) :-
	(is_flvariable(V,Name,_I) ; is_fltransactionalvariable(V,Name,_I)),
	!,
	remove_named_flvar(L,Name,Vars).
remove_named_flvar(L,_Name,L).

%% real remove duplicate flvars
remove_dupflvars(Vars,VarsOut) :-
	sort(Vars,VarsS),
	remove_dupflvars_aux(VarsS,VarsOut).
remove_dupflvars_aux([],[]) :- !.
remove_dupflvars_aux([H|T],[H|TT]) :-
	(is_flvariable(H,Name,_I) ; is_fltransactionalvariable(H,Name,_I)),
	!,
	remove_named_flvar(T,Name,Vars),
	remove_dupflvars_aux(Vars,TT).


/****************************************************************************
  singleton_warning(+VarList,-WarnList,-WarnTail)
  Warnings are not generated for variables beginning with an underscore.
****************************************************************************/
singleton_warning([],Warn,Warn).

singleton_warning([V|L],WarnList,WarnTail) :-
	(is_flvariable(V,Name,I) ; is_fltransactionalvariable(V,Name,I)),
	!,
	( %%flora_match_substring(FL_ANON_VAR,Name,0)
	  flratom_char_code(Name,0,CH_ANON_VAR)
	->
	    singleton_warning(L,WarnList,WarnTail)
	;
	  compiling_warning(I,SINGLETON_VAR,W),
	  WarnList=[W|T],
	  singleton_warning(L,T,WarnTail)
        ),
	!.


/****************************************************************************
  unbound_warning(+VarList,-WarnList,-WarnTail)
  Warnings are not generated for variables beginning with an underscore.
****************************************************************************/
unbound_warning(VarList,WarnList,WarnTail) :-
	unbound_warning(VarList,WarnList,WarnTail,UNBOUND_VAR).

unbound_warning([],WarnList,WarnList,_).

unbound_warning([V|L],WarnList,WarnTail,WarningMessage) :-
	(is_flvariable(V,Name,I) ; is_fltransactionalvariable(V,Name,I)),
	!,
	( %%flora_match_substring(FL_ANON_VAR,Name,0)
	  flratom_char_code(Name,0,CH_ANON_VAR)
	->
	  unbound_warning(L,WarnList,WarnTail,WarningMessage)
	;
	  compiling_warning(I,WarningMessage,W),
	  WarnList=[W|T],
	  unbound_warning(L,T,WarnTail,WarningMessage)
        ),
	!.


/****************************************************************************
  check_head_vars_for_safety(+HeadTermList,+BodyTerm,-Status)
****************************************************************************/
check_head_vars_for_safety(HeadTermList,BodyTerm,Status) :-
	collect_flvars(HeadTermList,HeadVars),
	collect_flvars(BodyTerm,BodyVars),
	append(HeadVars,BodyVars,Vars),
	sort(Vars,SortedVars), %% singleton_flvars relies on sorting
	singleton_flvars(SortedVars,SingletonVars),
	singleton_warning(SingletonVars,Status,WarnTail),
	subtract_vars(HeadVars,BodyVars,UnboundVars),
	%% Don't issue the unboundedness var warning for facts
	(BodyTerm \== [] -> unbound_warning(UnboundVars,WarnTail,[])
	; var(Status) -> Status = NO_ERRORS
	; WarnTail = []
	),
	!.


/****************************************************************************
  check_udf_vars_for_safety(+Function,+Predicate,+ReturnValue,-Status)
****************************************************************************/
check_udf_vars_for_safety(Function,Predicate,ReturnValue,Status) :-
        collect_flvars([Function,ReturnValue],FuncVars),
        collect_flvars(Predicate,PredVars),
        append(FuncVars,PredVars,Vars),
        sort(Vars,SortedVars), %% singleton_flvars relies on sorting
        singleton_flvars(SortedVars,SingletonVars),
        singleton_warning(SingletonVars,Status,WarnTail),
        subtract_vars(FuncVars,PredVars,UnboundVars),
        %% Don't issue the unboundedness var warning for facts
	%% (facts can be defined using function definition)
        (Predicate == NULL
	-> ( var(Status) -> Status = NO_ERRORS ; true )
        ;
            unbound_warning(UnboundVars,WarnTail,[],UNBOUND_UDF_VAR)
        ),
	!.



/****************************************************************************
    vars_to_var_names(+VarList,-NameList)

 Takes a list of vars from either the parser or compiler
 and returns a list of their names.
 Assumes that the list is indeed a list of vars.

****************************************************************************/
vars_to_var_names([],[]) :- !.
vars_to_var_names([V|VarList],[Name|NameList]) :-
	(is_flvariable(V,Name,_)
	; is_fltransactionalvariable(V,Name,_)
	; is_prvariable(V,Name,_)
	; is_prtransactionalvariable(V,Name,_)
	),
	!,
	vars_to_var_names(VarList,NameList).


/****************************************************************************
  clear_directive
  get_directive(-L)  
  report_directive(+Direct)
  clear_compilation_liboptions
  flora_get_compilation_liboptions(-L)
  report_option(+Option,+Index)
  clear_dynrule_varlist
  report_dynrule_varlist(+Var,+Val)
  get_dynrule_varlist(-L)
  get_dynrule_varlist(+CompileVarList,-L)
****************************************************************************/
/*
clear_directive :- retractall(TMPDIRECT(_)).
get_directive(L) :- findall(D,TMPDIRECT(D),L).
report_directive(Direct) :- assert(TMPDIRECT(Direct)).
*/

%%clear_compilation_liboptions :- flora_retractall_substitute(LIBOPTION(_,_)).
clear_compilation_liboptions :- retractall(LIBOPTION(_,_)).
flora_get_compilation_liboptions(L) :- findall((O,Idx),LIBOPTION(O,Idx),L).
report_option(Option,Idx) :- assert(LIBOPTION(Option,Idx)).

%% Do not(!) check for \+ PERMAOPTION(X) here!
%% So, do NOT use trie indexing!
%% We rely on duplicates if multiple declarations of argumentation theories
set_permaoption(X) :- asserta(PERMAOPTION(X)).
set_permaoptions([]) :- !.
set_permaoptions([X|Rest]) :-
	set_permaoption(X),
	set_permaoptions(Rest).
has_permaoption(X) :- PERMAOPTION(X).
flora_clear_compilation_permaoptions :- retractall(PERMAOPTION(_)).
clear_one_permaoption(X) :- (retract(PERMAOPTION(X)) ; true), !.
%% this is exported for others to use
%%flora_compiler_permaoption(X) :- has_permaoption(X).

set_context(X) :-
	atom(X),
	!,
	flora_set_counter(X,1).
set_context(X) :-
	compound(X),
	!,
	%% it is a trie - so no checking for duplicates
	%% replacing COMPILATION_CONTEXT/1 with interned tries and
	%% deleting tries instead of retractall does not help
	assert(COMPILATION_CONTEXT(X)).
	%%storage:storage_insert_fact(compiler_context,X,_).
set_context(X) :-
	abort(['[Compiler] BUG: ', X, ': invalid compiler context']).

has_context(X) :-
	atom(X),
	!,
	flora_get_counter(X,1).
has_context(X) :-
	compound(X),
	!,
	COMPILATION_CONTEXT(X).
	%%storage:storage_find_fact(compiler_context,X).

clear_context(X) :-
	atom(X),
	!,
	flora_set_counter(X,0).
clear_context(X) :-
	retract(COMPILATION_CONTEXT(X)),
	%%storage:storage_delete_fact(compiler_context,X,_),
	!.
clear_context(_).
clear_contextall(X) :- flora_retractall_substitute(COMPILATION_CONTEXT(X)).
/*
clear_contextall(X) :-
	var(X),
	!,
	storage:storage_delete_all(compiler_context).
clear_contextall(X) :-
	( storage:storage_delete_fact(compiler_context,X,_), fail
	; true
	).
*/

%% this one is exported
flora_compilation_context(X) :- has_context(X).

clear_dynrule_varlist :- flora_retractall_substitute(DYNRULE_VARLIST(_,_)).
report_dynrule_varlist(AttrVar,Val) :-
	asserta(DYNRULE_VARLIST(AttrVar,Val)).
get_dynrule_varlist(L) :- findall((Var,Val),DYNRULE_VARLIST(Var,Val),L).
get_dynrule_varlist(VarList,L) :- findall((Var,Val),(DYNRULE_VARLIST(Var,Val),memberchk(Var,VarList)),L).

%% Report options specified in the :- setsemantics{...} directive
%% Since the argument is a parser list (sans the FLLIST wrapper), we need 
%% to extract the actual values of terms in the list in order to pass
%% to report_options/2.
report_semantic_options([]).
report_semantic_options([H|T]) :-
	is_flplib(H,FlTerm),
	is_flterm(FlTerm,Funct,_N,[Arg|_]),
	is_flatom(Funct,FunctVal,Index),
	is_flatom(Arg,ArgVal),
	Option =.. [FunctVal,ArgVal],
	report_option(Option,Index),
	report_semantic_options(T).


/****************************************************************************
  prepare_to_compile_rule/0
  Called each time we start parsing a new sentence
****************************************************************************/
prepare_to_compile_rule :-
	flora_reset_newvar,
	%%clear_directive,
	%%clear_compilation_liboptions,
	clear_contextall(_),  %% maybe delete?
        clear_dynrule_varlist.

/****************************************************************************
  flora_reset_compiler(+Purpose)

  Purpose: file/shell
  The compiler is reset usially once per file.
****************************************************************************/
flora_reset_compiler(Purpose) :-
	reset_newpredicate,
	reset_rulenum,
	(Purpose == file -> reset_default_ruleid
	; true
	),
	clear_compilation_liboptions,
	flora_clear_compiletime_uriprefixes,
	flora_clear_compilation_symbols,
	reset_newoid.


/****************************************************************************
  flora_compile_add(+ParserTerm,-RuleDiffList,-FactDiffList,-UDFPredsDiffList,-RuleNum+RuleFileName,-Status)

  This is the top level predicate that is called to compile code for
  adding code to module.

  RuleDiffList is a difference list in the form of [...|R]-R. Diff lists
  are used for optimization of append.
  FactDiffList is the same for facts
  UDFPredsDiffList is the same for the list of tabled predicates
****************************************************************************/
flora_compile_add([NULL],R-R,F-F,Q-Q,LQ-LQ,U-U,_,[]) :- !.
	
flora_compile_add(ParserTermList,RuleDiffList,FactDiffList,QueryDiffList,LatentQueryDiffList,UDFPredsDiffList,RuleNum+FileName,Status) :-
#ifdef SHOW_COMPILE_ADD_INPUT
	DBGOUTLN('------------result of parsing-----------------'),
	DBGOUTLN(ParserTerm),
	DBGOUTLN('----------------------------------------------'),
#endif
	prepare_to_compile_rule,
	increment_rule_number,
	ParserTermList = [ParserTerm|_],
	approx_flindex(ParserTerm,RuleIdx),
	(RuleIdx > 0 -> flora_token_rulenum(RuleIdx,RuleNum)
	; RuleNum = -1
	),
	get_current_compile_file(FileName),
	set_context(compiling_for_addition),
	compile_add_list_internal(ParserTermList,
				  RuleDiffList,FactDiffList,
				  QueryDiffList,LatentQueryDiffList,
				  UDFPredsDiffList,
				  Stat1),
	clear_context(compiling_for_addition),
	(ruleoid(_,_,1) -> referenced_once(Stat1,Status) ;  Status=Stat1),
	clear_ruleoid,
#ifdef SHOW_COMPILE_ADD_OUTPUT
	DBGOUTLN('------------result of add_compilation-------------'),
	DBGOUTLN(rules=RuleDiffList),
	DBGOUTLN(facts=FactDiffList),
	DBGOUTLN(queries=QueryDiffList),
	DBGOUTLN(latent_queries=LatentQueryDiffList),
	DBGOUTLN(metafacts=MetaFactDiffList),
	%%DBGOUTLN(udfs =UDFPredsDiffList),
	DBGOUTLN(status=Status),
	DBGOUTLN('--------------------------------------------------'),
#endif
	!.
	
%% This rule is for debugging.
flora_compile_add(ParserTerm,[],[],[],[],[],_,Status) :-
	approx_flindex(ParserTerm,ErrIdx),
	compiling_error(ErrIdx,[UNKNOWN_ERROR,'\n\t\t Details: in flora_compile_add'],Err),
	Status = [Err].


/******************************************************************************
    compile_add_list_internal(+ParserTerm,-RuleDiffList,-FactDiffList,-QueryDiffList,-LatentQueryDiffList,-UDFPredsDiffList,-Status)
******************************************************************************/
compile_add_list_internal([],_R-_R,_F-_F,_Q-_Q,_LQ-_LQ,_U-_U,[]) :- !.

compile_add_list_internal([ParserTerm|ParserTermList],RuleDiffList-RuleTail,FactDiffList-FactTail,QueryList-QueryTail,LatentQueryList-LatentQueryTail,UDFPredsDiffList-UDFTail,Status) :-
	approx_flindex(ParserTerm,RuleIdx),
        compile_descriptor_list([]-RuleIdx,FL_DESCRMODE_ADDRULE,DescriptorIdCode,DescrVarsTerm,MetaFactDiffList,_),
	compile_add_internal(ParserTerm,DescriptorIdCode,DescrVarsTerm,RuleDiffList-RuleTail1,FactDiffList-FactTail1,QueryList-QueryTail1,LatentQueryList-LatentQueryTail1,MetaFactDiffList,UDFPredsDiffList-UDFTail1,Stat1),
	(no_errors_found(Stat1) ->
	    compile_add_list_internal(ParserTermList,RuleDiffList2-RuleTail,FactDiffList2-FactTail,QueryList2-QueryTail,LatentQueryList2-LatentQueryTail,UDFPredsDiffList2-UDFTail,Stat2),
	    RuleTail1 = RuleDiffList2,
	    FactTail1 = FactDiffList2,
	    QueryTail1 = QueryList2,
	    LatentQueryTail1 = LatentQueryList2,
	    UDFTail1 = UDFPredsDiffList2,
	    append(Stat1,Stat2,Status)
	; Status = Stat1
	).

/******************************************************************************
    compile_add_internal(+ParserTerm,+DescriptorIdCode,+DescrVarsTerm,
                         -RuleDiffList,-FactDiffList,-QueryList,
			 -LatentQueryList,
			 ?MetaFactDiffList,-UDFPredsDiffList,-Status) :-

    MetaFactDiffList may be bound or unbound. In case this is called from
          compile_annotated_construct_add, it will be bound.
******************************************************************************/
compile_add_internal(ParserTerm,DescriptorIdCode,DescrVarsTerm,RuleDiffList,FactDiffList,QueryList,LatentQueryList,MetaFactDiffList,UDFPreds-UDFPredsTail,Status) :-
	( is_flrule(ParserTerm,Head,Body) ->
	    compile_rule_add(Head,Body,
			     DescriptorIdCode,DescrVarsTerm,
			     RuleDiffList,
			     FactDiffList,MetaFactDiffList,
			     Status),
	    QueryList = _Q-_Q,
	    LatentQueryList = _LQ-_LQ,
	    UDFPreds=UDFPredsTail

	; is_flfact(ParserTerm,Head) ->
	    compile_fact_add(Head,DescriptorIdCode,DescrVarsTerm,RuleDiffList,FactDiffList,MetaFactDiffList,Status),
	    QueryList = _Q-_Q,
	    LatentQueryList = _LQ-_LQ,
	    UDFPreds=UDFPredsTail

	; is_flquery(ParserTerm,Body) ->
	    compile_query(Body,QueryList,Status),
	    RuleDiffList = _R-_R,
	    LatentQueryList = _LQ-_LQ,
	    FactDiffList = _Fact - _Fact,
	    UDFPreds=UDFPredsTail

	; is_fllatent_query(ParserTerm,Body) ->
	    %% Note: latent queries are always annotated.
	    %% So, this must have been called from
	    %% compile_annotated_construct_add.
	    %% Therefore, MetaFactDiffList must be bound
	    compile_latent_query(DescriptorIdCode,MetaFactDiffList,Body,FL_DESCRMODE_LATENT_ADDQUERY,LatentQueryList,Status),
	    RuleDiffList = _R-_R,
	    QueryList = _Q-_Q,
	    FactDiffList = _Fact - _Fact,
	    UDFPreds=UDFPredsTail

	; is_fldirective(ParserTerm,DirectList,DirctIdx) ->
	    compile_directive_add(DirectList,DirctIdx,RuleDiffList,FactDiffList,Status),
	    QueryList = _Q-_Q,
	    LatentQueryList = _LQ-_LQ,
	    UDFPreds=UDFPredsTail


	; is_flannotated_construct(ParserTerm,Descriptor,MainPartOfRule) ->
	    compile_annotated_construct_add(Descriptor,MainPartOfRule,RuleDiffList,FactDiffList,QueryList,LatentQueryList,Status),
	    UDFPreds=UDFPredsTail

	; is_fludfunction(ParserTerm,Function,Body,ReturnValue) ->
	    compile_udf_definition(Function,Body,ReturnValue,RuleDiffList,FactDiffList,UDFPreds-UDFPredsTail,Status),
	    QueryList = _Q-_Q,
	    LatentQueryList = _LQ-_LQ,
	    MetaFactDiffList = _M-_M

	; is_fludfunctionfact(ParserTerm,Function,Value) ->
	    compile_udf_definition(Function,NULL,Value,RuleDiffList,FactDiffList,UDFPreds-UDFPredsTail,Status),
	    QueryList = _Q-_Q,
	    LatentQueryList = _LQ-_LQ,
	    MetaFactDiffList = _M-_M
        ),
	!.

/****************************************************************************
  compile_rule_add(+Head,+Body,+DescriptorIdCode,+DescrVarsTerm,-RuleDiffList,-FactDiffList,-MetaFactDiffList,-Status)

  DescriptorIdCode is code for a term/object
  FactDiffList is a NULL or a list of codes.

  RuleDiffList is a difference list in the form of [...|R]-R.
  FactDiffList is Facts-Facts == empty diff list
  MetaFactDiffList diff list of meta facts generated from annotations.
                    In this case, it is always empty.
  It is for the optimization of append.
****************************************************************************/
compile_rule_add(Head,Body,DescriptorIdCode,DescrVarsTerm,RuleList-RuleTail,Facts-Facts,MetaFactDiffList,Status):-
	%% Note: DescriptorIdCode here is already compiled code for Id
	%% If FLDYNRULE(H,B,L) comes from the parser, then the
	%% descriptor has the form FLDESCRIPTOR(Id,Type,Index).
	compile_dynrule_main(FL_INSERTRULE_Z,Head,Body,DescriptorIdCode,DescrVarsTerm,MetaFactDiffList,RCode,Status),
	( no_errors_found(Status) -> 
	    list_struct([RCode],[],RListCode),
	    updaterule_syslib(FL_INSERTRULE_Z,UpdateruleLib),
	    approx_flindex(Head,Index),
	    florasyslib_struct(Index,UpdateruleLib,1,[RListCode],SysLibCode),
	    get_dynrule_varlist(L),
	    add_dynrule_attr_code(L,SysLibCode,InsertRuleCode),
	    query_struct(InsertRuleCode,Code),
	    RuleList = [Code|RuleTail]
	;
	    true
        ).

compile_directive_add([],_,R-R,F-F,[]) :- !.

%% Facts-Facts = empty diff list
compile_directive_add([D|L],DirIdx,RuleList-RuleTail,FactDiffList,Status) :-
	compile_direct_add(D,DirIdx,DCodeList,S),
	( no_errors_found(S) -> 
	    append(DCodeList,T,RuleList),
	    compile_directive_add(L,DirIdx,T-RuleTail,FactDiffList,S2),
	    append(S2,S,Status)
	;
	  Status=S
        ),
	!.

compile_direct_add(DirectTerm,_DirIdx,[Code],S) :-
	is_flsetsemantics(DirectTerm,_OptionsList),
	!,
	compile_exec_directive([DirectTerm],NULL,Code1,S),
	query_struct(Code1,Code).

compile_direct_add(DirectTerm,DirIdx,DCodeList,S) :-
	compile_direct(DirectTerm,DirIdx,DCodeList,S).

/****************************************************************************
  compile_annotated_construct_add(+DescriptorList,+MainPartOfRule,-RuleDiffList,-FactDiffList,-QueryList,-LatentQueryList,-Status)

  DescriptorList - list of descriptors
  MainPartOfRule - rule without descriptors
  RuleDiffList is a difference list in the form of [...|R]-R.
		It is used for append/3 optimization
  FactDiffList = the diff list of facts
  MetaFactDiffList - diff list of meta facts generated from annotations
****************************************************************************/
compile_annotated_construct_add(DescriptorList,MainPartOfRule,RuleDiffList,FactDiffList,QueryList,LatentQueryList,Status) :-
	approx_flindex(MainPartOfRule,RuleIdx),
	(is_fllatent_query(MainPartOfRule,_) -> Mode = FL_DESCRMODE_LATENT_ADDQUERY
	; Mode = FL_DESCRMODE_ADDRULE
	),
	compile_descriptor_list(DescriptorList-RuleIdx,Mode,DescrIdCode,DescrVarsTerm,MetaFactDifflist,Status1),
	( no_errors_found(Status1) -> 
	    %% this rule won't bring any new meta facts
	    compile_add_internal(MainPartOfRule,
				 DescrIdCode,DescrVarsTerm,
				 RuleDiffList,FactDiffList,QueryList,LatentQueryList,
				 MetaFactDifflist,
				 _UDFPreds,Status)
	;  Status = Status1
	),
	!.


/****************************************************************************
  flora_compile(+ParserTerm,-RuleDiffList,-SigDiffList,-FactDiffList,-QueryDiffList,-LatentQueryDiffList,-MetaFactDiffList,-UDFPredsDiffList,-RuleNum+RuleFileName,-Status)

  This is the top level procedure that is called to compile code.

  RuleDiffList is a rule difference list in the form of [...|R]-R.
                It is used in order to optimize append.
  SigDiffList - diff list of rule signatures
  FactDiffList is the same for facts
  MetaFactDiffList is a list of meta facts generated from annotations
  UDFPredsDiffList is the same for the list of tabled predicates
****************************************************************************/
flora_compile([NULL],R-R,S-S,F-F,Q-Q,LQ-LQ,M-M,U-U,_,[]) :- !.

flora_compile(ParserTermList,RuleDiffList,SigDiffList,FactDiffList,QueryDiffList,LatentQueryDiffList,MetaFactDiffList,UDFPredsDiffList,RuleNum+FileName,Status) :-
#ifdef SHOW_COMPILE_INPUT
	DBGOUTLN('------------result of parsing-----------------'),
	DBGOUTLN(ParserTermList),
	DBGOUTLN('----------------------------------------------'),
#endif
	prepare_to_compile_rule,
	increment_rule_number,
	ParserTermList = [ParserTerm|_],
	approx_flindex(ParserTerm,RuleIdx),
	(RuleIdx > 0 -> flora_token_rulenum(RuleIdx,RuleNum)
	; RuleNum = -1
	),
	get_current_compile_file(FileName),
	compile_list_internal(ParserTermList,
			      RuleDiffList,SigDiffList,
			      FactDiffList,QueryDiffList,LatentQueryDiffList,
			      MetaFactDiffList,
			      UDFPredsDiffList,
			      Stat1),
	(ruleoid(_,_,1) -> referenced_once(Stat1,Status) ;  Status=Stat1),
	clear_ruleoid,
#ifdef SHOW_COMPILE_OUTPUT
	DBGOUTLN('------------result of compilation-----------------'),
	DBGOUTLN(rules=RuleDiffList),
	DBGOUTLN(signatures=SigDiffList),
	DBGOUTLN(facts=FactDiffList),
	DBGOUTLN(queries=QueryDiffList),
	DBGOUTLN(latent_queries=LatentQueryDiffList),
	DBGOUTLN(metafacts=MetaFactDiffList),
	%%DBGOUTLN(udfs =UDFPredsDiffList),
	DBGOUTLN(status=Status),
	DBGOUTLN('--------------------------------------------------'),
#endif
	!.
	
%% This rule is for debugging.
flora_compile([ParserTerm|_],[],[],[],[],[],[],[],_,Status) :-
	    approx_flindex(ParserTerm,ErrIdx),
	    compiling_error(ErrIdx,[UNKNOWN_ERROR,'\n\t\t Details: in flora_compile'],Err),
	    Status = [Err].


/******************************************************************************
compile_list_internal(+ParserTermList,-RuleDiffList,-SigDiffList,-FactDiffList,-QueryList,-LatentQueryList,-MetaFactDiffList,-UDFPredsDiffList,-Status)
******************************************************************************/
compile_list_internal([],_R-_R,_S-_S,_F-_F,_Q-_Q,_LQ-_LQ,_M-_M,_U-_U,[]) :- !.

compile_list_internal([ParserTerm|ParserTermList],RuleDiffList-RuleTail,SigDiffList-SigTail,FactDiffList-FactTail,QueryList-QueryTail,LatentQueryList-LatentQueryTail,MetaFactDiffList-MetaTail,UDFPredsDiffList-UDFTail,Status) :-
	compile_internal(ParserTerm,_DescriptorIdCode,_DescrVarsTerm,RuleDiffList-RuleTail1,SigDiffList-SigTail1,FactDiffList-FactTail1,QueryList-QueryTail1,LatentQueryList-LatentQueryTail1,MetaFactDiffList-MetaTail1,UDFPredsDiffList-UDFTail1,Stat1),
	(no_errors_found(Stat1) ->
	    compile_list_internal(ParserTermList,RuleDiffList2-RuleTail,SigDiffList2-SigTail,FactDiffList2-FactTail,QueryList2-QueryTail,LatentQueryList2-LatentQueryTail,MetaFactDiffList2-MetaTail,UDFPredsDiffList2-UDFTail,Stat2),
	    RuleTail1 = RuleDiffList2,
	    SigTail1 = SigDiffList2,
	    FactTail1 = FactDiffList2,
	    QueryTail1 = QueryList2,
	    LatentQueryTail1 = LatentQueryList2,
	    MetaTail1 = MetaFactDiffList2,
	    UDFTail1 = UDFPredsDiffList2,
	    append(Stat1,Stat2,Status)
	; Status = Stat1
	).



/******************************************************************************
    compile_internal(+ParserTerm,+DescriptorIdCode,+DescrVarsTerm,-RuleDiffList,
                     -SigDiffList,-FactDiffList,-QueryList,-LatentQueryList,
		     ?MetaFactDiffList,-UDFPreds,-Status)
     This does the main work
     DescriptorIdCode is either a code for an explicit Id or NULL
     DescrVarsTerm = code for vars(Variables of the descriptor list)
     MetaFactDiffList is bound if compile_internal/11 is called from within
            compile_annotated_construct/9 (in this case MetaFactDiffList=[]-[]).
            Otherwise MetaFactDiffList is unbound.
******************************************************************************/
compile_internal(ParserTerm,DescriptorIdCode,DescrVarsTerm,RuleDiffList,SigDiffList,FactDiffList,QueryList,LatentQueryList,MetaFactDiffList,UDFPreds-UDFPredsTail,Status) :-
	( is_flrule(ParserTerm,Head,Body) ->
	    UDFPreds=UDFPredsTail,
	    (var(DescriptorIdCode) ->
		%% MetaFactDiffList is nonvar, if compile_internal is called by
		%% compile_annotated_construct (it is = []-[] then)
		approx_flindex(ParserTerm,RuleIdx),
		compile_descriptor_list([]-RuleIdx,FL_DESCRMODE_RULE,DescriptorIdCode,DescrVarsTerm,MetaFactDiffList,_)
	    ; true
	    ),
	    compile_rule(Head,Body,DescriptorIdCode,DescrVarsTerm,RuleDiffList,SigDiffList,FactDiffList,Status),
	    QueryList = _Q-_Q,
	    LatentQueryList = _LQ-_LQ

	; is_flfact(ParserTerm,Head) ->
	    %% DefaultMetaFactDiffList is empty diff list if Head is a real
	    %% fact. If Head is compliled as a rule then it is the
	    %% default metafact list.
	    %% We have to keep DefaultMetaFactDiffList as an argument to
	    %% compile_fact because we don't know at this pint if ParserTerm
	    %% is going to turn into a rule and thus can't know if
	    %% DefaultMetaFactDiffList will be empty or not.
	    compile_fact(Head,RuleDiffList,SigDiffList,FactDiffList,DefaultMetaFactDiffList,Status),
	    %% currently MetaFactDiffList is always a var here, since annotated
	    %% facts are converted to rules by the parser.
	    %% But in the future this may change, we we take precaution
	    (var(DescriptorIdCode) -> MetaFactDiffList = DefaultMetaFactDiffList
	    ; true
	    ),
	    UDFPreds=UDFPredsTail,
	    QueryList = _Q-_Q,
	    LatentQueryList = _LQ-_LQ

	; is_flquery(ParserTerm,Body) ->
	    UDFPreds=UDFPredsTail,
	    compile_query(Body,QueryList,Status),
	    RuleDiffList = _R-_R,
	    LatentQueryList = _LQ-_LQ,
	    SigDiffList = _S-_S,
	    FactDiffList = _Fact - _Fact,
	    MetaFactDiffList = _M-_M

	; is_fllatent_query(ParserTerm,Body) ->
	    UDFPreds=UDFPredsTail,
	    %% Note: latent queries are always annotated.
	    %% So, this must have been called from
	    %% compile_annotated_construct/9.
	    %% Therefore, MetaFactDiffList must be bound
	    %% This is why we don't bind it further.
	    %% However, we pass an empty diff list to
	    %% compile_latent_query/6 because this is static compile,
	    %% and the needed metafacts will be generated.
	    %% So, FLLIBINSQUERYSIG/7 does not need to.
	    %% Actually, compile_annotated_construct/9 passes []-[] to
	    %% compile_internal/11 anyway.
	    compile_latent_query(DescriptorIdCode,[]-[],Body,FL_DESCRMODE_LATENT_QUERY,LatentQueryList,Status),
	    RuleDiffList = _R-_R,
	    QueryList = _Q-_Q,
	    SigDiffList = _S-_S,
	    FactDiffList = _Fact - _Fact

	; is_fldirective(ParserTerm,DirectList,DirctIdx) ->
	    UDFPreds=UDFPredsTail,
	    compile_directive(DirectList,DirctIdx,RuleDiffList,FactDiffList,Status),
	    QueryList = _Q-_Q,
	    LatentQueryList = _LQ-_LQ,
	    SigDiffList = _S-_S,
	    MetaFactDiffList = _M-_M

	; is_flannotated_construct(ParserTerm,DescriptorList,MainPartOfRule) ->
	    compile_annotated_construct(DescriptorList,MainPartOfRule,RuleDiffList,SigDiffList,FactDiffList,QueryList,LatentQueryList,MetaFactDiffList,Status),
	    UDFPreds=UDFPredsTail

	; is_fludfunction(ParserTerm,Function,Body,ReturnValue) ->
	    compile_udf_definition(Function,Body,ReturnValue,RuleDiffList,FactDiffList,UDFPreds-UDFPredsTail,Status),
	    QueryList = _Q-_Q,
	    LatentQueryList = _LQ-_LQ,
	    SigDiffList = _S-_S,
	    MetaFactDiffList = _M-_M

	; is_fludfunctionfact(ParserTerm,Function,Value) ->
	    compile_udf_definition(Function,NULL,Value,RuleDiffList,FactDiffList,UDFPreds-UDFPredsTail,Status),
	    QueryList = _Q-_Q,
	    LatentQueryList = _LQ-_LQ,
	    SigDiffList = _S-_S,
	    MetaFactDiffList = _M-_M
        ),
	!.

/***************************************************************************
  referenced_once(+Status_rf,-Status)
  finds singleton numbered anon oid and puts warning message in Status
***************************************************************************/
referenced_once(Status_rf,Status) :-
	findall(Index,ruleoid(_,Index,1),IndexList),
	singleton_oid_warning(IndexList,WarnList,[]),
	append(Status_rf,WarnList,Status).


/*************************************************************************
singleton_oid_warning(+SingleOidList,-WarnList,-WarnTail)
***********************************************************************/
singleton_oid_warning([],WarnList,WarnList).

singleton_oid_warning([Index|L],WarnList,WarnTail) :-
	compiling_warning(Index,SINGLETON_OID,W),
	WarnList=[W|T],
	singleton_oid_warning(L,T,WarnTail).


/****************************************************************************
  compile_directive(+DirectList,+DirctIdx,-RuleDiffList,-FactDiffList,-Status)
  compile_direct(+DirectTerm,+DirctIdx,-RuleList,-Status)
****************************************************************************/
compile_directive([],_,R-R,F-F,[]) :- !.

%% Facts-Facts = empty diff list
compile_directive([D|L],DirIdx,RuleList-RuleTail,FactDiffList,Status) :-
	compile_direct(D,DirIdx,DCodeList,S),
	( no_errors_found(S) -> 
	    append(DCodeList,T,RuleList),
	    compile_directive(L,DirIdx,T-RuleTail,FactDiffList,S2),
	    append(S,S2,Status)
	;
	  Status=S
        ),
	!.

compile_direct(DirectTerm,_DirIdx,[Code],Status) :-
	is_flexport_list(DirectTerm,Term),
	compile_export(Term,Direct,Status),
	!,
	directive_struct(Direct,Code).

compile_direct(DirectTerm,DirIdx,[],[]) :-
	is_flindex(DirectTerm,A,P),
	!,
	report_option(FLINDEX(A,P),DirIdx).

compile_direct(DirectTerm,_DirIdx,[Code],[]) :-
	is_verbatim(DirectTerm,Instruction),
	!,
	atomobj_struct(Instruction,InstrCode),
	verbatim_struct(InstrCode,Direct),
	directive_struct(Direct,Code).

compile_direct(DirectTerm,_DirIdx,[],[]) :-
	is_suppress_rulesigns(DirectTerm),
	!,
	%% Right now this DOESN'T affect dynamic rules (neither _add
	%% nor insertrule{...}).
	%% But given this is intended for libraries, we don't need to extend
	%% this option to dynamic rules.
	set_permaoption(FLSUPPRESS_RULESIGNS_OPTION).

%% :- nontabled_module directive
compile_direct(DirectTerm,DirIdx,[],[]) :-
	is_flnontabled_module(DirectTerm),
	!,
	report_option(FLNONTABLEDMOD_OPT,DirIdx).

compile_direct(DirectTerm,DirIdx,[Code],[]) :-
	is_fldefeasible(DirectTerm,Module),
	!,
	is_flatom(Module,Name),
	set_permaoption(FLDEFEASIBLE(Name)),
	%% the next option is reported so that GCLP library would be included,
	%% if the default GCLP theory is used.
	(Name == FL_DEFAULT_DEFEASIBLE_THEORY
	->
	    report_option(FLSYSMOD(FL_DEFAULT_DEFEASIBLE_THEORY),DirIdx)
	; true
	),
	!,
	defeasible_struct(Name,Direct),
	directive_struct(Direct,Code).


compile_direct(DirectTerm,_DirIdx,[],[]) :-
	is_fldefeasible_rule_default(DirectTerm),
	!,
	set_permaoption(FLDEFEASIBLE_RULE_DEFAULT).
	
compile_direct(DirectTerm,_DirIdx,[],[]) :-
	is_flstrict_rule_default(DirectTerm),
	!,
	clear_one_permaoption(FLDEFEASIBLE_RULE_DEFAULT).
	

%% Operator definition. Must also induce executable op definition,
%% to execute in the shell (restricted to "main" module)
compile_direct(DirectTerm,_DirIdx,[Code],Status) :-
	is_flopdef(DirectTerm,P,A,O),
	flora_define_operator(P,A,O),
	compile_exec_directive([FLOPDEF(P,A,O)],NULL,Code1,Status),
	query_struct(Code1,Code),
	!.

compile_direct(DirectTerm,_,[Code],Status) :-
	is_flprolog_directive(DirectTerm,PairList,Idx),
	!,
	verify_symbol_context_pairlist(PairList,Idx, PROLOG_SYMBOL,
				       NONTRANSACTIONAL_SYMBOL,Status),
	maplist(prolog_option(_,_),PairList,PermaOptions),
	make_runtime_modular_prolog_declarations(PermaOptions,Code),
	set_permaoptions(PermaOptions).
%% for sensor predicates, we do not define them as prolog here:
%% this is done by the sensor directive itself.
prolog_option((P,N,_Idx),_) :- 
	has_permaoption(defsensor(P,N)),
	!,
	fail.
prolog_option(P/N/_Idx,_) :- 
	has_permaoption(defsensor(P,N)),
	!,
	fail.
prolog_option((P,N,_Idx),prolog(P,N)) :- 
	!,
	flora_define_modular_prolog(P,N),
	set_permaoption(atomreplacement(P,N,PRMODULARIZEDATOM(P))).
prolog_option(P/N/_Idx,prolog(P,N)) :- 
	flora_define_modular_prolog(P,N),
	set_permaoption(atomreplacement(P,N,PRMODULARIZEDATOM(P))).

compile_direct(DirectTerm,_,[CodeTbl,CodePrlg],Status) :-
	is_fltabledirect(DirectTerm,PredSpecList,Idx),
	!,
	maplist(skip_sensor_spec(_,_),PredSpecList,PredSpecListSansSensors),
	verify_symbol_context_pairlist(PredSpecListSansSensors,Idx,PROLOG_SYMBOL,
				       NONTRANSACTIONAL_SYMBOL,Status),
	maplist(prolog_option(_,_),PredSpecList,PermaOptions),
	make_runtime_modular_prolog_declarations(PermaOptions,CodePrlg),
	set_permaoptions(PermaOptions),
	maplist(table_option(_,_),PredSpecList,TableSpecList),
	list2commalist(TableSpecList,TableSpec),
	table_directive_struct(TableSpec,Direct),
	directive_struct(Direct,CodeTbl).
%% for sensor predicates, the table directive works differently:
%% it creates a sensor predicate name and tables it with arity+2
table_option(P/N/_Idx,PMod/N2) :-
	has_permaoption(defsensor(P,N)),
	%% N+2 because the actual sensor predicate has 2 extra arguments, but
	%% :- table is using the declared # of args in the :- sensor directive
	N2 is N+2,
	!,
	scrambled_atom_struct(P,NO_INDEX,PMod).
table_option(P/N/_Idx,PMod/N1) :-
	N1 is N+1, %% because of the caller argument
	modularized_pratom_struct(P,NO_INDEX,PMod).
skip_sensor_spec(P/N/_Idx,_) :-
	has_permaoption(defsensor(P,N)),
	!,
	fail.
skip_sensor_spec(P/N/Idx,P/N/Idx).

compile_direct(DirectTerm,_,[Code],Status) :-
	is_flusesensordirect(DirectTerm,PairList,Idx),
	!,
	maplist(make_sensor_permaoption(_,_),PairList,PermaOptions),
	set_permaoptions(PermaOptions),
	verify_symbol_context_pairlist(PairList,Idx, USE_SENSOR_SYMBOL,
				       NONTRANSACTIONAL_SYMBOL,Status),
	maplist(strip_pairlist_index(_,_),PairList,PairListSansIdx),
	verbatim_struct(PairListSansIdx,PairListCode),
	thismodule_struct(ThisMod),
	florasyslib_struct(FLLIBRECORDSENSORS,2,[ThisMod,PairListCode],Code1),
	report_option(FLSYSLIB(FLLIBRECORDSENSORS),NO_INDEX),
	query_struct(Code1,Code).
%% used in converting usesensor pred list
make_sensor_permaoption(P/N/_Idx,usesensor(P,N)).
%% strip the index part from pred/arity/idx
strip_pairlist_index(P/N/_Idx,P/N) :- !.
strip_pairlist_index((P,N,_Idx),(P,N)).
%% not used
%%sensor_name_replacement(P/N/_Idx,SP/N) :- flora_scramble_atom(P,SP).


%% Compile-time :- useudf directive.
%% Does not generate any code - just sets options for compilation
compile_direct(DirectTerm,_,[],Status) :-
	is_flusefunctiondirect(DirectTerm,PairList,Idx),
	!,
	verify_symbol_context_pairlist(PairList,Idx, USE_UDF_SYMBOL,
				       NONTRANSACTIONAL_SYMBOL,Status),
	maplist(usefunction_option(_,_),PairList,PermaOptions),
	set_permaoptions(PermaOptions).

usefunction_option(FunName/Arity/_Idx,PermaOption) :-
	flatom_struct(FunName,NO_INDEX,Funct),
	new_udf_predicate(Funct,_FunCompiled,FunNameCode,UDFCode,Arity,_,_NewHead,NewHeadPredName,NewHeadPredArity,_NewReturnValue,NewHeadCode,Status),
	( \+no_errors_found(Status) ->
	    %% TODO:  THIS IS BAD: Need to pass status
	    flora_abort([ERROR_UDF,', ',FunName,'/',Arity],FLORA_ABORT_NOTRACE)
	; true),
	flora_modularize_atom(NewHeadPredName,FLORA_DEFAULT_WORKSPACE,
			      NewHeadPredNameModularized),
	NewHeadPredArity1 is NewHeadPredArity+1,
	(\+current_predicate(NewHeadPredNameModularized/NewHeadPredArity1),
	    compiling_flrshell_command
	->
	    %% TODO: THIS IS BAD: Need to pass status
	    flora_abort([ERROR_UDF_WITHOUT_DEFINITION,', ',FunName,'/',Arity],FLORA_ABORT_NOTRACE)
	; PermaOption = udf_option(FunNameCode,Arity,UDFCode,NewHeadCode),
	    asserta(flora_used_udf_registry(FunNameCode,Arity,UDFCode,NewHeadCode))
	).
	


%% need to also construct a query so that sensor will be registered
%% during the compilation
compile_direct(DirectTerm,_,[Code],Status) :-
	is_flsensordirect(DirectTerm,SensCall,DelayCond),
	!,
	compile_defsensor_direct(SensCall,DelayCond,Direct,S1),
	query_struct(Direct,QueryCode),
	( no_errors_found(S1) -> 
	    flora_intern_code([QueryCode],NULL,PrologCode,S2),
	    ( no_errors_found(S2) -> call(PrologCode)
	    ; true
	    ),
	    directive_struct(Direct,Code),
	    append(S1,S2,Status)
	; Status = S1
	),
	!.

compile_direct(DirectTerm,_Idx,CodeList,[]) :-
	is_flsetsemantics(DirectTerm,OptionsList),
	!,
	is_fllist(OptionsList,L,_T,_I),
	report_semantic_options(L),
	CodeList = [],
	!.

%% prefix definition
compile_direct(DirectTerm,_Idx,[Code],[]) :-
	is_flprefixdef(DirectTerm,PrefixName,PrefixExpansion),
	!,
	FLLIBPREFIXDEF(PrefixName,PrefixExpansion),
	thismodule_struct(ThisModule),
	florasyslib_struct(FLLIBPREFIXDEF,3,[ThisModule,PrefixName,PrefixExpansion],Code1),
	query_struct(Code1,Code).

%% :- compiler_options
compile_direct(DirectTerm,_Idx,Code,Status) :-
	is_flcmpopt(DirectTerm,OptList),
	compile_compiler_options(OptList,Code,Status),
	!.
	
%% :- ignore_depchk
compile_direct(DirectTerm,_Idx,[Code],Status) :-
	is_flignoredep(DirectTerm,SpecList),
        set_context(compile_with_var_module),
	compile_ignoredep_list(SpecList,SCode,Status),
        clear_context(compile_with_var_module),
        !,
	( no_errors_found(Status) -> 
	    ignoredep_struct(SCode,LatentQueryode),
	    directive_struct(LatentQueryode,Code)
        ;   true
        ),
	!.

compile_direct(DirectTerm,_Idx,[Code],Status) :-
	is_importmodule(DirectTerm,Modspec) ->
	compile_body_pathexp(Modspec,FL_THISMODULE,Obj,_Oid,_Cd,[],Status),
	importmodule_struct(Obj,Code1),
	directive_struct(Code1,Code),
	!,
	(is_flbuiltin_identifier(Modspec,MName,Index),
	    flrlibman:flora_system_module(MName)
	-> report_option(FLSYSMOD(MName),Index)
	; true
	),
	!.

compile_direct(DirectTerm,_Idx,[],Status) :-
	is_flsymbolcontext(DirectTerm,SymbolList),
	compile_symbol_context_list(SymbolList,Status).

/****************************************************************************
  compile_ignoredep_list(+SpecList,-CodeList,-Status)
  compile a list of ignoredep sepcifications
****************************************************************************/
compile_ignoredep_list([],[],[]) :- !.
compile_ignoredep_list([H|L],[HCode|LCode],Status) :-
        compile_body(H,HCode,S),
	( no_errors_found(S) -> compile_ignoredep_list(L,LCode,Status)
        ;
            Status = S
        ),
	!.

/****************************************************************************
  Compile :- flora_compiler_options(OptList)
****************************************************************************/
compile_compiler_options([],[],[]) :- !.
compile_compiler_options([Opt|Rest],Code,Status) :-
	compile_compiler_option(Opt,OptCode,S1),
	(S1 == NO_ERRORS ->
	    compile_compiler_options(Rest,RestCode,Status),
	    (OptCode == [] -> Code = RestCode
	    ; Code = [OptCode|RestCode]
	    )
	; Status = S1
	).

compile_compiler_option(Opt,OptCode,Status) :-
	( %% suppress trace info due to performance reasons
	    is_flatom(Opt,FL_PRODUCTION) -> set_production_mode(on),
	    OptCode = [],
	    Status = NO_ERRORS
	%% turn devel mode on
	; is_flatom(Opt,FL_DEVELOPMENT) -> set_production_mode(off),
	    OptCode = [],
	    Status = NO_ERRORS
	;  %% Prolog compiler options of the form prolog(opt,opt,...)
	    is_flplib(Opt,FltermOpt),
	    is_flterm(FltermOpt,Funct,_N,PrologOptList),
	    is_flatom(Funct,prolog)
	->
	    compile_body_pathexplist(PrologOptList,FL_THISMODULE,OptListCode,_,_,[],Status),
	    cmpopt_struct(OptListCode,PrCode),
	    directive_struct(PrCode,OptCode)
	;
	    approx_flindex(Opt,Index),
	    compiling_error(Index,ERROR_CMPOPT,Err),
	    Status = [Err]
	).

set_production_mode(on) :-
	set_permaoption(no_trace_info).
set_production_mode(off) :-
	clear_one_permaoption(no_trace_info).

/****************************************************************************
  compile_symbol_context_list(+SymbolsList,-Status)
  compile a list of symbols for which compiler does NOT check context usage
****************************************************************************/
compile_symbol_context_list([],[]) :- !.
compile_symbol_context_list([H|L],Status) :-
        compile_symbol_literal(H,S),
	( no_errors_found(S) -> compile_symbol_context_list(L,Status)
        ;
            Status = S
        ),
	!.

/****************************************************************************
  compile_symbol_literal(+ParserTerm,-Status)
  compile_symbol_literal(+ParserTerm,+Context,-Status)
  compile a symbol for which compiler does NOT check context usage
****************************************************************************/
compile_symbol_literal(ParserTerm,Status) :-
	( is_fltransactionalterm(ParserTerm,Funct,N,Args) ->
	    compile_symbol_term(Funct,N,Args,FL_THISMODULE,FUNCTION_SYMBOL,TRANSACTIONAL_SYMBOL,Status)
	; is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_symbol_term(Funct,N,Args,FL_THISMODULE,FUNCTION_SYMBOL,NONTRANSACTIONAL_SYMBOL,Status)
	; is_flatom(ParserTerm,_Atom) ->
	    compile_symbol_term(ParserTerm,0,NULL,FL_THISMODULE,FUNCTION_SYMBOL,NONTRANSACTIONAL_SYMBOL,Status)
	; is_fltransactionalatom(ParserTerm,_Atom) ->
	    compile_symbol_term(ParserTerm,0,NULL,FL_THISMODULE,FUNCTION_SYMBOL,TRANSACTIONAL_SYMBOL,Status)
	; is_fltransactionaltermdescriptor(ParserTerm,Funct,Arity) ->
	    compile_symbol_term(Funct,Arity,NULL,FL_THISMODULE,ANY_SYMBOL_CONTEXT,TRANSACTIONAL_SYMBOL,Status)
	; is_fltermdescriptor(ParserTerm,Funct,Arity) ->
	    compile_symbol_term(Funct,Arity,NULL,FL_THISMODULE,ANY_SYMBOL_CONTEXT,NONTRANSACTIONAL_SYMBOL,Status)
	; is_fludfsymbol(ParserTerm,Term) ->
	    compile_symbol_literal(Term,FL_THISMODULE,UDF_SYMBOL,Status)
	; is_flsensorsymbol(ParserTerm,Term) ->
	    compile_symbol_literal(Term,FL_THISMODULE,SENSOR_SYMBOL,Status)
	; is_flprlgsymbol(ParserTerm,Term) ->
	    compile_symbol_literal(Term,FL_THISMODULE,PROLOG_SYMBOL,Status)
	; is_flworkspace(ParserTerm,Term,WS) ->
	    compile_symbol_literal(Term,WS,PREDICATE_SYMBOL,Status)
	; is_flfloralib(ParserTerm,Term,WS) ->
	    compile_symbol_literal(Term,WS,PREDICATE_SYMBOL,Status)
	;
	    approx_flindex(Funct,Index),
	    compiling_error(Index,ERROR_SYMBOL,Err),
	    Status = [Err]
	),
	!.

compile_symbol_literal(ParserTerm,WS,Context,Status) :-
	( is_fltransactionalterm(ParserTerm,Funct,N,Args) ->
	    compile_symbol_term(Funct,N,Args,WS,Context,TRANSACTIONAL_SYMBOL,Status)
	; is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_symbol_term(Funct,N,Args,WS,Context,NONTRANSACTIONAL_SYMBOL,Status)
	; is_flatom(ParserTerm,_Atom) ->
	    compile_symbol_term(ParserTerm,0,NULL,WS,Context,NONTRANSACTIONAL_SYMBOL,Status)
	; is_fltransactionalatom(ParserTerm,_Atom) ->
	    compile_symbol_term(ParserTerm,0,NULL,WS,Context,TRANSACTIONAL_SYMBOL,Status)
	;
	    approx_flindex(Funct,Index),
	    compiling_error(Index,ERROR_SYMBOL,Err),
	    Status = [Err]
	),
	!.

/****************************************************************************
  compile_symbol_term(+Funct,+N,+Args,+WS,+Context,+Transactional,-Status)
****************************************************************************/
compile_symbol_term(Funct,0,_Args,FL_THISMODULE,_Context,NONTRANSACTIONAL_SYMBOL,[]) :-
	flora_get_flatomvar_name(Funct,FLORA_WARNOFF),
	set_turnoff_symbol_warnings_flag(FLORA_WARNOFF),
	!.

compile_symbol_term(Funct,0,_Args,FL_THISMODULE,_Context,NONTRANSACTIONAL_SYMBOL,[]) :-
	flora_get_flatomvar_name(Funct,FLORA_CONSTOFF),
	set_turnoff_symbol_warnings_flag(FLORA_CONSTOFF),
	!.

compile_symbol_term(Funct,N,Args,WS,Context,Transactional,Status) :-
	flora_get_flatomvar_name(Funct,Name),
	(symbol_star_argument(Args) ->
		(N==1 ->
		    add_nowarn_symbol(Name,FL_STAR,WS,Context,Transactional),
		    Status = NO_ERRORS
		;
		    approx_flindex(Funct,Index),
		    compiling_error(Index,ERROR_SYMBOL_CONTEXT_STAR_ARG,Err),
		    Status = [Err]
		)
	;
		add_nowarn_symbol(Name,N,WS,Context,Transactional),
		Status = NO_ERRORS
	).

/****************************************************************************
  symbol_star_argument(+Args)
****************************************************************************/
symbol_star_argument([HArg]) :-
	flora_get_flatomvar_name(HArg,ArgName),
	ArgName==FL_STAR,
	!.

symbol_star_argument([HArg,_TArgs]) :-
	flora_get_flatomvar_name(HArg,ArgName),
	ArgName==FL_STAR,
	!.

symbol_star_argument([_HArg,TArgs]) :-
	symbol_star_argument(TArgs).

/****************************************************************************
  compile_atomvar(+T,-Code)

  T is a variable structure, or an atom structure, or a plain atomic.
****************************************************************************/
compile_atomvar(T,Code) :-
	( is_flvariable(T,TName,I) -> varobj_struct(TName,I,Code)
	; 
	    atomobj_struct(T,Code)
	),
	!.

/****************************************************************************
   compile_defsensor_direct(+SensCall,+DelayCond,-Direct,-Status)

   Compile a sensor directive.
****************************************************************************/
compile_defsensor_direct(SensCall,DelayCond,Code,Status) :-
	(flprologlib_atom_arity(SensCall,SensName,SensArity)
	%% sensor defined in a .flr file: declare it as prolog
	->
	    flora_scramble_atom(SensName,SensNameWithFloraPrefix),
	    set_permaoption(atomreplacement(SensName,SensArity,SensNameWithFloraPrefix)),
	    %% temporarily record as sensor
	    set_permaoption(defsensor(SensName,SensArity))
	; flprologlib_atom_arity_mod(SensCall,SensName,SensArity,ModName),
	    %% sensor defined in a prolog module
	    %%SensArity2 is SensArity+2,
	    set_permaoption(defsensor(SensName,SensArity,ModName))
	    %%flora_define_prolog(SensName,SensArity2,ModName)
	),
	set_context(compiling_sensor_directive(SensName,SensArity)),
	%% flprologlib_call converts flplib into flterm.
	%% This is needed because atomreplacement takes place in
	%% termlit_struct, which takes flterm's.
	flprologlib_call(SensCall,SensFLtermCall),
	compile_body_literal(SensFLtermCall,FL_THISMODULE,OidCode,WSCode,[],S1),
	conjunct_code([OidCode,WSCode],SensCode),
	(no_errors_found(S1) ->
	    detach_flworkspace(DelayCond,DelayCondSansWS,WS),
	    compile_body_literal(DelayCondSansWS,WS,DelayOidCode,DelayWSCode,[],S2),
	    conjunct_code([DelayOidCode,DelayWSCode],DelayCheckCode)
	; S2 = S1
	),
	(no_errors_found(S2) ->
	    %% record symbol as sensor symbol, for error checking
	    flprologlib_functor(SensCall,SensFunct),
	    verify_symbol_context(SensFunct,SensArity,
				  SENSOR_SYMBOL,NONTRANSACTIONAL_SYMBOL,
				  Status)
	; Status = S2
	),
	!,
	report_option(FLSYSLIB(FLLIBSENSOR),NO_INDEX),
	prologterm_struct(FLLIBREGISTERSENSOR,2,[SensCode,DelayCheckCode],Code),
	clear_context(compiling_sensor_directive(SensName,SensArity)).
	


/****************************************************************************
  compile_fact(+Head,+DescriptorIdCode,+DescrVarsTerm,-RuleDiffList,-SigDiffList,-FactDiffList,-MetaFactDiffList,-Status)
  compile_fact_add(+Head,+DescriptorIdCode,+DescrVarsTerm,-RuleDiffList,-SigDiffList,-FactDiffList,-MetaFactDiffList,-Status)

  RuleDiffList is a difference list in the form of [...|R]-R.
		It is used to optimize append
  SigDiffList list of insert rule signature commands.
               These are executed prior to loading
  FactDiffList is a difference list of facts

  Note: a fact containing a path expression might cause this
        fact to become a rule. However, we strip annotations from facts in
	the parser, so no need here to take rule tag/meta info into account.
****************************************************************************/
compile_fact(Head,RuleDiffList,SigDiffList,FactDiffList,MetaFactDiffList,Status) :-
	set_context(compiling_facts),
	compile_head(Head,HeadCode,H2BCodeHead,H2BCodeTail,HeadStat),
	!,
	( no_errors_found(S) ->
	    ( H2BCodeHead == NULL, H2BCodeTail == NULL ->
		compile_factlist(Head,HeadCode,RuleDiffList,FactDiffList,S2),
		SigDiffList = _Sign-_Sign,
		MetaFactDiffList = _M-_M
	    ; %% fact became static rule
	        compile_conjunct2list(HeadCode,HeadCodeList),
		get_dynrule_varlist(L),
		conjunct_code([H2BCodeHead,H2BCodeTail],H2BCode),
		add_dynrule_attr_code(L,H2BCode,BodyCode),
		%% no explicit id given: just generate new rule id
		approx_flindex(Head,RuleIdx),
		compile_descriptor_list([]-RuleIdx,FL_DESCRMODE_RULE,DescrIdCode,DescrVarsTerm,MetaFactDiffList,_),
		split_ruleheads_add_rulesig(HeadCodeList,
					    BodyCode,FL_TRUE,FL_TRUE,
					    DescrIdCode,DescrVarsTerm,
					    RuleDiffList,
					    SigDiffList,
					    []),
		FactDiffList = _F-_F, %% empty fact diff list
		(has_context(compiling_udf_definition) -> S2 = NO_ERRORS
		%% for UDFs, variables are checked separately
		; check_head_vars_for_safety(Head,[],S2)
		)
	    ),
	    append(HeadStat,S2,Status)
        ;
	  Status=S
	),
	!,
	clear_context(compiling_facts).

compile_fact_add(Head,DescriptorIdCode,DescrVarsTerm,RuleDiffList,FactDiffList,MetaFactDiffList,Status) :-
	set_context(compiling_facts), 
	compile_head(Head,HeadCode,H2BCodeHead,H2BCodeTail,S),
	!,
	( no_errors_found(S) ->
	    ( H2BCodeHead == NULL, H2BCodeTail == NULL ->
		compile_factlist(Head,HeadCode,RuleDiffList,FactDiffList,S2),
		MetaFactDiffList = _M-_M
	    ; %%% fact became a rule due to code in arguments: compile as a rule
	        %% if compiling for addition, just insert the rule: no need
		%% to add signature, as signatures are added when such rules
		%% are inserted at compile time
		flatom_struct(FL_TRUE,NO_INDEX,H2BflCode),
		%% no explicit id given: just generate new rule id
		compile_rule_add(Head,H2BflCode,
				 DescriptorIdCode,DescrVarsTerm,
				 RuleDiffList,FactDiffList,
				 MetaFactDiffList,S2)
	    ),
	    append(S,S2,Status)
        ;
	  Status=S
	),
	!,
	clear_context(compiling_facts).


/****************************************************************************
  compile_factlist(+FactList,+FactListCode,-RuleDifferenceList,-FactDifferenceList,-Status)

  This predicate takes a conjunction of atoms and splits into a
  difference list.

  If a fact is declared as a prolog term, it is put into the rule list,
  so it would be dumped as a normal Prolog fact rather than be put in a trie.
****************************************************************************/
compile_factlist(FactList,FactListCode,RuleDifferenceList,FactDifferenceList,Status) :-
	compile_factlist1(FactListCode,RuleDifferenceList,FactDifferenceList),
	( %% UDF vars are checked elsewhere
	    has_context(compiling_udf_definition) -> Status = NO_ERRORS
	; %% check fact vars for safety
	    collect_flvars(FactList,HeadVars), HeadVars \== []
	-> %% for facts we can do a fast check for var safety
	    unbound_warning(HeadVars,S1,[],UNBOUND_VAR_IN_FACT),
	    singleton_flvars(HeadVars,SingletonVars),
	    singleton_warning(SingletonVars,S2,[]),
	    append(S1,S2,Status)
	;  Status = NO_ERRORS
	).
compile_factlist1(NULL,RuleList-RuleList,FactList-FactList) :- !.

compile_factlist1(ConjunctCode,RuleList-RuleListTail,FactList-FactListTail) :-
	conjunct_struct(F1,F2,ConjunctCode),
	!,
	compile_factlist1(F1,RuleList-RT,FactList-FT),
	compile_factlist1(F2,RT-RuleListTail,FT-FactListTail).

%% this is for fact-predicates that the compiler defines as prolog
%% using flora_define_prolog
compile_factlist1(F,[FCode|ListTail]-ListTail,FL-FL) :-
	is_prologterm(F),
	!,
	(has_context(compiling_for_addition)
	->
	    generate_prolog_liblit(assert,1,[F],FCode1),
	    query_struct(FCode1,FCode)
	; fact_struct(F,FCode)
	),
	!.

%% these are just facts, nothing special
compile_factlist1(F,RL-RL,[FCode|ListTail]-ListTail) :-
	!,
        collect_prvars(F,FVars),
        get_dynrule_varlist(FVars,L),
        %%sort(L,NL), %% sorting does nothing here
	NL = L,
        ( NL == [] -> fact_struct(F,FCode)
        ;
            add_fact_attr_code(NL,F,AugmentedF),
            fact_struct(AugmentedF,FCode)
        ),
	!.

add_dynrule_attr_code([],Code,Code) :- !.
add_dynrule_attr_code([(Var,Val)|L],BCode,NewCode) :-
	attrvar_code(Var,Val,FLDYNRULEVARCHECK,Code),
        add_dynrule_attr_code(L,BCode,LCode),
        conjunct_struct(Code,LCode,NewCode).

%% This is used when a rule appears in a fact (as a reified subterm).
%% In this case, we prepend a var_val(Var,Val) pair to the code.
%% In flrutils.P, flora_put_attr_and_insert_fact will execute
%% put_attr(Var,FLDYNRULEVARCHECK,Val) before asserting the fact.
%% If this rule is then ever inserted, its variables will be chacked
%% for singletons and safety.
add_fact_attr_code([],Code,Code) :- !.
add_fact_attr_code([(Var,Val)|L],BCode,NewCode) :-
	attrvar_code_delayed(Var,Val,FLDYNRULEVARCHECK,Code),
        add_fact_attr_code(L,BCode,LCode),
        conjunct_struct(Code,LCode,NewCode).

attrvar_code(Var,Val,AttrName,Code) :-
	atomobj_struct(flora_put_attr,PutAttrFunct),
        atomobj_struct(AttrName,AttrCode),
        prologterm_struct(PutAttrFunct,3,[Var,AttrCode,Val],flrwhen,VCode),
        prologliblit_struct(VCode,Code).

%% This version creates record that will enable flrutils.P
%% flora_put_attr_and_insert_fact to create attributed variables
%% at insertion time
attrvar_code_delayed(Var,Val,AttrName,Code) :-
	atomobj_struct(var_val,VarValFunct), %% this is utilized in flrutils.P
        prologterm_struct(VarValFunct,3,[Var,AttrName,Val],Code).

/****************************************************************************
  compile_query(+Body,-QueryDiffList,-Status)

  QueryDiffList is a difference list in the form of [...|R]-R.
	It is used to optimize append/3
****************************************************************************/
compile_query(Body,_,[Err]) :-
	is_flterm(Body,Funct,2,_),
	is_flatom(Funct,FL_IMPLYOP,Idx),
	!,
	compiling_error(Idx,RULE_IN_PLACE_OF_QUERY,Err).
compile_query(Body,_,[Err]) :-
	is_flterm(Body,Funct,1,_),
	is_flatom(Funct,Sym,Idx),
	memberchk(Sym,[FL_IMPLYOP,FL_QUERYOP,FL_LATENT_QUERYOP]),
	!,
	compiling_error(Idx,SPURIOUS_SYMBOL,Err).
compile_query(Body,QueryList-QueryTail,Status) :-
	compile_body_top(Body,BCode,Status),
	( no_errors_found(Status) -> 
	    collect_prdatatypevars(BCode,DTVarsCode),
	    append(DTVarsCode,[BCode],BCode1),
	    conjunct_code(BCode1,BCode2),
            get_dynrule_varlist(L),
	    %% sets attributed variables for the checker of
	    %% vars in dynamic rules
            add_dynrule_attr_code(L,BCode2,BodyCode),
	    thismodule_struct(ThisMod),
	    %% code to bind the Caller variable to the calling module
	    caller_binding_code(ThisMod,CallerBindingCode),
	    conjunct_struct(CallerBindingCode,BodyCode,AugmentedBodyCode),
	    collect_name_var_pairs(Body,NV),
	    list_struct(NV,[],NVCode),
	    %% Note: we do not add delay-checker code FLORA_DELAY_CHECKER
	    %% in queries, since it is explicit in FLLIBANSWER
	    florasyslib_struct(FLLIBANSWER,2,[AugmentedBodyCode,NVCode],Goal),
	    query_struct(Goal,QueryCode),
	    %% The commented part would be used if we used import
	    %%get_directive(DirectCodeList),
	    %%append(DirectCodeList,[QueryCode|QueryTail],QueryList)
	    QueryList = [QueryCode|QueryTail]
	;
	  true
	),
	!.

/******************************************************************************
    compile_latent_query(+DescrIdCode,+MetaFactDiffList,+Body,+Mode,-LatentQueryDiffList,-Status)
******************************************************************************/
compile_latent_query(DescrIdCode,MetaFactDiffList,Body,Mode,LatentQueryList-LatentQueryTail,Status) :-
	compile_body_top(Body,BCode,Status),
	( no_errors_found(Status) -> 
	    collect_prdatatypevars(BCode,DTVarsCode),
	    append(DTVarsCode,[BCode],BCode1),
	    conjunct_code(BCode1,LatentQueryBodyCode),
	    thismodule_struct(ThisMod),
	    %% code to bind the Caller variable to the calling module
	    caller_binding_code(ThisMod,CallerBindingCode),
	    construct_rule_enabling_test(DescrIdCode,Mode,LatentQueryEnablerTest,_),
	    conjunct_code([CallerBindingCode,LatentQueryEnablerTest],PreLatentQueryCode),
	    get_current_compile_file(File),
	    (approx_prindex(DescrIdCode,Idx), Idx > 0 -> true
	    ; approx_prindex(Body,Idx)
	    ),
	    flora_token_rulenum(Idx,RuleNum), %% rulenum within file
	    MetaFactDiffList = MetaFactList - [],
	    list_struct(MetaFactList,[],MetaFactCode),
	    %% Note: we do not add delay-checker code FLORA_DELAY_CHECKER
	    %% in constraints, since it is explicit in FLLIBANSWER
	    florasyslib_struct(FLLIBINSQUERYSIG,7,[DescrIdCode,File,ThisMod,RuleNum,MetaFactCode,PreLatentQueryCode,LatentQueryBodyCode],LatentQuerySigCodePre),
	    (has_context(goal_reification) -> LatentQuerySigCode = LatentQuerySigCodePre
	    ; query_struct(LatentQuerySigCodePre,LatentQuerySigCode)
	    ),
	    LatentQueryList = [LatentQuerySigCode|LatentQueryTail]
	;
	  true
	),
	!.


/****************************************************************************
  compile_annotated_construct(+DescriptorList,+MainPartOfRule,-RuleDiffList,-SigDiffList,-FactDiffList,-QueryList,-LatentQueryList,-MetaFactDiffList,-Status)

  RuleDiffList is a difference list in the form of [...|R]-R.
		It is used for append/3 optimization
  SigDiffList = diff list of rule signatures
  FactDiffList = the diff list of facts
		 FactList includes meta-facts
****************************************************************************/
compile_annotated_construct(DescriptorList,MainPartOfRule,RuleDiffList,SigDiffList,FactDiffList,QueryList,LatentQueryList,MetaFacts-MetaFactsTail,Status) :-
	approx_flindex(MainPartOfRule,RuleIdx),
	(is_fllatent_query(MainPartOfRule,_) -> Mode = FL_DESCRMODE_LATENT_QUERY
	; Mode = FL_DESCRMODE_RULE
	),
	compile_descriptor_list(DescriptorList-RuleIdx,Mode,DescrIdCode,DescrVarsTerm,MetaFacts-MetaFactsTail,Status1),
	( no_errors_found(Status1) -> 
	    %% this rule won't bring any new meta facts
	    compile_internal(MainPartOfRule,DescrIdCode,DescrVarsTerm,
			     RuleDiffList,SigDiffList,
			     FactDiffList,QueryList,LatentQueryList,
			     []-[],
			     _UDFPreds,Status)
	;  Status = Status1
	),
	!.


/*
 compile_descriptor_list(+DescriptorList-RuleIdx,+Mode,-DescrIdCode,-DescrVarsTermOut,
                         -MetaFactDiffList,-Status)
 Mode - FL_DESCRMODE_RULE/FL_DESCRMODE_PLAIN_QUERY/FL_DESCRMODE_DYNRULE.
        The FL_DESCRMODE_PLAIN_QUERY mode is used for the @!{...} queries.
        The FL_DESCRMODE_CLAUSE mode is used for the clause{...} construct.
        FL_DESCRMODE_DYNRULE is for dynamic rules.
 DescrVarsTermOut normally is output as vars(VariablesInDescriptorList)
 If DescrVarsTermOut is bound then we assume that we are compiling
     for the clause{....} statement and so we pass a new unbound variable to
     compile_descriptor_list1, so MetaFacts will have unbound variable as arg 2.
     This is what we need for clause{....}
*/
compile_descriptor_list(DescriptorList-RuleIdx,Mode,DescrIdCode,DescrVarsTermOut,MetaFacts-MetaFactsTail,Status) :-
	flatten(DescriptorList,FlatDescrList),
	%% First, extract the code for the rule id
	findall(IdParserTerm-Idx,
		member(FLDESCRIPTOR(IdParserTerm,FLRULEID,Idx),FlatDescrList),
		IdParserTermList),
	!,
	set_context(no_symbol_check),
	set_context(compiling_descriptors(Mode)),
	(length(IdParserTermList,Len), Len > 1
	-> IdParserTermList = [_,_-Idx|_],
	    compiling_error(Idx,MULTIPLE_RULE_IDS,Err),
	    IdStatus = [Err]
	; IdParserTermList == [] % no explicit rule id
	-> construct_default_ruleid_descriptor(Mode,RuleIdx,DescrIdCode),
	    RuleidFrameCode = _M - _M,
	    ExplicitModule = NULL,
	    IdStatus = NO_ERRORS
	; IdParserTermList = [[IdParserTerm|_] - Idx],
	    %% compile Id descriptor here
	    compile_ruleid_descriptor(IdParserTerm,DescrIdCode,RuleidFrameCode,ExplicitModule,IdStatus)
	),
	(memberchk(Mode,[FL_DESCRMODE_RULE,FL_DESCRMODE_ADDRULE,FL_DESCRMODE_DYNRULE,FL_DESCRMODE_LATENT_QUERY,FL_DESCRMODE_LATENT_ADDQUERY,FL_DESCRMODE_LATENT_DYNQUERY,FL_DESCRMODE_UDFRULE])
	->
	    collect_flvars(FlatDescrList,DescrVars),
	    compile_var_list(DescrVars,DescrVarsCode),
	    length(DescrVarsCode,VarListLen),
	    %% construct the term containing all the vars in the descriptor
	    generate_prolog_liblit(FL_DESCRIPTOR_VARS_WRAPPER,VarListLen,DescrVarsCode,DescrVarsTermOut)
	%% we are compiling clause{...} or a query
	%% Generate a var in this case
	;   new_prvariable(NO_INDEX,DescrVarsTermOut)
	),
	get_current_compile_file_for_descriptor(CurrFileName,Mode),
	get_descriptor_module(ExplicitModule,Mode,DescrModule),
	(IdStatus == NO_ERRORS, Mode \== FL_DESCRMODE_UDFRULE
	->
	    extract_features_from_descriptor_list(FlatDescrList,DescrFeatures),
	    determine_defeasibility(DescrFeatures,Mode,DescrIdCode,CurrFileName,DescrModule,DescrVarsTermOut,DefeatMetaFact,StatDefeat),
	    (StatDefeat = NO_ERRORS ->
		compile_descriptor_list1(FlatDescrList,Mode,DescrIdCode,CurrFileName,DescrModule,RuleidFrameCode,DescrVarsTermOut,MetaFacts1-MetaFactsTail,Status),
		construct_rule_enabling_fact(DescrIdCode,CurrFileName,Mode,RuleEnablerFact),
		%% make the rule id into its tag as well, if no explicit tag
		(memberchk(FLTAG_FEATURE,DescrFeatures) -> TagIdMetaFact = NULL
		; construct_tag_descriptor_fact_from_id(DescrIdCode,CurrFileName,DescrModule,Mode,DescrVarsTermOut,TagIdMetaFact)
		),
		%% mandatory facts that are always there
		construct_type_descriptor_fact(DescrIdCode,CurrFileName,DescrModule,Mode,DescrVarsTermOut,TypeMetaFact),
		MetaFacts_pre = [TypeMetaFact,TagIdMetaFact,RuleEnablerFact,DefeatMetaFact|MetaFacts1],
		remove_all(NULL,MetaFacts_pre,MetaFacts)
	    ; Status = StatDefeat
	    )
	%% either status of Id is bad or it is udfrule,
	%% so no metafacts are to be generated
	; Status = IdStatus,
	    MetaFacts = []
	),
	clear_context(compiling_descriptors(Mode)),
	clear_context(no_symbol_check).



/*
    determine_defeasibility(+FlatDescrList,+Mode,+DescrIdCode,+CurrFileName,+DescrModule,+DescrVarsTerm,-DefeatMetaFact,-Status)

    If more than one defeasibility descriptor - error
    If exactly one defeasibility descriptor - noop.
          Note: tag+strict is allowed because one might turn
	        defeasibility on later
    If no defeasibility specified:
          If tag is specified, assume defeasible.
          Otherwise: assume strict.
*/
%% If Mode=FL_DESCRMODE_CLAUSE/FL_DESCRMODE_PLAIN_QUERY then don't produce defeasibility fact
determine_defeasibility(_Features,Mode,_DescrIdCode,_FileName,_Module,_DescrVarsTerm,NULL,[]) :-
	memberchk(Mode,[FL_DESCRMODE_CLAUSE,FL_DESCRMODE_PLAIN_QUERY,FL_DESCRMODE_LATENT_QUERY,FL_DESCRMODE_LATENT_DYNQUERY,FL_DESCRMODE_LATENT_ADDQUERY]),
	!.
determine_defeasibility(DescrFeatures,Mode,DescrIdCode,FileName,Module,DescrVarsTerm,DefeatMetaFact,Status) :-
	memberchk(Mode,[FL_DESCRMODE_RULE,FL_DESCRMODE_DYNRULE,FL_DESCRMODE_ADDRULE]),
	!,
	(memberchk(FL_DEFEASIBLE,DescrFeatures),
	    memberchk(FL_STRICT,DescrFeatures)
	->
	    approx_prindex(DescrIdCode,ErrIdx),
	    compiling_error(ErrIdx,MULTIPLE_RULE_DEFEASIBILITY_INDICATORS,Err),
	    Status = [Err]
	; \+ has_permaoption(FLDEFEASIBLE(_ArgTheory)),
	    memberchk(FL_DEFEASIBLE,DescrFeatures)
	-> %% defeasible is specified but no :- use_argumentation_theory
	    approx_prindex(DescrIdCode,ErrIdx),
	    compiling_error(ErrIdx,DEFEASIBLE_RULE_BUT_NO_ARGUMENTATION_THEORY,Err),
	    Status = [Err]
	; (memberchk(FL_DEFEASIBLE,DescrFeatures) ; memberchk(FL_STRICT,DescrFeatures))
	-> DefeatMetaFact = NULL, %% already specified
	    Status = NO_ERRORS
	; (memberchk(FLTAG_FEATURE,DescrFeatures) ; has_permaoption(FLDEFEASIBLE_RULE_DEFAULT))
	->
	    %% If TAG is given, assume rule is defeasible by default
	    %% If rules are defeasible by default, also assume defeasible rule
	    flatom_struct(FL_DEFEASIBLE,NO_INDEX,DefeasibleDescr),
	    construct_bool_descriptor_facts(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,DefeasibleDescr,[DefeatMetaFact|Tail]-Tail,Status)
	;  %% otherwise, assume rule is strict
	    flatom_struct(FL_STRICT,NO_INDEX,StrictDescr),
	    construct_bool_descriptor_facts(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,StrictDescr,[DefeatMetaFact|Tail]-Tail,Status)
	).


%% extract a list of interesting features from FlatDescrList.
%% features include: tag, strict, defeasible
extract_features_from_descriptor_list(DescrList,Features) :-
	extract_features_from_descriptor_list1(DescrList,Features1),
	flatten(Features1,Features2),
	sort(Features2,Features).

extract_features_from_descriptor_list1([],[]) :- !.
extract_features_from_descriptor_list1([Descr|DescrList],[DFeatures|Features]) :-
	descriptor_feature(Descr,DFeatures),
	extract_features_from_descriptor_list1(DescrList,Features).

descriptor_feature(FLDESCRIPTOR(_,FLTAG,_), FLTAG_FEATURE) :- !.
descriptor_feature(FLDESCRIPTOR(FlAtom,FLBOOLDESCRIPTOR,_), Name) :-
	get_flatom_name(FlAtom,Name),
	(Name == FL_STRICT ; Name == FL_DEFEASIBLE),
	!.
descriptor_feature(FLDESCRIPTOR(List,FLRULEID,_), Features) :-
	!,
	extract_features_from_ruleid(List,Features).
%% this is unreachable for now
descriptor_feature(_Descriptor, []).

extract_features_from_ruleid([],[]) :- !.
extract_features_from_ruleid([First|Rest],[Features|RestFeatures]) :-
	detach_flworkspace(First,FirstSansWS,_),
	is_flobjspec(FirstSansWS,_,Spec),
	!,
	extract_features_from_objspec(Spec,Features),
	extract_features_from_ruleid(Rest,RestFeatures).
extract_features_from_ruleid([_|Rest],RestFeatures) :-
	extract_features_from_ruleid(Rest,RestFeatures).

extract_features_from_objspec(Spec,Features) :-
	is_flconjunct(Spec,Left,Right),
	!,
	extract_features_from_objspec(Left,F1),
	extract_features_from_objspec(Right,F2),
	(is_list(F2) -> Features = [F1|F2]
	; Features = [F1,F2]
	).
extract_features_from_objspec(Spec, FLTAG_FEATURE) :-
	detach_flworkspace(Spec,SpecSansWS,_),
	is_flmvdattspec(SpecSansWS,Att,RefType,_),
	is_mvdspecop(RefType), %% FL_MVDARROW, ->
	get_flatom_name(Att,FL_TAG_PROPERTY),
	!.
extract_features_from_objspec(Spec, Name) :-
	detach_flworkspace(Spec,SpecSansWS,_),
	is_flmethspec(SpecSansWS,BoolProp),
	get_flatom_name(BoolProp,Name),
	(Name == FL_STRICT ; Name == FL_DEFEASIBLE),
	!.
extract_features_from_objspec(_Spec, []).


/*
   compile_descriptor_list1(+DescriptorList,+Mode,+DescrIdCode,+CurrFileName,+DescrModule,+RuleidFrameCode,+DescrVarsTerm,-MetaFactDiffList,-Status)
   Mode - FL_DESCRMODE_RULE/FL_DESCRMODE_CLAUSE/FL_DESCRMODE_PLAIN_QUERY/FL_DESCRMODE_DYNRULE/FL_DESCRMODE_ADDRULE/FL_DESCRMODE_LATENT_QUERY/FL_DESCRMODE_LATENT_DYNQUERY/FL_DESCRMODE_LATENT_ADDQUERY/FL_DESCRMODE_UDFRULE
        FL_DESCRMODE_CLAUSE is used for the clause{...} construct.
        FL_DESCRMODE_PLAIN_QUERY is for the @!{...} metainfo queries in bodies.
        FL_DESCRMODE_DYNRULE is for dynamic rules.
	etc.
*/
compile_descriptor_list1([],_Mode,_DescrIdCode,_FileName,_Module,_RuleidFrameCode,_DescrVarsTerm,M-M,[]) :- !.
compile_descriptor_list1([Descriptor|RestDescr],Mode,DescrIdCode,FileName,Module,RuleidFrameCode,DescrVarsTerm,MetaFacts-MetaTail,Status) :-
	compile_descriptor(Descriptor,Mode,DescrIdCode,FileName,Module,RuleidFrameCode,DescrVarsTerm,MetaFacts-Tail,S1),
	(no_errors_found(S1)
	->  
	    compile_descriptor_list1(RestDescr,Mode,DescrIdCode,FileName,Module,RuleidFrameCode,DescrVarsTerm,Tail-MetaTail,Status)
	; Status = S1
	).


/*
   compile_descriptor(+Descriptor,+Mode,+DescrIdCode,+DescrVarsTerm,-MetaFactDiffList,-Status)
   Mode - FL_DESCRMODE_RULE/FL_DESCRMODE_CLAUSE/FL_DESCRMODE_PLAIN_QUERY/FL_DESCRMODE_DYNRULE/FL_DESCRMODE_ADDRULE/FL_DESCRMODE_LATENT_QUERY/FL_DESCRMODE_LATENT_DYNQUERY/FL_DESCRMODE_LATENT_ADDQUERY/FL_DESCRMODE_UDFRULE
        FL_DESCRMODE_RULE - rule descriptor in static rules
        FL_DESCRMODE_CLAUSE mode is used for the clause{...} construct.
        FL_DESCRMODE_PLAIN_QUERY - for @!{...} queries in rule bodies
        FL_DESCRMODE_DYNRULE is for dynamic rules.
	etc.
*/
compile_descriptor(Descriptor,Mode,DescrIdCode,FileName,Module,RuleidFrameCode,DescrVarsTerm,MetaFactDiffList,Status) :-
	is_fldescriptor(Descriptor,DescrContents,Type,_Index),
	(Type == FLTAG
	-> construct_tag_descriptor_facts(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,DescrContents,MetaFactDiffList,Status)
	; Type == FLBOOLDESCRIPTOR
	-> construct_bool_descriptor_facts(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,DescrContents,MetaFactDiffList,Status)
	; Type == FLRULEID 
	-> 
	    construct_prop_descriptor_facts(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,RuleidFrameCode,MetaFactDiffList,Status)
	),
	!.
%% already compiled
compile_descriptor(Descriptor,_Mode,_DescrIdCode,_FileName,_Module,_RuleidFrameCode,_DescrVarsTerm,Descriptor,[]) :- !.

compile_ruleid_descriptor(IdDescriptorWithFrame,DescrIdCode,FrameCode,ExplicitModule,Status) :-
	compile_complex_descriptor(IdDescriptorWithFrame,
				   frames_ok,
				   DescrIdCode,FrameCode,ExplicitModule,Status).


/*
   Mode - FL_DESCRMODE_RULE/FL_DESCRMODE_CLAUSE/FL_DESCRMODE_PLAIN_QUERY/FL_DESCRMODE_DYNRULE/FL_DESCRMODE_ADDRULE/FL_DESCRMODE_LATENT_QUERY/FL_DESCRMODE_LATENT_DYNQUERY/FL_DESCRMODE_LATENT_ADDQUERY/FL_DESCRMODE_UDFRULE
        FL_DESCRMODE_RULE - rule descriptor in static (loaded) rules
        FL_DESCRMODE_CLAUSE mode is used for the clause{...} construct.
	       In that case, the default rule Id is just a new variable.
	       Same for FL_DESCRMODE_DYNRULE/FL_DESCRMODE_ADDRULE/FL_DESCRMODE_LATENT_DYNQUERY/FL_DESCRMODE_LATENT_ADDQUERY: these Ids are set at run time,
	            so here we just make the id into a variable.
        FL_DESCRMODE_PLAIN_QUERY is for @!{....} queries to metainfo in rule bodies
        FL_DESCRMODE_DYNRULE is for dynamic rules inserted at run time by insertrule.
        FL_DESCRMODE_ADDRULE is for dynamic rules inserted by _add.
        FL_DESCRMODE_LATENT_QUERY is for for static (loaded) latent queries
        FL_DESCRMODE_LATENT_ADDQUERY is for for latent queries inserted by _add.
        FL_DESCRMODE_LATENT_DYNQUERY is for for latent queries inserted by insert{}.
        FL_DESCRMODE_UDFRULE is for rules created as part of the UDF encoding

     Now we just use the rule number generated by the lexer as rule Id
     for static and UDF rules.
     This is because previously we used long atoms 20 chars and longer,
     and this takes a huge amount of space on the heap.
*/
construct_default_ruleid_descriptor(FL_DESCRMODE_RULE,Idx,RuleIdCode) :-
	!,
	increment_default_ruleid,
	current_default_ruleid(RuleId),
	numobj_struct(RuleId,Idx,RuleIdCode).
construct_default_ruleid_descriptor(ic,Idx,RuleIdCode) :-
	!,
	increment_default_ruleid,
	current_default_ruleid(RuleId),
	numobj_struct(RuleId,Idx,RuleIdCode).
construct_default_ruleid_descriptor(FL_DESCRMODE_UDFRULE,Idx,RuleIdCode) :-
	!,
	increment_default_ruleid,
	current_default_ruleid(RuleId),
	numobj_struct(RuleId,Idx,RuleIdCode).
construct_default_ruleid_descriptor(FL_DESCRMODE_ADDRULE,Idx,RuleIdCode) :-
	!,
	new_prvariable(Idx,RuleIdCode).
construct_default_ruleid_descriptor(FL_DESCRMODE_LATENT_ADDQUERY,Idx,RuleIdCode) :-
	!,
	new_prvariable(Idx,RuleIdCode).
construct_default_ruleid_descriptor(FL_DESCRMODE_LATENT_DYNQUERY,Idx,RuleIdCode) :-
	!,
	new_prvariable(Idx,RuleIdCode).
construct_default_ruleid_descriptor(FL_DESCRMODE_DYNRULE,Idx,RuleIdCode) :-
	!,
	new_prvariable(Idx,RuleIdCode).
construct_default_ruleid_descriptor(FL_DESCRMODE_CLAUSE,Idx,RuleIdCode) :-
	!,
	new_prvariable(Idx,RuleIdCode).
construct_default_ruleid_descriptor(FL_DESCRMODE_PLAIN_QUERY,Idx,RuleIdCode) :-
	new_prvariable(Idx,RuleIdCode).

%% construct_tag_descriptor_facts(+DescrIdCode,+FileName,+Module,+Mode,+DescrVarsTerm,+DescrContent,-MetaFactDiffList,-Stat)
%% construct_bool_descriptor_facts(+DescrIdCode,+File,+Module,+Mode,+DescrVarsTerm,+DescrContent,-MetaFactDiffList,-Stat)
construct_tag_descriptor_facts(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,DescrContents,[TagIdMetaFact|Tail]-Tail,Status) :-
	compile_simple_descriptor(DescrContents,DescrContentsCode,Status),
	construct_tag_descriptor_fact1(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,DescrContentsCode,TagIdMetaFact).

%% Like construct_tag_descriptor_facts/7, but uses DescrContentsCode (pr-obj)
%% instead of %% DescrContents (fl-obj)
%% Also takes ExplicitModule
construct_tag_descriptor_fact1(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,DescrContentsCode,TagIdMetaFact) :-
	PredCode = FL_TAG_DESCRIPTOR_META_PREDICATE,
	generate_prolog_liblit(PredCode,5,[DescrIdCode,FileName,Module,DescrContentsCode,DescrVarsTerm], TagIdMetaTerm),
	((Mode == FL_DESCRMODE_RULE ; Mode == FL_DESCRMODE_LATENT_QUERY)
	 -> fact_struct(TagIdMetaTerm,TagIdMetaFact)
	; %% Mode = FL_DESCRMODE_CLAUSE/FL_DESCRMODE_PLAIN_QUERY/FL_DESCRMODE_DYNRULE/FL_DESCRMODE_ADDRULE/FL_DESCRMODE_LATENT_DYNQUERY/FL_DESCRMODE_LATENT_ADDQUERY/FL_DESCRMODE_UDFRULE
	    TagIdMetaTerm = TagIdMetaFact
	).

construct_file_descriptor_query(DescrIdCode,Module,DescrVarsTerm,FileVal,MetaTerm,NO_ERRORS) :-
	has_context(compiling_body(_)),
	!,
	PredCode = FL_TAG_DESCRIPTOR_META_PREDICATE,
	new_dontcare_prvariable(NO_INDEX,SomeTagVar),
	generate_prolog_liblit(PredCode,5,[DescrIdCode,FileVal,Module,SomeTagVar,DescrVarsTerm], MetaTerm).
construct_file_descriptor_query(DescrIdCode,_,_,_,_,[Err]) :-
	approx_prindex(DescrIdCode,Idx),
	compiling_error(Idx,INVALID_FILE_DESCRIPTOR_PROP,Err).

construct_module_descriptor_query(DescrIdCode,FileName,DescrVarsTerm,ModuleVal,MetaTerm,NO_ERRORS) :-
	has_context(compiling_body(_)),
	!,
	PredCode = FL_TAG_DESCRIPTOR_META_PREDICATE,
	new_dontcare_prvariable(NO_INDEX,SomeTagVar),
	generate_prolog_liblit(PredCode,5,[DescrIdCode,FileName,ModuleVal,SomeTagVar,DescrVarsTerm], MetaTerm).
construct_module_descriptor_query(DescrIdCode,_,_,_,_,[Err]) :-
	approx_prindex(DescrIdCode,Idx),
	compiling_error(Idx,INVALID_MODULE_DESCRIPTOR_PROP,Err).

construct_type_descriptor_query(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,Prop,Val,MetaFact,NO_ERRORS) :-
	has_context(compiling_body(_)),
	!,
	construct_prop_descriptor_fact1(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,Prop,Val,MetaFact).
construct_type_descriptor_query(DescrIdCode,_,_,_,_,_,_,_,[Err]) :-
	approx_prindex(DescrIdCode,Idx),
	compiling_error(Idx,INVALID_TYPE_DESCRIPTOR_PROP,Err).

%% this constructs the meta fact for the type property: @!{id[type->rule/query]}
construct_type_descriptor_fact(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,MetaFact) :-
	has_context(compiling_body(_)),
	!,
	atomobj_struct(FL_TYPE_PROPERTY,Prop),
	(memberchk(Mode,[FL_DESCRMODE_LATENT_ADDQUERY,FL_DESCRMODE_LATENT_DYNQUERY,FL_DESCRMODE_LATENT_QUERY]) -> atomobj_struct(FL_DESCRTYPE_QUERY,Val)
	; memberchk(Mode,[FL_DESCRMODE_RULE,FL_DESCRMODE_ADDRULE,FL_DESCRMODE_DYNRULE]) -> atomobj_struct(FL_DESCRTYPE_RULE,Val)
	%% Mode = FL_DESCRMODE_PLAIN_QUERY/FL_DESCRMODE_CLAUSE
	; new_prvariable(NO_INDEX,Val)
	),
	construct_prop_descriptor_fact1(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,Prop,Val,MetaFact).
construct_type_descriptor_fact(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,MetaFact) :-
	atomobj_struct(FL_TYPE_PROPERTY,Prop),
	(memberchk(Mode,[FL_DESCRMODE_LATENT_ADDQUERY,FL_DESCRMODE_LATENT_DYNQUERY,FL_DESCRMODE_LATENT_QUERY]) -> atomobj_struct(FL_DESCRTYPE_QUERY,Val)
	; memberchk(Mode,[FL_DESCRMODE_RULE,FL_DESCRMODE_ADDRULE,FL_DESCRMODE_DYNRULE]) -> atomobj_struct(FL_DESCRTYPE_RULE,Val)
	;  %% this should be unreachable
	    flora_abort(['Compiler bug!!! construct_type_descriptor_fact: unreachable statement'], FLORA_ABORT_NOTRACE)
	),
	construct_prop_descriptor_fact1(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,Prop,Val,MetaFact).


construct_bool_descriptor_facts(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,DescrContents,[BoolIdMetaFact|Tail]-Tail,Status) :-
	compile_simple_descriptor(DescrContents,DescrContentsCode,Status),
	construct_bool_descriptor_fact1(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,DescrContentsCode,BoolIdMetaFact).
%% Like construct_tag_descriptor_facts, but uses DescrContentsCode (pr-obj)
%% instead of DescrContents (fl-obj)
construct_bool_descriptor_fact1(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,DescrContentsCode,BoolIdMetaFact) :-
	PredCode = FL_BOOL_DESCRIPTOR_META_PREDICATE,
	generate_prolog_liblit(PredCode,5,[DescrIdCode,FileName,Module,DescrContentsCode,DescrVarsTerm], BoolIdMetaTerm),
	((Mode == FL_DESCRMODE_RULE ; Mode == FL_DESCRMODE_LATENT_QUERY)
	-> fact_struct(BoolIdMetaTerm,BoolIdMetaFact)
	; %% Mode = FL_DESCRMODE_CLAUSE/FL_DESCRMODE_PLAIN_QUERY/FL_DESCRMODE_DYNRULE/FL_DESCRMODE_ADDRULE/FL_DESCRMODE_LATENT_DYNQUERY/FL_DESCRMODE_LATENT_ADDQUERY/FL_DESCRMODE_UDFRULE
	    BoolIdMetaTerm = BoolIdMetaFact
	).

%% construct_prop_descriptor_facts/8
construct_prop_descriptor_facts(_,_,_,_,_,NULL,Meta-Meta,[]) :- !.
construct_prop_descriptor_facts(_,_,_,_,_,FL_TRUE,Meta-Meta,[]) :- !.

construct_prop_descriptor_facts(DescrIdCode,File,Module,Mode,DescrVarsTerm,RuleidFrameCode,LeftMeta-RightTail,Status) :-
	is_prconjunct(RuleidFrameCode,Left,Right),
	!,
	construct_prop_descriptor_facts(DescrIdCode,File,Module,Mode,DescrVarsTerm,Left,LeftMeta-LeftTail,S1),
	(S1 == NO_ERRORS ->
	    construct_prop_descriptor_facts(DescrIdCode,File,Module,Mode,DescrVarsTerm,Right,LeftTail-RightTail,Status)
	; Status =S1
	).
%% this should be unreachable due to the parser, but just in case
construct_prop_descriptor_facts(_,_,_,Mode,_,RuleidFrameCode,_,[Err]) :-
	is_prdisjunct(RuleidFrameCode,_,_),
	memberchk(Mode,[FL_DESCRMODE_RULE,FL_DESCRMODE_DYNRULE,FL_DESCRMODE_ADDRULE,FL_DESCRMODE_LATENT_QUERY,FL_DESCRMODE_LATENT_DYNQUERY,FL_DESCRMODE_LATENT_ADDQUERY,FL_DESCRMODE_UDFRULE]),
	!,
	approx_prindex(RuleidFrameCode,Idx),
	compiling_error(Idx,NO_DISJUNCTS_DESCRIPTOR_FRAME,Err).

construct_prop_descriptor_facts(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,RuleidFrameCode,Metafacts,Status) :-
	(is_prworkspace(RuleidFrameCode,RealCode,ExplicitModule) -> true
	; RealCode = RuleidFrameCode, ExplicitModule = Module
	),
	%% change module to ExplicitModule
	construct_attrval_descriptor_facts(DescrIdCode,FileName,ExplicitModule,Mode,DescrVarsTerm,RealCode,Metafacts,Status).


%% construct_attrval_descriptor_facts/8 for attr-val pairs
construct_attrval_descriptor_facts(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,PRMVD(DescrIdCode,Prop,Val,_),[MetaFact|Tail]-Tail,Status) :-
	!,
	%% if property=tag: construct a tag metafact; else - property metafact
	(is_pratom(Prop,FL_TAG_PROPERTY)
	-> 
	    construct_tag_descriptor_fact1(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,Val,MetaFact),
	    Status = NO_ERRORS
	; is_pratom(Prop,FL_FILE_PROPERTY)
	->  %% this is used only in rule/query bodies
	    construct_file_descriptor_query(DescrIdCode,Module,DescrVarsTerm,Val,MetaFact,Status)
	; is_pratom(Prop,FL_MODULE_PROPERTY)
	->  %% this is used only in rule/query bodies
	    construct_module_descriptor_query(DescrIdCode,FileName,DescrVarsTerm,Val,MetaFact,Status)
	; is_pratom(Prop,FL_TYPE_PROPERTY)
	->  %% this is used only in rule/query bodies
	    construct_type_descriptor_query(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,Prop,Val,MetaFact,Status)
	;
	    construct_prop_descriptor_fact1(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,Prop,Val,MetaFact),
	    Status = NO_ERRORS
	).

%% construct_attrval_descriptor_facts/8 for Boolean properties
construct_attrval_descriptor_facts(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,PRMETH(DescrIdCode,Val,_),[MetaFact|Tail]-Tail,NO_ERRORS) :-
	!,
	construct_bool_descriptor_fact1(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,Val,MetaFact).

%% construct_attrval_descriptor_facts/8 for empty frames: empty metafacts
construct_attrval_descriptor_facts(DescrIdCode,_,_,_,_,PREXISTS(DescrIdCode,_),Meta-Meta,NO_ERRORS) :-
	!.

%% construct_attrval_descriptor_facts/8
construct_attrval_descriptor_facts(_DescrIdCode,_FileName,_Module,_Mode,_DescrVarsTerm,RuleidFrameCode,_DiffList,[Err]) :-
	approx_prindex(RuleidFrameCode,Idx),
	compiling_error(Idx,NO_NESTED_DESCRIPTOR_FRAME,Err).

%% constructs meta facts for 1 attr-value pair
construct_prop_descriptor_fact1(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,Prop,Val,MetaFact) :-
	PredCode = FL_PROP_DESCRIPTOR_META_PREDICATE,
	generate_prolog_liblit(PredCode,6,[DescrIdCode,FileName,Module,Prop,Val,DescrVarsTerm], MetaTerm),
	((Mode == FL_DESCRMODE_RULE ; Mode == FL_DESCRMODE_LATENT_QUERY)
	-> fact_struct(MetaTerm,MetaFact)
	; %% Mode = FL_DESCRMODE_CLAUSE/FL_DESCRMODE_PLAIN_QUERY/FL_DESCRMODE_DYNRULE/FL_DESCRMODE_ADDRULE/FL_DESCRMODE_LATENT_DYNQUERY/FL_DESCRMODE_LATENT_ADDQUERY/FL_DESCRMODE_UDFRULE
	    MetaTerm = MetaFact
	).


get_descriptor_module(ExplicitMod,Mode,OutModule) :-
	(ExplicitMod \== NULL -> OutModule = ExplicitMod
	; memberchk(Mode,[FL_DESCRMODE_CLAUSE,FL_DESCRMODE_DYNRULE]) ->
	    new_prvariable(NO_INDEX,OutModule)
	; Mode == FL_DESCRMODE_PLAIN_QUERY
	-> thismodule_struct(OutModule)
	; %% FL_DESCRMODE_RULE/FL_DESCRMODE_ADDRULE/FL_DESCRMODE_LATENT_QUERY/FL_DESCRMODE_LATENT_DYNQUERY/FL_DESCRMODE_LATENT_ADDQUERY
	    thismodule_struct(OutModule)
	).

%% descriptor without attached frames
compile_simple_descriptor(DescrContents,Object,Status) :-
	compile_complex_descriptor(DescrContents,no_frames,Object,_,_,Status).

%% When compiling tags or bool descriptors,
%% no frames are allowed: FramesOK == no_frames
%% When compiling rule ids, frames are allowed: FramesOK == frames_ok
%% Object here becomes the rule Id code.
compile_complex_descriptor(DescrContentsWS,FramesOK,Object,FrameCode,ExplicitModule,Status) :-
	(FramesOK == frames_ok -> true
	; FrameCode = NULL
	),
	%% If we are compiling descriptor as part of compiling a path
	%% expression (eg, reification in the rule body) then we need to
	%% make sure that the next compile_pathexp/7 won't clear the
	%% compiling_body_pathexp context.
	detach_flworkspace(DescrContentsWS,DescrContents,WS),
	(has_context(compiling_body_pathexp),
	    compile_body_pathexp(DescrContents,WS,Object,NULL,FrameCode,[],S1) 
	-> set_context(compiling_body_pathexp)
	;
	    compile_body_pathexp(DescrContents,WS,Object,NULL,FrameCode,[],S1)
	-> true
	; approx_flindex(DescrContents,Idx),
	    compiling_error(Idx,SIMPLE_FRAMES_IN_RULE_DESCRIPTORS,Err),
	    S1 = [Err]
	),
	
	%% don't let the user define a posint rule Id explicitly to avoid
	%% clashes. The only exception is the _@! constant. In the latter case,
	%% the context is set to allow__numeric_ruleids
	(has_context(allow_numeric_ruleids) -> Status = S1
	; is_prnumber(Object,RuleId,RidIdx), integer(RuleId), RuleId > 0 ->
	    compiling_error(RidIdx,NO_INTEGERS_AS_RULEID,Err),
	    Status = [Err|S1]
	; Status = S1
	),
	clear_context(allow_numeric_ruleids),

	(var(FrameCode) -> ExplicitModule = NULL
	; is_prworkspace(FrameCode,_,ExplicitModule) -> true
	; is_prconjunct(FrameCode,Left,_), is_prworkspace(Left,_,ExplicitModule)
	-> true
	; is_prdisjunct(FrameCode,Left,_), is_prworkspace(Left,_,ExplicitModule)
	-> true
	; ExplicitModule = NULL
	).
	
%% construct_rule_enabling_fact(+DescrIdCode,+Mode,-RuleEnablerMetaFact)
%% For clause{...} and the @!{...} query, don't construct the rule-enabling fact
construct_rule_enabling_fact(_DescrIdCode,_FileName,FL_DESCRMODE_CLAUSE,NULL) :- !.
construct_rule_enabling_fact(_DescrIdCode,_FileName,FL_DESCRMODE_PLAIN_QUERY,NULL) :- !.
construct_rule_enabling_fact(DescrIdCode,FileName,Mode,RuleEnablerMetaFact) :-
	construct_rule_enabling_query(DescrIdCode,FileName,Mode,RuleEnablerMetaTerm),
	((Mode == FL_DESCRMODE_RULE ; Mode == FL_DESCRMODE_LATENT_QUERY)
	-> fact_struct(RuleEnablerMetaTerm,RuleEnablerMetaFact)
	; %% Mode = FL_DESCRMODE_CLAUSE/FL_DESCRMODE_PLAIN_QUERY/FL_DESCRMODE_DYNRULE/FL_DESCRMODE_ADDRULE/FL_DESCRMODE_LATENT_DYNQUERY/FL_DESCRMODE_LATENT_ADDQUERY/FL_DESCRMODE_UDFRULE
	    RuleEnablerMetaTerm = RuleEnablerMetaFact
	).

construct_rule_enabling_query(DescrIdCode,FileName,Mode,RuleEnablerMetaTerm) :-
	PredCode = FL_RULE_ENABLER,
	get_descriptor_module(NULL,Mode,Module),
	generate_prolog_liblit(PredCode,3,[DescrIdCode,FileName,Module],RuleEnablerMetaTerm).

%% like construct_rule_enabling_query/4 but generates file name for itself
%% used as the first subgoal in rules, queries, latent queries
construct_rule_enabling_test(DescrIdCode,Mode,RuleEnablerMetaTerm,FileName) :-
	get_current_compile_file_for_descriptor(FileName,Mode),
	construct_rule_enabling_query(DescrIdCode,FileName,Mode,RuleEnablerMetaTerm).

construct_tag_descriptor_fact_from_id(DescrIdCode,FileName,Module,Mode,DescrVarsTerm,TagIdMetaFact) :-
	PredCode = FL_TAG_DESCRIPTOR_META_PREDICATE,
	(Mode == FL_DESCRMODE_DYNRULE ->
	    Tag = DescrIdCode
	; Mode == FL_DESCRMODE_CLAUSE ->
	    new_prvariable(NO_INDEX,Tag)
	; Mode == FL_DESCRMODE_PLAIN_QUERY ->
	    new_prvariable(NO_INDEX,Tag)
	;
	    Tag = DescrIdCode
	),
	generate_prolog_liblit(PredCode,5,[DescrIdCode,FileName,Module,Tag,DescrVarsTerm],TagIdMetaTerm),
	((Mode == FL_DESCRMODE_RULE ; Mode == FL_DESCRMODE_LATENT_QUERY)
	-> fact_struct(TagIdMetaTerm,TagIdMetaFact)
	; %% Mode = FL_DESCRMODE_CLAUSE/FL_DESCRMODE_PLAIN_QUERY/FL_DESCRMODE_DYNRULE/FL_DESCRMODE_ADDRULE/FL_DESCRMODE_LATENT_DYNQUERY/FL_DESCRMODE_LATENT_ADDQUERY/FL_DESCRMODE_UDFRULE
	    TagIdMetaTerm = TagIdMetaFact
	).


/***************************************************************************
  Compile the export directive
  The body can be a list of export terms, which are compiled individually.
***************************************************************************/
compile_export(BodyTerm,Code,Status) :-
	compile_export_predicate_list(BodyTerm,BodyTermCode,Status),
	list_struct(BodyTermCode,[],BodyTermCodeList),
	export_struct(BodyTermCodeList,Code).


/****************************************************************************
  compile_export_predicate_list(+List,-Code,-Status)
  To recursively compile a list of export predicates.
****************************************************************************/
compile_export_predicate_list([H|T],Code,Status) :-
	compile_export_predicate(H,HCode,S1),
	compile_export_predicate_list(T,TCode,S2),
	append(S1,S2,Status),
	Code = [HCode|TCode].
	
compile_export_predicate_list([],[],[]) :- !.


/****************************************************************************
  compile_export_predicate(+ExportTerm,-Code,-Status)
****************************************************************************/
compile_export_predicate(ExportTerm,Code,Status) :-
	( is_flexport(ExportTerm,BodyTerm,ModuleList,IsUpdatable),
	    WS = FL_THISMODULE
	;
	    %% Here WS is the dynamic module name. It is used only in
	    %% executable instruction like this:
	    %%    ?- (export pred(?)>>foo)@bar.
	    %% where dynamic module name = bar.
	    is_flexport(ExportTerm,WS,BodyTerm,ModuleList,IsUpdatable)
	),
	is_flfact(BodyTerm,ParseBodyTerm),
	!,
	%% compile_fact expects the argument to be a list, so
	%% ParseBodyTerm is put in a list.
	%% Uninitialized arguments are taken care of at run-time.
	compile_fact([ParseBodyTerm],_,_,ListBodyTermCode,_M-_M,StatusFact),
	compile_body_pathexp(ModuleList,FL_THISMODULE,ModuleListCode,_,_,[],_StatusModule),
	compile_body_pathexp(IsUpdatable,FL_THISMODULE,IsUpdatableCode,_,_,[],_StatusUpd),
	( WS == FL_THISMODULE -> StatusWS = NO_ERRORS
	;
	  compile_body_pathexp(WS,FL_THISMODULE,WSCode,_,_,[],StatusWS)
	),
	append(StatusFact,StatusWS,Status),
	%% It may be that the predicate itself is a comma separated list
	%% Convert ListBodyTermCode from a difference list to a normal list
	%% then wrap each element of the list in PREXPORT
	compile_export_list_convert(ListBodyTermCode,WSCode,ModuleListCode,IsUpdatableCode,Code).


/****************************************************************************
  compile_export_list_convert(+Args,-Code)
   Args is a difference list of the form : [H|_V] -_V.
   Ground _V to [] and convert the diff list to a list
   Then processes the list with compile_export_extract_facts
****************************************************************************/
compile_export_list_convert(ListBodyTermCode - T, WSCode, ModuleListCode,IsUpdatableCode,Code) :-
	T = [],
	%% ListBodyTermCode is a list of facts; process them
	compile_export_extract_facts(ListBodyTermCode,[],WSCode,ModuleListCode,IsUpdatableCode,Code).


/****************************************************************************
  compile_export_extract_facts(+Args,+InitialTerm,+WSCode,+ModuleListCode,+IsUpdatableCode,-Code)
  Encloses the individual predicates of the Args list in a PREXPORT struct. 
  Then the whole list is compiled as a list_struct.
****************************************************************************/
compile_export_extract_facts([H|T],InitTerm,WSCode,ModuleListCode,IsUpdatableCode,Code) :-
	is_prfact(H,HTermCode),
	!,
	construct_export_struct(HTermCode,WSCode,IsUpdatableCode,ModuleListCode,HCode),
	compile_export_extract_facts(T,[HCode|InitTerm],WSCode,ModuleListCode,IsUpdatableCode,Code).

compile_export_extract_facts([],InitTerm,_WSCode,_ModuleListCode,_IsUpdatableCode,Code) :-
	list_struct(InitTerm,[],Code).


/****************************************************************************
  construct_export_struct(+Term,+WSCode,+IsUpdatableCode,+ModuleListCode,-Code)
  Constructs an appropriate prexport struct.
  Here WSCode is the dynamic module name. It is used only in
  executable instruction like this:
  ?- (export pred(?)>>foo)@bar.
  where dynamic module name = bar.
****************************************************************************/
construct_export_struct(TermCode,WSCode,IsUpdatableCode,ModuleListCode,Code) :-
	thismodule_struct(ThisModule),
	atomobj_struct(FLEXPORT,FCode),
	( var(WSCode) ->
		prologterm_struct(FCode,4,[IsUpdatableCode,ThisModule,ModuleListCode,TermCode],Code)
	;
		prologterm_struct(FCode,5,[WSCode,IsUpdatableCode,ThisModule,ModuleListCode,TermCode],Code)
	).


%% UDFs are always compiled as STATIC rules, even the facts.
%% If a file is added to a module and the file has a definition for
%% the same function, the added UDFs are
%% represented by the same predicate, so the new definition overrides the old.
%%  To avoid this error-prone situation, in this case we issue an error.
%% When overriding a module, we abolish new_udf_predicates_FUN and
%% retractall flora_defined_udf_registry/6.
%% Structure of flora_defined_udf_registry/6 args:
%%
%%    Module,                 eg,     foobar
%%    UDF name,               eg,     fib          (say, for Fibonacci numbers)
%%    Arity of this UDF,              1
%%    UDF-term (user view)            fib(?_h2819)
%%    Name of the UDF predicate that defines this UDF,
%%                            eg,     FLORA_WORKSPACE(new_udf_predicate_fib)
%%    UDF Literal used to implement this UDF
%%       eg,    FLORA_WORKSPACE(new_udf_predicate_fib)(_h0,flapply(fib,_h1),_h2)
%%         
%% If overriding module FLORA_DEFAULT_WORKSPACE, we also
%% retractall flora_used_udf_registry/4.
%% Structure of flora_used_udf_registry/4 args:
%%
%%    UDF name,
%%    Arity of this UDF,
%%    UDF-term (user view)
%%    UDF Literal used to implement this UDF

/****************************************************************************
  compile_udf_definition(+Function,+Body,+ReturnValue,-RuleDiffList,-FactDiffList,-UDFPredsDiffList,-Status)

  Compile a UDF definition:
  udf Function := if Body.
  Creates a predicate representing the UDF and a rule for that predicate.

  Function - udf term
  Body - body of udf definition
  ReturnValue - return expression
  RuleDiffList - a difference list in the form of [...|T]-T. It is for
                  the optimization of append.
  FactDiffList - the same for facts
  UDFPredsDiffList -  the same for the list of tabled predicates
****************************************************************************/
compile_udf_definition(Function,Body,ReturnValue,CodeList-ListTail,FactDiffList,UDFPreds-UDFPredsTail,Status) :-
	set_context(compiling_udf_definition),
	( is_flterm_or_flatom(Function,Funct,N,Args)->
	    new_udf_predicate(Funct,FunctCompiled,FunctName,UDFCode,N,Args,NewHead,NewHeadPredName,NewHeadPredArity,NewReturnValue,NewHeadCode,FStatus),
	    ( no_errors_found(FStatus) -> 
		( \+ has_permaoption(udf_option(FunctName,N,UDFCode,NewHeadPredName,NewHeadCode)) ->
		    %% +1 for the caller argument
		    NewHeadPredArity1 is NewHeadPredArity+1,
		    UDFPreds = [(NewHeadPredName,NewHeadPredArity1),UDFPredsTail],
		    set_permaoption(udf_option(FunctName,N,UDFCode,NewHeadPredName,NewHeadCode))
		;
		    UDFPreds = UDFPredsTail
		),
		approx_flindex(Funct,FunctIndex),
		compile_descriptor_list([]-FunctIndex,FL_DESCRMODE_UDFRULE,DescrIdCode,DescrVarsTerm,_,_),
		( Body=NULL ->
		    %% UDFs are always compiled as rules: add a dummy body
		    flatom_struct(FL_TRUE,NO_INDEX,RealBody),
		    new_udfrule_body(RealBody,FunctIndex,
				     ReturnValue,NewReturnValue,NewBody),
		    %% empty descr list - just generate new rule id
		    compile_rule([NewHead],NewBody,
				 DescrIdCode, DescrVarsTerm,
				 RuleList-ListTail,
				 _SigList,
				 FactDiffList,S)
		;
		    new_udfrule_body(Body,FunctIndex,ReturnValue,NewReturnValue,NewBody),
		    %% empty descr list - just generate new rule id
		    compile_rule([NewHead],NewBody,
				 DescrIdCode, DescrVarsTerm,
				 RuleList-ListTail,
				 _SigList,
				 FactDiffList,S)
		),
		CodeList=[UDFCodeList|RuleList],
		( no_errors_found(S) -> 
		    %% udfunction_struct causes flrcoder.P to record UDF
		    %% definitions in the registry so that we could abolish all
		    %% new_udf_predicate_XXX on reloading modules.
		    %% This is done in flora_cleanup_udf/1, which is called
		    %% from flrutils:flora_flload/2
		    udfunction_struct(FunctCompiled,N,UDFCode,NewHeadPredName,NewHeadCode,UDFCodeList),
		    %% is_flterm_or_flatom rather than is_flterm is important:
		    %% Otherwise, "udf foo := moo." won't work.
		    is_flterm_or_flatom(Function,FuncSym,FuncSymArity,_),
		    verify_symbol_context(FuncSym,FuncSymArity,UDF_SYMBOL,
					  NONTRANSACTIONAL_SYMBOL,
					  SymbolStatus),
		    check_udf_vars_for_safety(Function,Body,ReturnValue,VarStatus),
		    append(SymbolStatus,VarStatus,Status)
		;
		    Status=S
		)
	    ;
		Status = FStatus
	   )
	;
	    approx_flindex(Function,Index),
	    compiling_error(Index,ERROR_UDF,Err),
	    Status = [Err]
	),
	!,
	clear_context(compiling_udf_definition).


/*
       new_udf_predicate(+Funct,-FunctCompiled,-FunctName,-UDFCode,
                         +N,+FunctionArgs,-New_udf_predicate_FUNC,
			 -New_udf_predicate_name,-New_udf_predicate_arity,
			 -NewReturnValue,-New_udf_predicate_FUNC_code,-Status)
   Funct - UDF functor
   FunctCompiled - UDF functor compiled (pr-object)
   FunctName - the functor name (atom). Used only for symbol-context checks.
               If the UDF is hilog, then FunctName is set to HILOG_SYMBOL_NAME.
               This is a simplifying assumption for symbol context checking.
   UDFCode - the udf term compiled (pr-object)
   N - UDF arity
   FunctionArgs - the UDF arguments (fl-object, not compiled)
   New_udf_predicate_FUNC - new_udf_predicate_XXX term
                          (fl-obj, not compiled)
   New_udf_predicate_name - new_udf_predicate_XXX name
   New_udf_predicate_arity - new_udf_predicate_XXX arity
   NewReturnValue - a new variable generated for the return expression of udf
   New_udf_predicate_FUNC_code - new_udf_predicate_XXX term compiled
*/
new_udf_predicate(Funct,FunctCompiled,FunctName,UDFCode,N,FunctionArgs,New_udf_predicate_FUNC,New_udf_predicate_name,New_udf_predicate_arity,NewReturnValue,New_udf_predicate_FUNC_code,Status) :-
	new_udf_predicate_funct(Funct,FunctCompiled,N,NPFunct,NPFunctCompiled,New_udf_predicate_name,New_udf_predicate_arity,Status1),
	( no_errors_found(Status1) -> 
	    new_flvariable(NO_INDEX,NewReturnValue,NewReturnValueObj),
	    varobj_struct(FL_ANON_VAR,AnonVar),
	    (flora_get_flatom_name(Funct,FunctName) -> true
	    ;
		(  atomic(Funct) -> FunctName=Funct
		%% for HiLog UDF, the function name is HILOG_SYMBOL_NAME.
		%% This is used only for symbol context checking.
		; FunctName = HILOG_SYMBOL_NAME
		)
	    ),
	    flterm_struct(Funct,N,FunctionArgs,UDFTerm),
	    New_udf_pred_args_compiled = [NewReturnValueObj,UDFCode,AnonVar],
	    prologterm_struct(NPFunctCompiled,New_udf_predicate_arity,New_udf_pred_args_compiled,New_udf_predicate_FUNC_code),
	    New_udf_pred_flargs = [NewReturnValue,UDFTerm],
	    flterm_struct(NPFunct,New_udf_predicate_arity,New_udf_pred_flargs,New_udf_predicate_FUNC),
	    flora_define_modular_prolog(New_udf_predicate_name,New_udf_predicate_arity),
	    compile_body_pathexplist(FunctionArgs,FL_THISMODULE,FunctionArgsCompiled,_,_,[],Status3),
	    ( no_errors_found(Status3) -> 
		termobj_struct(FunctCompiled,N,FunctionArgsCompiled,UDFCode),
		Status = NO_ERRORS
	    ;
		Status = Status3
	    )
	;
	    Status = Status1
	).
	


/*
    new_udfrule_body(+Body,+FunctIndex,+ReturnValue,+NewReturnValue,-NewBody)

    Body - body of udf definition
    FunctIndex - lexer's index of udf functor
    ReturnValue - return expression of udf definition
    NewReturnValue - new variable generated for new_udf_predicate_XXX
                     which gets bound to return expression of udf
    NewBody - the actual body of the rule for new_udf_predicate_XXX
*/
new_udfrule_body(Body,FunctIndex,ReturnValue,NewReturnValue,NewBody) :-
	%% Form body for the new rule.
	%% To avoid singleton variable warning variable in the head
	%%    and variable in the body of new rule must have different indexes
	flvar_struct_change_index(NewReturnValue,FunctIndex,NewReturnValueInBody), 
	flatom_struct(FL_UNIVEQ,NO_INDEX,ExprFunct),
	flterm_struct(ExprFunct,2,[NewReturnValueInBody,ReturnValue],ExprCode),
	flconjunct_struct(Body,ExprCode,NewBody).


/*
    new_udf_predicate_funct(+Funct,-FunctCompiled,+Arity,
                            -NewPredicateFunct,-NPFunctCompiled,-NewName,
			    -NPArity,-Status)
    Funct - UDF functor
    FunctCompiled - UDF functor compiled
    Arity - UDF arity 
    NewPredicateFunct - functor of new_udf_predicate_XXX
    NPFunctCompiled  - compiled functor of new_udf_predicate_XXX
    NewName - name (atom) of new_udf_predicate_XXX
    NPArity - new_udf_predicate_XXX arity
*/
new_udf_predicate_funct(Funct,FunctCompiled,Arity,
			NewPredicateFunct,NPFunctCompiled,NewName,NPArity,
			Status) :-
	set_context(compiling_term_name),
	compile_body_pathexp(Funct,FL_THISMODULE,FunctCompiled,_,_,[],Status), 
	clear_context(compiling_term_name),
	encode_prterm(FunctCompiled,EncodedFunct),
	flora_concat_atoms([NEWUDFPREDICATENAME,EncodedFunct],NewName),
	flatom_struct(NewName,NO_INDEX,NewPredicateFunct),
	modularized_pratom_struct(NewName,NO_INDEX,NPFunctCompiled),
	NPArity is Arity+1.

/****************************************************************************
    encode_prterm(+Term,-EncodedBuildTerm)

    Encode a Term into a String to create a UDF Predicate Name
****************************************************************************/
encode_prterm(Term,EncodedBuildTerm):-
	collect_prvars(Term,VarList),
	flora_reset_newudfpredvar,
	encode_prvariables(VarList,Term,EncodedTerm,_NewVarList),
	encode_term_build(EncodedTerm,EncodedBuildTerm).

/***************************************************************************
    encode_prvariables(+VarNameList,+VarType,+OldFormula,-NewFormula,-NewVarList)
       Replaces each occurrence of each variable in VarNameList with
       a counter value
    rename_one_prvariable(+VarName,+NewVarObj,+Body,-NewBody),
       Replaces each occurrence of a a var object having VarName
       as the variable name with NewVarObj. Returns the newly created formula.
***************************************************************************/
encode_prvariables([],Body,Body,[]) :- !.

encode_prvariables([Var|VarNameList],Body,NewBody,[NewVarObj|NewVarList]) :-
        flora_newudfpredvar_obj(NO_INDEX,NewVarObj),
	(is_prvariable(Var,VarName,_VarIndex) ; VarName = Var),
        encode_one_prvariable(VarName,NewVarObj,Body,NewBody1),
        encode_prvariables(VarNameList,NewBody1,NewBody,NewVarList).

encode_one_prvariable(VarName,NewVarObj,Body,NewBody) :-
        (
          atomic(Body) -> NewBody = Body
        ; var(Body) -> NewBody  = Body
        ; is_list(Body)
        -> encode_one_prvariable_in_list(VarName,NewVarObj,Body,NewBody)
        ; is_prvariable(Body,VarName,_Idx) -> NewBody = NewVarObj
        ; is_pratom(Body,_) ->  NewBody = Body
        ; is_prnumber(Body) ->  NewBody = Body
        ; is_prstring(Body) ->  NewBody = Body
        ; is_prbuiltin_identifier(Body,_) ->  NewBody = Body
        ; is_prdatatype(Body,_,_,_) ->  NewBody = Body
        ; is_prdatatypelist(Body,_) ->  NewBody = Body
        ),
        !.

encode_one_prvariable(VarName,NewVarObj,Body,NewBody) :-
        Body =.. [Wrapper|Args],
        encode_one_prvariable_in_list(VarName,NewVarObj,Args,NewArgs),
        NewBody =.. [Wrapper|NewArgs].

encode_one_prvariable_in_list(_,_,[],[]) :- !.
encode_one_prvariable_in_list(VarName,NewVarObj,[T|Terms],[NewT|NewTerms]) :-
        encode_one_prvariable(VarName,NewVarObj,T,NewT),
        encode_one_prvariable_in_list(VarName,NewVarObj,Terms,NewTerms).


/***************************************************************************
    encode_term_build(Term,BuildTerm)
    encode_term_build_list(Term,BuildTerm)
****************************************************************************/
encode_term_build(Term,BuildTerm):-
        is_prterm(Term,Funct,_Arity,Args),
	encode_term_build(Funct,BuildFunct),
	encode_term_build_list([Funct|Args],[_Comma,BuildFunct,_Comma|BuildArgs]),
	flora_concat_atoms([BuildFunct,'(',BuildArgs,')'],BuildTerm),
	!.	

encode_term_build(Term,BuildTerm):-
        (
          atomic(Term) ->  BuildTerm = Term
        ; is_list(Term) -> encode_term_build_list(Term,BuildTerm)
        ; is_prvariable(Term,VarName,_Idx) -> flora_concat_atoms(['?',VarName],BuildTerm)
        ; is_pratom(Term,AtomName) ->  BuildTerm = AtomName
        ; is_prnumber(Body,Number,_Idx) ->  BuildTerm = Number
        ; is_prstring(Body,String,_Idx) ->  BuildTerm = String
        ; is_prbuiltin_identifier(Body,Iden) ->  BuildTerm = Iden
        ),
        !.

encode_term_build_list([],[]):-!.

encode_term_build_list([Term|TermList],[',',BuildTerm|BuildTermList]):-
	encode_term_build(Term,BuildTerm),
	encode_term_build_list(TermList,BuildTermList).




/****************************************************************************
  compile_rule(+Head,+Body,+DescriptorIdCode,+DescrVarsTerm,-RuleDiffList,-SigDiffList,-FactDiffList,-Status)

  DescriptorIdCode is either code for term/object or NULL

  RuleDiffList is a difference list in the form of [...|T]-T. It is for
  the optimization of append.
  FactDiffList = Facts-Facts: the empty diff list
****************************************************************************/
compile_rule(Head,Body,DescriptorIdCode,DescrVarsTerm,RuleList-RuleTail,SigDiffList,Facts-Facts,Status) :-
	set_context(compiling_rule(DescriptorIdCode)),
	(has_context(compiling_udf_definition) ->
	    /* When compiling headlits of UDF rules, we should turn
	       off UDF conversion. For instance, for
		   udf c(?x):=?y if pred(?x,?y).
	       we create the rule:
	         new_udf_predicate_c(RetVal,flapply(c,x)) :- pred(X,Y),RetVal=Y.
	    */
	    set_context(block_udf_expansion),
	    set_context(no_symbol_check)
	; true
	),
	compile_head_top(Head,HeadCode,H2BCodeHead,H2BCodeTail,HeadStatusPre),
	(has_context(compiling_udf_definition) ->
	    %% done compiling UDF definition head
	    clear_context(block_udf_expansion),
	    clear_context(no_symbol_check)
	; true
	),
	compile_conjunct2list(HeadCode,HeadCodeList),
	no_mixed_sensor_nonsensor_heads(HeadCodeList,Head,DelayStatus),
	append(HeadStatusPre,DelayStatus,HeadStatus),
	( no_errors_found(HeadStatus) ->
	    compile_body_top(Body,BCode1,BodyStatus),
	    collect_prdatatypevars([HeadCodeList,BCode1],DTVarsCode),
	    %% TODO: get rid of this append and in collect_prdatatypevars
	    append(DTVarsCode,[H2BCodeHead,BCode1,H2BCodeTail],BCodeList),
	    conjunct_code(BCodeList,BCode),
            get_dynrule_varlist(L),
            add_dynrule_attr_code(L,BCode,PureBodyCode),
	    %% should not add delay-checker to sensor rules
	    (all_defined_as_sensors(HeadCodeList) -> DelayCheckCode = NULL
	    ; delay_literals_checking_code(Head,Body,DescrVarsTerm,DelayCheckCode)
	    ),
	    (has_context(compiling_udf_definition) -> RuleEnablerTest = true
	    ; construct_rule_enabling_test(DescriptorIdCode,FL_DESCRMODE_RULE,RuleEnablerTest,_)
	    ),
	    PreBody = RuleEnablerTest,
	    PostBody = DelayCheckCode,
	    (is_prvariable(PostBody) -> RealPostBody = NULL
	    ; RealPostBody = PostBody
	    ),
	    ( no_errors_found(BodyStatus) ->
		%%get_directive(DirectCodeList),
		%%append(DirectCodeList,Tail,RuleList),
		split_ruleheads_add_rulesig(HeadCodeList,
					    PureBodyCode,PreBody,RealPostBody,
					    DescriptorIdCode,DescrVarsTerm,
					    RuleList-RuleTail,
					    SigDiffList,
					    Status1),
		( no_errors_found(Status1), \+ has_context(compiling_udf_definition)
		%% for UDFS checking of variables is done separately
		->
		    check_head_vars_for_safety(Head,Body,VarStatus),
		    flatten([HeadStatus,BodyStatus,Status1,VarStatus],Status)
		; Status = Status1
		)
	    ;
		Status=BodyStatus
	    )
	;
	    Status=HeadStatus
        ),
	clear_context(compiling_rule(DescriptorIdCode)),
	!.

/****************************************************************************
  split_ruleheads_add_rulesig(+HeadCodeList,+PureBodyCode,+PreBody,+PostBody,+DescriptorIdCode,+DescrVarsTerm,-RuleDiffList,-SigDiffList,-Status)

  HeadCodeList is a list of atoms in the rule head. BodyCode is the formula
  in the rule body. This procedure splits the list of atoms in the rule
  head and generates a difference list.

  DescriptorIdCode is a term code
  DescrVarsTerm is code for vars(variables in the descriptor list)

  Note: delay checker is NOT added to the body in signatures
****************************************************************************/

split_ruleheads_add_rulesig([H],PureBodyCode,PreBody,PostBody,DescriptorIdCode,DescrVarsTerm,[RuleCode|R]-R,[InsSigCode|S]-S,[]) :-
	!,
	%% Only a single atom appears in the rule head.
	construct_defeasible_condition_for_signature_or_dynrule(H,DescriptorIdCode,DescrVarsTerm,DefeatCond),
	insert_rule_signature_onehead(H,PureBodyCode,PreBody,PostBody,(DescriptorIdCode,DescrVarsTerm,DefeatCond),InsSigCode),
	construct_static_defeasible_condition(H,DescriptorIdCode,DescrVarsTerm,DefeatCondWithHead),
	add_defeasible_condition_to_body(DefeatCondWithHead,PureBodyCode,PreBody,PostBody,NewBody),
	rule_struct(H,NewBody,RuleCode).

split_ruleheads_add_rulesig(HeadList,PureBodyCode,PreBody,PostBody,DescriptorIdCode,DescrVarsTerm,[IntermedRuleCode|RuleCodeList]-RuleListTail,[InsSigCode|SigList]-SigList,Status) :-
	%% Multiple atoms appear in the rule head.
	%% Generate a temp rule.
	collect_prvars(HeadList,HeadVars),
	length(HeadVars,N),
	new_predicate(Name),
	!,
	head_caller_info_structure(CallerVarObj),
	append(HeadVars,[CallerVarObj],HeadVarsAndCaller),
	N1 is N+1,
	newpredicate_struct(Name,N1,HeadVarsAndCaller,Newpredicate),
        insert_rule_signature_multihead(HeadList,PureBodyCode,PreBody,PostBody,(DescriptorIdCode,DescrVarsTerm),Newpredicate,InsSigCode),
	%% new intermediate rule
	rule_struct(Newpredicate,PureBodyCode,IntermedRuleCode),
	%% Split the head of this intermediate rule.
	rule_difflist(HeadList,Newpredicate,PreBody,PostBody,DescriptorIdCode,DescrVarsTerm,RuleCodeList-RuleListTail,Status).


/*
   Splits multi-headed rules and adds defeasible condition to each rule
*/
rule_difflist([],_B,_PreB,_PostB,_IdCode,_DescrVarsTerm,CodeList-CodeList,[]) :- !.
rule_difflist([H|L],B,PreB,PostB,IdCode,DescrVarsTerm,[HC|LC]-T,Status) :-
	construct_static_defeasible_condition(H,IdCode,DescrVarsTerm,DefeatCond),
	add_defeasible_condition_to_body(DefeatCond,B,PreB,PostB,NewB),
	rule_struct(H,NewB,HC),
	rule_difflist(L,B,PreB,PostB,IdCode,DescrVarsTerm,LC-T,Status).

insert_rule_signature_onehead(_Head,_Body,_PreBody,_PostBody,_,NULL) :-
	(has_context(compiling_udf_definition)
	; has_permaoption(FLSUPPRESS_RULESIGNS_OPTION)
	),
	!.
insert_rule_signature_onehead(Head,Body,PreBody,PostBody,(DescrIdCode,DescrVarsTerm,DefeatCond),Code) :-
        insert_rulesig_struct(Head,Body,PreBody,PostBody,(DescrIdCode,DescrVarsTerm,DefeatCond),NULL,CCode),
        query_struct(CCode,Code).

insert_rule_signature_multihead(_HeadList,_Body,_PreBody,_PostBody,_,_Newpred,NULL) :-
	(has_context(compiling_udf_definition)
	; has_permaoption(FLSUPPRESS_RULESIGNS_OPTION)
	),
	!.
insert_rule_signature_multihead(HeadList,Body,PreBody,PostBody,(DescrIdCode,DescrVarsTerm),Newpred,Code) :-
        list_struct(HeadList,[],HeadListCode),
	construct_defeasible_condition_for_signature_or_dynrule(HeadList,DescrIdCode,DescrVarsTerm,DefeatCond),
        insert_rulesig_struct(HeadListCode,Body,PreBody,PostBody,(DescrIdCode,DescrVarsTerm,DefeatCond),Newpred,CCode),
        query_struct(CCode,Code).


%% add_defeasible_condition_to_body(+DefeatCondCode,+BodyCode,+PreBody,+PostBody,-NewBodyCode)
add_defeasible_condition_to_body(DefeatCondCode,BodyCode,PreBody,PostBody,NewBodyCode) :-
	conjunct_code([PreBody,BodyCode,DefeatCondCode,PostBody],NewBodyCode).

%% DefeatCondCode = FL_UNDEFEATED(DescrIdCode,FileName,VarsCode,NewVar,ThisModule)
%% FL_UNDEFEATED is modularized Prolog predicate
%% NewVar is used because this type of defeasible condition is used in rule
%% signatures and dynamic rules; NewVar is bound to the head at run time.
construct_defeasible_condition_for_signature_or_dynrule(Head,DescrIdCode,DescrVarsTerm,DelayedDefeatCondCode) :-
	(has_permaoption(FLDEFEASIBLE(LibModule)), \+ has_context(compiling_udf_definition)
	->
	    %% DummyVarObj4Head is unified with Head in
	    %% flora_record_rule_signature in flrcanon.P and flrdynrule.P
	    %% This is because the rule head can be a variable bound at runtime.
	    %% Eg, ?X=${p(?Y)}, insertrule{?X :- ...}.
	    %% So, we cannot determine the rule head statically here.
	    new_prvariable(NO_INDEX,DummyVarObj4Head),
	    thismodule_struct(ThisModule),
	    %% create FL_UNDEFEATED(DescrIdCode,FileName,DescrVarsTerm,NewVar,ThisModule)
	    %% this code makes FL_UNDEFEATED into Prolog predicate
	    %% It is faster, saves table space
	    modularized_pratom_struct(FL_UNDEFEATED,LibModule,NO_INDEX,UnDefeatFunCode),
	    var_caller_info_structure(ThisModule,CallerInfo),
	    get_current_compile_file_for_descriptor(FileName,FL_DESCRMODE_DYNRULE),
	    prologterm_struct(UnDefeatFunCode,6,
			      [DescrIdCode,FileName,DescrVarsTerm,DummyVarObj4Head,ThisModule,CallerInfo],
			      DefeatCondCode),
	    %% wrap up for delaying the defeasible condition
	    list_struct([],[],EmptyListObj), %% empty list
	    ( approx_prindex(Head,HeadIdx) -> true
	    ; HeadIdx=NO_INDEX
	    ),
	    delay_defeat_struct(HeadIdx,DefeatCondCode,
				EmptyListObj,EmptyListObj, %% no code 4 headvars
				DummyVarObj4Head,  %% will be bound to head
				DelayedDefeatCondCode)
	;
	    DelayedDefeatCondCode = true
	),
	!.

%% DefeatCondCode = FL_UNDEFEATED(DescrIdCode,FileName,DescrVarsTerm,HeadCode,ThisModule)
%%                  or true.
%% FL_UNDEFEATED is a modularized Prolog predicate
%% The difference is that instead of NewVar we insert head code at compile time.
construct_static_defeasible_condition(HeadCode,DescrIdCode,DescrVarsTerm,DelayedDefeatCondCode) :-
	(has_permaoption(FLDEFEASIBLE(LibModule)),
	    \+ has_context(compiling_udf_definition)
	->
	    %% create FL_UNDEFEATED(DescrIdCode,NewVar,ThisModule)
	    thismodule_struct(ThisModule),
	    %% create FL_UNDEFEATED(DescrIdCode,NewVar,ThisModule)
	    %% this code makes FL_UNDEFEATED into modularized Prolog predicate
	    %% It is faster, saves table space
	    modularized_pratom_struct(FL_UNDEFEATED,LibModule,NO_INDEX,UnDefeatFunCode),
	    var_caller_info_structure(ThisModule,CallerInfo),
	    get_current_compile_file(FileName),
	    prologterm_struct(UnDefeatFunCode,6,
			      [DescrIdCode,FileName,DescrVarsTerm,HeadCode,ThisModule,CallerInfo],
			      DefeatCondCode),
	    %% wrap up for delaying the defeasible condition
	    collect_prvars(HeadCode,HeadCodeVars1),
	    remove_caller_vars(HeadCodeVars1,HeadCodeVars),
	    vars_to_var_names(HeadCodeVars,HeadCodeVarNames),
	    list_struct(HeadCodeVars,[],HeadCodeVarsStruct),
	    list_struct(HeadCodeVarNames,[],HeadCodeVarNamesStruct),
	    ( approx_prindex(HeadCode,HeadIdx) -> true
	    ; HeadIdx=NO_INDEX
	    ),
	    delay_defeat_struct(HeadIdx,DefeatCondCode,
				HeadCodeVarsStruct,HeadCodeVarNamesStruct,
				NULL, %% head code
				DelayedDefeatCondCode)
	;
	    DelayedDefeatCondCode = true
	),
	!.


/****************************************************************************
  compile_conjunct2list(+ConjunctCode,-CodeList)
  compile_conjunct2list(+ConjunctCode,-CodeList,-ListTail)

  ConjunctCode may contain NULL.
****************************************************************************/
compile_conjunct2list(ConjunctCode,CodeList) :-
	compile_conjunct2list(ConjunctCode,CodeList,[]).

compile_conjunct2list(NULL,CodeList,CodeList) :- !.

compile_conjunct2list(ConjunctCode,CodeList,ListTail) :-
	conjunct_struct(C1,C2,ConjunctCode),
	!,
	compile_conjunct2list(C1,CodeList,T1),
	compile_conjunct2list(C2,T1,ListTail).

compile_conjunct2list(Code,[Code|ListTail],ListTail) :- !.


/****************************************************************************
  compile_head(+ParserTermList,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
  H2BCodeHead - code passed from head to body, which is supposed to be
                prepended to the code of the body
  H2BCodeTail - code passed from head to body, which is supposed to be
                appended to the code of the body
****************************************************************************/
compile_head_top(ParserTerm,Code,H2BCodeHead,H2BCodeTail,Status) :-
	collect_flvars(ParserTerm,FlVars),
	%% TODO: pass FlVars to compile_head as a parameter
	%%       Then pass it also to compile_body_top, compile_body,
	%%       compile_stop_delay
	set_context(compiling_head(FlVars)),
	compile_head(ParserTerm,Code,H2BCodeHead,H2BCodeTail,Status),
	clear_context(compiling_head(FlVars)),
	!.
compile_head([],NULL,NULL,NULL,[]) :- !.

compile_head([ParserTerm|ParserTermList],Code,H2BCodeHead,H2BCodeTail,Status) :-
	detach_flworkspace(ParserTerm,P,WS),
	compile_head_literal(P,WS,PCode,PH2BCodeHead,PH2BCodeTail,S),
	( no_errors_found(S) ->
	    compile_head(ParserTermList,PLCode,PLH2BCodeHead,PLH2BCodeTail,S2),
	    ( no_errors_found(S2) ->
		    conjunct_struct(PCode,PLCode,Code),
		    conjunct_code([PH2BCodeHead,PLH2BCodeHead],H2BCodeHead),
		    conjunct_code([PH2BCodeTail,PLH2BCodeTail],H2BCodeTail),
		    append(S,S2,Status)
	     ;
		Status=S2
	    )
	;
	  Status=S
        ),
	!.
compile_head([ParserTerm|_],_,_,_,Status) :-
	approx_flindex(ParserTerm,ErrIdx),
	compiling_error(ErrIdx,[UNKNOWN_ERROR,'\n\t\t Details: in compile_head'],Err),
	Status = [Err].


/****************************************************************************
  compile_body_top(+ParserTerm,-Code,-Status)
  compile_body(+ParserTerm,-Code,-Status)
****************************************************************************/
%% this is a top-level entry into the body compile. Called by compile_query/rule
compile_body_top(ParserTerm,Code,Status) :-
	collect_flvars(ParserTerm,FlVars),
	%% TODO: pass FlVars to compile_body as a parameter
	%%       Then pass it to compile_body_literal, compile_stop_delay
	set_context(compiling_body(FlVars)),
	compile_body(ParserTerm,Code,Status),
	clear_context(compiling_body(FlVars)),
	!.


compile_body(ParserTerm,Code,Status) :-
	is_flconjunct(ParserTerm,L,R),
	!,
	compile_body(L,LCode,S),
	( no_errors_found(S) ->
	    compile_body(R,RCode,S2),
	    ( no_errors_found(S2) ->
		conjunct_struct(LCode,RCode,Code),
		append(S,S2,Status)
	    ; Status=S2)
	;
	  Status=S
        ).

compile_body(ParserTerm,Code,Status) :-
	is_fldisjunct(ParserTerm,L,R),
	!,
	compile_body(L,LCode,S),
	( no_errors_found(S) ->
	    compile_body(R,RCode,S2),
	    ( no_errors_found(S2) ->
		disjunct_struct(LCode,RCode,Code),
		append(S,S2,Status)
	    ; Status=S2)
	;
	  Status=S
        ).


compile_body(ParserTerm,Code,Status) :-
	is_flneg(ParserTerm,G,Idx),
	!,
	compile_body(G,GCode,Status1),
	( no_errors_found(Status1) ->
	   neg_struct(GCode,Idx,Code,Status2),
	   append(Status1,Status2,Status)
	; Status = Status1
	).

compile_body(ParserTerm,Code,Status) :-
	is_default_negation(ParserTerm,G,NAFType),
	!,
	set_context(compiling_default_negation),
	compile_body(G,GCode,Status),
	( no_errors_found(Status) ->
	    (is_prquantifier(GCode,_Quant,FormCode,FreeVarObjList)
	    -> list_struct(FreeVarObjList,[],FreeVarObjs)
	    ;  FormCode = GCode,
		%% if no quantifier, use all vars minus dontcare/callervars
		collect_prvars(GCode,AllVars),
		remove_prdontcare_and_caller_vars(AllVars,FreeVarObjList1),
		%% this is used if naf-exists is nested deep inside the code
		remove_existential_vars(FreeVarObjList1,FreeVarObjList),
		list_struct(FreeVarObjList,[],FreeVarObjs)
	    ),
	    (NAFType == FL_RULELOGNAF
	    -> naf_struct_flora(FormCode,FreeVarObjs,Code)
	    ; naf_struct_prolog(FormCode,Code)
	    )
	; true
	),
	clear_context(compiling_default_negation).

compile_body(ParserTerm,Code,Status) :-
	is_fllogicquantifier(ParserTerm,FL_EXISTS,QuantVarNames,Formula,Idx),
	has_context(compiling_default_negation),
	!,
	%% no quantified don't care vars (?,?_) allowed
	(memberchk(FL_ANON_VAR,QuantVarNames) ->
	    compiling_error(Idx,NO_QUANTIFIED_ANONVARS,Err1),
	    S1 = [Err1]
	; S1 = NO_ERRORS
	),

	compile_body(Formula,FormCode,S2),
	%% We use prvars so that newly introduced vars will be accounted for
	collect_prvars(FormCode,FormVarList),
	vars_to_var_names(FormVarList,FormVarNames),
	(QuantVarNames == FL_STAR -> S3 = NO_ERRORS %% all vars are existential
	%% quantified vars must occur in Formula
	; subset(QuantVarNames,FormVarNames) -> S3 = NO_ERRORS
	; compiling_error(Idx,QUANT_VARS_NOT_SUBSET,Err3),
	    S3 = [Err3]
	),
	(QuantVarNames == FL_STAR -> FreeVarObjs_aux = []
	; subtract_varnames_from_vars(FormVarList,QuantVarNames,FreeVarObjs_aux)
	),
	remove_prdontcare_and_caller_vars(FreeVarObjs_aux,FreeVarObjs_aux2),
	%% this is used if naf-exists is nested deep inside the code
	remove_existential_vars(FreeVarObjs_aux2,FreeVarObjs),

	(QuantVarNames == FL_STAR -> RenamedFormCode = FormCode
	; rename_prvariables(QuantVarNames,NEWEXISTENTIALVAR,FormCode,
			     RenamedFormCode,_RenamedQuantVars)
	),
	flatten([S1,S2,S3],Status),
	!,
	( no_errors_found(Status) ->
	    %% Create code for compiled quantification.
	    quantifier_struct(FL_EXISTS,RenamedFormCode,FreeVarObjs,Code)
	;
	    true
	).


compile_body(ParserTerm,Code,Status) :-
	is_flhypothetical(ParserTerm,Op,Goal,Index),
	!,
	compile_body(Goal,GCode,Status),
	( no_errors_found(Status) ->
		hypothetical_struct(Op,GCode,Index,Code)
	;
	    true
	).

%% this is used when we reify latent queries
compile_body(ParserTerm,Code,Status) :-
	is_flannotated_construct(ParserTerm,Descriptor,Statement),
	is_fllatent_query(Statement,Body),
	!,
	approx_flindex(Statement,RuleIdx),
	compile_descriptor_list(Descriptor-RuleIdx,FL_DESCRMODE_LATENT_ADDQUERY,DescrIdCode,_DescrVarsTerm,MetaFacts,Status1),
	(no_errors_found(Status1) ->
	    compile_latent_query(DescrIdCode,MetaFacts,Body,FL_DESCRMODE_LATENT_ADDQUERY,CodeList-[],Status),
	    conjunct_code(CodeList,Code)
	; Status = Status1
	).
	%%compile_annotated_construct_add(Descriptor,MainPartOfRule,RuleDiffList,FactDiffList,QueryList,LatentQueryList,Status),
	%%lists:append_lists([RuleDiffList,FactDiffList,QueryList,LatentQueryList],Code).


%% a descriptor query in rule/query body like ... :- ..., @!{...}
compile_body(ParserTerm,Code,Status) :-
	is_fldescriptor(ParserTerm,_,FLRULEID,_),
	!,
	approx_flindex(ParserTerm,QueryIdx),
	compile_descriptor_list([ParserTerm]-QueryIdx,FL_DESCRMODE_PLAIN_QUERY,_,_,CodeList-[],Status),
	conjunct_code(CodeList,Code).

compile_body(ParserTerm,Code,Status) :-
	detach_flworkspace(ParserTerm,P,WS),
	compile_body_literal(P,WS,OidCode,SpecCode,BodyFrontList,Status),
	conjunct_code([OidCode,SpecCode],LitCode),
	append(BodyFrontList,[LitCode],CodeList), 
	conjunct_code(CodeList,Code).


/****************************************************************************
  compile_ifthenelse(+Cond,+Then,+Else,-Code,-Status)
****************************************************************************/
compile_ifthenelse(Cond,Then,Else,Code,Status) :-
	compile_body(Cond,CondCode,S1),
	compile_body(Then,ThenCode,S2),
	append(S1,S2,CondThenStatus),
	( no_errors_found(CondThenStatus) ->
	    compile_body(Else,ElseCode,Status),
	    ( no_errors_found(Status) ->
	       ifthenelse_struct(CondCode,ThenCode,ElseCode,Code)
	    ;
		true
	    )
	;
	    Status=CondThenStatus
	).


/****************************************************************************
  compile_ifthen(+Cond,+Then,-Code,-Status)
****************************************************************************/
compile_ifthen(Cond,Then,Code,Status) :-
	compile_body(Cond,CondCode,S1),
	( no_errors_found(S1) ->
	    compile_body(Then,ThenCode,Status),
	    ( no_errors_found(Status) ->
	       ifthen_struct(CondCode,ThenCode,Code)
	    ;
		true
	    )
	;
	  Status=S1
	).

/****************************************************************************
  compile_univeqform(+Left,+Right,-Code,-Status)

  Compiling ~
  This produces only spec code -- no oid code, because each argument
  is treated as Meta, so no oid is passed utside of this term
****************************************************************************/
compile_univeqform(Left,Right,Code,Status) :-
        set_context(goal_reification),
	compile_body(Left,LeftCode,S1),
	( no_errors_found(S1) ->
	    compile_body(Right,RightCode,Status),
	    ( no_errors_found(Status) ->
		univeqform_struct(LeftCode,RightCode,Code)
	    ;
		true
	    )
	;
	  Status=S1
	),
        clear_context(goal_reification).


/****************************************************************************
  compile_metauniv(+Left,+Right,-OidCode,-Code,-Status)
  Compiling =..
****************************************************************************/
compile_metauniv(Left,Right,OidCode,Code,Status) :-
	%% Use pathexp translation instead of body translation, because we
	%% don't want module name to be tacked on unless requested
	%% LeftCode becomes bound to the OID code of Left
	%% ObjCode is later conjuncted with the result
	compile_body_pathexp(Left,FL_THISMODULE,LeftCode,OidCodeLeft,ObjCode,[],S1),
	( no_errors_found(S1) ->
	    set_context(no_symbol_check),
	    compile_body_pathexp(Right,FL_THISMODULE,RightCode,OidCodeRight,RightObjCode,[],Status),
	    clear_context(no_symbol_check),
	    ( no_errors_found(Status) ->
	       metauniv_struct(LeftCode,RightCode,UnivCode),
		conjunct_code([UnivCode,ObjCode,RightObjCode],Code),
		conjunct_code([OidCodeLeft,OidCodeRight],OidCode)
	    ; true
	    )
	;
	    Status=S1
	).

/****************************************************************************
  compile_prologifthen(+Left,+Right,-Code,-Status)
  Compiling -->>
****************************************************************************/
compile_prologifthen(Left,Right,Code,Status) :-
        set_context(goal_reification),
	compile_body(Left,LeftCode,S1),
	( no_errors_found(S1) ->
	    compile_body(Right,RightCode,Status),
	    ( no_errors_found(Status) ->
		atomobj_struct(('->'),ArrowObj),
		prologterm_struct(ArrowObj,2,[LeftCode,RightCode],Code)
	    ;
		true
	    )
	;
	  Status=S1
	),
        clear_context(goal_reification).


/****************************************************************************
  compile_controlconstruct(+Cond,+Action,+Wrapper,-Code,-Status)

  Handle control stmts while-do,do-until,while-loop,loop-until,unless-do
****************************************************************************/
compile_controlconstruct(Cond,Action,Wrapper,Code,Status) :-
	compile_body(Cond,CondCode,S1),
	( no_errors_found(S1) ->
	    compile_body(Action,ActionCode,Status),
	    ( no_errors_found(Status) -> 
	       controlconstruct_struct(CondCode,ActionCode,Wrapper,Code)
	    ; true
	    )
	; Status = S1
	).


/****************************************************************************
verify_symbol_context(+Funct,+Arity,+SymbolContext,+Transactional,-SymbolContextStatus)
verify_symbol_context(+Funct,+Arity,+WS,+SymbolContext,+Transactional,-SymbolContextStatus)

  The context 'compiling_term_name' is set in rule body responsible
  for compiling a term (e.g. compile_body_termlit).
  It is cleared before compiling arguments of the term.
  It is needed to distinguish between compiling an atom as a term
  name and atom by itself

****************************************************************************/
verify_symbol_context(Funct,Arity,SymbolContext,Transactional,Status) :-
	verify_symbol_context(Funct,Arity,FL_THISMODULE,SymbolContext,Transactional,Status).

%% If term name is a variable, do not check 
/*
verify_symbol_context(Funct,_Arity,_WS,_SymbolContext,_Transactional,[]):-
	is_flvariable(Funct,_Name,_Index),
	!.
*/

%% If this is a HiLog term (Funct is a var or a complex term),
%% record the symbol context
verify_symbol_context(Funct,Arity,WS,SymbolContext,Transactional,Status):-
	(is_flvariable(Funct,_Name,Index) ; is_flterm(Funct,_FFunct,_FArity,_FArgs)),
	%% for hilog udfs, we record only a generic name, HILOG_SYMBOL_NAME.
	flatom_struct(HILOG_SYMBOL_NAME,Index,VarFunct),
	verify_symbol_context(VarFunct,Arity,WS,SymbolContext,Transactional,Status),
	!.

%% Already checked symbol: do not check again and do not record duplicates(!)
verify_symbol_context(Funct,Arity,_WS,SymbolContext,Transactional,[]):-
	SymbolContext \== SENSOR_SYMBOL,
	SymbolContext \== UDF_SYMBOL,
	flora_get_flatomvar_name(Funct,Name),
	has_symbol(Name,Arity,_,_SIndex,_SLine,SymbolContext,Transactional),
	!.

verify_symbol_context(Funct,Arity,_WS,UDF_SYMBOL,Transactional,[]):-
	flora_get_flatomvar_name(Funct,Name),
	(has_symbol(Name,Arity,_,_SIndex,_SLine,USE_UDF_SYMBOL,Transactional)
	; has_symbol(Name,Arity,_,_SIndex,_SLine,UDF_SYMBOL,Transactional)
	),
	!.

verify_symbol_context(Funct,Arity,_WS,SENSOR_SYMBOL,Transactional,[]):-
	flora_get_flatomvar_name(Funct,Name),
	(has_symbol(Name,Arity,_,_SIndex,_SLine,USE_SENSOR_SYMBOL,Transactional)
	; has_symbol(Name,Arity,_,_SIndex,_SLine,SENSOR_SYMBOL,Transactional)
	),
	!.

verify_symbol_context(_Funct,_Arity,_WS,_SymbolContext,_Transactional,[]):-
	has_context(compiling_term_name),
	!.

verify_symbol_context(_Funct,_Arity,_WS,_SymbolContext,_Transactional,[]):-
	has_context(no_symbol_check),
	!.

verify_symbol_context(Funct,Arity,_WS,PREDICATE_SYMBOL,NONTRANSACTIONAL_SYMBOL,[]):-
	flora_get_flatomvar_name(Funct,Name),
	has_symbol(Name,Arity,_,_SIndex,_SLine,PROLOG_SYMBOL,_Transactional),
	!.

verify_symbol_context(Funct,Arity,_WS,PREDICATE_SYMBOL,NONTRANSACTIONAL_SYMBOL,[]):-
	flora_get_flatomvar_name(Funct,Name),
	(has_context(compiling_sensor_directive(Name,Arity))
	;
	    has_permaoption(defsensor(Name,Arity))
	),
	!.


verify_symbol_context(Funct,Arity,WS,SymbolContext,Transactional,SymbolContextStatus):-
	flora_get_flatomvar_name(Funct,Name),
	!,
  	approx_flindex(Funct,Index),
        %% Check if symbol was used before in a different context
	( has_symbol(Name,SArity,_,_SIndex,SLine,SContext,STransactional),
	    Name \= HILOG_SYMBOL_NAME,
	    %% Index > 0 ensures that symbols introduced by the compiler
	    %% are not checked
	    integer(Index),
	    Index > 0,
	    make_symbol_context_status(SContext,SLine,' in the same file ',
				       STransactional,
				       SArity,Name,Arity,WS,
				       Index,SymbolContext,Transactional,
				       SymbolContextStatus),
	    SymbolContextStatus \== NO_ERRORS,
	    %% note: we need to backtrack through enough of symbols to
	    %% get a warning
	    !
	 ;
	    SymbolContextStatus = NO_ERRORS
         ),
	!,
	get_index_line(Index,Line),
	add_symbol(Name,Arity,WS,Index,Line,SymbolContext,Transactional).

verify_symbol_context(_Funct,_Arity,_WS,_SymbolContext,_Transactional,[]).

/****************************************************************************
suppress_symbol_warning(+Name,+Arity,+WS,+SymbolContext,+Transactional)
****************************************************************************/
%% do not check workspace for function symbols
suppress_symbol_warning(Name,Arity,_WS,FUNCTION_SYMBOL,Transactional):-
	(has_nowarn_any_symbol(Name,Arity,_,FUNCTION_SYMBOL,Transactional);
	has_nowarn_any_symbol(Name,FL_STAR,_,FUNCTION_SYMBOL,Transactional)),
	!.

suppress_symbol_warning(Name,Arity,_WS,SymbolContext,Transactional):-
	(has_nowarn_any_symbol(Name,Arity,StoredWS,SymbolContext,Transactional);
	has_nowarn_any_symbol(Name,FL_STAR,StoredWS,SymbolContext,Transactional)),
	%% If StoredWS is an anonymous variable - then ignore warnings
	is_flvariable(StoredWS,VarName,_VarIndex),
	VarName == FL_ANON_VAR,
	!.

/*
%% Is this redundant in view of the next clause?? WS can't be NULL any more
suppress_symbol_warning(Name,Arity,NULL,SymbolContext,Transactional):-
	%% if workspace for symbol is NULL then ignore warnings
	%% only if StoredWS is current module or NULL
	(has_nowarn_any_symbol(Name,Arity,NULL,SymbolContext,Transactional);
	has_nowarn_any_symbol(Name,FL_STAR,NULL,SymbolContext,Transactional)),
	!.
*/

suppress_symbol_warning(Name,Arity,FL_THISMODULE,SymbolContext,Transactional):-
	%% if workspace for symbol is FL_THISMODULE then ignore warnings
	(has_nowarn_any_symbol(Name,Arity,FL_THISMODULE,SymbolContext,Transactional);
	has_nowarn_any_symbol(Name,FL_STAR,FL_THISMODULE,SymbolContext,Transactional)),
	!.

suppress_symbol_warning(Name,Arity,WS,SymbolContext,Transactional):-
	%% if workspace for symbol is not NULL then we ignore warnings
	%% only if StoredWS has the same name as WS
	%%WS \= NULL,
	WS \= FL_THISMODULE,
	flora_get_flatomvar_name(WS,WSName),
	(has_nowarn_any_symbol(Name,Arity,WSName,SymbolContext,Transactional);
	has_nowarn_any_symbol(Name,FL_STAR,WSName,SymbolContext,Transactional)),
	!.

/****************************************************************************
compiling_symbol_warning(+Name,+Arity,+WS,+SymbolContext,+Transactional,+Index,+Mesg,-Status)
****************************************************************************/
compiling_symbol_warning(_Name,_Arity,_WS,_SymbolContext,_Transactional,_Index,_Mesg,[]):-
	symbol_warnings_flag(FLORA_WARNOFF),
	!.

compiling_symbol_warning(Name,Arity,WS,SymbolContext,Transactional,_Index,_Mesg,[]):-
	suppress_symbol_warning(Name,Arity,WS,SymbolContext,Transactional),
	!.

compiling_symbol_warning(_Funct,_Arity,_WS,_SymbolContext,_Transactional,Index,Mesg,[Warning]):-
	compiling_warning(Index,Mesg,Warning).

/****************************************************************************
make_symbol_context_status(+UsedContext,+UsedLine,+UsedFileMsg,+UsedTransactional,+UsedArity,+SymbolName,+SymbolArity,+SymbolWS,+SymbolIndex,+SymbolContext,+SymbolTransactional,-Status)
****************************************************************************/
make_symbol_context_status(_UsedContext,UsedLine,UsedFileMsg,UsedTransactional,_UsedArity,SymbolName,SymbolArity,SymbolWS,SymbolIndex,SymbolContext,SymbolTransactional,ContextStatus) :-
	UsedTransactional\=SymbolTransactional,
	!,
	(SymbolTransactional==TRANSACTIONAL_SYMBOL
	-> compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,SymbolContext,SymbolTransactional,SymbolIndex,
			     [WARN_TRANSACTIONAL_SYMBOL,ERRLINE_NO,
			      UsedLine,UsedFileMsg],
			     ContextStatus)
	; compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,SymbolContext,SymbolTransactional,SymbolIndex,
			    [WARN_NONTRANSACTIONAL_SYMBOL,ERRLINE_NO,
			     UsedLine,UsedFileMsg],
			    ContextStatus)
	).

make_symbol_context_status(UsedContext,UsedLine,UsedFileMsg,_UsedTransactional,UsedArity,SymbolName,SymbolArity,SymbolWS,SymbolIndex,FUNCTION_SYMBOL,SymbolTransactional,ContextStatus) :-
	( UsedContext==UDF_SYMBOL, UsedArity\=SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,FUNCTION_SYMBOL,SymbolTransactional,SymbolIndex,
			      [WARN_FUNC_UDF_ARITY_SYMBOL,ERRLINE_NO,
			       UsedLine,UsedFileMsg],
			      ContextStatus)
	; UsedContext==FUNCTION_SYMBOL,
	    UsedArity\=SymbolArity,
	    %%_UsedTransactional = SymbolTransactional,
	    %% This prevents things like a+b and X = +1 from causing a warning
	    %% Ditto with a-b, X=-2.
	    ((SymbolName \== FL_MINUS, SymbolName \== FL_PLUS)
	    ; (UsedArity =\= 1, UsedArity =\= 2)
	    ; (SymbolArity =\= 1, SymbolArity =\= 2)
	    )
	    ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,FUNCTION_SYMBOL,SymbolTransactional,SymbolIndex,
			      [WARN_FUNC_ARITY_SYMBOL,ERRLINE_NO,
			       UsedLine,UsedFileMsg],
			      ContextStatus)
	;   %% for the following, we warn only if there was prior use as
	    %% hilog predicate, modular prolog predicate, or sensor
	    %% with the ***same*** number of arguments
	    UsedContext==PREDICATE_SYMBOL, UsedArity==SymbolArity,
	    (\+memberchk(SymbolName,[FL_FALSE,FL_TRUE]) ; UsedArity =\= 0)
	->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,FUNCTION_SYMBOL,SymbolTransactional,SymbolIndex,
			      [WARN_FUNC_PREDICATE_SYMBOL,ERRLINE_NO,
			       UsedLine,UsedFileMsg],
			      ContextStatus)
	; UsedContext==PROLOG_SYMBOL, UsedArity==SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,FUNCTION_SYMBOL,SymbolTransactional,SymbolIndex,
			      [WARN_FUNC_PROLOG_SYMBOL,ERRLINE_NO,
			       UsedLine,UsedFileMsg],
			      ContextStatus)
	; UsedContext==SENSOR_SYMBOL, UsedArity==SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,FUNCTION_SYMBOL,SymbolTransactional,SymbolIndex,
			      [WARN_FUNC_SENS_SYMBOL,ERRLINE_NO,
			       UsedLine,UsedFileMsg],
			      ContextStatus)
/*
	; UsedContext==BUILTIN_SYMBOL,
	    (UsedArity==SymbolArity
	    -> compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,FUNCTION_SYMBOL,SymbolTransactional,SymbolIndex, WARN_BUILTIN_SYMBOL, ContextStatus)
	    ; compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,FUNCTION_SYMBOL,SymbolTransactional,SymbolIndex, WARN_BUILTIN_ARITY_SYMBOL, ContextStatus)
	    )
*/
	;
		ContextStatus = NO_ERRORS
        ),
	!.

make_symbol_context_status(UsedContext,UsedLine,UsedFileMsg,_UsedTransactional,UsedArity,SymbolName,SymbolArity,SymbolWS,SymbolIndex,PREDICATE_SYMBOL,SymbolTransactional,ContextStatus) :-
	( UsedContext==UDF_SYMBOL, UsedArity==SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,PREDICATE_SYMBOL,SymbolTransactional,SymbolIndex,
			      [WARN_PREDICATE_UDF_SYMBOL,ERRLINE_NO,
			       UsedLine,UsedFileMsg],
			      ContextStatus)
	; UsedContext==FUNCTION_SYMBOL, UsedArity==SymbolArity,
	    (\+memberchk(SymbolName,[FL_FALSE,FL_TRUE]) ; UsedArity =\= 0)
	->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,PREDICATE_SYMBOL,SymbolTransactional,SymbolIndex,
			      [WARN_PREDICATE_FUNC_SYMBOL,ERRLINE_NO,
			       UsedLine,UsedFileMsg],
			      ContextStatus)
	; UsedContext==PREDICATE_SYMBOL,
	    %%_UsedTransactional = SymbolTransactional,
	    UsedArity\=SymbolArity
	->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,PREDICATE_SYMBOL,SymbolTransactional,SymbolIndex,
			      [WARN_PREDICATE_ARITY_SYMBOL,ERRLINE_NO,
			       UsedLine,UsedFileMsg],
			      ContextStatus)
	; UsedContext==PROLOG_SYMBOL, UsedArity\=SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,PREDICATE_SYMBOL,SymbolTransactional,SymbolIndex,
			      [WARN_PREDICATE_PROLOG_ARITY_SYMBOL,ERRLINE_NO,
			       UsedLine,UsedFileMsg],
			      ContextStatus)
	; UsedContext==SENSOR_SYMBOL, UsedArity==SymbolArity,
	    \+compiling_flrshell_command ->
	    compiling_error(SymbolIndex,
			    [ERROR_PREDICATE_SENS_SYMBOL,ERRLINE_NO,
			     UsedLine,UsedFileMsg],
			    Err),
	    ContextStatus = [Err]
	; UsedContext==SENSOR_SYMBOL, \+compiling_flrshell_command ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,PREDICATE_SYMBOL,SymbolTransactional,SymbolIndex,
			      [ERROR_PREDICATE_SENS_SYMBOL,ERRLINE_NO,
			      UsedLine,UsedFileMsg],
			      ContextStatus)
	;
	    ContextStatus = NO_ERRORS
	),
	!.

make_symbol_context_status(UsedContext,UsedLine,UsedFileMsg,_UsedTransactional,UsedArity,SymbolName,SymbolArity,SymbolWS,SymbolIndex,UDF_SYMBOL,SymbolTransactional,ContextStatus) :-
	( UsedContext==PROLOG_SYMBOL, UsedArity==SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,UDF_SYMBOL,SymbolTransactional,SymbolIndex,
			      [WARN_UDF_PROLOG_SYMBOL,ERRLINE_NO,
			       UsedLine,UsedFileMsg],
			      ContextStatus)
	; UsedContext==FUNCTION_SYMBOL,
	    (UsedArity==SymbolArity
	    -> compiling_error(SymbolIndex,
			       [ERROR_UDF_SYMBOL, %%WARN_UDF_FUNC_SYMBOL,
				ERRLINE_NO, UsedLine,UsedFileMsg],
			       Err),
		ContextStatus = [Err]
	    ; compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,UDF_SYMBOL,SymbolTransactional,SymbolIndex,
				[WARN_UDF_FUNC_ARITY_SYMBOL,ERRLINE_NO,
				 UsedLine,UsedFileMsg],
				ContextStatus)
	    )
	; UsedContext==PREDICATE_SYMBOL,
	    (UsedArity==SymbolArity
	    -> compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,UDF_SYMBOL,SymbolTransactional,SymbolIndex,
				 [WARN_UDF_PREDICATE_SYMBOL,ERRLINE_NO,
				  UsedLine,UsedFileMsg],
				 ContextStatus)
	    ; compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,UDF_SYMBOL,SymbolTransactional,SymbolIndex,
				[WARN_UDF_PREDICATE_ARITY_SYMBOL,ERRLINE_NO,
				 UsedLine,UsedFileMsg],
				ContextStatus)
	    )
	; UsedContext==SENSOR_SYMBOL, UsedArity==SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,UDF_SYMBOL,SymbolTransactional,SymbolIndex,
			      [WARN_UDF_SENSOR_SYMBOL,ERRLINE_NO,
			       UsedLine,UsedFileMsg],
			      ContextStatus)
	; UsedContext==BUILTIN_SYMBOL,
	    (UsedArity==SymbolArity
	    -> compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,UDF_SYMBOL,SymbolTransactional,SymbolIndex, WARN_BUILTIN_SYMBOL, ContextStatus)
	    ; compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,UDF_SYMBOL,SymbolTransactional,SymbolIndex, WARN_BUILTIN_ARITY_SYMBOL, ContextStatus)
	    )
	;
	    ContextStatus = NO_ERRORS
	),
	!.

make_symbol_context_status(UsedContext,UsedLine,UsedFileMsg,_UsedTransactional,UsedArity,SymbolName,SymbolArity,SymbolWS,SymbolIndex,SENSOR_SYMBOL,SymbolTransactional,ContextStatus) :-
	( UsedContext==UDF_SYMBOL, UsedArity==SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,SENSOR_SYMBOL,SymbolTransactional,SymbolIndex,
			      [WARN_SENSOR_UDF_SYMBOL,ERRLINE_NO,
			       UsedLine,UsedFileMsg],
			      ContextStatus)
	; UsedContext==FUNCTION_SYMBOL, UsedArity==SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,SENSOR_SYMBOL,SymbolTransactional,SymbolIndex,
			      [WARN_SENSOR_FUNC_SYMBOL,ERRLINE_NO,
			       UsedLine,UsedFileMsg],
			      ContextStatus)
	; UsedContext==PREDICATE_SYMBOL, UsedArity\=SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,SENSOR_SYMBOL,SymbolTransactional,SymbolIndex,
			      [ERROR_SENSOR_PREDICATE_SYMBOL,ERRLINE_NO,
			       UsedLine,UsedFileMsg],
			      ContextStatus)
	; UsedContext==PREDICATE_SYMBOL, UsedArity==SymbolArity ->
	    (\+compiling_flrshell_command ->
		compiling_error(SymbolIndex,
			      [ERROR_SENSOR_PREDICATE_SYMBOL,ERRLINE_NO,
			       UsedLine,UsedFileMsg],
			      Err),
		ContextStatus = [Err]
	    %% in the FLORA shell just give a warning
	    ; compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,SENSOR_SYMBOL,SymbolTransactional,SymbolIndex,
			      [ERROR_SENSOR_PREDICATE_SYMBOL,ERRLINE_NO,
			       UsedLine,UsedFileMsg],
			      ContextStatus)
	    )
	; UsedContext==SENSOR_SYMBOL, UsedArity\=SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,SENSOR_SYMBOL,SymbolTransactional,SymbolIndex,
			      [WARN_SENSOR_ARITY_SYMBOL,ERRLINE_NO,
			       UsedLine,UsedFileMsg],
			      ContextStatus)
	; UsedContext==PROLOG_SYMBOL,
	    %% prolog symbol that comes from a sensor has 2 more args: file+line
	    (UsedArity=\=SymbolArity
	    -> compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,SENSOR_SYMBOL,SymbolTransactional,SymbolIndex,
				 [ERROR_SENSOR_PROLOG_SYMBOL,ERRLINE_NO,
				  UsedLine,UsedFileMsg],
				 ContextStatus)
	    ; compiling_error(SymbolIndex,
			      [ERROR_SENSOR_PROLOG_SYMBOL,ERRLINE_NO,
			       UsedLine,UsedFileMsg],
			      Err),
	    	ContextStatus=[Err]
	    )
	; UsedContext==BUILTIN_SYMBOL,
	    (UsedArity==SymbolArity
	    -> compiling_error(SymbolIndex, WARN_BUILTIN_SYMBOL, Err),
	    	ContextStatus=[Err]
	    ; compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,SENSOR_SYMBOL,SymbolTransactional,SymbolIndex, WARN_BUILTIN_ARITY_SYMBOL, ContextStatus)
	    )
	;
	    ContextStatus = NO_ERRORS
	),
	!.

make_symbol_context_status(UsedContext,UsedLine,UsedFileMsg,_UsedTransactional,UsedArity,SymbolName,SymbolArity,SymbolWS,SymbolIndex,PROLOG_SYMBOL,SymbolTransactional,ContextStatus) :-
	%% MK: can this happen in the FLORA shell?
	( UsedContext==UDF_SYMBOL, UsedArity==SymbolArity ->
	    compiling_error(SymbolIndex,
			    [ERROR_PROLOG_UDF_SYMBOL,ERRLINE_NO,
			     UsedLine,UsedFileMsg],
			    Err),
		ContextStatus=[Err]
	; UsedContext==PROLOG_SYMBOL, UsedArity\=SymbolArity ->
	    compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,PROLOG_SYMBOL,SymbolTransactional,SymbolIndex,
			      [WARN_PROLOG_ARITY_SYMBOL,ERRLINE_NO,
			       UsedLine,UsedFileMsg],
			      ContextStatus)
	; UsedContext==FUNCTION_SYMBOL, UsedArity==SymbolArity ->
		compiling_error(SymbolIndex,
				[ERROR_PROLOG_FUNC_SYMBOL,ERRLINE_NO,
				 UsedLine,UsedFileMsg],
				Err),
		ContextStatus=[Err]
	; UsedContext==PREDICATE_SYMBOL,
	    (UsedArity==SymbolArity
	    -> compiling_error(SymbolIndex,
			       [ERROR_PROLOG_PREDICATE_SYMBOL,ERRLINE_NO,
				UsedLine,UsedFileMsg],
			       Err),
	    	ContextStatus=[Err]
	    ; compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,PROLOG_SYMBOL,SymbolTransactional,SymbolIndex,
				[WARN_PROLOG_PREDICATE_ARITY_SYMBOL,ERRLINE_NO,
				 UsedLine,UsedFileMsg],
				ContextStatus)
	    )
	; UsedContext==BUILTIN_SYMBOL,
	    (UsedArity==SymbolArity
	    -> compiling_error(SymbolIndex, WARN_BUILTIN_SYMBOL, Err),
		    ContextStatus=[Err]
	    ; compiling_symbol_warning(SymbolName,SymbolArity,SymbolWS,PROLOG_SYMBOL,SymbolTransactional,SymbolIndex, WARN_BUILTIN_ARITY_SYMBOL, ContextStatus)
	    )
	;
	    ContextStatus = NO_ERRORS
	),
	!.

make_symbol_context_status(_,_,_,_,_,_,_,_,_,_,_,[]).


/****************************************************************************
  compile_load(+LoadList,-Code,-Status)
****************************************************************************/
compile_load(LoadList,Code,Status) :-
	is_fllist(LoadList,L,T,I),
	%% since complex terms aren't allowed in load lists, we ignore OidCode
	compile_body_list_obj(L,T,I,FL_THISMODULE,ObjList,_OidCode,OCode,[],Status),
	( no_errors_found(Status) ->
	    thismodule_struct(Mod),
	    %% This is the file being compiled
	    (flora_compiler_environment(file,ProgramFile), !
	    ; ProgramFile=userin
	    ),
	    %% "I" is a token index
	    flora_nth_token(I,Token),
	    flora_token_text(Token,_TextStr,BLN,BCN,_ELN,_ECN),
	    %% Encode location of the literal [file>>mod]
	    %% Location is used for error checking in flrload.P to make sure
	    %% that loading of a file doesn't override the program
	    %% in which the loading statement occurs
	    list_struct([BLN,BCN],[],PositionCode),
	    florasyslib_struct(I,FLLIBLOAD,
			       4,
			       [ObjList,ProgramFile,Mod,PositionCode],LCode),
	    conjunct_code([OCode,LCode],Code)
	;
	  true
        ).


/****************************************************************************
  compile_var(+Name,+Index,-VarObject)
****************************************************************************/
compile_var(Name,Index,VarObject) :-
	( Name == FL_ANON_VAR -> new_dontcare_prvariable(Index,VarObject)
	;
	  varobj_struct(Name,Index,VarObject)
        ),
	!.

compile_transactionalvar_without_trans(Name,Index,VarObject) :-
	( Name == FL_ANON_VAR -> new_dontcare_prvariable(Index,VarObject)
	;
	  varobj_struct(Name,Index,VarObject)
        ),
	!.

compile_transactionalvar(Name,Index,VarObject) :-
	( Name == FL_ANON_VAR -> new_dontcare_prtransactionalvar(Index,VarObject)
	;
	  transactionalvar_struct(Name,Index,VarObject)
        ),
	!.

%% takes list of flvars
compile_var_list([],[]) :- !.
compile_var_list([Var|Rest],[PrVar|PrRest]) :-
	is_flvariable(Var,Name,Index),
	compile_var(Name,Index,PrVar),
	compile_var_list(Rest,PrRest).

/****************************************************************************
  compile_atomobj(+ParserTerm,-Object,?BodyFrontList,-Status)

  ?BodyFrontList - code to add at the beginning of the body
                  (mostly for user defined fnctions),
		  it is output argument, but if it is initialized to empty ([])
		  ignores user defined functions
****************************************************************************/
compile_atomobj(ParserTerm,Object,BodyFrontList,Status):-
	var(BodyFrontList),
	%% NO cut here!
	\+ has_context(compiling_arithmetics),
	has_UDF(ParserTerm,0,[],Predicate,Object /* return value */,_,_),
	!,
	verify_symbol_context(ParserTerm,0,UDF_SYMBOL,
			      NONTRANSACTIONAL_SYMBOL,SymStatus),
	compile_udf_body_literal(ParserTerm,Predicate,PCode,PBodyFrontList,S),
	( no_errors_found(S) -> 
	    append(PBodyFrontList,[PCode],BodyFrontList),
	    append(S,SymStatus,Status)
	;
	    approx_flindex(ParserTerm,Index),
	    compiling_error(Index,ERROR_UDF_COMPILE,Err),
	    Status = [Err|S]
	).

compile_atomobj(ParserTerm,Object,[],Status):-
	verify_symbol_context(ParserTerm,0,FUNCTION_SYMBOL,
			      NONTRANSACTIONAL_SYMBOL,Status),
	atomobj_struct(ParserTerm,Object).


/****************************************************************************
  compile_udf_body_literal(+Funct,+Predicate,-PCode,-PBodyFrontList,-Status)

  Compile a UDF literal in the body.
****************************************************************************/
compile_udf_body_literal(Funct,Predicate,PCode,PBodyFrontList,Status) :-
	%% If we set no_symbol_check here then clear it out at the end.
	%% If inherited no_symbol_check from the caller - do not do
	%% clear out the context
	(has_context(no_symbol_check) -> Clear = no
	; set_context(no_symbol_check), Clear = yes
	),
	set_context(compiling_udf_hilog(Funct)),
	compile_body_literal(Predicate,FL_THISMODULE,OidCode,SpecCode,PBodyFrontList,Status),
	conjunct_code([OidCode,SpecCode],PCode),
	clear_context(compiling_udf_hilog(Funct)),
	(Clear == yes -> clear_context(no_symbol_check)
	; true
	).


/****************************************************************************
  find_UDF(+BaseName,+N,-UDFCode,-Predicate) 

  Indicate if there is an active UDF
****************************************************************************/
find_UDF(BaseName,N,UDFCode,Predicate) :-
	has_permaoption(udf_option(BaseName,N,UDFCode,_PredName,Predicate)),
	!.
find_UDF(BaseName,N,UDFCode,Predicate) :-
	flora_used_udf_registry(BaseName,N,UDFCode,Predicate),
	!.

/****************************************************************************
  has_UDF(+Funct,+N,-Predicate,-ReturnValue,-BodyFrontList,-Status) 

  Tells if there is an active UDF with this Funct/N

  Funct - Functor of UDF
  N - Arity of UDF
  Predicate - the new_udf_predicate_XXX that computes this UDF
  ReturnValue - the variable representing the return value of this UDF;
                it appears in Predicate as Arg 1.
  BodyFrontList - a list of literals to be added to rule body where udf appears
                 (again for cases when udf functor is a term)
  Example:
     head :- q(?x(a,b)(?x))
     head :- udf_hilog_predicate(?x(a,b),?var2),
	     udf_hilog_predicate(?var2(?x)),?var1),
             q(?var1) 
****************************************************************************/
%% TODO: Status seems to be always [] - remove?
has_UDF(Funct,N,Args,Predicate,ReturnValue,[],[]) :-
	\+ has_context(block_udf_expansion),
	\+ has_context(compiling_udf_hilog(Funct)),
	\+ get_flatom_name(Funct,UDFHILOGPREDICATENAME),
	flora_get_flatom_name(Funct,Name),
	(flrsynonym:flora_op_synonym(Name,BaseName)
	; BaseName = Name
	),
	find_UDF(BaseName,N,_UDFCode,_PredicateCode),
	form_udf_hilog_predicate(Funct,N,Args,Predicate,ReturnValue),
	!.

has_UDF(Funct,N,Args,Predicate,ReturnValue,[],[]) :-
	\+ has_context(block_udf_expansion),
	N\=0,
	Args\=[],
	Args\=null,
	is_flvariable(Funct,_VarName,_Idx),
	!,
	\+ has_context(compiling_udf_hilog(Funct)),
	find_UDF(_BaseName,N,_UDFCode,_PredicateCode),
	form_udf_hilog_predicate(Funct,N,Args,Predicate,ReturnValue).


has_UDF(Funct,N,Args,Predicate,ReturnValue,[],[]) :-
	\+ has_context(block_udf_expansion),
	N\=0,
	Args\=[],
	Args\=null,
	is_flterm(Funct,_FFunct,_FunctN,_FunctArgs),
	!,
	\+ has_context(compiling_udf_hilog(Funct)),
	find_UDF(_BaseName,N,_UDFCode,_Predicate),
	form_udf_hilog_predicate(Funct,N,Args,Predicate,ReturnValue).

has_UDF(Funct,N,Args,Predicate,ReturnValue,[],[]) :-
	\+ has_context(block_udf_expansion),
	\+ has_context(compiling_udf_hilog(Funct)),
	N\=0,
	Args\=[],
	Args\=null,
	find_UDF(HILOG_SYMBOL_NAME,N,_UDFCode,_PredicateCode),
	form_udf_hilog_predicate(Funct,N,Args,Predicate,ReturnValue).

/****************************************************************************
  form_udf_hilog_predicate(+Funct,+N,+Args,+ReturnOrigPred,-Predicate,-ReturnValue) 

  forms the predicate for UDF with term names (hilog).

  Funct - udf functor
  N - udf arity
  Args - udf arguments
  Predicate - UDFHILOGPREDICATENAME code
  ReturnValue - code for the return variable which represents the return value
                of udf_hilog_predicate. This variable appears as argument 5 in
		UDFHILOGPREDICATENAME.
****************************************************************************/
form_udf_hilog_predicate(Funct,N,Args,NewHeadCode,NewReturnValueObj):-
	get_udf_hilog_predicate_funct(NPFunct),
	%%set_context(compiling_udf_hilog(NPFunct)),
	new_flvariable(NO_INDEX,NewReturnValue,NewReturnValueObj),
	flterm_struct(Funct,N,Args,OrigPredicateCode),
	flthismodule_struct(Module),
	flterm_struct(NPFunct,5,[OrigPredicateCode,N,Module,NewReturnValue],NewHeadCodePre),
	flplib_struct(NewHeadCodePre,NewHeadCode).

/****************************************************************************
  get_udf_hilog_predicate_funct(-Funct) 

  form predicate functor for UDF with term names (hilog).
****************************************************************************/
get_udf_hilog_predicate_funct(Funct):-
	flatom_struct(UDFHILOGPREDICATENAME,NO_INDEX,Funct).



/****************************************************************************
  compile_delayquant(+Quant,+Condition,+Goal,+Index,-SpecCode,-BodyFrontList,-Status)
****************************************************************************/
compile_delayquant(Quant,ConditionWS,Goal,Index,SpecCode,BodyFrontList,Status):-
	collect_flvars(ConditionWS,CondVarList),
	vars_to_var_names(CondVarList,CondVarNames),
	collect_flvars(Goal,GoalVarList),
	vars_to_var_names(GoalVarList,GoalVarNames),
	detach_flworkspace(ConditionWS,Condition,WS),
	compile_body_literal(Condition,WS,OidCode,WSCode,BodyFrontList,S1),
	conjunct_code([OidCode,WSCode],ConditionCode),
	(subset(CondVarNames,GoalVarNames) ->
	    ( no_errors_found(S1) ->
		compile_body(Goal,GoalCode,S2),
		( no_errors_found(S2) ->
		    append(S1,S2,Status),
		    delay_struct(Index,FL_DELAYQUANT,
				 [Quant,ConditionCode,GoalCode],
				 SpecCode)
		;
		    Status = S2
		)
	    ;
		Status = S1
	    )
	;
	    approx_flindex(Condition,Idx),
	    compiling_error(Idx,DELAY_QUANT_VARS_NOT_IN_GOAL,Err),
	    Status = [Err]
	).


/****************************************************************************
  compile_aggregate(+Op,+Var,+GVars,+SortSpec,+BodyTerm,-Object,-Code,-Status)
****************************************************************************/
compile_aggregate(Op,Var,GVars,SortSpec,BodyTerm,Object,Code,Status) :-
	compile_body(BodyTerm,BodyPureCode,S),
	delay_literals_checking_code([],BodyTerm,FL_DESCRIPTOR_VARS_WRAPPER,DelayCheckCode),
	PostBody = DelayCheckCode,
	(is_prvariable(PostBody) -> BCode = BodyPureCode
	; conjunct_struct(BodyPureCode,PostBody,BCode)
	),
	( no_errors_found(S) -> 
            (
	      /* check_aggregate was disabled by changz after adding singleton
	         checks to dynamic rules. Not clear why she did that. None of
	         the tests are affected by this, but such a change prevents
	         checks for grouping/aggregate vars in cases like
		      ?- insertrule{a :- ?x=count{?k|true@?V}}.
		 So, we zap changz's change until we find out why it is needed.
	      */
	    /*
	      has_context(compile_with_var_module),
		\+ has_context(goal_reification) ->
                S1 = NO_ERRORS
            ;
	    */
	        check_aggregate(Var,GVars,BodyTerm,S1)
            ),
	    ( no_errors_found(S1) -> 
		compile_body_pathexplist([Var|GVars],FL_THISMODULE,[VarCode|GVarsCode],NULL,NULL,[],[]),
		list_struct(GVarsCode,[],GVarsListCode),
		(SortSpec==NULL
		-> aggregate_struct(Op,VarCode,GVarsListCode,BCode,Object,Code),
		    Status = NO_ERRORS
		;
		    is_flterm(SortSpec,Funct,N,Args),
		    (is_fltransactionalatom(Funct,_)
		    -> Transactionality = TRANSACTIONAL_SYMBOL
		    ; Transactionality = NONTRANSACTIONAL_SYMBOL
		    ),
		    compile_body_termobj(Funct,N,Args,FL_THISMODULE,SpecCode,_,_,[],Transactionality,Status),
		    ( no_errors_found(Status) -> 
			aggregate_struct(Op,VarCode,GVarsListCode,SpecCode,BCode,Object,Code)
		    ;   true
		    )
		)
	    ;
	      Status = S1
	    )
	;
	  Status=S
        ),
	!.


/****************************************************************************
  check_aggregate(+Var,+GroupVars,+BodyTerm,-Status)
  check_repeatedvar(+Vars,-Status,-TailStatus)
  allgvar_notin(+SortedVars,-Status,-TailStatus)
  Checks for any abnormalities with grouping and aggregate variables.
****************************************************************************/
check_aggregate(Var,GVars,BodyTerm,Status) :-
	is_flvariable(Var,VarName,VarIndex),
	%% Check if the aggregate variable is anonymous.
	( VarName == FL_ANON_VAR ->
	    compiling_error(VarIndex,ERROR_AVAR,M1),
	    Status=[M1|S1]
	;
	  Status=S1
        ),
	%% Check if any grouping variable is anonymous.
	check_gvar(GVars,S1,S2),
	%% Check if the aggregate variable is also used for grouping.
	( VarName \= FL_ANON_VAR, is_flvariable(U,VarName,_Iu), memberchk(U,GVars) ->
	    compiling_error(VarIndex,AVAR_ASGVAR,M2),
	    S2=[M2|S3]
	;
	  S3=S2
        ),
	%% Check if there are any repeated grouping variables.
	sort(GVars,SVars),
	check_repeatedvar(SVars,S3,S4),
	collect_flvars(BodyTerm,BVars),
	%% Check if aggregate variable is used in the aggregate body.
	( (VarName == FL_ANON_VAR; is_flvariable(W,VarName,_Iw), memberchk(W,BVars)) ->
	    S5=S4
        ;
	  compiling_error(VarIndex,AVAR_NOTIN,M5),
	  S4=[M5|S5]
        ),
	%% Check if all grouping variables are used in the aggregate body.
	( subtract_vars(GVars,BVars,L), L \== [] ->
	    sort(L,SL),
	    allgvar_notin(SL,S5,[])
	;
	  S5 = NO_ERRORS
        ),
	!.


check_gvar([],S,S) :- !.

check_gvar([H|L],Status,TS) :-
	( is_flvariable(H,FL_ANON_VAR,HIndex) ->
	    compiling_error(HIndex,ERROR_GVAR,M),
	    Status=[M|S],
	    check_gvar(L,S,TS)
	;
	  check_gvar(L,Status,TS)
        ).


check_repeatedvar([],S,S) :- !.

check_repeatedvar([H|L],Status,TS) :-
	is_flvariable(H,FL_ANON_VAR,_I),
	!,
	check_repeatedvar(L,Status,TS).

check_repeatedvar([_H],S,S) :- !.

check_repeatedvar([H1,H2|T],Status,TS) :-
	( is_flvariable(H1,Name,_I1), is_flvariable(H2,Name,I2) ->
	    compiling_error(I2,REPEATED_GVAR,Msg),
	    Status=[Msg|S],
	    check_repeatedvar([H1|T],S,TS)
	;
	  check_repeatedvar([H2|T],Status,TS)
        ).


allgvar_notin([],S,S) :- !.

allgvar_notin([H|L],Status,TS) :-
	is_flvariable(H,FL_ANON_VAR,_I),
	!,
	allgvar_notin(L,Status,TS).

allgvar_notin([H|T],[Msg|S],TS) :-
	is_flvariable(H,Name,Index),
	compiling_error(Index,GVAR_NOTIN,Msg),
	remove_named_flvar(T,Name,L),
	allgvar_notin(L,S,TS).


/****************************************************************************
  compile_head_fltoken(+Token,+Index,-Object)

  Handles _#, _#123, _@, atoms
****************************************************************************/
compile_head_fltoken(Token,Index,Object) :-
	( Token == FL_NEWOID -> new_oidobj(Index,Object)
        ; Token == FL_THISMODULE -> thismodule_struct(Object)
        ;
	  atomobj_struct(Token,Index,Object)
	),
	!.

/****************************************************************************
  compile_head_fltoken(+Token,+Num,+Index,-Object,-Status)
****************************************************************************/
compile_head_fltoken(Token,Suffix,Index,Object,Status) :-
        ( Token == FL_NEWOID ->
	    new_oidobj(Suffix,Index,Object),
	    Status = NO_ERRORS
	; %% _@F, _@L
	    Token == FL_SPECIAL_CONST_TOKEN, Suffix == FL_SPECIAL_FILE_TOKEN ->
	    get_current_compile_file(FileName),
	    atomobj_struct(FileName,Index,Object),
	    Status = NO_ERRORS
	; %% _@F, _@L
	    Token == FL_SPECIAL_CONST_TOKEN, Suffix == FL_SPECIAL_LINE_TOKEN ->
	    flora_token_index_to_line(Index,Line),
	    numobj_struct(Line,Index,Object),
	    Status = NO_ERRORS
	;  %% _@!, the rule id
	    Token == FL_SPECIAL_CONST_TOKEN, Suffix == FL_RULEID_SYM ->
	    ( has_context(compiling_descriptors(Mode))
	    -> construct_default_ruleid_descriptor(Mode,Index,DescrIdCode),
		%% the allow_numeric_ruleids context is
		%% cleared out in compile_complex_descriptor/6
		set_context(allow_numeric_ruleids),
		Object = DescrIdCode,
		Status = NO_ERRORS
	    ; (has_context(compiling_dynrule(DescrIdCode)) -> true
	      ; has_context(compiling_rule(DescrIdCode))
	      )
	    -> 
		Object = DescrIdCode,
		Status = NO_ERRORS
	    ;
		compiling_error(Index,RULEID_TOKEN_NOT_IN_RULE,Err),
		Status = [Err]
	    )
        ;
	    atomobj_struct(Token,Index,Object),
	    Status = NO_ERRORS
        ),
	!.


/****************************************************************************
  compile_floraliblit(+ParserTerm,+Workspace,-OidCode,-Code,?BodyFrontList,-Status)

  This procedure compiles a literal that is associated with a Flora system
  module specification.
 ?BodyFrontList - code to add at the beginning of the body
                 (mostly for user defined fnctions),
		 it is output argument, but if it is initialized to
		 empty ([]) ignores user defined functions
****************************************************************************/
compile_floraliblit(ParserTerm,WS,OidCode,Code,BodyFrontList,Status) :-
	%% Flora system modules are like normal user modules except that
	%% users cannot load files into them
	is_flatom(WS,WSName,Index),
	report_option(FLSYSMOD(WSName),Index),
	atomobj_struct(WSName,Index,WSNameCode),
	floralib_struct(WSNameCode,WSCode),
	compile_body_literal(ParserTerm,WSCode,OidCode,Code,
			     BodyFrontList,Status).


/****************************************************************************
  compile_body_literal(+ParserTerm,+Workspace,-OidCode,-Code,?BodyFrontList,-Status)
  ?BodyFrontList - code to add at the beginning of the body
                  (mostly for user defined fnctions),
		  it is output argument, but if it is initialized to
		  empty ([]) ignores user defined functions
****************************************************************************/
%% TODO: no need for separate OidCode+WSCode. This is used only in
%% compile_floraliblit, but compile_floraliblit does not need it either!!!
compile_body_literal(ParserTerm,WS,OidCode,WSCode,BodyFrontList,Status) :-
	( is_fltransactionalterm(ParserTerm,Funct,N,Args) ->
	    compile_body_transactional_termlit(Funct,N,Args,WS,OidCode,
					       WSCode,BodyFrontList,Status)

	; is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_body_termlit(Funct,N,Args,WS,OidCode,
				 WSCode,BodyFrontList,Status)

	%% Literal variable without @module
	; is_flvariable(ParserTerm,VName,VIndex), WS == FL_THISMODULE ->
            compile_var(VName,VIndex,V),
            ( (has_context(compile_with_var_module)
	      ; has_context(goal_reification)
	      ; has_context(compile_delete))
	    ->
                WSCode = V
            ;
                %% Not for promoting term to predicate, but to bind caller info.
                %% Needed only for calls when a variable occurs by itself in
		%% the rule body:  ... :- ..., X, ,,,
                thismodule_struct(ThisModule),
		%% doesn't matter??
                body_caller_info_structure(ThisModule,CallerInfo),
		%% ...:-...,X, is compiled into
		%%    FLLIBMODLIT(libmod_wrapper,X,FL_INVALIDMODULE,CallerInfo)
                atomobj_struct(FL_INVALIDMODULE,Module),
                florasyslib_struct(VIndex,FLLIBMODLIT,3,[V,Module,CallerInfo],WSCode)
            ),
	    BodyFrontList = [],
            OidCode=NULL,
            Status = NO_ERRORS

	%% Variable with @module. E.g., ?- ?X=p, ?X@pqr.
	; is_flvariable(ParserTerm,VarName,Index) ->
	    compile_var(VarName,Index,VarCode),
	    attach_workspace(VarCode,WS,WSCode,Status),
	    BodyFrontList = [],
	    OidCode = NULL

	; is_fldelayquant(ParserTerm,Quant,Condition,Goal,Idx) ->
		compile_delayquant(Quant,Condition,Goal,Idx,WSCode,BodyFrontList,Status),
	    OidCode = NULL

	%% %?X@module. E.g., ?- ?X = p, %?X@pp.
	%% Note: ?- %?X is impossible: parser catches it.
	; is_fltransactionalvariable(ParserTerm,VarName,Index) ->
	    compile_transactionalvar(VarName,Index,VarCode),
	    attach_workspace(VarCode,WS,WSCode,Status),
	    BodyFrontList = [],
	    OidCode = NULL

	; is_flbirelate(ParserTerm,ObjTerm1,RelType,ObjTerm2) ->
	    BodyFrontList = [],
	    compile_body_bin_relation(ObjTerm1,RelType,ObjTerm2,WS,_Obj,OidCode,
				      WSCode,Status)

	; is_flobjspec(ParserTerm,ObjTerm,Spec) ->
	    compile_body_objspec(ObjTerm,Spec,WS,_Obj,OidCode,WSCode,
				 BodyFrontList,Status)

	; is_flobjeql(ParserTerm,O1,O2) ->
	    compile_body_objeql(O1,O2,WS,OidCode,WSCode,Status),
	    BodyFrontList = []

	; is_fldirective(ParserTerm,DirectList,_Idx) ->
	    compile_exec_directive(DirectList,WS,WSCode,Status),
	    BodyFrontList = [],
	    OidCode=NULL

	; is_flload(ParserTerm,LoadList) ->
	    compile_load(LoadList,WSCode,Status),
	    BodyFrontList = [],
	    OidCode=NULL

	; is_flconstraint(ParserTerm,ConstrBody) ->
	    set_context(compiling_arithmetics),
	    set_context(compiling_constraint),
	    compile_body(ConstrBody,ConstrBodyCode,Status),
	    clear_context(compiling_constraint),
	    clear_context(compiling_arithmetics),
	    constraint_struct(ConstrBodyCode,WSCode),
	    BodyFrontList = [],
	    OidCode=NULL

	%% prolog call withOUT prolog module
	; is_flplib(ParserTerm,P) ->
	    compile_prologliblit(P,OidCode,WSCode,BodyFrontList,Status)

	%% prolog call WITH prolog module
	; is_flplib(ParserTerm,P,Module) ->
	    compile_prologliblit(P,Module,OidCode,WSCode,BodyFrontList,Status)

	%% prologALL call withOUT prolog module
	; is_flpliball(ParserTerm,P) ->
	    compile_prologallliblit(P,OidCode,WSCode,BodyFrontList,Status)

	%% prologALL call WITH prolog module
	; is_flpliball(ParserTerm,P,Module) ->
	    compile_prologallliblit(P,Module,OidCode,WSCode,BodyFrontList,Status)

	; is_flfloralib(ParserTerm,P,Module) ->
	    compile_floraliblit(P,Module,OidCode,WSCode,BodyFrontList,Status)

	%% Not attaching workspace: it is propagated inwards by the parser
	; is_flinsert(ParserTerm,Op,List,Cond) ->
	    compile_insert(Op,List,Cond,WSCode,Status),
	    BodyFrontList = [],
	    OidCode=NULL

	; is_flinsert(ParserTerm,Op,List) ->
	    compile_insert(Op,List,WSCode,Status),
	    BodyFrontList = [],
	    OidCode=NULL

	%% Not attaching workspace: it is propagated inwards by the parser
	; is_fldelete(ParserTerm,Op,List,Cond) ->
	    compile_delete(Op,List,Cond,WSCode,Status),
	    BodyFrontList = [],
	    OidCode=NULL

	; is_fldelete(ParserTerm,Op,List) ->
	    compile_delete(Op,List,WSCode,Status),
	    BodyFrontList = [],
	    OidCode=NULL

	; is_flneg(ParserTerm,_,_) ->
	    compile_body(ParserTerm,WSCode,Status),
	    BodyFrontList = [],
	    OidCode=NULL

	; is_fldelayedliteral(ParserTerm,Op,Args) ->
	    compile_delayed_literal(Op,Args,WSCode,OidCode,BodyFrontList,Status)
	; is_fldelayedliteral(ParserTerm,Op,Args,Mod) ->
	    compile_delayed_literal(Op,Args,Mod,WSCode,OidCode,BodyFrontList,Status)

	%% Rule: can occur only inside reify_op as a top-level literal
	; ParserTerm = [ReifiedRule|_],
	    is_fldynrule(ReifiedRule,_H,_B,_Descr) ->
	    compile_reifyop(ParserTerm,WSCode,OidCode,Status),
	    BodyFrontList = []

	%% Rule: can occur inside reify_op
	; ParserTerm = [ReifiedRule|_],
	    is_flruleworkspace(ReifiedRule,_RealRule,_WS) ->
	    compile_reifyop(ParserTerm,WSCode,OidCode,Status),
	    BodyFrontList = []

	; is_fltablerefresh(ParserTerm,List) ->
	    compile_refresh(List,WSCode,Status),
	    BodyFrontList = [],
	    OidCode=NULL

	%% !!{Vars}
	; is_flstopdelay(ParserTerm,VarList,Idx) ->
	    compile_stop_delay(VarList,Idx,WSCode,Status),
	    BodyFrontList = [],
	    OidCode=NULL

	%% !! without the vars
	; is_flstopdelay(ParserTerm,Idx) ->
	    compile_stop_delay(_,Idx,WSCode,Status),
	    BodyFrontList = [],
	    OidCode=NULL

	; is_fltruthvalue(ParserTerm,Formula,Atom) ->
	    compile_truthvalue(Formula,Atom,WSCode,Status),
	    BodyFrontList = [],
	    OidCode=NULL

	; is_fltag_primitive(ParserTerm,Descriptor,HeadList) ->
	    compile_tag_primitive(Descriptor,HeadList,WSCode,Status),
	    BodyFrontList = [],
	    OidCode=NULL

	; is_flprefixprimitive(ParserTerm,Prefix,Expansion,Module) ->
	    compile_prefixprimitive(Prefix,Expansion,Module,WSCode,Status),
	    BodyFrontList = [],
	    OidCode=NULL

	; is_flcatch(ParserTerm,Goal,Error,Handler) ->
	    compile_catch(Goal,Error,Handler,WSCode,Status),
	    BodyFrontList = [],
	    OidCode=NULL

	; is_flthrow(ParserTerm,Error) ->
	    compile_throw(Error,WSCode,Status),
	    BodyFrontList = [],
	    OidCode=NULL

	; is_flp2h(ParserTerm,Prolog,Hilog) ->
	    compile_p2h(Prolog,Hilog,WSCode,Status),
	    BodyFrontList = [],
	    OidCode=NULL

	; is_flnewmodule(ParserTerm,Op,Module) ->
	    is_flatom(Op,_OpAtom,Index),
	    compile_atomvar(Module,ModCode),
	    thismodule_struct(ThisModuleName),
	    florasyslib_struct(Index,FLLIBNEWMODULE,2,[ThisModuleName,ModCode],
			       WSCode),
	    Status = NO_ERRORS,
	    BodyFrontList = [],
	    OidCode=NULL

	; is_flerasemodule(ParserTerm,Op,Module) ->
	    is_flatom(Op,_OpAtom,Index),
	    compile_atomvar(Module,ModCode),
	    thismodule_struct(ThisModuleName),
	    florasyslib_struct(Index,FLLIBERASEMODULE,2,
			       [ThisModuleName,ModCode],WSCode),
	    Status = NO_ERRORS,
	    BodyFrontList = [],
	    OidCode=NULL

	; is_flcallermodule(ParserTerm,Op,Module) ->
	    is_flatom(Op,_OpAtom,Index),
	    compile_atomvar(Module,ModCode),
	    caller_binding_code(ModCode,WSCode),
	    BodyFrontList = [],
	    Status = NO_ERRORS,
	    OidCode=NULL

	; is_flsimpleprimitive(ParserTerm,PrimName,Args) ->
	    flora_simple_primitive(PrimName,PN,PrimPredicate,PrimModule),
	    %% Ignore the arity given by flora_simple_primitive/4. Here we
	    %% might get cases where the actual #args is less by 2
	    %% (this is a hack bedscibed below)
	    length(Args,N1),
	    compile_body_pathexplist(Args,WS,ArgsCode1,OidCode,_,_,Status),
	    %% This is a hack: add two extra arguments to primitives listed in
	    %% rule_manipulation_primitive/1.
	    %% Need to find a more general solution for the future.
	    (rule_manipulation_primitive(PrimName), N1==1
	    -> get_rule_manipulation_primitive_extra_args(ExtraArgs),
		append(ArgsCode1,ExtraArgs,ArgsCode),
		N is N1+2
	    ; ArgsCode1 = ArgsCode, N = N1, N1 == PN
	    ; flora_abort(['Compiler bug!!! something wrong with flora_simple_primitive'], FLORA_ABORT_NOTRACE)
	    ),
	    prologterm_struct(PrimPredicate,N,ArgsCode,PrimModule,WSCodePre),
	    prologliblit_struct(WSCodePre,WSCode)

	; is_flupdaterule(ParserTerm,Op,List) ->
	    compile_updaterule(Op,List,WSCode,Status),
	    BodyFrontList = [],
	    OidCode=NULL
		
        ; is_flclause(ParserTerm,Head,Body) ->
            compile_clause([],NULL,Head,Body,WSCode,Status),
	    BodyFrontList = [],
            OidCode=NULL

        ; is_flclause(ParserTerm,Mode,Head,Body) ->
            compile_clause([],Mode,Head,Body,WSCode,Status),
	    BodyFrontList = [],
            OidCode=NULL

        ; is_flannotated_clause_stmt(ParserTerm,Descriptor,Mode,Head,Body) ->
            compile_clause(Descriptor,Mode,Head,Body,WSCode,Status),
	    BodyFrontList = [],
            OidCode=NULL

	; is_flannotated_clause_stmt(ParserTerm,Descriptor,Head,Body) ->
            compile_clause(Descriptor,NULL,Head,Body,WSCode,Status),
	    BodyFrontList = [],
            OidCode=NULL

	; is_flcallmetafacts(ParserTerm,MetaFacts,_) ->
	    compile_callmetafacts(MetaFacts,WSCode,Status),
	    BodyFrontList = [],
            OidCode=NULL

	; is_flifthenelse(ParserTerm,Cond,Then,Else) ->
	    compile_ifthenelse(Cond,Then,Else,WSCode,Status),
	    BodyFrontList = [],
	    OidCode=NULL

	; is_flifthen(ParserTerm,Cond,Then) ->
	    compile_ifthen(Cond,Then,WSCode,Status),
	    BodyFrontList = [],
	    OidCode=NULL

	; is_fluniveqform(ParserTerm,Left,Right) ->
	    compile_univeqform(Left,Right,WSCode,Status),
	    BodyFrontList = [],
	    OidCode=NULL

	; is_flmetauniv(ParserTerm,Left,Right) ->
	    compile_metauniv(Left,Right,OidCode,WSCode,Status),
	    BodyFrontList = []

	; is_flprologifthen(ParserTerm,Left,Right) ->
	    compile_prologifthen(Left,Right,WSCode,Status),
	    BodyFrontList = [],
	    OidCode=NULL

	; is_flcontrolconstruct(ParserTerm,Wrapper,Cond,Action) ->
	    compile_controlconstruct(Cond,Action,Wrapper,WSCode,Status),
	    BodyFrontList = [],
	    OidCode = NULL
	
	; is_flcut(ParserTerm,I) ->
	    cut_struct(I,WSCode),
	    BodyFrontList = [],
	    OidCode=NULL,
	    Status = NO_ERRORS

	; is_flatom(ParserTerm,_A) ->
	    atomlit_struct(BODYLITERAL,ParserTerm,Code),
	    attach_workspace(Code,WS,WSCode,WSStatus),
	    verify_symbol_context(ParserTerm,0,PREDICATE_SYMBOL,
				  NONTRANSACTIONAL_SYMBOL,SymbolStatus),
	    (WSStatus == NO_ERRORS -> Status = SymbolStatus
	    ; Status = WSStatus
	    ),
	    BodyFrontList = [],
	    OidCode=NULL

	; is_flbuiltin_identifier(ParserTerm,_A) ->
	    atomlit_struct(BODYLITERAL,ParserTerm,Code),
	    attach_workspace(Code,WS,WSCode,WSStatus),
	    verify_symbol_context(ParserTerm,0,PREDICATE_SYMBOL,
				  NONTRANSACTIONAL_SYMBOL,SymbolStatus),
	    (WSStatus == NO_ERRORS -> Status = SymbolStatus
	    ; Status = WSStatus
	    ),
	    BodyFrontList = [],
	    OidCode=NULL

	; is_fltransactionalatom(ParserTerm,_A) ->
	    transactionalatomlit_struct(BODYLITERAL,ParserTerm,Code),
	    attach_workspace(Code,WS,WSCode,WSStatus),
	    verify_symbol_context(ParserTerm,0,PREDICATE_SYMBOL,
				  TRANSACTIONAL_SYMBOL,SymbolStatus),
	    (WSStatus == NO_ERRORS -> Status = SymbolStatus
	    ; Status = WSStatus
	    ),
	    BodyFrontList = [],
	    OidCode=NULL

	; is_fldatatype(ParserTerm,_Sort,_Lit,_Index) ->
	    datatypeobj_struct(ParserTerm,Code1,Status),
	    atomlit_struct(BODYLITERAL,Code1,WSCode),
	    BodyFrontList = [],
	    OidCode=NULL

	; is_fltransactionaldatatype(ParserTerm,_Sort,_Lit,_Index) ->
	    datatypeobj_struct(ParserTerm,Code1,Status),
	    transactionalatomlit_struct(BODYLITERAL,Code1,WSCode),
	    BodyFrontList = [],
	    OidCode=NULL

	;
	    approx_flindex(ParserTerm,ErrIdx),
	    compiling_error(ErrIdx,[UNKNOWN_ERROR,'\n\t\t Details: in compile_body_literal'],Err),
	    Status = [Err]
	),
	!.


/****************************************************************************
  compile_floralibobj(+ParserTerm,+Workspace,-Object,-OidCode,-Code,-Status)
****************************************************************************/
compile_floralibobj(ParserTerm,WS,Object,OidCode,Code,Status) :-
	is_flatom(WS,WSName,Index),
	report_option(FLSYSMOD(WSName),Index),
	atomobj_struct(WSName,Index,WSNameCode),
	floralib_struct(WSNameCode,WSCode),
	compile_body_pathexp(ParserTerm,WSCode,Object,OidCode,Code,[],Status).


/****************************************************************************
  compile_body_pathexplist(+ParserTermList,+Workspace,-ObjectList,-OidCode,-Code,?BodyFrontList,-Status)
  ?BodyFrontList - code to add at the beginning of the body
                  (mostly for user defined fnctions),
		  it is normally an output parameter, but if bound to []
		  then ignores user defined functions
****************************************************************************/
compile_body_pathexplist([],_WS,[],NULL,NULL,[],[]).

compile_body_pathexplist([T|L],WS,[TObj|LObj],OidCode,Code,BodyFrontList,Status) :-
	(var(BodyFrontList) -> true ; BodyFrontList1=[],BodyFrontList2=[]),
	compile_body_pathexp(T,WS,TObj,OidCodeHead,TCode,BodyFrontList1,S),
	clear_context(compiling_term_name),
	( no_errors_found(S) -> 
	    compile_body_pathexplist(L,WS,LObj,OidCodeTail,LCode,BodyFrontList2,S2),
	    ( var(BodyFrontList) ->
		append(BodyFrontList1,BodyFrontList2,BodyFrontList)
	    ;
		true
	    ),
	    ( no_errors_found(S2) -> 
		conjunct_code([TCode,LCode],Code),
		conjunct_code([OidCodeHead,OidCodeTail],OidCode),
		append(S,S2,Status)
	    ; Status=S2
	    )
	;
	  Status=S
        ),
	!.


/****************************************************************************
  compile_body_pathexp(+ParserTerm,+Workspace,-Object,-OidCode,-Code,?BodyFrontList,-Status)

  Handles pathexps that are atoms, numbers, special tokens, like _#, _#123, _@,
  vars, strings

  Object  - the term that goes in place of this path expression.
  OidCode - conjunction of the code for computing the arguments of
            the pathexp such as a.b[c.d->e.f]
	    Eg, AND(a[b->?X],c[d-?Y],e[f->?Z]) - the code for computing the
	        objects that go in place of a.b, c.d, e.f. These objects are
		?X, ?Y, ?Z, respectively.
            OidCode comes before the code for the molecule or predicate
	    where the path expression occurs. For instance, in the above,
	    we'll have:
	      AND(a[b->?X],c[d-?Y],e[f->?Z]), <<--- OidCode for path expressions
		?X[?Y->?Z],                   <<--- the actual molecule.
                                                    ?X,?Y,?Z are Object(s)
						    for path expressions
		   Code(for a.b,c.d,e.f)      <<--- Code for path expressions
  Code    - code for the actual Boolean expression that corresponds to
            a.b[c.d->e.f], ie, ?X[?Y->?Z].
            Note: Code is conjoined from the right. For instance,
	          in obj[attr->c.d], the Code for c.d appears after the code
		  for obj[attr->...]. Namely, the overall code will be:
		    OidCode(for_c.d,Object(for_c.d)),
		      obj[attr->Object(for_c.d)],
		        Code(for_c.d)
  BodyFrontList - code to add at the beginning of the body
                 (mostly for user defined fnctions),
		 it is output argument, but if it is initialized to empty ([])
		 ignores user defined functions
****************************************************************************/
%% ParserTerm is a primitive object -- no oid code and no spec code results
compile_body_pathexp(ParserTerm,WS,Object,OidCode,Code,BodyFrontList,Status) :-
	set_context(compiling_body_pathexp),
	( is_flobjref(ParserTerm,ObjTerm,RefType,AttTerm) ->
	    BodyFrontList = [],
	    compile_body_objref(ObjTerm,RefType,AttTerm,WS,Object,
			   OidCode,Code,Status)

	; is_flobjspec(ParserTerm,ObjTerm,Spec) ->
	    compile_body_objspec(ObjTerm,Spec,WS,Object,OidCode,Code,
				 BodyFrontList,Status)

	; is_flbirelate(ParserTerm,ObjTerm1,RelType,ObjTerm2) ->
	    BodyFrontList = [],
	    compile_body_bin_relation(ObjTerm1,RelType,ObjTerm2,WS,Object,OidCode,Code,Status)

	; is_fltransactionalterm(ParserTerm,Funct,N,Args) ->
	    compile_body_termobj(Funct,N,Args,WS,Object,OidCode,Code,
			    BodyFrontList,TRANSACTIONAL_SYMBOL,Status)

	; is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_body_termobj(Funct,N,Args,WS,Object,OidCode,Code,
			    BodyFrontList,NONTRANSACTIONAL_SYMBOL,Status)

	; is_flarith(ParserTerm,StrippdParseTerm) ->
	    set_context(compiling_arithmetics),
	    compile_body_pathexp(StrippdParseTerm,WS,Object,OidCode,Code,[],Status),
	    clear_context(compiling_arithmetics)

	; is_fllist(ParserTerm,L,T,I) ->
	    compile_body_list_obj(L,T,I,WS,Object,OidCode,Code,
				  BodyFrontList,Status)

	%% Case like this: pred(?X@...)
	%% ?X@Mod is treated separately from other ...@Mod cases because
	%% we have to create a libmodobj code to compute ?X@Mod.
	%% This libmodobj-code is placed in
	%% OidCode so that it would precede the code for pred(...)
	; is_flworkspace(ParserTerm,P,NestedWS),
	    is_flvariable(P,VarName,VarIndex) ->
	    compile_var(VarName,VarIndex,VarCode),
	    workspaceobj_struct(VarCode,NestedWS,Object,OidCode),
	    BodyFrontList = [],
	    Code=NULL,
	    Status = NO_ERRORS

	; is_flworkspace(ParserTerm,P,NestedWS) ->
	    compile_pathexp_with_explicit_workspace(P,NestedWS,Object,OidCode,Code,BodyFrontList,Status)

	;
	  compile_pathexp_no_workspace(ParserTerm,Object,OidCode,Code,BodyFrontList,Status)
        ),
	!,
	clear_context(compiling_body_pathexp).

%% compile_pathexp_with_explicit_workspace(+ParserTerm,-Object,-OidCode,-Code,?BodyFrontList,-Status)
compile_pathexp_with_explicit_workspace(ParserTerm,WS,Object,OidCode,Code,BodyFrontList,Status) :-
	(is_flvariable(ParserTerm,VarName,VarIndex) ->
	    compile_var(VarName,VarIndex,VarCode),
	    workspaceobj_struct(VarCode,WS,Object,OidCode),
	    BodyFrontList = [],
	    Code=NULL,
	    Status = NO_ERRORS
	; (atomlit_struct(BODYLITERAL,ParserTerm,_)
	  ; transactionalatomlit_struct(BODYLITERAL,ParserTerm,_))
	->
	    approx_flindex(ParserTerm,Index),
	    compiling_error(Index,NO_WORKSPACE,Err),
	    Status = [Err]
	; compile_body_pathexp(ParserTerm,WS,Object,OidCode,Code,
			       BodyFrontList,Status)
	).

%% compile_pathexp_no_workspace(+ParserTerm,-Object,-OidCode,-Code,?BodyFrontList,-Status)
compile_pathexp_no_workspace(ParserTerm,Object,OidCode,Code,BodyFrontList,Status) :-
	( is_flatom(ParserTerm,_A) ->
	    Code = NULL,
	    OidCode = NULL,
	    compile_atomobj(ParserTerm,Object,BodyFrontList,Status)

	; is_modularized_pratom(ParserTerm,Atm,Idx) ->
	    modularized_pratom_struct(Atm,Idx,Object),
	    BodyFrontList = [],
	    Code = NULL,
	    OidCode = NULL,
	    Status = NO_ERRORS

	; is_fltransactionalatom(ParserTerm,_A) ->
	    verify_symbol_context(ParserTerm,0,FUNCTION_SYMBOL,
				  TRANSACTIONAL_SYMBOL,Status),
	    BodyFrontList=[],
	    Code = NULL,
	    OidCode = NULL,
	    transactionalatomobj_struct(ParserTerm,Object)

	; is_fltoken(ParserTerm,FL_THISMODULE,_Index) ->
	    /*
	    verify_symbol_context(ParserTerm,0,FUNCTION_SYMBOL,
				  NONTRANSACTIONAL_SYMBOL,Status),
	    */
	    Status = NO_ERRORS,
	    BodyFrontList=[],
	    Code = NULL,
	    OidCode = NULL,
	    thismodule_struct(Object)

	%% Anonymous OIDs can appear in the "body": they can appear
	%% in reified formulas, which are compiled as body literals
	; is_fltoken(ParserTerm,FL_NEWOID,Index) ->
	    /*
	    %% no point checking skolems!!!
	    verify_symbol_context(ParserTerm,0,FUNCTION_SYMBOL,
				  NONTRANSACTIONAL_SYMBOL,Status),
	    */
	    ((has_context(goal_reification);has_context(compiling_descriptors(_)))
	    ->
		Code = NULL,
		(compiling_flrshell_command ->
		    %% In the shell we do:
		    %% ?- ?X = ${p(_#)} ==>> p(shell-skolem)
		    OidCode = NULL,
		    new_dynoidobj(Index,Object)
		;   %% If not in the shell, generate a new Skolem constant
		    OidCode = NULL,
		    new_oidobj(Index,Object)
		)
	    ;   %% Otherwise, p(_#) ==>> p(?N), _skolem(?N)
		OidCode = NULL,
		new_prvariable(Index,Object),
		prologterm_struct(FL_SKOLEM,1,[Object],flrnewoid,Code)
	    ),
	    Status = NO_ERRORS,
	    BodyFrontList=[]

	%% A numbered OID, which appears in a reified formula in rule body
	; is_fltoken(ParserTerm,FL_NEWOID,Num,Index) ->
	    /*
	    %% do not check the context of the skolems!
	    verify_symbol_context(ParserTerm,0,FUNCTION_SYMBOL,
				  NONTRANSACTIONAL_SYMBOL,Status),
	    */
	    ((has_context(goal_reification);has_context(compiling_descriptors(_)))
	    ->
		Code = NULL,
		(compiling_flrshell_command ->
		    OidCode = NULL,
		    new_dynoidobj(Num,Index,Object)
		;   %% If not in the shell, generate a new Skolem constant
		    OidCode = NULL,
		    new_oidobj(Num,Index,Object)
		)
	    ;
		OidCode = NULL,
		prvariable_for_numbered_skolem(Index,Num,Object),
		prologterm_struct(FL_SKOLEM,1,[Object],flrnewoid,Code)
	    ),
	    Status = NO_ERRORS,
	    BodyFrontList=[]

	; is_fltoken(ParserTerm,FL_SPECIAL_CONST_TOKEN,FL_SPECIAL_FILE_TOKEN,Index) ->
	    get_current_compile_file(FileName),
	    Code = NULL,
	    OidCode = NULL,
	    atomobj_struct(FileName,Index,Object),
	    Status = NO_ERRORS,
	    BodyFrontList=[]
	; is_fltoken(ParserTerm,FL_SPECIAL_CONST_TOKEN,FL_SPECIAL_LINE_TOKEN,Index) ->
	    flora_token_index_to_line(Index,Line),
	    Code = NULL,
	    OidCode = NULL,
	    numobj_struct(Line,Index,Object),
	    Status = NO_ERRORS,
	    BodyFrontList=[]
	%% _@! - rule id token
	; is_fltoken(ParserTerm,FL_SPECIAL_CONST_TOKEN,FL_RULEID_SYM,Index) ->
	    BodyFrontList=[],
	    OidCode = NULL,
	    Code = NULL,
	    ( has_context(compiling_descriptors(Mode))
	    ->  approx_flindex(ParserTerm,Idx),
		construct_default_ruleid_descriptor(Mode,Idx,DescrIdCode),
		%% the allow_numeric_ruleids context is
		%% cleared out in compile_complex_descriptor/6
		set_context(allow_numeric_ruleids),
		Object = DescrIdCode,
		Status = NO_ERRORS
	    ;  %% Note: descriptors are compiled BEFORE compiling_dynrule
	       %% is set. So, this test must be after
	       %% has_context(compiling_descriptors(Mode)) above
		(has_context(compiling_dynrule(DescrIdCode)) -> true
		; has_context(compiling_rule(DescrIdCode))
		)
	    ->
		Object = DescrIdCode,
		Status = NO_ERRORS
	    ; compiling_error(Index,RULEID_TOKEN_NOT_IN_RULE,Err),
		Status = [Err]
	    )

	; is_fltoken(ParserTerm,FL_SPECIAL_VAR_TOKEN,Suffix,Index) ->
	    OidCode = NULL,
	    (memberchk(Suffix, [FL_SPECIAL_FILE_TOKEN,FL_SPECIAL_LINE_TOKEN])
	    ->
		special_variable_struct(Suffix,Object),
		Code = NULL,
		Status = NO_ERRORS,
		BodyFrontList=[]
	    ; Suffix == FL_SPECIAL_CALLER_TOKEN
	    ->
		new_prvariable(NO_INDEX,Object),
		caller_binding_code(Object,Code),
		Status = NO_ERRORS,
		BodyFrontList=[]
	    ; 
		compiling_error(Index,UNSUPPORTED_SPECIAL_TOKEN,TokenErr),
		Status = [TokenErr]
	    )

	; (is_flnumber(ParserTerm,_N) ; number(ParserTerm)) ->
	    numobj_struct(ParserTerm,Object),
	    BodyFrontList=[],
	    OidCode = NULL,
	    Code = NULL,
	    Status = NO_ERRORS

	; is_flvariable(ParserTerm,Name,Index) ->
	    compile_var(Name,Index,Object),
	    OidCode = NULL,
	    BodyFrontList=[],
	    Code = NULL,
	    Status = NO_ERRORS

	; is_fltransactionalvariable(ParserTerm,Name,Index) ->
	    compile_transactionalvar_without_trans(Name,Index,Object),
	    BodyFrontList=[],
	    OidCode = NULL,
	    Code = NULL,
	    Status = NO_ERRORS

	; is_flstring(ParserTerm,_S) ->
	    strobj_struct(ParserTerm,Object),
	    BodyFrontList=[],
	    OidCode = NULL,
	    Code = NULL,
	    Status = NO_ERRORS

	; is_flbuiltin_identifier(ParserTerm,_Ident) ->
	    verify_symbol_context(ParserTerm,0,FUNCTION_SYMBOL,
				  NONTRANSACTIONAL_SYMBOL,Status),
	    builtin_identifier_struct(ParserTerm,Object),
	    BodyFrontList=[],
	    OidCode = NULL,
	    Code = NULL

	; is_fldatatype(ParserTerm,_Sort,_Lit,_Index) ->
	    datatypeobj_struct(ParserTerm,Object,Status),
	    BodyFrontList=[],
	    OidCode = NULL,
	    Code = NULL

	; is_fltransactionalstring(ParserTerm,_S) ->
	    transactionalstrobj_struct(ParserTerm,Object),
	    BodyFrontList=[],
	    OidCode = NULL,
	    Code = NULL,
	    Status = NO_ERRORS
	),
	!.

compile_pathexp_no_workspace(ParserTerm,Object,OidCode,Code,BodyFrontList,Status) :-
        ( is_fldelayquant(ParserTerm,Quant,Condition,Goal,Idx) ->
	    compile_delayquant(Quant,Condition,Goal,Idx,OidCode,BodyFrontList,Status)

	; is_flaggregate(ParserTerm,Op,V,GV,SortSpec,B) ->
	    %% Aggregates are treated as OID, so its code would come
	    %% ahead of the code of the literal it occurs in
	    compile_aggregate(Op,V,GV,SortSpec,B,Object,OidCode,Status),
	    BodyFrontList=[],
	    Code=NULL

	; is_reifyop(ParserTerm,Formula) ->
	    compile_reifyop(Formula,Object,OidCode,Status),
	    BodyFrontList=[],
	    Code=NULL

	; is_flplib(ParserTerm,P) ->
	    compile_prologlibobj(P,Object,OidCode,Code,BodyFrontList,Status)
	; is_flplib(ParserTerm,P,Module) ->
	    compile_prologlibobj(P,Module,Object,OidCode,Code,BodyFrontList,Status)

	; is_flpliball(ParserTerm,P) ->
	    compile_prologalllibobj(P,Object,OidCode,Code,BodyFrontList,Status)
	; is_flpliball(ParserTerm,P,Module) ->
	    compile_prologalllibobj(P,Module,Object,OidCode,Code,BodyFrontList,Status)
	
	; is_flfloralib(ParserTerm,P,Module) ->
	    BodyFrontList=[],
	    compile_floralibobj(P,Module,Object,OidCode,Code,Status)
	),
	!.


/****************************************************************************
  compile_body_termobj(+FunctorTerm,+Arity,+ArgList,+Workspace,-Object,-OidCode,-Code,?BodyFrontList,+Transactional,-Status)

  BodyFrontList - code to add at the beginning of the body
                  (mostly for user defined fnctions),
		  it is output argument, but if it is initialized to
		  empty ([]) ignores user defined functions
  Transactional - flag if Funct is transactional
			can be TRANSACTIONAL_SYMBOL or NONTRANSACTIONAL_SYMBOL
****************************************************************************/
compile_body_termobj(Funct,N,Args,WS,Object,OidCode,Code,BodyFrontList,Transactional,CompileStatus) :-
	var(BodyFrontList),
	!,
        ( \+ has_context(compiling_arithmetics),
	    has_UDF(Funct,N,Args,Predicate,Object /* return value */,FunctBodyFrontList,S1)
	->
	    ( no_errors_found(S1) -> 
		OidCode=NULL,
		Code=NULL,
		compile_udf_body_literal(Funct,Predicate,PCode,PBodyFrontList,S),
		SymbolContext = UDF_SYMBOL,
		( no_errors_found(S) -> 
		    append(FunctBodyFrontList,PBodyFrontList,BodyFrontList1),
		    append(BodyFrontList1,[PCode],BodyFrontList),
		    Status = NO_ERRORS
		;
		    approx_flindex(Funct,Index),
		    compiling_error(Index,ERROR_UDF_COMPILE,Err),
		    Status = [Err|S]
		)
	    ;
		approx_flindex(Funct,Index),
		compiling_error(Index,ERROR_UDF_COMPILE,Err),
		Status = [Err|S1]
	    )
        ;
	    set_context(compiling_term_name),
	    compile_body_pathexplist([Funct|Args],WS,[FObj|AObj],OidCode,Code,BodyFrontList,Status),
	    SymbolContext = FUNCTION_SYMBOL,
	    ( no_errors_found(Status) -> 
		termobj_struct(FObj,N,AObj,Object)
	    ; true
	    )
        ),
	!,
	verify_symbol_context(Funct,N,WS,SymbolContext,
			      Transactional,SymbolStatus),
	append(SymbolStatus,Status,CompileStatus).

compile_body_termobj(Funct,N,Args,WS,Object,OidCode,Code,[],Transactional,CompileStatus) :-
	verify_symbol_context(Funct,N,WS,FUNCTION_SYMBOL,
			      Transactional,SymbolStatus),
	set_context(compiling_term_name),
	compile_body_pathexplist([Funct|Args],WS,[FObj|AObj],OidCode,Code,_BodyFrontList,Status),
	!,
	( no_errors_found(Status) -> termobj_struct(FObj,N,AObj,Object)
	; true
	),
	append(SymbolStatus,Status,CompileStatus).

/****************************************************************************
  compile_body_termlit(+FunctorTerm,+Arity,+ArgList,+Workspace,-OidCode,-Code,?BodyFrontList,-Status)
  BodyFrontList - code to add at the beginning of the body
                  (mostly for user defined fnctions),
		  it is output argument, but if it is initialized to
		  empty ([]) ignores user defined functions
****************************************************************************/
%% Terms declared with :- usesensor are treated here
compile_body_termlit(Funct,N,Args,_WS,OidCode,Code,BodyFrontList,CompileStatus) :-
	is_flatom(Funct, FAtom, FunctIdx),
	(has_permaoption(usesensor(FAtom,N))
	; has_permaoption(usesensor((FAtom,PlMod),N))
	%% the below allows _add'ed files to inherit the usesensor directive 
	; flora_delayed_sensor_literal(FAtom,N,FLORA_DEFAULT_WORKSPACE),
	    \+has_permaoption(defsensor(FAtom,N))
	; flora_delayed_sensor_literal((FAtom,PlMod),N, FLORA_DEFAULT_WORKSPACE),
	    \+has_permaoption(defsensor(FAtom,N,PlMod))
	),
	!,
	verify_symbol_context(Funct,N,SENSOR_SYMBOL,
			      NONTRANSACTIONAL_SYMBOL,SymbolStatus),
	is_anonymous_flvariable(Anon,NO_INDEX),
	%% compile_delayed_literal expects FLLIST as Arglist
	is_fllist(ArgsList,[Anon,Anon|Args],[],NO_INDEX),
	(atom(PlMod)
	->
	    is_flatom(ModParserTerm,PlMod,NO_INDEX),
	    compile_delayed_literal(Funct,ArgsList,ModParserTerm,Code,OidCode,BodyFrontList,Status)
	;
	    %% if it is a sensor defined in a .flr file, scramble its
	    %% name by adding FLORA_PREFIX
	    flora_scramble_atom(FAtom,ScrambledAtom),
	    is_flatom(ScrambledFunct,ScrambledAtom,FunctIdx),
	    compile_delayed_literal(ScrambledFunct,ArgsList,Code,OidCode,BodyFrontList,Status)
	),
	!,
	append(SymbolStatus,Status,CompileStatus).

compile_body_termlit(Funct,N,Args,WS,OidCode,Code,BodyFrontList,CompileStatus) :-
	verify_symbol_context(Funct,N,WS,PREDICATE_SYMBOL,
			      NONTRANSACTIONAL_SYMBOL,SymbolStatus),
	set_context(compiling_term_name),
	compile_body_pathexplist([Funct|Args],WS,[FObj|AObj],OidCode,ObjCode,BodyFrontList,PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    termlit_struct(BODYLITERAL,FObj,N,AObj,TCode),
	    attach_workspace(TCode,WS,WSCode,WSStatus),
	    conjunct_code([WSCode,ObjCode],Code)
	;
	    WSStatus = NO_ERRORS
        ),
	!,
	(WSStatus == NO_ERRORS -> append(SymbolStatus,PathexpStatus,CompileStatus)
	; CompileStatus = WSStatus
	).

compile_body_transactional_termlit(Funct,N,Args,WS,OidCode,Code,BodyFrontList,CompileStatus) :-
	verify_symbol_context(Funct,N,WS,PREDICATE_SYMBOL,
			      TRANSACTIONAL_SYMBOL,SymbolStatus),
	set_context(compiling_term_name),
	compile_body_pathexplist([Funct|Args],WS,[FObj|AObj],OidCode,ObjCode,BodyFrontList,PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    transactionaltermlit_struct(BODYLITERAL,FObj,N,AObj,TCode),
	    attach_workspace(TCode,WS,WSCode,WSStatus),
	    conjunct_code([WSCode,ObjCode],Code)
	;
	    WSStatus = NO_ERRORS
        ),
	!,
	(WSStatus == NO_ERRORS -> append(SymbolStatus,PathexpStatus,CompileStatus)
	; CompileStatus = WSStatus
	).

/****************************************************************************
  compile_body_list_obj(+ObjTermList,+ObjTerm,+Index,+WS,-Object,-OidCode,-Code,?BodyFrontList,-Status)
    Lists are like this: [a,b,c|rest]
    ObjTermList refers to the list [a,b,c] and ObjTerm to rest.

 BodyFrontList - code to add at the beginning of the body
                 (mostly for user defined fnctions),
		 it is output argument, but if it is initialized to empty ([]) ignores user defined functions
****************************************************************************/
compile_body_list_obj(ObjTermList,ObjTerm,Index,WS,Object,OidCode,Code,BodyFrontList,Status) :-
	(var(BodyFrontList) -> true; BodyFrontList1=[],BodyFrontList2=[]),
	compile_body_pathexplist(ObjTermList,WS,ObjList,OidCodeList,ObjListCode,BodyFrontList1,S),
	( no_errors_found(S) -> 
	    ( ObjTerm == [] ->
		BodyFrontList=BodyFrontList1,
		Obj=[],
		OidCodeObj=NULL,
		ObjCode=NULL,
		Status = NO_ERRORS
	    ;
	      compile_body_pathexp(ObjTerm,WS,Obj,OidCodeObj,ObjCode,BodyFrontList2,Status),
	      ( var(BodyFrontList) ->
		append(BodyFrontList1,BodyFrontList2,BodyFrontList)
	      ;
		true
	      )
	    ),
	    ( no_errors_found(Status) -> 
		list_struct(ObjList,Obj,Index,Object),
		conjunct_code([ObjListCode,ObjCode],Code),
		conjunct_code([OidCodeList,OidCodeObj],OidCode)
	    ;
	      true
	    )
	;
	  Status=S
        ),
	!.


/****************************************************************************
  compile_body_objref(+ObjTerm,+RefType,+AttTerm,+Workspace,-Object,-OidCode,-Code,-Status)

  Process an object reference like a.b.c@module
  An objref can be more complex, e.g., a[f->g].b[h->p].c[k->u]@module
****************************************************************************/
compile_body_objref(ObjTerm,RefType,AttTerm,WS,Object,OidCode,Code,Status) :-
	compile_body_pathexplist([ObjTerm,AttTerm],WS,[Obj,Att],OidCodeList,OACode,[],PathexpStatus),
	!,
	( no_errors_found(PathexpStatus) -> 
	    %% Approximate the textual information for the new variable.
	    approx_flindex(AttTerm,Index),
	    body_objref_struct(Obj,RefType,Att,Index,Object,TCode),
	    attach_workspace(TCode,WS,WTCode,WSStatus),
	    Code = OACode,
	    conjunct_code([OidCodeList,WTCode],OidCode)
	;
	    WSStatus = NO_ERRORS
        ),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	).


/****************************************************************************
  compile_body_bin_relation(+ObjTerm1,+RelType,+ObjTerm2,+Workdpace,-Object,-OidCode,-Code,-Status)
****************************************************************************/
compile_body_bin_relation(ObjTerm1,RelType,ObjTerm2,WS,Obj1,OidCode,Code,Status) :-
	compile_body_pathexplist([ObjTerm1,ObjTerm2],WS,[Obj1,Obj2],OidCode,OCode,[],PathexpStatus),
	!,
	( no_errors_found(PathexpStatus) -> 
	    birelate_struct(BODYLITERAL,Obj1,RelType,Obj2,TCode),
	    attach_workspace(TCode,WS,WTCode,WSStatus),
	    conjunct_code([WTCode,OCode],Code)
	;
	    WSStatus = NO_ERRORS
        ),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	).


/****************************************************************************
  compile_body_objspec(+ObjTerm,+SpecBody,+Workspace,-Object,-OidCode,-Code,-BodyFrontList,-Status)

  Code produced by this and similar predicates is divided into
  OidCode and Code. 
  OidCode is the code needed to compute the attribute of molecule
  and the oid of the value part (in ->, *->, etc.)
  Code represents the code needed to compute the the attribute specification.
  For instance, in  a.b[c.d->e.f],
      OidCode will represent the computation of a.b, c.d, and e.f:
	 prand(prmvd(a,b,_newvar1),prand(prmvd(c,d,_newvar2),prmvd(e,f,_newvar3)))
      Code will represent the -> part:
                 prmvd(_newvar1,_newvar2,_newvar3)
      Object is the code for restricting
****************************************************************************/
compile_body_objspec(ObjTerm,SpecBody,WS,Object,OidCode,Code,BodyFrontList,Status) :-
	( SpecBody == [] ->
	    ( is_flobjref(ObjTerm,OTerm,RefType,ATerm) ->
		compile_body_pathexplist([OTerm,ATerm],WS,[OObj,AObj],OidCode,ObjCode,BodyFrontList,PathexpStatus),
		( no_errors_found(PathexpStatus) ->
		    approx_flindex(ATerm,Index),
		    body_objref_struct(OObj,RefType,AObj,Index,Object,TCode),
		    attach_workspace(TCode,WS,WTCode,WSStatus),
		    conjunct_code([WTCode,ObjCode],Code)
		;
		    WSStatus = NO_ERRORS
	        ),
		(WSStatus == NO_ERRORS -> Status = PathexpStatus
		; Status = WSStatus
		)
	    ;
		%% object exists test: a.b.c[]@module
		compile_body_pathexp(ObjTerm,WS,Object,OidCode,ObjCode,BodyFrontList,PathexpStatus),
		( no_errors_found(PathexpStatus) -> 
		    objexists_struct(BODYLITERAL,Object,ECode),
		    attach_workspace(ECode,WS,WSECode,WSStatus),
		    conjunct_code([WSECode,ObjCode],Code)
		;
		    WSStatus = NO_ERRORS
		),
		(WSStatus == NO_ERRORS -> Status = PathexpStatus
		; Status = WSStatus
		)
	    )
	; % oid spec plus object spec. something like a.b[c->d]@module
	  compile_body_pathexp(ObjTerm,WS,Object,ObjOidCode,ObjCode,
			       BodyFrontList1,S),
	  ( no_errors_found(S) -> 
	      compile_body_specbody(Object,SpecBody,WS,SpecOidCode,SpecCode,
				    BodyFrontList2,Status),
	      ( no_errors_found(Status) -> 
		  %% Because ObjCode contains : and ::, we put it after
		  %% the code for molecule --- a heuristic that assumes that
		  %% computing a:b  (or a::b)when a or b are vars, is expensive.
		  %% Ideally we should check the type of ObjCode or used
		  %% delay for ObjCode
		  conjunct_code([SpecCode,ObjCode],Code),
		  conjunct_code([ObjOidCode,SpecOidCode],OidCode)
	      ; 
		  true
	      ),
	      append(BodyFrontList1,BodyFrontList2,BodyFrontList)
	  ;
	    BodyFrontList = BodyFrontList1,
	    Status=S
          )
        ),
	!.


/****************************************************************************
  compile_body_specbody(+Object,+SpecTerm,+Workspace,-OidCode,-Code,-BodyFrontList,-Status)

     SpecTerm here represents the inner part of a molecule.
     Object represents the molecule's oid.

     For instance, in a[c->d,e->f], Object will be pratom(a,4) and SpecTerm
     flconjunct(flmvdattspec(flatom(c,8),->,[flatom(d,10)]),
                flmvdattspec(flatom(e,12),->,[flatom(f,14)]))
****************************************************************************/
compile_body_specbody(Object,SpecTerm,WS,OidCode,Code,BodyFrontList,Status) :-
	is_flconjunct(SpecTerm,L,R),
	!,
	compile_body_specbody(Object,L,WS,OidCode,LCode,BodyFrontList1,S),
	( no_errors_found(S) -> 
	    compile_body_specbody(Object,R,WS,OidCode,RCode,BodyFrontList2,Status),
	    ( no_errors_found(Status) -> 
		conjunct_code([LCode,RCode],Code)
	    ; true
	    ),
	    append(BodyFrontList1,BodyFrontList2,BodyFrontList)
	;
	  Status=S
        ),
	!.

compile_body_specbody(Object,SpecTerm,WS,OidCode,Code,BodyFrontList,Status) :-
	is_fldisjunct(SpecTerm,L,R),
	!,
	compile_body_specbody(Object,L,WS,OidCode,LCode,BodyFrontList1,S),
	( no_errors_found(S) -> 
	    compile_body_specbody(Object,R,WS,OidCode,RCode,BodyFrontList2,Status),
	    ( no_errors_found(Status) -> 
		disjunct_struct(LCode,RCode,Code)
	    ; true
	    ),
	    append(BodyFrontList1,BodyFrontList2,BodyFrontList)
	;
	  Status=S
        ),
	!.

compile_body_specbody(Object,SpecTerm,WS,OidCode,Code,BodyFrontList,Status) :-
	is_default_negation(SpecTerm,G,NAFType),
	!,
	set_context(compiling_default_negation),
	compile_body_specbody(Object,G,WS,OidCode,GCode,BodyFrontList,Status),
	( no_errors_found(Status) -> 
	    (is_prquantifier(GCode,_Quant,FormCode,FreeVarObjList)
	    -> list_struct(FreeVarObjList,[],FreeVarObjs)
	    ;  FormCode = GCode,
		%% if no quantifier, use all vars minus dontcare/callervars
		collect_prvars(GCode,AllVars),
		remove_prdontcare_and_caller_vars(AllVars,FreeVarObjList1),
		%% this is used if naf-exists is nested deep inside the code
		remove_existential_vars(FreeVarObjList1,FreeVarObjList),
		list_struct(FreeVarObjList,[],FreeVarObjs)
	    ),
	    conjunct_code([OidCode,FormCode],CombinedCode),
	    (NAFType == FL_RULELOGNAF
	    -> naf_struct_flora(CombinedCode,FreeVarObjs,Code)
	    ; naf_struct_prolog(CombinedCode,Code)
	    )
	; true
	),
	clear_context(compiling_default_negation).

compile_body_specbody(Object,SpecTerm,WS,OidCode,Code,BodyFrontList,Status) :-
	is_flneg(SpecTerm,G,Idx),
	!,
	compile_body_specbody(Object,G,WS,OidCode,GCode,BodyFrontList,Status1),
	( no_errors_found(Status1) -> 
	    conjunct_code([OidCode,GCode],CombinedGCode),
	    neg_struct(CombinedGCode,Idx,Code,Status)
	; Status = Status1
	),
	!.

%% Quantification under default negation
compile_body_specbody(Object,SpecTerm,WS,OidCode,Code,BodyFrontList,Status) :-
	is_fllogicquantifier(SpecTerm,FL_EXISTS,QuantVarNames,Formula,Idx),
	has_context(compiling_default_negation),
	!,
	%% no quantified don't care vars (?,?_) 
	(memberchk(FL_ANON_VAR,QuantVarNames) ->
	    compiling_error(Idx,NO_QUANTIFIED_ANONVARS,Err1),
	    S1 = [Err1]
	; S1 = NO_ERRORS
	),

	compile_body_specbody(Object,Formula,WS,OidCode,FormCode,BodyFrontList,S2),
	%% We use prvars so that newly introduced vars will be accounted for
	collect_prvars([Object,OidCode,FormCode],AllVarList),
	vars_to_var_names(AllVarList,AllVarList_names),
	%% quantified vars must occur in Formula
	(subset(QuantVarNames,AllVarList_names) -> S3 = NO_ERRORS
	; compiling_error(Idx,QUANT_VARS_NOT_SUBSET,Err3),
	    S3 = [Err3]
	),

	subtract_varnames_from_vars(AllVarList,QuantVarNames,FreeVarObjs_aux),
	%% remove don't care vars, since no need to delay because of them
	remove_prdontcare_and_caller_vars(FreeVarObjs_aux,FreeVarObjs_aux2),
	%% this is used if naf-exists is nested deep inside the code
	remove_existential_vars(FreeVarObjs_aux2,FreeVarObjs),
	
	rename_prvariables(QuantVarNames,NEWEXISTENTIALVAR,FormCode,
			   RenamedFormCode,_RenamedQuantVars),

	!,
	flatten([S1,S2,S3],Status),
	( no_errors_found(Status) -> 
	    %% Create the code for compiled quantification.
	    conjunct_code([OidCode,RenamedFormCode],CombinedCode),
	    quantifier_struct(FL_EXISTS,CombinedCode,FreeVarObjs,Code)
	;
	    true
	).


%% OidCodeList below gets bound to code needed to produce
%% the attribute (M) and the value (V). We conjunct this code in front of the
%% code for the molecule
%% NULL means that we don't pass OID code out, because we use it right here.

%% No OidCode is passed outside: we consume it here
compile_body_specbody(Object,SpecTerm,WS,NULL,Code,BodyFrontList,Status) :-
	is_flmvdattspec(SpecTerm,AttTerm,RefType,ValTermList),
	!,
	compile_body_pathexp(AttTerm,WS,AttObj,AOidCode,ACode,BodyFrontList1,S),
	( no_errors_found(S) -> 
	    ( ValTermList == [] ->
		mvdattdef_struct(BODYLITERAL,Object,AttObj,RefType,SCode),
		attach_workspace(SCode,WS,WSCode,Status),
		%% Fold OidCode in front of molecule
		conjunct_code([AOidCode,ACode,WSCode],Code)
	    ;
	      compile_body_mvd_attspec(Object,AttObj,RefType,ValTermList,WS,VOidCode,WSCode,BodyFrontList2,Status),
	      ( no_errors_found(Status) -> 
		  %% ACode: Code to produce attribute
		  %% WSCode: code to produce pure attr specs and 
		  %%         the objects that represents the values
		  conjunct_code([AOidCode,VOidCode,ACode,WSCode],Code)
	      ; true
	      )
	    ),
	    append(BodyFrontList1,BodyFrontList2,BodyFrontList)
        ;
	  BodyFrontList = BodyFrontList1,
	  Status=S
        ),
	!.

%% signatures: =>, *=>, etc.
compile_body_specbody(Object,SpecTerm,WS,NULL,Code,BodyFrontList,Status) :-
	is_flsigattspec(SpecTerm,AttTerm,RefType,ValTerm),
	!,
	compile_body_pathexp(AttTerm,WS,AttObj,AOidCode,ACode,BodyFrontList1,S),
	( no_errors_found(S) -> 
	    (is_flemptyterm(ValTerm) ->
		%% This is SIGDEF: occurs when we have a[b=> ()]
		sigattdef_struct(BODYLITERAL,Object,AttObj,RefType,SCode),
		attach_workspace(SCode,WS,WSCode,Status),
		conjunct_code([AOidCode,ACode,WSCode],Code),
		BodyFrontList = BodyFrontList1
	    ;
		compile_body_pathexp(ValTerm,WS,ValObj,VOidCode,VCode,BodyFrontList2,PathexpStatus),
		( no_errors_found(PathexpStatus) -> 
		    sigattspec_struct(BODYLITERAL,Object,AttObj,RefType,ValObj,SCode),
		    attach_workspace(SCode,WS,WSCode,WSStatus),
		    conjunct_code([AOidCode,VOidCode,ACode,VCode,WSCode],Code)
		;
		    WSStatus = NO_ERRORS
		),
		(WSStatus == NO_ERRORS -> Status = PathexpStatus
		; Status = WSStatus
		),
		append(BodyFrontList1,BodyFrontList2,BodyFrontList)
	    )
	;
	    BodyFrontList = BodyFrontList1,
	    Status = S
        ),
	!.

compile_body_specbody(Object,SpecTerm,WS,NULL,Code,BodyFrontList,Status) :-
	is_flsigattconspec(SpecTerm,AttTerm,ConstrTerm,RefType,ValTerm),
	!,
	compile_body_pathexp(AttTerm,WS,AttObj,AOidCode,ACode,BodyFrontList1,S),
	( no_errors_found(S) -> 
	    (is_flemptyterm(ValTerm) ->
		%% This is SIGDEF: occurs when we have a[b=> ()]
		sigattdef_struct(BODYLITERAL,Object,AttObj,RefType,SCode),
		attach_workspace(SCode,WS,WSCode,Status),
		conjunct_code([AOidCode,ACode,WSCode],Code),
		BodyFrontList = BodyFrontList1
	    ;
		is_flsigconstr(ConstrTerm,Lower,Upper),
		compile_body_pathexplist([Lower,Upper],WS,[OLower,OUpper],COidCode,CCode,BodyFrontList2,S_C),
		( no_errors_found(S_C) -> 
		    compile_body_pathexp(ValTerm,WS,ValObj,VOidCode,VCode,BodyFrontList3,PathexpStatus),
		    ( no_errors_found(PathexpStatus) -> 
			sigattspec_struct(BODYLITERAL,Object,AttObj,RefType,ValObj,SCode),
			attach_workspace(SCode,WS,WSCode,WSStatus1),
			sigattconstr_struct(BODYLITERAL,Object,AttObj,OLower,OUpper,RefType,CSCode),
			attach_workspace(CSCode,WS,CWSCode,WSStatus2),
			conjunct_code([AOidCode,VOidCode,ACode,VCode,WSCode,COidCode,CCode,CWSCode],Code)
		    ;
			WSStatus1 = NO_ERRORS, WSStatus2 = NO_ERRORS
		    ),
		    (WSStatus1 == NO_ERRORS, WSStatus2 == NO_ERRORS -> Status = PathexpStatus
		    ; append(WSStatus1,WSStatus2,Status)
		    )
		;
		    Status = S_C
		),
		append(BodyFrontList1,BodyFrontList2,BodyFrontList4),
		append(BodyFrontList4,BodyFrontList3,BodyFrontList)
	    )
	;
	    BodyFrontList = BodyFrontList1,
	    Status = S
        ),
	!.

%% boolean signatures: =>.
compile_body_specbody(Object,SpecTerm,WS,NULL,Code,BodyFrontList,Status) :-
	is_flboolsig(SpecTerm,AttTerm,_RefType),
	!,
	compile_body_pathexp(AttTerm,WS,AttObj,AOidCode,ACode,BodyFrontList,PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    boolsig_struct(BODYLITERAL,Object,AttObj,SCode),
	    attach_workspace(SCode,WS,WSCode,WSStatus),
	    conjunct_code([AOidCode,ACode,WSCode],Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.

%% boolean signatures: *=>.
compile_body_specbody(Object,SpecTerm,WS,NULL,Code,BodyFrontList,Status) :-
	is_fliboolsig(SpecTerm,AttTerm,_RefType),
	!,
	compile_body_pathexp(AttTerm,WS,AttObj,AOidCode,ACode,BodyFrontList,PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    iboolsig_struct(BODYLITERAL,Object,AttObj,SCode),
	    attach_workspace(SCode,WS,WSCode,WSStatus),
	    conjunct_code([AOidCode,ACode,WSCode],Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.

%% boolean signatures: =>% for transactional method
compile_body_specbody(Object,SpecTerm,WS,NULL,Code,BodyFrontList,Status) :-
	is_fltransig(SpecTerm,AttTerm,_RefType),
	!,
	compile_body_pathexp(AttTerm,WS,AttObj,AOidCode,ACode,BodyFrontList,PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    transig_struct(BODYLITERAL,Object,AttObj,SCode),
	    attach_workspace(SCode,WS,WSCode,WSStatus),
	    conjunct_code([AOidCode,ACode,WSCode],Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.

%% boolean signatures: *=>% for transactional method
compile_body_specbody(Object,SpecTerm,WS,NULL,Code,BodyFrontList,Status) :-
	is_flitransig(SpecTerm,AttTerm,_RefType),
	!,
	compile_body_pathexp(AttTerm,WS,AttObj,AOidCode,ACode,BodyFrontList,PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    itransig_struct(BODYLITERAL,Object,AttObj,SCode),
	    attach_workspace(SCode,WS,WSCode,WSStatus),
	    conjunct_code([AOidCode,ACode,WSCode],Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.

%% +>>, *+>>@module
%% NULL means: consume OidCode for attr and val here -- don't pass up the chain
compile_body_specbody(Object,SpecTerm,WS,NULL,Code,BodyFrontList,Status) :-
	is_flincattspec(SpecTerm,AttTerm,RefType,ValTerm),
	!,
	compile_body_pathexplist([AttTerm,ValTerm],WS,[AttObj,ValObj],OidCode,OCode,BodyFrontList,PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    incattspec_struct(Object,AttObj,RefType,ValObj,SCode),
	    attach_workspace(SCode,WS,WSCode,WSStatus),
	    %% Fold OidCode in front of molecule
	    conjunct_code([OidCode,WSCode,OCode],Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.

%% same for ->->@module
%% NULL means: consume OidCode for attr and val here -- don't pass up the chain
compile_body_specbody(Object,SpecTerm,WS,NULL,Code,BodyFrontList,Status) :-
	is_fltolistattspec(SpecTerm,AttTerm,RefType,ValTerm),
	!,
	compile_body_pathexplist([AttTerm,ValTerm],WS,[AttObj,ValObj],OidCode,OCode,BodyFrontList,PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    tolistattspec_struct(Object,AttObj,RefType,ValObj,SCode),
	    attach_workspace(SCode,WS,WSCode,WSStatus),
	    conjunct_code([OidCode,WSCode,OCode],Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.

%% Obj[true], Obj[fail], Obj[!] translate as true, fail, and !
compile_body_specbody(_Object,SpecTerm,_WS,NULL,Code,[],Status) :-
	is_flpassthru(SpecTerm,P),
	is_flatom(P, Atom, I),
	!,
	(Atom==FL_CUT -> cut_struct(I,Code)
	; atomobj_struct(P,Code)
	),
	Status = NO_ERRORS.

%% Obj[X>Y], Obj[X=Y], etc.
compile_body_specbody(_Object,SpecTerm,_WS,NULL,Code,BodyFrontList,Status) :-
	is_flpassthru(SpecTerm,P),
	is_flterm(P, Funct, N, Args),
	!,
	compile_prlgterm(Funct,N,Args,
			 TCode,_OidCode,ACode,BodyFrontList,Status),
	( no_errors_found(Status) -> conjunct_code([ACode,TCode],Code)
	; true
	).

%% for O[BoolMeth]@module
%% NULL means: consume OidCode for attr and val here -- don't pass up the chain
compile_body_specbody(Object,SpecTerm,WS,NULL,Code,BodyFrontList,Status) :-
	is_flmethspec(SpecTerm,MethTerm),
	!,
	compile_body_pathexp(MethTerm,WS,MethObj,OidCode,MCode,
			    BodyFrontList,PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    methspec_struct(BODYLITERAL,Object,MethObj,SCode),
	    attach_workspace(SCode,WS,WSCode,WSStatus),
	    conjunct_code([OidCode,MCode,WSCode],Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.

%% for O[*BoolMeth]@module
%% NULL means: consume OidCode for attr and val here -- don't pass up the chain
compile_body_specbody(Object,SpecTerm,WS,NULL,Code,BodyFrontList,Status) :-
	is_flimethspec(SpecTerm,IMethTerm),
	!,
	compile_body_pathexp(IMethTerm,WS,IMethObj,OidCode,IMCode,
			    BodyFrontList,PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    imethspec_struct(BODYLITERAL,Object,IMethObj,SCode),
	    attach_workspace(SCode,WS,WSCode,WSStatus),
	    %% Fold OidCode in front of molecule
	    conjunct_code([OidCode,IMCode,WSCode],Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.

%% O[%M]@module
compile_body_specbody(Object,SpecTerm,WS,NULL,Code,BodyFrontList,Status) :-
	is_fltranspec(SpecTerm,TranTerm),
	!,
	compile_body_pathexp(TranTerm,WS,TranObj,OidCode,TCode,
			    BodyFrontList,PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    transpec_struct(BODYLITERAL,Object,TranObj,SCode),
	    attach_workspace(SCode,WS,WSCode,WSStatus),
	    conjunct_code([OidCode,TCode,WSCode],Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.


/****************************************************************************
  compile_body_mvd_attspec(+Object,+AttObj,+RefType,+ValTermList,+Workspace,-OidCode,-Code,?BodyFrontList,-Status)

  Compiles ->, *->, etc., when they have one or more value terms
****************************************************************************/
compile_body_mvd_attspec(Object,AttObj,RefType,[T],WS,OidCode,Code,BodyFrontList,Status) :-
	!,
	compile_body_pathexp(T,WS,TObj,OidCode,TCode,BodyFrontList,PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    mvdattspec_struct(BODYLITERAL,Object,AttObj,RefType,TObj,SCode),
	    attach_workspace(SCode,WS,WSCode,WSStatus),
	    conjunct_code([WSCode,TCode],Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.

compile_body_mvd_attspec(Object,AttObj,RefType,[T|L],WS,OidCode,Code,BodyFrontList,Status) :-
	!,
	compile_body_mvd_attspec(Object,AttObj,RefType,[T],WS,OidCodeHead,WTCode,BodyFrontList1,S),
	( no_errors_found(S) -> 
	    compile_body_mvd_attspec(Object,AttObj,RefType,L,WS,OidCodeTail,WLCode,BodyFrontList2,Status),
	    ( no_errors_found(Status) -> 
		conjunct_code([WTCode,WLCode],Code),
		conjunct_code([OidCodeHead,OidCodeTail],OidCode)
	    ; true
	    ),
	    append(BodyFrontList1,BodyFrontList2,BodyFrontList)
	;
	  Status=S
        ),
	!.


/****************************************************************************
  compile_body_objeql(+Obj1,+Obj2,+Workspace,-OidCode,-Code,-Status)
****************************************************************************/
compile_body_objeql(Obj1,Obj2,WS,OidCode,Code,Status) :-
	compile_body_pathexplist([Obj1,Obj2],WS,[O1,O2],OidCode,OCode,[],PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    objeql_struct(BODYLITERAL,O1,O2,OECode),
	    attach_workspace(OECode,WS,WSCode,WSStatus),
	    conjunct_code([OCode,WSCode],Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.


/****************************************************************************
  compile_reifyop(+Formula,-Object,-Status)
  Compiling ${...}
****************************************************************************/
/*
compile_reifyop(Formula,Object,OidCode,Status) :-
	has_context(compiling_body_pathexp),
	\+has_context(compiling_update_literals),
	!,
	%% PrependedCode might come from LIBMODLIT or LIBMODOBJ
	compute_reification_expr(Formula,AttrValCode,PrependedCode,Status),
	( no_errors_found(Status) -> 
	    new_prvariable(NO_INDEX,Object),
	    attrvar_code(Object,AttrValCode,FLSEMANTICUNIFICATION,PutAttrCode),
	    conjunct_code([PrependedCode,PutAttrCode],OidCode)
	;
	    true
	).
*/
compile_reifyop(Formula,Object,OidCode,Status) :-
	compute_reification_expr(Formula,Object,OidCode,Status).

compute_reification_expr(Formula,Object,OidCode,Status) :-
	Formula = [Rule|_],
	(is_fldynrule(Rule,_Head,_Body,_Descr)
	; is_flruleworkspace(Rule,_RealRule,_WS)
	),
	!,
	set_context(rule_reification),
        %% singleton/unbound vars are flagged in reified/inserted rules
	compile_dynrule(FL_INSERTRULE,Rule,Object,Status),
	clear_context(rule_reification),
	OidCode=NULL.

compute_reification_expr(Formula,Object,OidCode,Status) :-
	set_context(goal_reification),
	compile_body(Formula,Object1,Status),
	clear_context(goal_reification),
	(is_florasyslib_struct(Object1, Index,FLLIBMODLIT,_N,Args)
	%% If it is compiled into a LIBMODLIT/3, replace with LIBMODOBJ
	->
            new_prvariable(Index,Object),
	    %% LIBMODLIT/3 already has the caller argument -- no
	    %% need to add it here
	    Args = [Pred,WS,Caller],
	    (has_context(compiling_headliteral)
	    -> NewArgs = [FL_HEAD,Pred,WS,Caller,Object]
	    ;  NewArgs = [FL_BODY,Pred,WS,Caller,Object]
	    ),
	    florasyslib_struct(Index,FLLIBMODOBJ,5,NewArgs,OidCode)
	;
	    reify_struct(Object1,Object),
	    OidCode = NULL
	),
	!.

/****************************************************************************
  compile_truthvalue(+Form,+Op,-OidCode,-Code,-Status)
  Compiles true{...}, false{...}, unknown{...}
****************************************************************************/
compile_truthvalue(Formula,Op,Code,Status) :-
	atomobj_struct(Op,OpCode),
	compile_body(Formula,FCode,Status),
	!,
	( no_errors_found(Status) -> 
	   truthvalue_struct(FCode,OpCode,Code)
	; true
	).


/****************************************************************************
   compile_tag_primitive(+DescriptorParserTerm,?HeadList,-Code,-Status)
****************************************************************************/
compile_tag_primitive(DescriptorParserTerm,HeadList,Code,Status) :-
	compile_body_pathexp(DescriptorParserTerm,FL_THISMODULE,TagCode,_,_,[],S1),
	( no_errors_found(S1) -> 
	    set_context(compile_with_var_module),
	    set_context(compiling_headliteral),
	    compile_delete_litlist(HeadList,HLC,Status),
	    clear_context(compiling_headliteral),
	    ( no_errors_found(Status) -> 
		list_struct(HLC,[],HeadListCode),
		tagprimitive_struct(TagCode,HeadListCode,Code)
	    ; true
	    )
	; Status = S1
	),
	!.


/****************************************************************************
   compile_prefixprimitive(+Prefix,+Expansion,+Module,-Code,-Status)

   Compiles the prefix{...} primitive.
****************************************************************************/
compile_prefixprimitive(Prefix,Expansion,Module,Code,Status) :-
	(memberchk(Module,[NULL,FL_THISMODULE]) -> thismodule_struct(ModuleCode)
	; compile_atomvar(Module,ModuleCode)
	),
	compile_body_pathexplist([Prefix,Expansion],FL_THISMODULE,[PrefixCode,ExpansionCode],_,_,[],Status),
	!,
	( no_errors_found(Status) -> 
	    prefixprimitive_struct(PrefixCode,ExpansionCode,ModuleCode,Code)
	; true
	).


/****************************************************************************
  compile_prologliblit(+ParserTerm,-OidCode,-Code,?BodyFrontList,-Status)

  Compiles Prolog library call @_prolog
****************************************************************************/
compile_prologliblit(ParserTerm,OidCode,Code,BodyFrontList,Status) :-
	( is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_prlgterm(Funct,N,Args,
			     TCode,OidCode,ACode,BodyFrontList,Status),
	    ( no_errors_found(Status) -> 
		conjunct_code([ACode,TCode],Code)
	    ; true
	    )
	;
	    atomobj_struct(ParserTerm,FObj),
	    N=0,
	    prologterm_struct(FObj,0,[],Code),
	    OidCode=NULL,
	    Status = NO_ERRORS
	),
	!.


/****************************************************************************
  compile_prologliblit(+ParserTerm,+Module,-OidCode,-Code,?BodyFrontList,-Status)

  Compiles Prolog library call @_prolog(module)
****************************************************************************/
compile_prologliblit(ParserTerm,Module,OidCode,Code,BodyFrontList,Status) :-
	( is_flterm(ParserTerm,Funct,N,Args) ->
	    get_flatom_name(Funct,FAtom),
	    %%compile_prlgterm(Funct,N,Args, %% Module,
	    compile_prlgterm(Funct,N,Args,Module,
			     TCode,OidCode,ACode,BodyFrontList,Status)
	;
	    get_flatom_name(ParserTerm,FAtom),
	    atomobj_struct(ParserTerm,FObj),
	    N=0,
	    prologterm_struct(FObj,0,[],Module,TCode),
	    ACode=NULL,
	    OidCode=NULL,
	    BodyFrontList = [],
	    Status = NO_ERRORS
	),
	( no_errors_found(Status) -> 
	    %% build a special structure for the coder
	    %% prologliblit_struct is NOT added by compile_prologliblit/6 ---
	    %% only by compile_prologliblit/7
	    prologliblit_struct(TCode,PCode),
	    conjunct_code([ACode,PCode],Code)
	/*
	    %% generate an import statement for the corresponding XSB predicate
	    is_flatom(Module,MName),
	    import_struct(FAtom,N,MName,ICode),
	    directive_struct(ICode,DCode),
	    report_directive(DCode)
	*/
	;
	  true
	),
	!.


/****************************************************************************
  compile_prologallliblit(+ParserTerm,-OidCode,-Code,-BodyFrontList,-Status)

  Compiles Prolog library call @_prologall
****************************************************************************/
compile_prologallliblit(ParserTerm,OidCode,Code,BodyFrontList,Status) :-
	compile_prologliblit(ParserTerm,OidCode,PrelimCode,BodyFrontList,Status),
	( % here PrelimCode is bound and we decompose it
	  conjunct_struct(ACode,PrelimTermCode,PrelimCode), !
	; PrelimCode = PrelimTermCode, ACode=NULL
	),
	!,
	%% Here PrelimTermCode is bound and we decompose it
	prologterm_struct(FunctCode,N,ArgsCode,PrelimTermCode),
	new_prvarlist(N,NewVarList),
	generate_convert_to_prolog_code(ArgsCode,NewVarList,ToPrologCode),
	prologterm_struct(FunctCode,N,NewVarList,TermCode),
	generate_convert_from_prolog_code(ArgsCode,NewVarList,FromPrologCode),
	conjunct_code([ACode,ToPrologCode,TermCode,FromPrologCode],Code).


/****************************************************************************
  compile_prologallliblit(+ParserTerm,+Module,-OidCode,-Code,-BodyFrontList,-Status)

  Compiles Prolog library call @_prologall(module)
****************************************************************************/
compile_prologallliblit(ParserTerm,Module,OidCode,Code,BodyFrontList,Status) :-
	compile_prologliblit(ParserTerm,Module,OidCode,PrelimCode,BodyFrontList,Status),
	( % here PrelimCode is bound and we decompose it
	  conjunct_struct(ACode,PrelimTermLitCode,PrelimCode), !
	; PrelimCode = PrelimTermLitCode, ACode=NULL
	),
	!,
	%% PrelimTermLitCode is bound and we decompose it
	prologliblit_struct(PrelimTermCode,PrelimTermLitCode),
	%% PrelimTermCode is bound and we decompose it
	%%prologterm_struct(FunctCode,N,ArgsCode,PrelimTermCode),
	prologterm_struct(FunctCode,N,ArgsCode,Module,PrelimTermCode),
	new_prvarlist(N,NewVarList),
	generate_convert_to_prolog_code(ArgsCode,NewVarList,ToPrologCode),
	%%prologterm_struct(FunctCode,N,NewVarList,TermCode),
	prologterm_struct(FunctCode,N,NewVarList,Module,TermCode),
	prologliblit_struct(TermCode,TermLitCode),
	generate_convert_from_prolog_code(ArgsCode,NewVarList,FromPrologCode),
	conjunct_code([ACode,ToPrologCode,TermLitCode,FromPrologCode],Code).


/****************************************************************************
  compile_prologlibobj(+ParserTerm,-Object,-OidCode,-Code,?BodyFrontList,-Status)

  Compiles Prolog library call @_prolog in the arguments position
  E.g., f(member(X,[a])@_prolog)
  This feature might be useful for meta-programming.  
****************************************************************************/
compile_prologlibobj(ParserTerm,Object,OidCode,Code,BodyFrontList,Status) :-
	( is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_prlgterm(Funct,N,Args,
			     Object,OidCode,Code,BodyFrontList,Status)
	;
	    atomobj_struct(ParserTerm,FObj),
	    N=0,
	    prologterm_struct(FObj,0,[],Object),
	    Code=NULL,
	    OidCode=NULL,
	    BodyFrontList=[],
	    Status = NO_ERRORS
	),
	!.


/****************************************************************************
  compile_prologlibobj(+ParserTerm,+Module,-Object,-OidCode,-Code,?BodyFrontList,-Status)

  Compiles Prolog library call @_prolog(module) in the arguments position
****************************************************************************/
compile_prologlibobj(ParserTerm,Module,Object,OidCode,Code,BodyFrontList,Status) :-
	( is_flterm(ParserTerm,Funct,N,Args) ->
	    get_flatom_name(Funct,FAtom),
	    %%compile_prlgterm(Funct,N,Args, %%Module,
	    compile_prlgterm(Funct,N,Args,Module,
			     Object,OidCode,Code,BodyFrontList,Status)
	;
	    get_flatom_name(ParserTerm,FAtom),
	    atomobj_struct(ParserTerm,FObj),
	    N=0,
	    prologterm_struct(FObj,0,[],Module,Object),
	    Code=NULL,
	    OidCode=NULL,
	    BodyFrontList=[],
	    Status = NO_ERRORS
	),
	/*
	( no_errors_found(Status) -> 
	    %% generate an import statement for the corresponding XSB predicate
	    is_flatom(Module,MName),
	    import_struct(FAtom,N,MName,ICode),
	    directive_struct(ICode,DCode),
	    report_directive(DCode)
	;
	  true
	),
	*/
	!.


/****************************************************************************
  compile_prologalllibobj(+ParserTerm,-Object,-OidCode,-Code-,?BodyFrontList,-Status)

  Compiles @_prologall in argument position, e.g., foo(f(...)@_prologall
***************************************************************************/
compile_prologalllibobj(ParserTerm,Object,OidCode,Code,BodyFrontList,Status) :-
	compile_prologlibobj(ParserTerm,PrelimObject,PrelimOidCode,PrelimCode,BodyFrontList,Status),
	%% PrelimObject is bound and we decompose it
	prologterm_struct(FunctCode,N,ArgsCode,PrelimObject),
	new_prvarlist(N,NewVarList),
	generate_convert_to_prolog_code(ArgsCode,NewVarList,ToPrologCode),
	prologterm_struct(FunctCode,N,NewVarList,Object),
	generate_convert_from_prolog_code(ArgsCode,NewVarList,FromPrologCode),
	conjunct_code([ToPrologCode,PrelimOidCode],OidCode),
	conjunct_code([FromPrologCode,PrelimCode],Code).

/****************************************************************************
  compile_prologalllibobj(+ParserTerm,+Module,-Object,-OidCode,-Code,?BodyFrontList,-Status)

  Compiles @_prologall(module) in argument position,
  e.g., foo(f(...)@_prologall(module)
***************************************************************************/
compile_prologalllibobj(ParserTerm,Module,Object,OidCode,Code,BodyFrontList,Status) :-
	compile_prologlibobj(ParserTerm,Module,PrelimObject,PrelimOidCode,PrelimCode,BodyFrontList,Status),
	%% PrelimObject is bound and we decompose it
	prologterm_struct(FunctCode,N,ArgsCode,PrelimObject),
	new_prvarlist(N,NewVarList),
	generate_convert_to_prolog_code(ArgsCode,NewVarList,ToPrologCode),
	prologterm_struct(FunctCode,N,NewVarList,Object),
	generate_convert_from_prolog_code(ArgsCode,NewVarList,FromPrologCode),
	conjunct_code([ToPrologCode,PrelimOidCode],OidCode),
	conjunct_code([PrelimCode,FromPrologCode],Code).


/****************************************************************************
  compile_prlgterm(+FunctTerm,+Arity,+ArgList,-Object,-OidCode,-Code,?BodyFrontList,-Status)
  compile_prlgterm(+FunctTerm,+Arity,+ArgList,+PlgModule,-Object,-OidCode,-Code,?BodyFrontList,-Status)
  
 BodyFrontList - code to add at the beginning of the body
                 (mostly for user defined fnctions),
		 it is output argument, but if it is initialized to
		 empty ([]) ignores user defined functions
****************************************************************************/
compile_prlgterm(Funct,N,Args,Object,OidCode,Code,BodyFrontList,Status) :-
	atomobj_struct(Funct,FObj),
	prologterm_struct(FObj,N,AObj,Object),
	(has_context(no_symbol_check) -> Clear = no
	; set_context(no_symbol_check), Clear = yes
	),
	compile_body_pathexplist(Args,FL_THISMODULE,AObj,OidCode,Code,BodyFrontList,Status),
	(Clear == yes -> clear_context(no_symbol_check)
	; true
	),
	!.

%% Generate prolog term with module prefix
compile_prlgterm(Funct,N,Args,Module,Object,OidCode,Code,BodyFrontList,Status) :-
	atomobj_struct(Funct,FObj),
	prologterm_struct(FObj,N,AObj,Module,Object),
	set_context(no_symbol_check),
	compile_body_pathexplist(Args,FL_THISMODULE,AObj,OidCode,Code,BodyFrontList,Status),
	clear_context(no_symbol_check),
	!.

/*************************************************************************
   generate_convert_to_prolog_code(+AObjList,+VarList,-Code)
*************************************************************************/ 
generate_convert_to_prolog_code([],_,NULL).

generate_convert_to_prolog_code([AObjH|AObjT],[VarH|VarT],Code) :-
	atomobj_struct(P2H_PREDICATE,FlP2H),
	%% P2H_DONOT_UNIFY_VARS - do not unify when both arguments are vars
	%%prologterm_struct(FlP2H,4,[VarH,AObjH,WRAP_HILOG,P2H_DONOT_UNIFY_VARS],CodeH),
	/* Previously we used P2H_DONOT_UNIFY_VARS here, but this meant that,
	   for example     ?- write(f(?X,?X))@_prologall.
           will print the two versions of ?Y as different vars.
           Do not know why P2H_DONOT_UNIFY_VARS was used here before.
	*/
	prologterm_struct(FlP2H,4,[VarH,AObjH,WRAP_HILOG,P2H_UNIFY_VARS],CodeH),
	generate_convert_to_prolog_code(AObjT,VarT,CodeT),
	conjunct_code([CodeH,CodeT],Code).

/*************************************************************************
   generate_convert_from_prolog_code(+AObjList,+VarList,-Code)
*************************************************************************/ 
generate_convert_from_prolog_code([],_,NULL).

generate_convert_from_prolog_code([AObjH|AObjT],[VarH|VarT],Code) :-
	atomobj_struct(P2H_PREDICATE,FlP2H),
	%% P2H_UNIFY_VARS - unify when both arguments are vars
	prologterm_struct(FlP2H,4,[VarH,AObjH,WRAP_HILOG,P2H_UNIFY_VARS],CodeH),
	generate_convert_from_prolog_code(AObjT,VarT,CodeT),
	conjunct_code([CodeH,CodeT],Code).
		

/****************************************************************************
  compile_head_floraliblit(+ParserTerm,+Workspace,-Code,-H2BCodeHead,-H2BCodeTail,-Status)

  This procedure compiles a head literal associated with a Flora system
  module specification.
****************************************************************************/
compile_head_floraliblit(ParserTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	%% Flora system modules are like normal user modules except that
	%% users cannot load files into them
	is_flatom(WS,WSName,Index),
	report_option(FLSYSMOD(WSName),Index),
	atomobj_struct(WSName,Index,WSNameCode),
	floralib_struct(WSNameCode,WSCode),
	compile_head_literal(ParserTerm,WSCode,Code,H2BCodeHead,H2BCodeTail,Status).


/****************************************************************************
  compile_head_literal(+ParserTerm,+Workspace,-Code,-H2BCodeHead,-H2BCodeTail,-Status)

  H2BCodeHead - code passed from head to body, which is supposed to be
                prepended to the code of the body
  H2BCodeTail - code passed from head to body, which is supposed to be
                appended to the code of the body
****************************************************************************/
compile_head_literal(ParserTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
        set_context(compiling_headliteral),
	( is_fltransactionalterm(ParserTerm,Funct,N,Args) ->
	    compile_head_transactional_termlit(Funct,N,Args,WS,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_head_termlit(Funct,N,Args,WS,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flbirelate(ParserTerm,ObjTerm1,RelType,ObjTerm2) ->
	    compile_head_bin_relation(ObjTerm1,RelType,ObjTerm2,WS,_Obj,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flobjspec(ParserTerm,ObjTerm,Spec) ->
	    compile_head_objspec(ObjTerm,Spec,WS,_Obj,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flobjeql(ParserTerm,O1,O2) ->
	    compile_head_objeql(O1,O2,WS,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flneg(ParserTerm,PosPart,Idx) ->
	    detach_flworkspace(PosPart,PosPartSansWS,PosWS),
	    compile_head_neg(PosPartSansWS,PosWS,Idx,Code,H2BCodeHead,H2BCodeTail,Status)

        ; is_flvariable(ParserTerm,VarName,Index) ->
	    %% Is this possible? Should be taken care by the libmodlit code
	    compile_var(VarName,Index,VarCode),
	    attach_workspace(VarCode,WS,Code,Status),
	    H2BCodeHead=NULL,
	    H2BCodeTail=NULL

        ; is_fltransactionalvariable(ParserTerm,VarName,Index) ->
	    %% Is this possible? Should be taken care by the libmodlit code
	    compile_transactionalvar(VarName,Index,VarCode),
	    attach_workspace(VarCode,WS,Code,Status),
	    H2BCodeHead=NULL,
	    H2BCodeTail=NULL

	; is_flfloralib(ParserTerm,P,Module) ->
	    compile_head_floraliblit(P,Module,Code,H2BCodeHead,H2BCodeTail,Status)
	; is_fldatatype(ParserTerm,_Sort,_Lit,_Index) ->
	    datatypeobj_struct(ParserTerm,Code1,Status),
	    atomlit_struct(HEADLITERAL,Code1,Code),
	    H2BCodeHead=NULL,
	    H2BCodeTail=NULL

	; is_fltransactionaldatatype(ParserTerm,_Sort,_Lit,_Index) ->
	    datatypeobj_struct(ParserTerm,Code1,Status),
	    transactionalatomlit_struct(HEADLITERAL,Code1,Code),
	    H2BCodeHead=NULL,
	    H2BCodeTail=NULL

	; is_flatom(ParserTerm,_) ->
	    %% atom (0-ary predicate)
	    atomlit_struct(HEADLITERAL,ParserTerm,AtmCode),
	    attach_workspace(AtmCode,WS,Code,WSStatus),
	    verify_symbol_context(ParserTerm,0, PREDICATE_SYMBOL,
				  NONTRANSACTIONAL_SYMBOL,SymbolStatus),
	    (WSStatus == NO_ERRORS -> Status = SymbolStatus
	    ; append(SymbolStatus,WSStatus,Status)
	    ),
	    H2BCodeHead=NULL,
	    H2BCodeTail=NULL
	
	; is_fltransactionalatom(ParserTerm,_A) ->
	    transactionalatomlit_struct(HEADLITERAL,ParserTerm,ACode),
	    attach_workspace(ACode,WS,Code,WSStatus),
	    verify_symbol_context(ParserTerm,0,WS,PREDICATE_SYMBOL,
				  TRANSACTIONAL_SYMBOL,SymbolStatus),
	    (WSStatus == NO_ERRORS -> Status = SymbolStatus
	    ; append(SymbolStatus,WSStatus,Status)
	    ),
	    H2BCodeHead=NULL,
	    H2BCodeTail=NULL

	; is_flbuiltin_identifier(ParserTerm,_) ->
	    atomlit_struct(HEADLITERAL,ParserTerm,BICode),
	    attach_workspace(BICode,WS,Code,WSStatus),
	    verify_symbol_context(ParserTerm,0, PREDICATE_SYMBOL,
				  NONTRANSACTIONAL_SYMBOL,SymbolStatus),
	    (WSStatus == NO_ERRORS -> Status = SymbolStatus
	    ; append(SymbolStatus,WSStatus,Status)
	    ),
	    H2BCodeHead=NULL,
	    H2BCodeTail=NULL
	;
	    approx_flindex(ParserTerm,ErrIdx),
	    compiling_error(ErrIdx,[UNKNOWN_ERROR,'\n\t\t Details: in compile_head_literal'],Err),
	    Status = [Err]
	),
	!,
        clear_context(compiling_headliteral).


/****************************************************************************
  compile_head_pathexplist(+ParserTermList,+WS,-ObjectList,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
****************************************************************************/
compile_head_pathexplist([],_WS,[],NULL,NULL,NULL,[]) :- !.

compile_head_pathexplist([T|L],WS,[TObj|LObj],Code,H2BCodeHead,H2BCodeTail,Status) :-
	compile_head_pathexp(T,WS,TObj,TCode,TH2BCodeHead,TH2BCodeTail,S),
	clear_context(compiling_term_name),
	( no_errors_found(S) -> 
	    compile_head_pathexplist(L,WS,LObj,LCode,LH2BCodeHead,LH2BCodeTail,S2),
	    ( no_errors_found(S2) -> 
		conjunct_struct(TCode,LCode,Code),
		conjunct_code([TH2BCodeHead,LH2BCodeHead],H2BCodeHead),
		conjunct_code([TH2BCodeTail,LH2BCodeTail],H2BCodeTail),
		append(S,S2,Status)
	    ;
		Status=S2
	    )
	;
	  Status=S
        ),
	!.


/****************************************************************************
  compile_head_pathexp(+ParserTerm,+WS,-Object,-Code,-H2BCodeHead,-H2BCodeTail,-Status)

  Path expression in rule head

****************************************************************************/
compile_head_pathexp(ParserTerm,_WS,Object,NULL,NULL,NULL,Status) :-
        ( is_fltransactionalatom(ParserTerm,_A) ->
	    verify_symbol_context(ParserTerm,0,FUNCTION_SYMBOL,
				  TRANSACTIONAL_SYMBOL,Status),
            transactionalatomobj_struct(ParserTerm,Object)

	; is_flnumber(ParserTerm,_N) ->
	    numobj_struct(ParserTerm,Object),
	    Status = NO_ERRORS

	; is_flvariable(ParserTerm,Name,Index) ->
	    compile_var(Name,Index,Object),
	    Status = NO_ERRORS

        ; is_fltransactionalvariable(ParserTerm,Name,Index) ->
            compile_transactionalvar_without_trans(Name,Index,Object),
	    Status = NO_ERRORS

	; is_flbuiltin_identifier(ParserTerm,_Ident) ->
	    verify_symbol_context(ParserTerm,0,FUNCTION_SYMBOL,
				  NONTRANSACTIONAL_SYMBOL,Status),
	    builtin_identifier_struct(ParserTerm,Object)

	; is_fldatatype(ParserTerm,_Sort,_Lit,_Index) ->
	    datatypeobj_struct(ParserTerm,Object,Status)

	; is_flstring(ParserTerm,_S) ->
	    strobj_struct(ParserTerm,Object),
	    Status = NO_ERRORS

	; is_fltransactionalstring(ParserTerm,_S) ->
	    transactionalstrobj_struct(ParserTerm,Object),
	    Status = NO_ERRORS

	; is_fltoken(ParserTerm,Token,Index) ->
	    verify_symbol_context(ParserTerm,0,FUNCTION_SYMBOL,
				  NONTRANSACTIONAL_SYMBOL,Status),
	    compile_head_fltoken(Token,Index,Object)

	; is_fltoken(ParserTerm,Token,Suffix,Index) ->      
	    verify_symbol_context(ParserTerm,0,FUNCTION_SYMBOL,
				  NONTRANSACTIONAL_SYMBOL,Stat1),
	    compile_head_fltoken(Token,Suffix,Index,Object,Stat2),
	    append(Stat1,Stat2,Status)
	),
	!.

compile_head_pathexp(ParserTerm,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status) :- 
	( is_flbirelate(ParserTerm,OT1,RelType,OT2) ->
	    compile_head_bin_relation(OT1,RelType,OT2,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flobjspec(ParserTerm,ObjTerm,Spec) ->
	    compile_head_objspec(ObjTerm,Spec,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flobjref(ParserTerm,ObjTerm,RefType,AttTerm) ->
	    compile_head_objref(ObjTerm,RefType,AttTerm,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_head_termobj(Funct,N,Args,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status)

        ; is_fltransactionalterm(ParserTerm,Funct,N,Args) ->
	    compile_head_termobj(Funct,N,Args,WS,Object,Code,
				     H2BCodeHead,H2BCodeTail,Status)

	; is_fllist(ParserTerm,L,T,I) ->
	    compile_head_list_obj(L,T,I,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flworkspace(ParserTerm,P,NestedWS) ->
	    compile_head_pathexp(P,NestedWS,Object,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flatom(ParserTerm,_A) ->
	    Code=NULL,
	    H2BCodeTail=NULL,
	    compile_atomobj(ParserTerm,Object,BodyFrontList,Status),
	    (BodyFrontList==[] -> H2BCodeHead=NULL
	    ;
		conjunct_code(BodyFrontList,H2BCodeHead)
	    )

	; is_reifyop(ParserTerm,Formula) ->
	    %% Code: code to get Object
	    /* We push fllibmodobj creating reified statement
	       to the body. This allows us to have reified statements with
	       var module in the head. For instance,
	        p(${a(?X)@?M}) :- a(?X,?M).
		a(1,mmm).
		?- p(${a(?X)@mmm}).
	    */
	    %% If H2BCodeHead != NULL, it means that head-reification could
	    %% not be fully computed due to a var in the module or literal
	    %% position. In that case, fllibmodobj/5 is pushed to the body;
	    %% it will then compute the reification or will unify with it.
	    compile_reifyop(Formula,Object,H2BCodeHead,Status),
	    Code = NULL,
	    H2BCodeTail = NULL

	;
	    approx_flindex(ParserTerm,ErrIdx),
	    compiling_error(ErrIdx,[UNKNOWN_ERROR,'\n\t\t Details: in compile_head_pathexp'],Err),
	    Status = [Err]
        ),
	!.


/****************************************************************************
  compile_head_termobj(+FunctorTerm,+Arity,+ArgList,+WS,-Object,-Code,-H2BCodeHead,-H2BCodeTail,-Status)

****************************************************************************/
compile_head_termobj(Funct,N,Args,WS,Object,Code,H2BCodeHead,H2BCodeTail,CompileStatus) :-
        ( \+ has_context(compiling_arithmetics),
	    has_UDF(Funct,N,Args,Predicate,Object /* return value */,FunctBodyFrontList,S1)
	->
	    ( no_errors_found(S1) -> 
	    	H2BCodeTail=NULL,
	    	Code=NULL,
	    	compile_udf_body_literal(Funct,Predicate,PCode,PH2BCodeHead,S),
	    	SymbolContext = UDF_SYMBOL,
	    	( no_errors_found(S) -> 
		    append(FunctBodyFrontList,PH2BCodeHead,List1),
		    append(List1,[PCode],List),
		    conjunct_code(List,H2BCodeHead),
		    Status = NO_ERRORS
	    	;
		    approx_flindex(Funct,Index),
		    compiling_error(Index,ERROR_UDF_COMPILE,Err),
		    Status = [Err|S]
	    	)
	    ;
		approx_flindex(Funct,Index),
		compiling_error(Index,ERROR_UDF_COMPILE,Err),
		Status = [Err|S1]
	    )
        ;
	    set_context(compiling_term_name),
	    compile_head_pathexplist([Funct|Args],WS,[FObj|AObj],Code,H2BCodeHead,H2BCodeTail,Status),
	    SymbolContext = FUNCTION_SYMBOL,
	    ( no_errors_found(Status) -> 
		termobj_struct(FObj,N,AObj,Object)
	    ; true
	    )
        ),
	(is_fltransactionalatom(Funct,_)
	-> Transactionality = TRANSACTIONAL_SYMBOL
	; Transactionality = NONTRANSACTIONAL_SYMBOL
	),
	verify_symbol_context(Funct,N,WS,SymbolContext,Transactionality,SymbolStatus),
	!,
	append(SymbolStatus,Status,CompileStatus).


/****************************************************************************
  compile_head_termlit(+FunctorTerm,+Arity,+ArgList,+WS,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
****************************************************************************/
compile_head_termlit(Funct,N,Args,WS,Code,H2BCodeHead,H2BCodeTail,CompileStatus) :-
	verify_symbol_context(Funct,N,WS,PREDICATE_SYMBOL,NONTRANSACTIONAL_SYMBOL,SymbolStatus),
	set_context(compiling_term_name),
	compile_head_pathexplist([Funct|Args],WS,[FObj|AObj],ObjCode,H2BCodeHead_pre,H2BCodeTail,PathexpStatus),
	((H2BCodeHead_pre \== NULL ; H2BCodeTail \== NULL)
	-> H2BCodeHead = H2BCodeHead_pre
	; /* compiling modular prolog fact: convert to rule fact :- true.
	     such rules are compiled by compile_fact_add so they will
	     be insertable and will not conflict with the staic version
	     of the same modular prolog fact
	     For instance: 

	     THIS IS A HACK: Think of a better way. Example:
	       :- prolog ppp/1.
               ?- _add(load2).
               ppp(abc).
	     ----- load.flr -----
	       :- prolog ppp/1.
               ppp(cde).

	      Without this special treatment, there will be an error because
	      ppp(abc) will be compiled as a static Prolog face and ppp(cde) as
	      ?- assert(ppp(cde)).
	      These two will conflict: redefinition of static by dynamic.
	    */
	    has_context(compiling_facts),
	    has_context(compiling_for_addition),
	    get_flatom_name(Funct,AtomName),
	    flora_modular_prlgdef(AtomName,N)
	-> %% FL_TRUE is dummy code, which gets ignored by conjunct_struct/3
	    H2BCodeHead = FL_TRUE
	; H2BCodeHead = H2BCodeHead_pre
	),
	( no_errors_found(PathexpStatus) -> 
	    termlit_struct(HEADLITERAL,FObj,N,AObj,TObj),
	    attach_workspace(TObj,WS,WSTObj,WSStatus),
	    conjunct_struct(ObjCode,WSTObj,Code)
	;
	    WSStatus = NO_ERRORS
        ),
	!,
	(WSStatus == NO_ERRORS -> append(SymbolStatus,PathexpStatus,CompileStatus)
	; CompileStatus = WSStatus
	).

compile_head_transactional_termlit(Funct,N,Args,WS,Code,H2BCodeHead,H2BCodeTail,CompileStatus) :-
	verify_symbol_context(Funct,N,WS,PREDICATE_SYMBOL,TRANSACTIONAL_SYMBOL,SymbolStatus),
	set_context(compiling_term_name),
	compile_head_pathexplist([Funct|Args],WS,[FObj|AObj],ObjCode,H2BCodeHead,H2BCodeTail,PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    transactionaltermlit_struct(HEADLITERAL,FObj,N,AObj,TObj),
	    attach_workspace(TObj,WS,WSTObj,WSStatus),
	    conjunct_struct(ObjCode,WSTObj,Code)
	;
	    WSStatus = NO_ERRORS
        ),
	!,
	(WSStatus == NO_ERRORS -> append(SymbolStatus,PathexpStatus,CompileStatus)
	; CompileStatus = WSStatus
	).



/****************************************************************************
  compile_head_list_obj(+ObjTermList,+ObjTerm,+Index,+WS,-Object,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
****************************************************************************/
compile_head_list_obj(ObjTermList,ObjTerm,Index,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status) :-
	compile_head_pathexplist(ObjTermList,WS,ObjList,ObjListCode,ObjListH2BCodeHead,ObjListH2BCodeTail,S),
	( no_errors_found(S) -> 
	    ( ObjTerm == [] ->
		Obj=[],
		ObjCode=NULL,
		ObjH2BCodeHead=NULL,
		ObjH2BCodeTail=NULL,
		Status = NO_ERRORS
	    ;
	      compile_head_pathexp(ObjTerm,WS,Obj,ObjCode,ObjH2BCodeHead,ObjH2BCodeTail,Status)
	    ),
	    ( no_errors_found(Status) -> 
		list_struct(ObjList,Obj,Index,Object),
		conjunct_struct(ObjListCode,ObjCode,Code),
		conjunct_code([ObjListH2BCodeHead,ObjH2BCodeHead],H2BCodeHead),
		conjunct_code([ObjListH2BCodeTail,ObjH2BCodeTail],H2BCodeTail)
	    ;
	      true
	    )
	;
	  Status=S
        ),
	!.


/****************************************************************************
  compile_head_objref(+ObjT,+RefType,+AttT,+WS,-Object,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
****************************************************************************/
compile_head_objref(ObjTerm,RefType,AttTerm,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status) :-
	compile_head_pathexplist([ObjTerm,AttTerm],WS,[Obj,Att],OACode,OAH2BCodeHead,OAH2BCodeTail,PathexpStatus),
	!,
	( no_errors_found(PathexpStatus) -> 
	    %% Approximate the textual information for the new variable.
	    approx_flindex(AttTerm,Index),
	    head_objref_struct(Obj,RefType,Att,Index,Object,TCode),
	    attach_workspace(TCode,WS,WTCode,WSStatus),
	    OAH2BCodeHead = H2BCodeHead,
	    conjunct_code([OAH2BCodeTail,WTCode],H2BCodeTail),
	    Code = OACode
	;
	    WSStatus = NO_ERRORS
        ),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	;  Status = WSStatus
	).


/****************************************************************************
  compile_head_bin_relation(+OT1,+RelType,+OT2,+WS,-Object,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
****************************************************************************/
compile_head_bin_relation(ObjTerm1,RelType,ObjTerm2,WS,Obj1,Code,H2BCodeHead,H2BCodeTail,Status) :-
	compile_head_pathexplist([ObjTerm1,ObjTerm2],WS,[Obj1,Obj2],OCode,H2BCodeHead,H2BCodeTail,PathexpStatus),
	!,
	( no_errors_found(PathexpStatus) -> 
	    birelate_struct(HEADLITERAL,Obj1,RelType,Obj2,TCode),
	    attach_workspace(TCode,WS,WTCode,WSStatus),
	    conjunct_struct(OCode,WTCode,Code)
	;
	    WSStatus = NO_ERRORS
        ),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	;  Status = WSStatus
	).


/****************************************************************************
  compile_head_objspec(+ObjTerm,+SpecBody,+WS,-Object,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
****************************************************************************/
compile_head_objspec(ObjTerm,SpecBody,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status) :-
	( SpecBody == NO_ERRORS ->
	    ( is_flobjref(ObjTerm,OTerm,RefType,ATerm) ->
		compile_head_objref(OTerm,RefType,ATerm,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status)
	    ;
		compile_head_pathexp(ObjTerm,WS,Object,ObjCode,H2BCodeHead,H2BCodeTail,PathexpStatus),
		( no_errors_found(PathexpStatus) -> 
		    objexists_struct(HEADLITERAL,Object,ECode),
		    attach_workspace(ECode,WS,WSECode,WSStatus),
		    conjunct_struct(ObjCode,WSECode,Code)
		;
		    WSStatus = NO_ERRORS
		),
		(WSStatus == NO_ERRORS -> Status = PathexpStatus
		; Status = WSStatus
		)
	    )
	;
	  compile_head_pathexp(ObjTerm,WS,Object,ObjCode,ObjH2BCodeHead,ObjH2BCodeTail,S),
	  ( no_errors_found(S) -> 
	      compile_head_specbody(Object,SpecBody,WS,SCode,SH2BCodeHead,SH2BCodeTail,Status),
	      ( no_errors_found(Status) -> 
		      conjunct_struct(ObjCode,SCode,Code),
	              conjunct_code([ObjH2BCodeHead,SH2BCodeHead],H2BCodeHead),
	              conjunct_code([ObjH2BCodeTail,SH2BCodeTail],H2BCodeTail)
	      ; true
	      )
	  ;
	    Status=S
	  )
        ),
	!.


/****************************************************************************
  compile_head_specbody(+Object,+SpecTerm,+WS,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
  compile_head_mvd_attspec(+Object,+AttObj,+RefType,+VL,+WS,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
****************************************************************************/
compile_head_specbody(Object,SpecTerm,_WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flworkspace(SpecTerm,Spec,SpecWS),
	!,
	compile_head_specbody(Object,Spec,SpecWS,Code,H2BCodeHead,H2BCodeTail,Status).

compile_head_specbody(Object,SpecTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flconjunct(SpecTerm,L,R),
	!,
	compile_head_specbody(Object,L,WS,LCode,LH2BCodeHead,LH2BCodeTail,S),
	( no_errors_found(S) -> 
	    compile_head_specbody(Object,R,WS,RCode,RH2BCodeHead,RH2BCodeTail,Status),
	    ( no_errors_found(Status) -> 
		conjunct_struct(LCode,RCode,Code),
		conjunct_code([LH2BCodeHead,RH2BCodeHead],H2BCodeHead),
		conjunct_code([LH2BCodeTail,RH2BCodeTail],H2BCodeTail)
	    ; true
	    )
	;
	  Status=S
        ),
	!.

compile_head_specbody(Object,SpecTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flneg(SpecTerm,G,Idx),
	!,
	compile_head_specbody(Object,G,WS,GCode,H2BCodeHead,H2BCodeTail,S),
	!,
	( no_errors_found(S) -> 
	    neg_struct(GCode,Idx,Code,Status)
	; Status = S
	).

compile_head_specbody(Object,SpecTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flmvdattspec(SpecTerm,AttTerm,RefType,VL),
	!,
	compile_head_pathexp(AttTerm,WS,AObj,ACode,AH2BCodeHead,AH2BCodeTail,S),
	( no_errors_found(S) -> 
	    ( VL == [] ->
		mvdattdef_struct(HEADLITERAL,Object,AObj,RefType,SCode),
		attach_workspace(SCode,WS,WSSCode,Status),
		conjunct_struct(ACode,WSSCode,Code),
		H2BCodeHead=AH2BCodeHead,
		H2BCodeTail=AH2BCodeTail
	    ;
	      compile_head_mvd_attspec(Object,AObj,RefType,VL,WS,VCode,VH2BCodeHead,VH2BCodeTail,Status),
	      ( no_errors_found(Status) -> 
	              conjunct_struct(ACode,VCode,Code),
		      conjunct_code([AH2BCodeHead,VH2BCodeHead],H2BCodeHead),
		      conjunct_code([AH2BCodeTail,VH2BCodeTail],H2BCodeTail)
	       
	      ; true
	      )
	    )
        ;
	  Status=S
        ),
	!.

compile_head_specbody(Object,SpecTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flmethspec(SpecTerm,MethTerm),
	!,
	compile_head_pathexp(MethTerm,WS,MethObj,MCode,H2BCodeHead,H2BCodeTail,PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    methspec_struct(HEADLITERAL,Object,MethObj,SCode),
	    attach_workspace(SCode,WS,WSSCode,WSStatus),
	    conjunct_struct(MCode,WSSCode,Code)
	;
	    WSStatus = NO_ERRORS
        ),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.

compile_head_specbody(Object,SpecTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flimethspec(SpecTerm,IMethTerm),
	!,
	compile_head_pathexp(IMethTerm,WS,IMethObj,IMCode,H2BCodeHead,H2BCodeTail,PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    imethspec_struct(HEADLITERAL,Object,IMethObj,SCode),
	    attach_workspace(SCode,WS,WSSCode,WSStatus),
	    conjunct_struct(IMCode,WSSCode,Code)
	;
	    WSStatus = NO_ERRORS
        ),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.

compile_head_specbody(Object,SpecTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_fltranspec(SpecTerm,TranTerm),
	!,
	compile_head_pathexp(TranTerm,WS,TranObj,TCode,H2BCodeHead,H2BCodeTail,PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    transpec_struct(HEADLITERAL,Object,TranObj,SCode),
	    attach_workspace(SCode,WS,WSSCode,WSStatus),
	    conjunct_struct(TCode,WSSCode,Code)
	;
	    WSStatus = NO_ERRORS
        ),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.


%% signatures: =>, *=>, etc.
compile_head_specbody(Object,SpecTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flsigattspec(SpecTerm,AttTerm,RefType,ValTerm),
	!,
	compile_head_pathexp(AttTerm,WS,AttObj,ACode,AH2BCodeHead,AH2BCodeTail,S),
	( no_errors_found(S) -> 
	    (is_flemptyterm(ValTerm) ->
		%% This is SIGDEF: occurs when we have a[b=> ()]
		sigattdef_struct(HEADLITERAL,Object,AttObj,RefType,SCode),
		attach_workspace(SCode,WS,WSSCode,Status),
		conjunct_struct(ACode,WSSCode,Code),
		H2BCodeHead=AH2BCodeHead,
		H2BCodeTail=AH2BCodeTail
	    ;
		compile_head_pathexp(ValTerm,WS,ValObj,VCode,VH2BCodeHead,VH2BCodeTail,PathexpStatus),
		( no_errors_found(PathexpStatus) -> 
		    sigattspec_struct(HEADLITERAL,Object,AttObj,RefType,ValObj,SCode),
		    attach_workspace(SCode,WS,WSSCode,WSStatus),
		    conjunct_code([ACode,VCode,WSSCode],Code),
		    conjunct_code([AH2BCodeHead,VH2BCodeHead],H2BCodeHead),
		    conjunct_code([AH2BCodeTail,VH2BCodeTail],H2BCodeTail)
		;
		    WSStatus = NO_ERRORS
		),
		(WSStatus == NO_ERRORS -> Status = PathexpStatus
		; Status = WSStatus
		)
	    )
	;
	    Status = S
        ),
	!.

compile_head_specbody(Object,SpecTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flsigattconspec(SpecTerm,AttTerm,ConstrTerm,RefType,ValTerm),
	!,
	compile_head_pathexp(AttTerm,WS,AttObj,ACode,AH2BCodeHead,AH2BCodeTail,S),
	( no_errors_found(S) -> 
	    (is_flemptyterm(ValTerm) ->
		%% This is SIGDEF: occurs when we have a[b=> ()]
		sigattdef_struct(HEADLITERAL,Object,AttObj,RefType,SCode),
		attach_workspace(SCode,WS,WSSCode,Status),
		conjunct_struct(ACode,WSSCode,Code),
		H2BCodeHead = AH2BCodeHead,
		H2BCodeTail = AH2BCodeTail
	    ;
		is_flsigconstr(ConstrTerm,Lower,Upper),
		compile_head_pathexplist([Lower,Upper],WS,[OLower,OUpper],CCode,CH2BCodeHead,CH2BCodeTail,S_C),
		( no_errors_found(S_C) -> 
		    compile_head_pathexp(ValTerm,WS,ValObj,VCode,VH2BCodeHead,VH2BCodeTail,PathexpStatus),
		    ( no_errors_found(PathexpStatus) -> 
			sigattspec_struct(HEADLITERAL,Object,AttObj,RefType,ValObj,SCode),
			attach_workspace(SCode,WS,WSSCode,WSStatus1),
			sigattcondef_struct(HEADLITERAL,Object,AttObj,OLower,OUpper,RefType,ValObj,CSCode),
			attach_workspace(CSCode,WS,CWSSCode,WSStatus2),
			(WSStatus1 == NO_ERRORS, WSStatus2 == NO_ERRORS -> Status = PathexpStatus
			; append(WSStatus1,WSStatus2,Status)
			),
			conjunct_code([ACode,CCode,VCode,WSSCode,CWSSCode],Code),
			conjunct_code([AH2BCodeHead,CH2BCodeHead,VH2BCodeHead],H2BCodeHead),
			conjunct_code([AH2BCodeTail,CH2BCodeTail,VH2BCodeTail],H2BCodeTail)
		    ;
			Status = PathexpStatus
		    )
		;
		    Status = S_C
		)
	    )
	;
	    Status = S
        ),
	!.


%% boolean signatures: =>.
compile_head_specbody(Object,SpecTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flboolsig(SpecTerm,AttTerm,_RefType),
	!,
	compile_head_pathexp(AttTerm,WS,AttObj,ACode,H2BCodeHead,H2BCodeTail,PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    boolsig_struct(HEADLITERAL,Object,AttObj,SCode),
	    attach_workspace(SCode,WS,WSCode,WSStatus),
	    conjunct_struct(ACode,WSCode,Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.

%% boolean signatures: *=>.
compile_head_specbody(Object,SpecTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_fliboolsig(SpecTerm,AttTerm,_RefType),
	!,
	compile_head_pathexp(AttTerm,WS,AttObj,ACode,H2BCodeHead,H2BCodeTail,PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    iboolsig_struct(HEADLITERAL,Object,AttObj,SCode),
	    attach_workspace(SCode,WS,WSCode,WSStatus),
	    conjunct_struct(ACode,WSCode,Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.

%% boolean signatures: =>% for transactional method
compile_head_specbody(Object,SpecTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_fltransig(SpecTerm,AttTerm,_RefType),
	!,
	compile_head_pathexp(AttTerm,WS,AttObj,ACode,H2BCodeHead,H2BCodeTail,PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    transig_struct(HEADLITERAL,Object,AttObj,SCode),
	    attach_workspace(SCode,WS,WSCode,WSStatus),
	    conjunct_struct(ACode,WSCode,Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.

%% boolean signatures: *=>% for transactional method
compile_head_specbody(Object,SpecTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flitransig(SpecTerm,AttTerm,_RefType),
	!,
	compile_head_pathexp(AttTerm,WS,AttObj,ACode,H2BCodeHead,H2BCodeTail,PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    itransig_struct(HEADLITERAL,Object,AttObj,SCode),
	    attach_workspace(SCode,WS,WSCode,WSStatus),
	    conjunct_struct(ACode,WSCode,Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.

compile_head_mvd_attspec(_Object,_AttObj,_RefType,[],_WS,NULL,NULL,NULL,[]) :- !.

compile_head_mvd_attspec(Object,AttObj,RefType,[T|L],WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	!,
	compile_head_pathexp(T,WS,TObj,TCode,TH2BCodeHead,TH2BCodeTail,S),
	( no_errors_found(S) -> 
	    mvdattspec_struct(HEADLITERAL,Object,AttObj,RefType,TObj,SCode),
	    attach_workspace(SCode,WS,WSSCode,WSStatus),
	    conjunct_struct(TCode,WSSCode,TSCode),
	    compile_head_mvd_attspec(Object,AttObj,RefType,L,WS,LCode,LH2BCodeHead,LH2BCodeTail,AttspecStatus),
	    append(AttspecStatus,WSStatus,Status),
	    ( no_errors_found(Status) -> 
		conjunct_struct(TSCode,LCode,Code),
		conjunct_code([TH2BCodeHead,LH2BCodeHead],H2BCodeHead),
		conjunct_code([TH2BCodeTail,LH2BCodeTail],H2BCodeTail)
	    ; true
	    )
	;
	  Status=S
        ),
	!.


/****************************************************************************
  compile_head_objeql(+Obj1,+Obj2,+Workspace,-Code,-H2BCodeHead,-H2BCodeTail,-Status)

  H2BCodeHead - code passed from head to body, which is supposed to be
                prepended to the code of the body
  H2BCodeTail - code passed from head to body, which is supposed to be
                appended to the code of the body
****************************************************************************/
compile_head_objeql(Obj1,Obj2,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	compile_head_pathexplist([Obj1,Obj2],WS,[O1,O2],OCode,H2BCodeHead,H2BCodeTail,PathexpStatus),
	( no_errors_found(PathexpStatus) -> 
	    objeql_struct(HEADLITERAL,O1,O2,OECode),
	    attach_workspace(OECode,WS,WSCode,WSStatus),
	    conjunct_struct(OCode,WSCode,Code)
	;
	    WSStatus = NO_ERRORS
	),
	(WSStatus == NO_ERRORS -> Status = PathexpStatus
	; Status = WSStatus
	),
	!.

/****************************************************************************
  compile_head_neg(+PosPart,+WS,+Idx,-Code,-H2BCodeHead,-H2BCodeTail,-Status)

  H2BCodeHead - code passed from head to body, which is supposed to be
                prepended to the code of the body
  H2BCodeTail - code passed from head to body, which is supposed to be
                appended to the tail of the code of the body
****************************************************************************/
compile_head_neg(PosPart,WS,Idx,Code,H2BCodeHead,H2BCodeTail,Status) :-
	compile_head_literal(PosPart,WS,PosCode,H2BCodeHead,H2BCodeTail,S),
	( no_errors_found(S) -> 
	    head_neg_struct(PosCode,Idx,NegCode,Status1),
	    attach_workspace(NegCode,WS,Code,WSStatus),
	    (WSStatus == NO_ERRORS -> append(S,Status1,Status)
	    ; append(Status1,WSStatus,Status)
	    )
	; Status = S
	),
	!.


/****************************************************************************
  compile_insert(+Op,+List,+Cond,-Code,-Status)
****************************************************************************/
compile_insert(Op,List,Cond,Code,Status) :-
	compile_insert_literals(List,CodeList,S),
	( no_errors_found(S) -> 
	    compile_body(Cond,CondCode,Status1),
	    ( no_errors_found(Status1) -> 
		list_struct(CodeList,[],ListCode),
		insert_struct(Op,ListCode,CondCode,Code)
	    ;
	      true
	    ),
	    append(S,Status1,Status)
	;
	  Status=S
        ),
	!.

/****************************************************************************
  compile_insert(+Op,+List,-Code,Status)
****************************************************************************/
compile_insert(Op,List,Code,Status) :-
	compile_insert_literals(List,CodeList,Status),
	( no_errors_found(Status) -> 
	    list_struct(CodeList,[],ListCode),
	    insert_struct(Op,ListCode,Code)
	;
	  true
        ),
	!.


/****************************************************************************
  compile_insert_literals(+List,-DBCodeList,-Status)
****************************************************************************/
compile_insert_literals(List,DBCodeList,Status) :-
	set_context(compiling_update_literals),
	compile_insert_litlist(List,Code,Status),
	compile_conjunct2list(Code,CodeList),
	( no_errors_found(Status) -> 
	    compile_dbupdate_list(CodeList,DBCodeList)
	;
	    true
	),
	!,
	clear_context(compiling_update_literals).


/****************************************************************************
  compile_insert_litlist(+List,-Code,-Status)

  Code is the conjunctions of atoms to be inserted.
****************************************************************************/
compile_insert_litlist([],NULL,[]) :- !.

compile_insert_litlist([H|T],Code,Status) :-
	is_flupdaterule(H,Op,List),
	!,
	is_flatom(Op,OpAtom,_Index),
	List = [R],
	compile_dynrule(OpAtom,R,HCode,S),
	( no_errors_found(S) -> 
	    compile_insert_litlist(T,TCode,Status1),
	    ( no_errors_found(Status1) -> conjunct_struct(HCode,TCode,Code)
	    ; true
	    ),
	    append(S,Status1,Status)
	;
	  Status=S
	),
	!.

compile_insert_litlist([HWS|T],Code,Status) :-
	%% regular fact. may have path expression inside
	detach_flworkspace(HWS,H,WS),
	compile_head_literal(H,WS,HeadCode1,H2BCodeHead1,H2BCodeTail1,S),
	!,
	( no_errors_found(S) -> 
	    ( H2BCodeHead1==NULL, H2BCodeTail1==NULL
	    ->
		compile_insert_litlist(T,TCode,S2),
		( no_errors_found(S2) -> 
		   conjunct_struct(HeadCode1,TCode,Code)
		; true
		),
		append(S,S2,Status)
	    ;
		%% Head literal contains a path expr, so it becomes a rule.
		%% Treat it as a dynamically inserted rule.

		%% Since this rule came from a dynamic fact that contains
		%% a path expression, the annotation code is empty.
		%% The last FL_TRUE is the defeasible condition to be
		%% attached to rule bodies.
		approx_flindex(H,RuleIdx),
		compile_descriptor_list([]-RuleIdx,FL_DESCRMODE_DYNRULE,DescrIdCode,DescrVarsTerm,DefaultMetaFactDiffList,_),
		set_context(compile_with_var_module),
		set_context(compiling_dynrule(DescrIdCode)),
		compile_head_literal(H,WS,HeadCode,H2BCodeHead,H2BCodeTail,S),
		compile_conjunct2list(HeadCode,HCode),
		new_prvariable(NO_INDEX,HVL),
		new_prvariable(NO_INDEX,BVL),
		list_struct(HCode,[],HeadCodeList),
		conjunct_code([H2BCodeHead,H2BCodeTail],H2BCode),
		%% only the vars in the fact-term are to be checked
		delay_literals_checking_code([],H,DescrVarsTerm,DelayCheckCode),
		construct_rule_enabling_test(DescrIdCode,FL_DESCRMODE_DYNRULE,RuleEnablerTest,FileName),
		PreBody = RuleEnablerTest,
		PostBody = DelayCheckCode,
		dynrule_struct(HeadCodeList,H2BCode,HVL,BVL,PreBody,PostBody,
			       (DescrIdCode,FileName,
				   DescrVarsTerm,
				   -1, %% RuleNum
				   DefaultMetaFactDiffList,
				   FL_TRUE),  %% default defeat condition
			       HDynruleCode),
		collect_name_var_pairs(H,HeadVars),
		list_struct(HeadVars,[],HVLValue),
		report_dynrule_varlist(HVL,HVLValue),
		collect_name_var_pairs([],BodyVars),
		list_struct(BodyVars,[],BVLValue),
		report_dynrule_varlist(BVL,BVLValue),
		clear_context(compiling_dynrule(DescrIdCode)),
		clear_context(compile_with_var_module),
		compile_insert_litlist(T,TCode,S2),
		( no_errors_found(S2) -> 
		    conjunct_struct(HDynruleCode,TCode,Code)
		; true
		),
		append(S,S2,Status)
	    )
	;
	    Status=S
	),
	!.


/****************************************************************************
  compile_delete(+Op,+List,+Cond,-Code,-Status)

  for delete operations with a condition.
****************************************************************************/
compile_delete(Op,List,Cond,Code,Status) :-
	compile_delete_literals(List,CodeList,S),
	( no_errors_found(S) -> 
	    compile_body(Cond,CondCode,Status1),
	    ( no_errors_found(Status1) -> 
		list_struct(CodeList,[],ListCode),
		delete_struct(Op,ListCode,CondCode,Code)
	    ;
	      true
	    ),
	    append(S,Status1,Status)
	;
	  Status=S
        ),
	!.


/****************************************************************************
  compile_delete(+Op,+List,-Code,-Status)

  for delete operations without a condition.
****************************************************************************/
compile_delete(Op,List,Code,Status) :-
	compile_delete_literals(List,CodeList,Status),
	!,
	( no_errors_found(Status) -> 
	    list_struct(CodeList,[],ListCode),
	    delete_struct(Op,ListCode,Code)
	;
	  true
        ).


/****************************************************************************
  compile_delete_literals(+List,-DBCodeList,-Status)
****************************************************************************/
compile_delete_literals(List,DBCodeList,Status) :-
	set_context(compiling_update_literals),
	compile_delete_litlist(List,CodeList,Status),
	( no_errors_found(Status) -> 
	    compile_dbupdate_list(CodeList,DBCodeList)
	;
	    true
	),
	!,
	clear_context(compiling_update_literals).


/****************************************************************************
  compile_delete_litlist(+List,-CodeList,-Status)
****************************************************************************/
compile_delete_litlist([],[],[]) :- !.

compile_delete_litlist([H|T],CodeList,Status) :-
	%% When delete list contains an object equality definition, the compiler
	%% will prepare to load the basic equality trailer, unless it is
	%% overridden by an explicity directive.
	is_flobjeql(H,O1,O2),
	!,
	compile_body_objeql(O1,O2,FL_THISMODULE,OidCode,SpecCode,S),
	conjunct_code([OidCode,SpecCode],HCode),
	approx_flindex(O1,Idx),
	report_option(FLOBJEQLDEF,Idx),
	( no_errors_found(S) -> 
	    compile_conjunct2list(HCode,HCodeList),
	    compile_delete_litlist(T,TCodeList,Status),
	    ( no_errors_found(Status) -> 
		append(HCodeList,TCodeList,CodeList)
	    ; true
	    )
	;
	  Status=S
        ),
	!.

compile_delete_litlist([H|T],CodeList,Status) :-
	is_flupdaterule(H,Op,List),
	!,
	is_flatom(Op,OpAtom,_Index),
	List = [R],
	compile_dynrule(OpAtom,R,HCode,S),
	( no_errors_found(S) -> 
	    compile_delete_litlist(T,TCodeList,Status),
	    ( no_errors_found(Status) -> 
		CodeList = [HCode|TCodeList]
	    ; true
	    )
	;
	  Status=S
	),
	!.

compile_delete_litlist([HWS|T],CodeList,Status) :-
	%% Call compile_body_literal because path expressions should be
	%% compiled into queries.
        set_context(compile_delete),
	detach_flworkspace(HWS,H,WS),
	compile_body_literal(H,WS,OidCode,SpecCode,[],S),
	conjunct_code([OidCode,SpecCode],HCode),
        clear_context(compile_delete),
	( no_errors_found(S) -> 
	    compile_conjunct2list(HCode,HCodeList),
	    compile_delete_litlist(T,TCodeList,Status),
	    ( no_errors_found(Status) -> 
		append(HCodeList,TCodeList,CodeList)
	    ; true
	    )
	;
	  Status=S
        ),
	!.


/****************************************************************************
  compile_dbupdate_list(+CodeList,-DBCodeList)

  This predicate processes the list of literals in a DB update. For each
  literal, it tries to add the name of the storage trie for the module.

  Note: a DB update can only update a Flora user module or itself. If a
        Flora system module allows update, it must provide an update interface.
****************************************************************************/
compile_dbupdate_list([],[]) :- !.

compile_dbupdate_list([C|CL],[C|DBCodeList]) :-
	( is_prvariable(C)
        ; is_florasyslib_struct(C,_,_,_,_)
	),
	!,
	compile_dbupdate_list(CL,DBCodeList).

compile_dbupdate_list([C|CL],[DBCode|DBCodeList]) :-
	is_prdynrule(C,_Head,_Body,_HeadVars,_BodyVars,_PreBody,_PostBody,_Descriptor),
	!,
	%% Already compiled, don't tack on FLSYSDBUPDATE
	DBCode = C,
	compile_dbupdate_list(CL,DBCodeList).

compile_dbupdate_list([C|CL],[DBCode|DBCodeList]) :-
	( workspace_struct(_P,WS,C) ->
	    %% The name of the module is known.
	    storage_struct(WS,SCode)
	;
	    thisstorage_struct(fdb,SCode),
	    thismodule_struct(WS)
	),
	atomobj_struct(FLSYSDBUPDATE,FCode),
	prologterm_struct(FCode,3,[C,SCode,WS],DBCode),
	!,
	compile_dbupdate_list(CL,DBCodeList).

/****************************************************************************
  compile_updaterule(+Op,+List,-Code,-Status)
****************************************************************************/
compile_updaterule(Op,List,Code,Status) :-
	is_flatom(Op,OpAtom,Index),
	compile_dynrule_list(OpAtom,List,CodeList,Status),
	!,
	( no_errors_found(Status) -> 
	    list_struct(CodeList,[],ListCode),
	    updaterule_syslib(OpAtom,UpdateruleLib),
	    florasyslib_struct(Index,UpdateruleLib,1,[ListCode],Code)
	;
	    true
        ).

%% compile_dynrule_list(+Op,+RuleList,-RuleListCode,-Status)
compile_dynrule_list(_Op,[],[],[]) :- !.
compile_dynrule_list(Op,[H|L],[HCode|LCode],Status) :-
	compile_dynrule(Op,H,HCode,S),
	!,
	( no_errors_found(S) -> 
	    compile_dynrule_list(Op,L,LCode,S1),
	    append(S,S1,Status)
	; S = Status
	).

%% compile single dynamic rule
%% compile_dynrule(+Op,+R,-RCode,-Status)
compile_dynrule(Op,R,RCode,Status) :-
	is_flruleworkspace(R,Rule,WS),
	!,
	workspaceterm_struct(WS,WSTerm),
	set_context(dynruleworkspace(WSTerm)),
	compile_dynrule(Op,Rule,RCode,Status),
	!,
	clear_contextall(dynruleworkspace(_)).

compile_dynrule(_Op,R,RCode,Status) :-
	is_flvariable(R,Name,Index),
	varobj_struct(Name,Index,RCode),
	Status = NO_ERRORS.

%% Note: prolog-headed rules (declared as :- prolog), including sensors,
%%       are not allowed to be dynamic in FLORA-2.
compile_dynrule(Op,R,RCode,Status) :-
	is_fldynrule(R,Head,Body,DescriptorList),
	approx_flindex(R,RuleIdx),
	%% If delete op: default rule id descriptor should be Var
	%% and shouldn't generate the rule enabling metafact.
	%% In this case we use the same representation as in clause{...},
	%% whence the FL_DESCRMODE_CLAUSE mode in compile_descriptor_list/6
	(is_fldeleteruleop(Op) -> DescrMode = FL_DESCRMODE_CLAUSE
	; is_fllatent_query(Body,_) -> DescrMode = FL_DESCRMODE_LATENT_DYNQUERY
	; DescrMode = FL_DESCRMODE_DYNRULE
	),
	compile_descriptor_list(DescriptorList-RuleIdx,DescrMode,DescrIdCode,DescrVarsTerm,MetaFactDiffList,DescriptorStatus),

	( no_errors_found(DescriptorStatus) -> 
	    (is_fllatent_query(Body,RealBody) ->
		compile_dyn_latent_query(Op,DescrIdCode,MetaFactDiffList,RealBody,RCode,Status)
	    ; compile_dynrule_main(Op,Head,Body,DescrIdCode,DescrVarsTerm,MetaFactDiffList,RCode,Status)
	    )
	;
	    Status = DescriptorStatus
	).


%% compile_dyn_ic(+Op,+DescrIdCode,+MetaFactDiffList,+Body,-LatentQueryDiffList,-Status)
%% op: delete/insert/insertrule/etc.
compile_dyn_latent_query(Op,DescrIdCode,MetaFactDiffList,Body,LatentQuerySigCode,Status) :-
	set_context(compile_with_var_module),
	set_context(compiling_dynrule(DescrIdCode)),
	compile_body_top(Body,BCode,Status),
	( no_errors_found(Status) -> 
	    collect_prdatatypevars(BCode,DTVarsCode),
	    append(DTVarsCode,[BCode],BCode1),
	    conjunct_code(BCode1,LatentQueryBodyCode),
	    thismodule_struct(ThisMod),
	    %% code to bind the Caller variable to the calling module
	    caller_binding_code(ThisMod,CallerBindingCode),
	    construct_rule_enabling_test(DescrIdCode,FL_DESCRMODE_LATENT_DYNQUERY,LatentQueryEnablerTest,_),
	    conjunct_code([CallerBindingCode,LatentQueryEnablerTest],PreLatentQueryCode),
	    get_current_compile_file_for_descriptor(File,FL_DESCRMODE_LATENT_DYNQUERY),
	    (approx_prindex(DescrIdCode,Idx), Idx > 0 -> true
	    ; approx_prindex(Body,Idx)
	    ),
	    flora_token_rulenum(Idx,RuleNum), %% rulenum within file
	    MetaFactDiffList = MetaFactList - [],
	    list_struct(MetaFactList,[],MetaFactCode),
	    (is_fldeleteruleop(Op) ->
		florasyslib_struct(FLLIBDELQUERYSIG,5,[DescrIdCode,File,ThisMod,MetaFactCode,LatentQueryBodyCode],LatentQuerySigCode)
	    ; florasyslib_struct(FLLIBINSQUERYSIG,7,[DescrIdCode,File,ThisMod,RuleNum,MetaFactCode,PreLatentQueryCode,LatentQueryBodyCode],LatentQuerySigCode)
	    )
	;
	  true
	),
	clear_context(compiling_dynrule(DescrIdCode)),
	clear_context(compile_with_var_module),
	!.

%% main workhorse that compiles dynamic rules
%% compile_dynrule_main(+Op,+Head,+Body,+DescrIdCode,+DescrVarsTerm,+MetaFactDiffList,-RuleCode,-Status) :-
compile_dynrule_main(Op,Head,Body,DescrIdCode,DescrVarsTerm,MetaFactDiffList,RuleCode,Status) :-
        set_context(compile_with_var_module),
	set_context(compiling_dynrule(DescrIdCode)),
	compile_head_top(Head,HeadCode1,H2BCodeHead,H2BCodeTail,HeadStatusPre),
        new_prvariable(NO_INDEX,HVL), % head var list
	compile_conjunct2list(HeadCode1,HeadCode2),
	remove_empty_list(HeadCode2,HeadCode),
	%% no :- prolog predicates in dynamic rule heads
	(has_prologlit(HeadCode,IdxH)
	-> compiling_error(IdxH,NO_PROLOG_IN_DYNRULE_HEAD,DelayStatus1),
	    DelayStatus = [DelayStatus1]
	; DelayStatus = NO_ERRORS
	),
	append(HeadStatusPre,DelayStatus,HeadStatus),
	( no_errors_found(HeadStatus) -> 
	    compile_body_top(Body,BodyCode1,BodyStatus),
	    ( no_errors_found(BodyStatus) -> 
	        collect_prdatatypevars([HeadCode,BodyCode1],DTVarsCode),
		%% TODO: get rid of this append!!!
		append(DTVarsCode,[H2BCodeHead,BodyCode1,H2BCodeTail],BCodeList),
		conjunct_code(BCodeList,PureBodyCode),

	        list_struct(HeadCode,[],HeadCodeList),
                new_prvariable(NO_INDEX,BVL), % body var list
		construct_defeasible_condition_for_signature_or_dynrule(HeadCode,DescrIdCode,DescrVarsTerm,DefeatCondCode),
		%% Note: Head cannot contain sensors, so no need to check
		%% multi-headed rules if sensors mix with non-sensors
		(has_context(compiling_udf_definition)
		-> RuleEnablerTest = true, FileName = NULL
		; construct_rule_enabling_test(DescrIdCode,FL_DESCRMODE_DYNRULE,RuleEnablerTest,FileName)
		),
		delay_literals_checking_code(Head,Body,DescrVarsTerm,DelayCheckCode),
		PreBody = RuleEnablerTest,
		PostBody = DelayCheckCode,
		dynrule_struct(HeadCodeList,PureBodyCode,HVL,BVL,
			       PreBody,PostBody,
			       (DescrIdCode,FileName,
				   DescrVarsTerm,
				   -1, %% RuleNum,
				   MetaFactDiffList,DefeatCondCode),
			       RuleCode),
		( is_fldeleteruleop(Op)
		->  true
		;   collect_name_var_pairs(Head,HeadVars),
		    list_struct(HeadVars,[],HVLValue),
		    report_dynrule_varlist(HVL,HVLValue),
		    collect_name_var_pairs(Body,BodyVars),
		    list_struct(BodyVars,[],BVLValue),
		    report_dynrule_varlist(BVL,BVLValue)
		),
		flatten([HeadStatus,BodyStatus],Status)
	    ;
		flatten([HeadStatus,BodyStatus],Status)
	    )
	;
	    Status=HeadStatus
	),
	!,
	clear_context(compiling_dynrule(DescrIdCode)),
        clear_context(compile_with_var_module).

remove_empty_list([],[]) :- !.
remove_empty_list([[]|L],NL) :- 
	!,
	remove_empty_list(L,NL).
remove_empty_list([H|L],[H|NL]) :- 
	remove_empty_list(L,NL).

%% remove all occurrences of Elt from List.
%% this is a stop clause for var-terminated lists
remove_all(_Elt,Tail,Tail) :-
	var(Tail),
	!.
remove_all(_Elt,[],[]) :- !.
remove_all(Elt,[Elt|List],List2) :-
	!,
	remove_all(Elt,List,List2).
remove_all(Elt,[H|List],[H|List2]) :-
	remove_all(Elt,List,List2).


/****************************************************************************
             compile_stop_delay(VarList,Code)
     !!{...} and !! - immediate execution of delayed literals
****************************************************************************/
compile_stop_delay(_VarList,Idx,_Code,[Err]) :-
	has_context(goal_reification),
	!,
	compiling_error(Idx,NO_IMMEDIATE_EXECUTION_OF_DELAY,Err).
compile_stop_delay(VarList,_Idx,Code,Status) :-
	(var(VarList)
	->
	    (has_context(compiling_body(BVarList)) -> true ; BVarList = []),
	    (has_context(compiling_head(HVarList)) -> true ; HVarList = []),
	    append(HVarList,BVarList,VarList)
	; true
	),
	compile_body_pathexplist(VarList,FL_THISMODULE,VarListCode,_,_,[],Status),
	list_struct(VarListCode,[],ArgsCode),
	list_struct([],[],EmptyListCode), %% empty list
	prologterm_struct(FLORA_DELAY_CHECKER,2,[ArgsCode,EmptyListCode],Code).


/****************************************************************************
             Table maintenance predicates
     refresh{...} removes the corresponding calls from Prolog tables.
****************************************************************************/
compile_refresh(List,Code,Status) :-
	compile_delete_litlist(List,CodeList,Status),
	!,
	( no_errors_found(Status) -> 
	    list_struct(CodeList,[],ListCode),
	    table_refresh_struct(ListCode,Code)
	;
	  true
        ).

/****************************************************************************
  compile_clause(+Mode,+HeadList,+Body,-Code,-Status)
  Mode determines which rules to search for: static only, dynamic only, etc.
****************************************************************************/
compile_clause(Descriptor,Mode,HeadList,Body,Code,Status) :-
	approx_flindex(HeadList,ClauseIdx),
	compile_descriptor_list(Descriptor-ClauseIdx,FL_DESCRMODE_CLAUSE,DescrIdCode,
				DescrVarTerm,
				MetaFactDiffList,Descr_Status),
	( no_errors_found(Descr_Status) -> 
	    (Mode == NULL -> ModeCode = Mode
	    ;
		compile_atomvar(Mode,ModeCode)
	    ),
	    set_context(compiling_clause_primitive),
	    set_context(compile_with_var_module),
	    set_context(compiling_headliteral),
	    compile_delete_litlist(HeadList,HLC,Head_Status),
	    clear_context(compiling_headliteral),
	    ( no_errors_found(Head_Status) -> 
		list_struct(HLC,[],HeadListCode),
		compile_body_top(Body,BodyCode,Status),
		( no_errors_found(Status) -> 
		    MetaFactDiffList = MetaFactList - [],
		    conjunct_code(MetaFactList,MetaFactsCode),
		    clause_struct(DescrIdCode,DescrVarTerm,MetaFactsCode,
				  ModeCode,HeadListCode,BodyCode,Code)
		;
		    true
		)
	    ;
		Status = Head_Status
	    )
	;
	    Status = Descr_Status
        ),
	!,
        clear_context(compile_with_var_module),
	set_context(compiling_clause_primitive).

/****************************************************************************
	    compile_callmetafacts(+MetaFacts,-Code,-Status)
****************************************************************************/
compile_callmetafacts(MetaFacts,Code,Status) :-
	compile_body(MetaFacts,MetaCode,Status),
	generate_prolog_liblit(call_metafacts,1,[MetaCode],flrdescriptor_support,Code).

/****************************************************************************
    Error handling: catch{Goal,Err,Handler}
****************************************************************************/
compile_catch(Goal,Err,Handler,Code,Status) :-
	compile_body(Goal,GoalCode,GoalStatus),
	( no_errors_found(GoalStatus) -> 
	    compile_body_pathexp(Err,FL_THISMODULE,ErrCode,_OidCode,_ObjSpec,[],ErrStatus),
	    ( no_errors_found(ErrStatus) -> 
		compile_body(Handler,HandlerCode,Status),
		( no_errors_found(Status) -> 
		    catch_struct(GoalCode,ErrCode,HandlerCode,Code)
		; true
		)
	    ; Status = ErrStatus
	    )
	; Status = GoalStatus
	),
	!.

/****************************************************************************
     throw{Err}
****************************************************************************/
compile_throw(Err,Code,Status) :-
	compile_body_pathexp(Err,FL_THISMODULE,ErrCode,_OidCode,_ObjSpec,[],Status),
	!,
	( no_errors_found(Status) -> throw_struct(ErrCode,Code)
	; true
	).


/****************************************************************************
     p2h{Prolog,Hilog}
****************************************************************************/
compile_p2h(Prolog,Hilog,Code,Status) :-
	compile_body_pathexp(Prolog,FL_THISMODULE,PCode,_POidCode,_PObjSpec,[],PStatus),
	( no_errors_found(PStatus) -> 
	    compile_body_pathexp(Hilog,FL_THISMODULE,HCode,_HOidCode,_HObjSpec,[],Status),
	    ( no_errors_found(Status) -> p2h_struct(PCode,HCode,Code)
	    ; true
	    )
	; Status = PStatus
	),
	!.


/****************************************************************************
  compile_exec_directive(+DirectList,+WS,-Code,-Status)
  compile_execdirect_list(+DirectList,+WS,-DirectCodeList,-Status)
****************************************************************************/
compile_exec_directive(DirectList,WS,Code,Status) :-
	compile_execdirect_list(DirectList,WS,DirectCodeList,Status),
	conjunct_code(DirectCodeList,Code).


compile_execdirect_list([],_,[],[]) :- !.

compile_execdirect_list([D|L],WS,[DCode|LCode],Status) :-
	compile_execdirect(D,WS,DCode,S1),
	( no_errors_found(S1) -> 
	    compile_execdirect_list(L,WS,LCode,Status)
	; Status = S1
	).


/****************************************************************************
  compile_execdirect(+Direct,+WS,-Code)
****************************************************************************/
compile_execdirect(DirectTerm,_WS,Code,Status) :-
        %%to compile the export directive
	is_flexport_list(DirectTerm,Term),
        !,
	compile_export(Term,Code,Status).

compile_execdirect(DirectTerm,WS,Code,Status) :-
	(WS == FL_THISMODULE -> thismodule_struct(Mod)
	; compile_atomvar(WS,Mod)
	),
	( is_flopdef(DirectTerm,Precedence,Associativity,Op) ->
	    florasyslib_struct(FLLIBSHDIRECT,5,[FL_OP,Mod,Precedence,Associativity,Op],Code),
	    Status = NO_ERRORS

	; is_flsemantics(DirectTerm,OptionsList) ->
	    is_fllist(OptionsList,L,T,I),
	    %% compile_body_list_obj won't break here: parser checks everything
	    compile_body_list_obj(L,T,I,WS,OptionListCode,_OidCode,_Code,[],Status),
	    thismodule_struct(ThisModuleName),
	    florasyslib_struct(FLLIBSEMANTICS,3,[ThisModuleName,OptionListCode,Mod],Code)

	; is_flsetsemantics(DirectTerm,OptionsList) ->
	    is_fllist(OptionsList,L,T,I),
	    %% compile_body_list_obj won't break here: parser checks everything
	    compile_body_list_obj(L,T,I,WS,OptionListCode,_OidCode,_Code,[],Status),
	    thismodule_struct(ThisModuleName),
	    florasyslib_struct(FLLIBSETSEMANTICS,3,[ThisModuleName,OptionListCode,Mod],Code)

	; is_flindex(DirectTerm,A,P) ->
	    %% transactional numbers are used only in :- index %arity-argument
            ( transactionalnumobj_struct(A,ACode)
	    ; is_fltransactionalvariable(A,AN,AI),
		transactionalvar_struct(AN,AI,ACode)
	    ; numobj_struct(A,ACode)
	    ; is_flvariable(A,AN,AI), varobj_struct(AN,AI,ACode)
	    ),
	    (numobj_struct(P,PCode)
	    ; is_flvariable(P,PN,PI), varobj_struct(PN,PI,PCode)
	    ),
            florasyslib_struct(FLLIBSHDIRECT,4,[FL_INDEX,Mod,ACode,PCode],Code),
	    Status = NO_ERRORS

	; is_flsensordirect(DirectTerm,SensCall,DelayCond) ->
	    compile_defsensor_direct(SensCall,DelayCond,Direct,Status),
	    directive_struct(Direct,Code)

	%% This runtime usesensor directive enables to use sensors in the shell
	%% This directive can be called from within a file or interactively.
	; is_flusesensordirect(DirectTerm,PairList,Idx) ->
	    verify_symbol_context_pairlist(PairList,Idx, USE_SENSOR_SYMBOL,
					   NONTRANSACTIONAL_SYMBOL,Status),
	    maplist(strip_pairlist_index(_,_),PairList,PairListSansIdx),
	    verbatim_struct(PairListSansIdx,PairListCode),
	    thismodule_struct(ThisMod),
	    florasyslib_struct(FLLIBRECORDSENSORS,2,[ThisMod,PairListCode],Code),
	    report_option(FLSYSLIB(FLLIBRECORDSENSORS),NO_INDEX)

	%% Run-time useudf directive. It defines the use of a function
	%% **only** in the shell and only for the module main.
	; is_flusefunctiondirect(DirectTerm,PairList,Idx) ->
	    verify_symbol_context_pairlist(PairList,Idx, USE_UDF_SYMBOL,
					   NONTRANSACTIONAL_SYMBOL,Status1),
	    maplist(usefunction_option(_,_),PairList,PermaOptions),
	    set_permaoptions(PermaOptions),
	    (compiling_flrshell_command -> Status = Status1
	    ;
		compiling_error(Idx,ERROR_USEFUNCTION_IN_SHELL_ONLY,Err),
		Status = [Err|Status1]
	    ),
	    Code = NULL

	/*
	%% Executable :- prolog and :- table directives are not allowed!!!
	%% They are used inside files/documents for optimization only
	%% We consider them non-logical and users are not allowed to call
	%% them directly (sensors are also prolog, but are different in
	%% this respect)
	;  is_flprolog_directive(DirectTerm,PairList,Idx) ->
	    ....
	;  is_fltabledirect(DirectTerm,PredSpecList,_Idx) ->
	    ....
	*/

	;   %% Ensure that prefix definition is recorded in the current module
	    %% to be used in other modules. For instance, if somebody make a
	    %% reference to prefix#local@module
	    is_flprefixdef(DirectTerm,PrefixName,PrefixExpansion) ->
	    florasyslib_struct(FLLIBPREFIXDEF,3,[Mod,PrefixName,PrefixExpansion],Code),
	    Status = NO_ERRORS

	),
	!.


/*******************************************************************************
compile_delayed_literal(+Op,+Args,-SpecCode,-OidCode,-BodyFrontList,-Status)
compile_delayed_literal(+Op,+Args,+Mod,-SpecCode,-OidCode,-BodyFrontList,-Status)
  Args are expected to be FLLIST
*******************************************************************************/
compile_delayed_literal(Op,Args,SpecCode,OidCode,BodyFrontList,Status) :-
	is_flatom(Op,_,Index),
	code_line_and_file_by_index(Index,Line,CurrFileName),
	%% Normally, CurrFileName is an atom. But can be flvar, if reification
	(atom(CurrFileName)
	-> is_flatom(CurrFileParserObj,CurrFileName,NO_INDEX)
	; %% assume it is flvar
	    CurrFileParserObj = CurrFileName
	),
	compile_prlgterm(FLLIBDELAYEDLITERAL,4,[Op,CurrFileParserObj,Line,Args],
			 SpecCode,OidCode,_ACode,BodyFrontList,Status).
compile_delayed_literal(Op,Args,Mod,SpecCode,OidCode,BodyFrontList,Status) :-
	is_flatom(Op,_,Index),
	code_line_and_file_by_index(Index,Line,CurrFileName),
	%% Normally, CurrFileName is an atom. But can be flvar, if reification
	(atom(CurrFileName)
	-> is_flatom(CurrFileParserObj,CurrFileName,NO_INDEX)
	; %% assume it is flvar
	    CurrFileParserObj = CurrFileName
	),
	is_flplib(OpModTerm,Op,Mod),
	compile_prlgterm(FLLIBDELAYEDLITERAL,4,[OpModTerm,CurrFileParserObj,Line,Args],
			 SpecCode,OidCode,_ACode,BodyFrontList,Status).


/*******************************************************************************
%% Used for reading FLORA terms (including reified formulas) from within
%% FLORA-2 programs
	flora_compile_pathexp(+ParserTerm,-Code,-Status)
*******************************************************************************/
flora_compile_pathexp(ParserTerm,Code,Status) :-
	compile_body_pathexp(ParserTerm,FL_THISMODULE,ObjectCode,OidCode,SpecCode,[],Status1),
	!,
	( no_errors_found(Status1), (OidCode \= NULL ; SpecCode \= NULL) -> 
	    %%conjunct_code([OidCode,SpecCode],Code)
	    approx_flindex(ParserTerm,Index),
	    compiling_error(Index,READING_NONREIFIED_MOLECULE, S),
	    Status = [S|Status1]
	;
	    Code = ObjectCode, Status = Status1
	).


%% list of data type literals
compile_datatype_list([],[],[]) :- !.
compile_datatype_list([H|Tail],[HCode|TailCode],Status) :-
	(integer(H)
	-> HCode = H, S1 = NO_ERRORS %% list of characters inside DATATYPE
	;
	    compile_body_pathexp(H,FL_THISMODULE,HCode,_,_,[],S1)
	),
	( no_errors_found(S1) -> 
	   compile_datatype_list(Tail,TailCode,Status)
	;
	    Status=S1
	),
	!.

%% Check if Goal is negatable by NEG (explicit negation)
%% Only F-logic atoms (except the derived ones) and HiLog
%% predicates are negatable.
is_head_neg_negatable_literal(PRATOMLIT(_,_)) :- !.
is_head_neg_negatable_literal(PRTERMLIT(_,_,_)) :- !.
is_head_neg_negatable_literal(PREXISTS(_,_)) :- !.
is_head_neg_negatable_literal(PRISA(_,_,_)) :- !.
is_head_neg_negatable_literal(PRSUB(_,_,_)) :- !.
is_head_neg_negatable_literal(PRMVD(_,_,_,_)) :- !.
is_head_neg_negatable_literal(PRIMVD(_,_,_,_)) :- !.
is_head_neg_negatable_literal(PRMVDDEF(_,_,_)) :- !.
is_head_neg_negatable_literal(PRIMVDDEF(_,_,_)) :- !.
is_head_neg_negatable_literal(PRMETH(_,_,_)) :- !.
is_head_neg_negatable_literal(PRIMETH(_,_,_)) :- !.
is_head_neg_negatable_literal(PROBJEQL(_,_,_)) :- !.
is_head_neg_negatable_literal(PRMVDSIG(_,_,_,_)) :- !.
is_head_neg_negatable_literal(PRIMVDSIG(_,_,_,_)) :- !.
is_head_neg_negatable_literal(PRBOOLSIG(_,_,_)) :- !.
is_head_neg_negatable_literal(PRIBOOLSIG(_,_,_)) :- !.
is_head_neg_negatable_literal(PRMVDSIGDEF(_,_,_)) :- !.
is_head_neg_negatable_literal(PRIMVDSIGDEF(_,_,_)) :- !.

is_head_neg_negatable_literal(X) :-
	is_prologterm(X,Struct,Arity,_Args),
	is_modularized_pratom(Struct,Atom,_),
	Arity1 is Arity-1,
	flora_negatable_prlgdef(Atom,Arity1,_),
	!.

is_body_neg_negatable_literal(X) :- is_head_neg_negatable_literal(X), !.
is_body_neg_negatable_literal(X) :-
	workspace_struct(L,_WS,X),
	is_head_neg_negatable_literal(L),
	!.
is_body_neg_negatable_literal(X) :-
	prologterm_atom_arity(X,Atm,Arity1),
	%% modularized prolog predicates have an extra caller argument
	Arity is Arity1-1,
	flora_negatable_prlgdef(Atm,Arity,_),
	!.
is_body_neg_negatable_literal(X) :-
	(is_florasyslib_struct(X, _I,FLLIBMODLIT,_N,Args)
	; is_florasyslib_struct(X,_I,FLLIBMODOBJ,_N,Args)
	; is_florasyslib_struct(X, _I,FLNEGLIBMODLIT,_N,Args)
	; is_florasyslib_struct(X,_I,FLNEGLIBMODOBJ,_N,Args)
	),
	!,
	Args = [P|_],
	is_body_neg_negatable_literal(P).
is_body_neg_negatable_literal(X) :-
	X = PRVARIABLE(_,_),
	%% Allow variables to be negated so that
	%% ?X = ${a[b->c]}, neg ?X would be possible.
	%%has_context(goal_reification),
	!.

%% this one is used to make neg(UDFHILOGPREDICATENAME(....),Goal) into
%% UDFHILOGPREDICATENAME(....), neg(Goal)
is_body_neg_passthrough_literal(X) :-
	is_prologterm(X,Struct,5,_Args),
	is_pratom(Struct,UDFHILOGPREDICATENAME,_),
	!.
is_body_neg_passthrough_literal(X) :-
	is_prologterm(X,Struct,1,_Args,_),
	(Struct = FL_SKOLEM
	; is_pratom(Struct,UDFHILOGPREDICATENAME,_)
	),
	!.
/*
is_unimplemented_neg_negatable_literal(X) :-
	is_florasyslib_struct(X, _I,_F,_N,_Args).
*/


delay_literals_checking_code(Head,Body,DescrVarsTerm,Code) :-
	collect_flvars(Head,HeadVars1),
	collect_flvars(Body,BodyVars1),
	%% DescrVarsTerm is a pr-object, so use collect_prvars
	collect_prvars(DescrVarsTerm,DescrPrvars),
	prvar_to_flvar_struct_list(DescrPrvars,DescrFlvars),
	%% BodyVars2 now contains descriptor vars
	append(BodyVars1,DescrFlvars,BodyVars2),
	remove_dupflvars(HeadVars1,HeadVars),
	remove_dupflvars(BodyVars2,BodyVars),
	(has_context(rule_reification),
	    has_context(compiling_body_pathexp)
	-> %% use new flvariables
	    is_flvariable(ParserHeadVars,FL_ANON_VAR,NO_INDEX),
	    is_flvariable(ParserBodyVars,FL_ANON_VAR,NO_INDEX)
	;
	    is_fllist(ParserHeadVars,HeadVars,[],NO_INDEX),
	    is_fllist(ParserBodyVars,BodyVars,[],NO_INDEX)
	),
	%% Optimization: if HeadVars contains BodyVars+DescrVars,
	%% no delay checking is
	%% needed for that rule. Instead, we put a var in place of the delay
	%% checker. In static & dynamic code, this var is ignored in generating
	%% the corresponding rules. However, dynamic rules are encoded as
	%% FLSYSRULEUPDATE(Id,FileName,DescrVarTerm,DescrMetaFacts,Head,Body,Hvars,Bvars,PreBody,PostBody,Defeat)
	%% To match reified rules, we make DelayCheckCode into a new var
	%% If there will be other stuff in PostBody, we'll have to integrate it.
	(vars_contains(HeadVars,BodyVars) ->
	    new_dontcare_prvariable(NO_INDEX,Code)
	; compile_prlgterm(FLORA_DELAY_CHECKER,2,
			   [ParserBodyVars,ParserHeadVars],
			   Code,_OidCode,_ACode,[],_Status)
	),
	!.


no_mixed_sensor_nonsensor_heads(CompiledHead,ParsedHead,Status) :-
	(no_mixed_sensor_nonsensor_heads(CompiledHead) -> Status = NO_ERRORS
	;  
	    approx_flindex(ParsedHead,I),
	    compiling_error(I,MIXED_HEAD_SENSORS,MixStatus),
	    Status = [MixStatus]
	).

%% cannot add delay-checking code for some heads but not others.
%% we check that there is no mixture of sensors (for which delay-checker
%% is NOT added) and non-sensors (for which delay IS added) here.
%% Used in conjunction with delay_literals_checking_code/2 when Head \= []
no_mixed_sensor_nonsensor_heads([]) :- !.
no_mixed_sensor_nonsensor_heads(HeadList) :-
	all_defined_as_sensors(HeadList) -> true
	; \+ some_defined_as_sensors(HeadList),
	!.

all_defined_as_sensors([]) :- !.
all_defined_as_sensors([Head|HeadList]) :-
	is_defined_as_sensor(Head)
	-> all_defined_as_sensors(HeadList).

some_defined_as_sensors([]) :- !, fail.
some_defined_as_sensors([Head|HeadList]) :-
	is_defined_as_sensor(Head) -> true
	; some_defined_as_sensors(HeadList).

%% sensors can't be in the heads of dynamic rules.
%% so we need to check only the permaoptions
is_defined_as_sensor(Head) :-
	prologterm_atom_arity(Head,Funct,Arity),
	is_pratom(Funct,Atom,_),
	!,
	has_permaoption(usesensor(Atom,Arity)).

%% Code that generates a prolog liblit with a given name.
%% **** This is PR code that goes to the coder.
%% Arguments must already be compiled (ie pr-code)
%% For instance, to generate "dummy" true code, use:
%%      generate_prolog_liblit(FL_TRUE,0,[],Code)
%% +PrologAtom, +Arity, +ArgsList, -Code
%% generate_prolog_liblit/4
generate_prolog_liblit(Atom,Arity,Args,Code) :-
	atomobj_struct(Atom,AtomCode),
	!,
        prologterm_struct(AtomCode,Arity,Args,Code1),
        prologliblit_struct(Code1,Code).
generate_prolog_liblit(AtomCode,Arity,Args,Code) :-
	is_modularized_pratom(AtomCode,_,_),
	!,
        prologterm_struct(AtomCode,Arity,Args,Code1),
        prologliblit_struct(Code1,Code).
%% generate_prolog_liblit/5
generate_prolog_liblit(Atom,Arity,Args,PrlgModule,Code) :-
	atomobj_struct(Atom,AtomCode),
        prologterm_struct(AtomCode,Arity,Args,PrlgModule,Code1),
        prologliblit_struct(Code1,Code).

list2commalist([A],(A)) :- !.
list2commalist([A|L], (A,LL)) :- list2commalist(L,LL).


get_current_compile_file(CurrFileName) :-
	flora_current_compile_filename(CurrFileName)->true
	; CurrFileName = '(interactive)'.
compiling_flrshell_command :- \+ flora_current_compile_filename(_).

get_current_compile_file_for_descriptor(CurrFileName,_Mode) :-
	has_context(rule_reification),
	filename_in_ruleid_struct(CurrFileName).
get_current_compile_file_for_descriptor(CurrFileName,Mode) :-
	memberchk(Mode,[FL_DESCRMODE_CLAUSE,FL_DESCRMODE_PLAIN_QUERY]),
	!,
	new_prvariable(NO_INDEX,CurrFileName).
get_current_compile_file_for_descriptor(FL_DYNRULE_FICTITIOUS_FILENAME,FL_DESCRMODE_DYNRULE) :-
	\+ has_context(compiling_for_addition),
	!.
get_current_compile_file_for_descriptor(FL_DYNRULE_FICTITIOUS_FILENAME,FL_DESCRMODE_LATENT_DYNQUERY) :-
	\+ has_context(compiling_for_addition),
	!.

get_current_compile_file_for_descriptor(CurrFileName,_Mode) :-
	get_current_compile_file(CurrFileName).



/*
%% This often looses warnings and errors, so we replaced with append and flatten
%%
%% This can simplify code when there is no dependency in the intervening code
%% on the outcome of the status codes in the Arg 1 list
merge_status([],[]) :- !.
merge_status([S|Rest],T) :-
	(S == NO_ERRORS -> merge_status(Rest,T)
	; T = S
	).
*/


/***************************************************************************
    rename_prvariables(+VarNameList,+VarType,+OldFormula,-NewFormula,-NewVarList)
       Replaces each occurrence of each variable in VarNameList with
       a newly created variable (the same for different occurrences of the
       same var name. Returns a new formula and the variable objects used
       in the substitutions.
       VarType: NEWVAR, NEWDONTCAREVAR, NEWCALLERVAR, NEWEXISTENTIALVAR
    rename_one_prvariable(+VarName,+NewVarObj,+Body,-NewBody),
       Replaces each occurrence of a a var object having VarName
       as the variable name with NewVarObj. Returns the newly created formula.
***************************************************************************/
rename_prvariables([],_VarType,Body,Body,[]) :- !.
rename_prvariables([VarName|VarNameList],VarType,Body,NewBody,[NewVarObj|NewVarList]) :-
	flora_new_varobj(VarType,NO_INDEX,NewVarObj),
	rename_one_prvariable(VarName,NewVarObj,Body,NewBody1),
	rename_prvariables(VarNameList,VarType,NewBody1,NewBody,NewVarList).

rename_one_prvariable(VarName,NewVarObj,Body,NewBody) :-
	(
	  atomic(Body) -> NewBody = Body
	; var(Body) -> NewBody  = Body
	; is_list(Body)
	-> rename_one_prvariable_in_list(VarName,NewVarObj,Body,NewBody)
	; is_prvariable(Body,VarName,_Idx) -> NewBody = NewVarObj
	; is_pratom(Body,_) ->  NewBody = Body
	; is_prnumber(Body) ->  NewBody = Body
	; is_prstring(Body) ->  NewBody = Body
	; is_prbuiltin_identifier(Body,_) ->  NewBody = Body
	; is_prdatatype(Body,_,_,_) ->  NewBody = Body
	; is_prdatatypelist(Body,_) ->  NewBody = Body
	),
	!.

rename_one_prvariable(VarName,NewVarObj,Body,NewBody) :-
	Body =.. [Wrapper|Args],
	rename_one_prvariable_in_list(VarName,NewVarObj,Args,NewArgs),
	NewBody =.. [Wrapper|NewArgs].

rename_one_prvariable_in_list(_,_,[],[]) :- !.
rename_one_prvariable_in_list(VarName,NewVarObj,[T|Terms],[NewT|NewTerms]) :-
	rename_one_prvariable(VarName,NewVarObj,T,NewT),
	rename_one_prvariable_in_list(VarName,NewVarObj,Terms,NewTerms).


%% Get the line number and file name of code represented by a PRTERM
code_line_and_file_by_prterm(_CompiledTerm,Line,File) :-
	%% in reified cases, do not put the line and file, since reified terms
	%% are not used where they are compiled, so the line number
	%% (and likely) file name are going to be wrong.
	%% Also, explicit line number & file name will prevent unification.
	(has_context(goal_reification);has_context(compiling_clause_primitive)),
	!,
	new_prvariable(NO_INDEX,Line),
	new_prvariable(NO_INDEX,File).
code_line_and_file_by_prterm(CompiledTerm,Line,File) :-
	(approx_prindex(CompiledTerm,Index), Index \= NO_INDEX
	-> flora_token_index_to_line(Index,Line)
	; Line = NULL
	),
	!,
	get_current_compile_file(File).

%% Get the line number and file name of code represented by line/position index
code_line_and_file_by_index(Index,LineVar,FileVar) :-
	has_context(goal_reification),
	!,
	%% if reification, file/line should be variables
	new_flvariable(Index,LineVar,_),
	new_flvariable(Index,FileVar,_).
code_line_and_file_by_index(NO_INDEX,NULL,NULL) :- !.
code_line_and_file_by_index(Index,Line,File) :-
	flora_token_index_to_line(Index,Line),
	get_current_compile_file(File).

get_index_line(NO_INDEX,NULL) :- !.
get_index_line(Index,Line) :- flora_token_index_to_line(Index,Line).




/****************************************************************************
 add_symbol(+Name,+N,+WS,+Index,+LineNumber,+Context,+Transactional)
 has_symbol(?Name,?N,?WS,?Index,?LineNumber,?Context,?Transactional)
 flora_clear_compilation_symbols
 add_nowarn_symbol(+Name,+N,+Context)
 has_nowarn_symbol(+Name,+N,+Context)

Predicates for checking usage of symbols with the same name and arity
The goal is to generate warnings/errors if the same symbol is used in different
contexts or a UDF is used before it is declared, etc. 
****************************************************************************/
add_symbol(_Name,_N,_WS,Index,_LineNumber,_Context,_Transactional) :-
	%% do not add symbols that are not in the user program
	(var(Index) ; Index == NO_INDEX),
	!.
add_symbol(Name,N,_WS,_Index,_LineNumber,_Context,_Transactional) :-
	%% do not add builtins
	flora_nodefp(Name,N),
	!.
%% the following three should be in some file rather than listed here
add_symbol(FL_COMMA,0,_,_,_,_,_) :- !.
add_symbol(FL_SEMICOLON,0,_,_,_,_,_) :- !.
add_symbol(FL_MVDARROW,0,_,_,_,_,_) :- !.
add_symbol(Name,N,_WS,_Index,_LineNumber,_Context,_Transactional) :-
	%% do not add delayed builtins
	%%flora_get_flatomvar_name(WS,WSName),
	%%flora_delayed_literal(Name,N,WSName),
	flora_delayed_builtin_literal(Name,N),
	!.
add_symbol(_Name,_N,_WS,_Index,_LineNumber,_Context,_Transactional) :-
	%% do not add symbols used in shell commands: errors/warnings get
	%% too confusing for the user
	compiling_flrshell_command,
	!.
%% if checking symbols for constants is off, then do not add constant symbols
add_symbol(_Name,0,_WS,_Index,_LineNumber,_Context,_Transactional) :-
	symbol_warnings_flag(FLORA_CONSTOFF),
	!.
add_symbol(Name,N,FL_THISMODULE,Index,LineNumber,Context,Transactional) :-
	!,
	assert(symbol(Name,N,FL_THISMODULE,Index,LineNumber,Context,Transactional)).
add_symbol(Name,N,WS,Index,LineNumber,Context,Transactional) :-
	is_flvariable(WS,_VarName,_VarIndex),
	!,
	assert(symbol(Name,N,WS,Index,LineNumber,Context,Transactional)).
add_symbol(Name,N,WS,Index,LineNumber,Context,Transactional) :-
	is_prfloralib(WS,WSName,_),
	!,
	assert(symbol(Name,N,WSName,Index,LineNumber,Context,Transactional)).
add_symbol(Name,N,WS,Index,LineNumber,Context,Transactional) :-
	flora_get_flatomvar_name(WS,WSName),
	assert(symbol(Name,N,WSName,Index,LineNumber,Context,Transactional)).

add_nowarn_symbol(Name,N,FL_THISMODULE,Context,Transactional) :-
	!,
	assert(nowarn_symbol(Name,N,FL_THISMODULE,Context,Transactional)).
add_nowarn_symbol(Name,N,WS,Context,Transactional) :-
	is_flvariable(WS,_VarName,_VarIndex),
	!,
	assert(nowarn_symbol(Name,N,WS,Context,Transactional)).
add_nowarn_symbol(Name,N,WS,Context,Transactional) :-
	is_prfloralib(WS,WSName,_),
	!,
	assert(nowarn_symbol(Name,N,WSName,Context,Transactional)).
add_nowarn_symbol(Name,N,WS,Context,Transactional) :-
	flora_get_flatomvar_name(WS,WSName),
	assert(nowarn_symbol(Name,N,WSName,Context,Transactional)).

has_symbol(Name,Arity,_,NO_INDEX,-1,BUILTIN_SYMBOL,_) :-
	flora_nodefp(Name,Arity),
	!.
has_symbol(Name,Arity,_WS,NO_INDEX,-1,BUILTIN_SYMBOL,_) :-
	%%flora_get_flatomvar_name(WS,WSName),
	%%flora_delayed_literal(Name,Arity,WSName).
	flora_delayed_builtin_literal(Name,Arity),
	!.
has_symbol(Name,N,WS,Index,LineNumber,Context,Transactional) :-
	symbol(Name,N,WS,Index,LineNumber,Context,Transactional).


has_nowarn_symbol(Name,N,WS,Context,Transactional) :-
	nowarn_symbol(Name,N,WS,Context,Transactional),
	!.

has_nowarn_any_symbol(Name,N,WS,_Context,Transactional) :-
	nowarn_symbol(Name,N,WS,ANY_SYMBOL_CONTEXT,Transactional),
	!.

has_nowarn_any_symbol(Name,N,WS,Context,Transactional) :-
	has_nowarn_symbol(Name,N,WS,Context,Transactional).

flora_clear_compilation_symbols :-
        %% following \+ is a workaround for an XSB garbage collection bug:
	(\+ symbol(_,_,_,_,_,_,_) -> true ; retractall(symbol(_,_,_,_,_,_,_))),
	(\+ nowarn_symbol(_,_,_,_,_) -> true ; retractall(nowarn_symbol(_,_,_,_,_))),
	clear_turnoff_symbol_warnings_flag.

set_turnoff_symbol_warnings_flag(Flag):- 
	assert(symbol_warnings_flag(Flag)).

clear_turnoff_symbol_warnings_flag:- 
	(\+ symbol_warnings_flag(_) -> true ; retractall(symbol_warnings_flag(_))).

/****************************************************************************
no_errors_found(+Status)
****************************************************************************/
no_errors_found([]) :- !.
no_errors_found([warning(_,_)|Rest]) :-
	(var(Rest) ->
	    flora_abort(['Critical compiler bug!!! Some predicate returns variable as status!'],FLORA_ABORT_NOTRACE)
	;
	    \+ memberchk(error(_,_), Rest)
	).


%% Maplist
maplist(_Pred,[],[]) :- !.
maplist(Pred,[X|Rest],[Y|MapRest]) :-
	copy_term(Pred,PredNew),
	arg(1,PredNew,X),
	arg(2,PredNew,Y),
	call(PredNew),
	!,
	maplist(Pred,Rest,MapRest).
%% if call(PredNew) fails, skip the item
maplist(Pred,[_|Rest],MapRest) :-
	maplist(Pred,Rest,MapRest).

%% This replaces atoms with scrambled or modularized atoms
%% in case there was a sensor or prolog declaration
atom_replacement(A,N,AA) :-
	has_permaoption(atomreplacement(A,N,AA)),
	!.
atom_replacement(A,_N,A).

%% this applies to pr-objects
termlit_replacement(PRBUILTIN_IDENTIFIER(F,I),N,PRMODULARIZEDATOM(FF,I)) :-
	atom_replacement(F,N,PRMODULARIZEDATOM(FF)),
	!.
termlit_replacement(PRBUILTIN_IDENTIFIER(F,I),N,PRBUILTIN_IDENTIFIER(FF,I)) :-
	atom_replacement(F,N,FF),
	!.
termlit_replacement(PRATOM(F,I),N,PRMODULARIZEDATOM(FF,I)) :-
	atom_replacement(F,N,PRMODULARIZEDATOM(FF)),
	!.
termlit_replacement(PRATOM(F,I),N,PRATOM(FF,I)) :-
	atom_replacement(F,N,FF),
	!.
termlit_replacement(Funct,_N,Funct).


%% The Index argument is not used currently
verify_symbol_context_pairlist([],_Index,_Context,_Trans,[]) :- !.
verify_symbol_context_pairlist([(P,A,Idx)|PairList],Index,Context,Trans,Status) :-
	%% P can be either the sensor name or (PrologSensor,PrologModule)
	(P = (PA,_) ; P=PA),
	!,
	is_flatom(PObj,PA,Idx),
	verify_symbol_context(PObj,A,Context,Trans,S1),
	verify_symbol_context_pairlist(PairList,Index,Context,Trans,S2),
	append(S2,S1,Status).
verify_symbol_context_pairlist([P/A/Idx|PairList],Index,Context,Trans,Status) :-
	(P = (PA,_) ; P=PA),
	!,
	is_flatom(PObj,PA,Idx),
	verify_symbol_context(PObj,A,Context,Trans,S1),
	verify_symbol_context_pairlist(PairList,Index,Context,Trans,S2),
	append(S2,S1,Status).

%% this takes predicate-arity pairs without the index
%% generates a query out of
%%    flrprolog:flora_define_modular_prolog([prolog(pred,arity,thisModule)|...])
make_runtime_modular_prolog_declarations(PairList,Code) :-
	maplist(term_to_prologterm_struct(_,_),PairList,PairListCode),
	list_struct(PairListCode,[],PairListCodeList),
	generate_prolog_liblit(flora_define_modular_prolog,1,
			       [PairListCodeList],
			       flrprolog,PreCode),
	query_struct(PreCode,Code).


%% converts prolog terms to PROLOGTERM structures
term_to_prologterm_struct(Term,PTermStruct) :-
	Term =.. [Funct|Args],
	functor(Term,_,N),
	thismodule_struct(ThisMod),
	N1 is N+1,
	append(Args,[ThisMod],Args1), %% add curent module
	prologterm_struct(Funct,N1,Args1,PTermStruct).

%% compile sensor literals in the file where defsensor is specified.
%% these literals get 2 arguments prepended
compile_sensor_literal(PrlgModName,FObj,N,ArgList,Code) :-
	special_variable_struct(FL_SPECIAL_FILE_TOKEN,FileVariableCode),
	special_variable_struct(FL_SPECIAL_LINE_TOKEN,LineVariableCode),
	NewArgList = [FileVariableCode,LineVariableCode|ArgList],
	termlit_replacement(FObj,N,NewFObj),
	SensArity2 is N+2,
	(var(PrlgModName) ->
	    prologterm_struct(NewFObj,SensArity2,NewArgList,Code)
	;
	    prologterm_struct(NewFObj,SensArity2,NewArgList,PrlgModName,Code)
	).


%% get_rule_manipulation_primitive_extra_args(+Args)
%% This is for rule manipulation primitives that need to be augmented
%% with _@F and _@ as the last args.
get_rule_manipulation_primitive_extra_args([ThisFile,ThisModule]) :-
	get_current_compile_file(File),
	atomobj_struct(File,NO_INDEX,ThisFile),
	thismodule_struct(ThisModule).
rule_manipulation_primitive(FL_RULEENABLE).
rule_manipulation_primitive(FL_RULEDISABLE).
rule_manipulation_primitive(FL_TRANS_RULEENABLE).
rule_manipulation_primitive(FL_TRANS_RULEDISABLE).
rule_manipulation_primitive(FL_ISRULEENABLED).
rule_manipulation_primitive(FL_ISRULEDISABLED).
rule_manipulation_primitive(FL_MAKEDEFEASIBLE).
rule_manipulation_primitive(FL_MAKESTRICT).
rule_manipulation_primitive(FL_ISDEFEASIBLE).
rule_manipulation_primitive(FL_ISSTRICT).
rule_manipulation_primitive(FL_RUN_QUERY).


/*
%% used to debug symbol context info
show_nowarn_symbols :-
	nowarn_symbol(A,B,C,D,E),
	DBGOUTLN(nowarn(A,B,C,D,E)),
	fail.
show_nowarn_symbols.
*/
