/*******************************************************************************
  file: closure/flrcommon.fli - The common part of all trailers

  Author(s): Guizhen Yang

  Contact:   flora-users@lists.sourceforge.net

  Copyright (C) by
       The Research Foundation of the State University of New York, 1999-2013.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
 
       http://www.apache.org/licenses/LICENSE-2.0
 
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

*******************************************************************************/


#include "flora_wspredicates.flh"
#include "flora_porting.flh"
#include "flora_exceptions.flh"

:- import 
	flora_abort/1
   from flrutils.

:- import flora_optimizer_registry/2 from flrregistry.
:- import when/2 from constraintLib.

:- WRAP_COPY_UNQUOTED 'FLORA_THIS_MODULE_NAME'.


#include "flrtypes.fli"

#include "flrcommon_neg.inc"


/***************************************************************************
  inferred predicates

  These wrapper predicates with the 'inferred_' prefix (FLTRAILERPREFIX)
  are needed to make the trailer dynamically loadable. Note that the
  program rules use wrapper predicates with the 'derived_', prefix, i.e.,
  FLHEADPREFIX.
***************************************************************************/
FLTRAILERPREFIX(WRAP_SUB)(X,Y,CallerInfo) :-
	FLHEADPREFIX(WRAP_SUB)(X,Y,CallerInfo).
FLTRAILERPREFIX(WRAP_ISA)(O,C,CallerInfo) :-
	FLHEADPREFIX(WRAP_ISA)(O,C,CallerInfo).
FLTRAILERPREFIX(WRAP_MVD)(O,A,V,CallerInfo) :-
	FLHEADPREFIX(WRAP_MVD)(O,A,V,CallerInfo).
FLTRAILERPREFIX(WRAP_IMVD)(C,A,V,CallerInfo) :-
	FLHEADPREFIX(WRAP_IMVD)(C,A,V,CallerInfo).
FLTRAILERPREFIX(WRAP_MVDDEF)(O,A,CallerInfo) :-
	FLHEADPREFIX(WRAP_MVDDEF)(O,A,CallerInfo).
FLTRAILERPREFIX(WRAP_IMVDDEF)(C,A,CallerInfo) :-
	FLHEADPREFIX(WRAP_IMVDDEF)(C,A,CallerInfo).
FLTRAILERPREFIX(WRAP_MVDSIG)(O,MethodArgs,R,CallerInfo) :-
	FLHEADPREFIX(WRAP_MVDSIG)(O,MethodArgs,R,CallerInfo).
FLTRAILERPREFIX(WRAP_MVDCONDEF)(O,MethodArgs,L,H,CallerInfo) :-
	FLHEADPREFIX(WRAP_MVDCONDEF)(O,MethodArgs,L,H,CallerInfo),
	( integer(L) ->
	     true
	;
	     flora_concat_items(['Lower bound ',L,' of cardinality
	constraint of ',O,'[',MethodArgs,'=>?]  is not an integer.'],ErrorMsg),
	     flora_abort(FLORA_CARDINALITY_CONSTRAINT_EXCEPTION(ErrorMsg))
	),
	( ((integer(H),H>=0);H=='*') ->
	     true
	;
	     flora_concat_items(['Higher bound ',H,' of cardinality
	constraint of ',O,'[',MethodArgs,'=>?]  is not a non-negative integer or infinity(*).'],ErrorMsg),
	     flora_abort(FLORA_CARDINALITY_CONSTRAINT_EXCEPTION(ErrorMsg))
	).
FLTRAILERPREFIX(WRAP_MVDSIGDEF)(O,MethodArgs,CallerInfo) :-
	FLHEADPREFIX(WRAP_MVDSIGDEF)(O,MethodArgs,CallerInfo).
FLTRAILERPREFIX(WRAP_IMVDSIG)(O,MethodArgs,R,CallerInfo) :-
	FLHEADPREFIX(WRAP_IMVDSIG)(O,MethodArgs,R,CallerInfo).
FLTRAILERPREFIX(WRAP_IMVDCONDEF)(O,MethodArgs,L,H,CallerInfo) :-
	FLHEADPREFIX(WRAP_IMVDCONDEF)(O,MethodArgs,L,H,CallerInfo),
	( integer(L) ->
	     true
	;
	     flora_concat_items(['Lower bound ',L,' of cardinality
	constraint of ',O,'[',MethodArgs,'*=>?]  is not an integer.'],ErrorMsg),
	     flora_abort(FLORA_CARDINALITY_CONSTRAINT_EXCEPTION(ErrorMsg))
	),
	( ((integer(H),H>=0);H=='*') ->
	     true
	;
	     flora_concat_items(['Higher bound ',H,' of cardinality
	constraint of ',O,'[',MethodArgs,'*=>?]  is not a non-negative integer or infinity(*).'],ErrorMsg),
	     flora_abort(FLORA_CARDINALITY_CONSTRAINT_EXCEPTION(ErrorMsg))
	).
FLTRAILERPREFIX(WRAP_IMVDSIGDEF)(O,MethodArgs,CallerInfo) :-
	FLHEADPREFIX(WRAP_IMVDSIGDEF)(O,MethodArgs,CallerInfo).
FLTRAILERPREFIX(WRAP_METH)(O,M,CallerInfo) :-
	FLHEADPREFIX(WRAP_METH)(O,M,CallerInfo).
FLTRAILERPREFIX(WRAP_IMETH)(C,M,CallerInfo) :-
	FLHEADPREFIX(WRAP_IMETH)(C,M,CallerInfo).
FLTRAILERPREFIX(WRAP_BOOLSIG)(O,M,CallerInfo) :-
	FLHEADPREFIX(WRAP_BOOLSIG)(O,M,CallerInfo).
FLTRAILERPREFIX(WRAP_IBOOLSIG)(C,M,CallerInfo) :-
	FLHEADPREFIX(WRAP_IBOOLSIG)(C,M,CallerInfo).
FLTRAILERPREFIX(WRAP_TRANSIG)(O,M,CallerInfo) :-
	FLHEADPREFIX(WRAP_TRANSIG)(O,M,CallerInfo).
FLTRAILERPREFIX(WRAP_ITRANSIG)(C,M,CallerInfo) :-
	FLHEADPREFIX(WRAP_ITRANSIG)(C,M,CallerInfo).
FLTRAILERPREFIX(WRAP_TRAN)(O,T,CallerInfo) :-
	FLHEADPREFIX(WRAP_TRAN)(O,T,CallerInfo).
FLTRAILERPREFIX(WRAP_OBJEQL)(X,Y,CallerInfo) :-
	FLHEADPREFIX(WRAP_OBJEQL)(X,Y,CallerInfo).
FLTRAILERPREFIX(WRAP_EXISTS)(X,CallerInfo) :-
	FLHEADPREFIX(WRAP_EXISTS)(X,CallerInfo).


/***************************************************************************
  multivalued attributes inclusion
***************************************************************************/
WRAP_MVDINC(_O,_M,[],CallerInfo) :- !.
WRAP_MVDINC(O,M,[H|T],CallerInfo) :-
    	WRAP_MVD(O,M,H,CallerInfo),
	WRAP_MVDINC(O,M,T,CallerInfo).


WRAP_IMVDINC(_O,_M,[],CallerInfo) :- !.
WRAP_IMVDINC(O,M,[H|T],CallerInfo) :-
    	WRAP_IMVD(O,M,H,CallerInfo),
	WRAP_IMVDINC(O,M,T,CallerInfo).


/****************************************************************************
  multivalued attributes aggregation

  Note: (1) These two predicates always succeeds.
        (2) These two predicates are not tabled.
****************************************************************************/
WRAP_MVDTOLIST(O,M,L,CallerInfo) :-
	WRAP_MVDDEF(O,M,CallerInfo),
	findall(V,WRAP_MVD(O,M,V,CallerInfo),L).

WRAP_MVDTOLIST(O,M,[],CallerInfo) :-
	FLORA_NAF_EXISTS(WRAP_MVDDEF(O,M,CallerInfo)).


WRAP_IMVDTOLIST(O,M,L,CallerInfo) :-
	WRAP_IMVDDEF(O,M,CallerInfo),
	findall(V,WRAP_IMVD(O,M,V,CallerInfo),L).
 
WRAP_IMVDTOLIST(O,M,[],CallerInfo) :-
	FLORA_NAF_EXISTS(WRAP_IMVDDEF(O,M,CallerInfo)).


/****************************************************************************
   Odd-lot predicates
****************************************************************************/
%% These are tabled in genincludes/flrtable.fli
FL_TRUTHVALUE_TABLED_CALL(X) :- call(X).
FL_TABLED_UNNUMBER_CALL(GGoal) :-
    	num_vars:unnumbervars(GGoal,VGoal),
	call(VGoal).

/****************************************************************************
  WRAP_EXISTS/1
****************************************************************************/
WRAP_EXISTS(X,CallerInfo) :- WRAP_MVD(X,_,_,CallerInfo).
WRAP_EXISTS(X,CallerInfo) :- WRAP_MVD(_,_,X,CallerInfo).
WRAP_EXISTS(X,CallerInfo) :- WRAP_MVDDEF(X,_,CallerInfo).
WRAP_EXISTS(X,CallerInfo) :- WRAP_IMVD(X,_,_,CallerInfo).
WRAP_EXISTS(X,CallerInfo) :- WRAP_IMVD(_,_,X,CallerInfo).
WRAP_EXISTS(X,CallerInfo) :- WRAP_IMVDDEF(X,_,CallerInfo).

WRAP_EXISTS(X,CallerInfo) :- WRAP_METH(X,_,CallerInfo).
WRAP_EXISTS(X,CallerInfo) :- WRAP_IMETH(X,_,CallerInfo).

%% We need to restrict these so that one could not infer existence merely
%% due to standard classes such as _symbol, _object, (?;?), etc.
WRAP_EXISTS(X,CallerInfo) :- WRAP_ISA(X,C,CallerInfo).
WRAP_EXISTS(X,CallerInfo) :- WRAP_ISA(O,X,CallerInfo).
WRAP_EXISTS(X,CallerInfo) :- WRAP_SUB(X,C,CallerInfo).
WRAP_EXISTS(X,CallerInfo) :- WRAP_SUB(C,X,CallerInfo).

/* Ensure that objects corresponding to the standard data types "exist" */
WRAP_EXISTS(FL_TOPTYPE,_CallerInfor).
WRAP_EXISTS(FL_LONG,_CallerInfor).
WRAP_EXISTS(FL_INTEGER,_CallerInfor).
WRAP_EXISTS(FL_DECIMAL,_CallerInfor).
WRAP_EXISTS(FL_DOUBLE,_CallerInfor).
WRAP_EXISTS(FL_SYMBOL,_CallerInfor).
WRAP_EXISTS(FL_STRING,_CallerInfor).
WRAP_EXISTS(FL_DATETIME,_CallerInfor).
WRAP_EXISTS(FL_DATE,_CallerInfor).
WRAP_EXISTS(FL_DURATION,_CallerInfor).
WRAP_EXISTS(FL_TIME,_CallerInfor).
WRAP_EXISTS(FL_IRI,_CallerInfor).
WRAP_EXISTS(FL_BOOL,_CallerInfor).
WRAP_EXISTS(FL_LISTTYPE,_CallerInfor).

%% Have to assert, because flora_defined_class/1 gets its content from
%% different modules. Using compiled rules would cause each module to
%% override another
?- assert((
       flora_defined_class(X) :-
	    FLTRAILERPREFIX(WRAP_SUB)(X, _,_Caller) ;
	    FLTRAILERPREFIX(WRAP_SUB)(_, X,_Caller) ;
	    FLTRAILERPREFIX(WRAP_ISA)(_, X,_Caller)
    )).

FLORA_SYMBOL('class')(X) :-
	FLTRAILERPREFIX(WRAP_SUB)(X, _,_Caller) ;
	FLTRAILERPREFIX(WRAP_SUB)(_, X,_Caller) ;
	FLTRAILERPREFIX(WRAP_ISA)(_, X,_Caller).


#include "flrequality_none.inc"


/****************************************************************************
    Introduced in support of the debugger
****************************************************************************/
%% like WRAP_SUB, but the debugger won't trace these
silent_sub(C,S,CallerInfo) :- WRAP_SUB(C,S,CallerInfo).
FLINHERITANCEPREFIX(WRAP_SUB)(C,S,CallerInfo) :- WRAP_SUB(C,S,CallerInfo).
FLINHERITANCEPREFIX(WRAP_ISA)(C,S,CallerInfo) :- WRAP_ISA(C,S,CallerInfo).

%% Like inferred_* but the debugger (actually the decoder, flrdecode.P)
%% will print them in a special way
FLINHERITANCEPREFIX(WRAP_IMVD)(C,M,V,CallerInfo) :- FLTRAILERPREFIX(WRAP_IMVD)(C,M,V,CallerInfo).
FLINHERITANCEPREFIX(WRAP_IMVDDEF)(C,M,CallerInfo) :- FLTRAILERPREFIX(WRAP_IMVDDEF)(C,M,CallerInfo).

FLINHERITANCEPREFIX(WRAP_IMVD_EQL)(C,M,V,CallerInfo) :- FLTRAILERPREFIX(WRAP_IMVD_EQL)(C,M,V,CallerInfo).
FLINHERITANCEPREFIX(WRAP_IMVDDEF_EQL)(C,M,CallerInfo) :- FLTRAILERPREFIX(WRAP_IMVDDEF_EQL)(C,M,CallerInfo).

FLINHERITANCEPREFIX(WRAP_IMETH)(C,M,CallerInfo) :- FLTRAILERPREFIX(WRAP_IMETH)(C,M,CallerInfo).
FLINHERITANCEPREFIX(WRAP_IMETH_EQL)(C,M,CallerInfo) :- FLTRAILERPREFIX(WRAP_IMETH_EQL)(C,M,CallerInfo).


FL_SILENT_EQUAL(X,X).


/****************************************************************************
   axioms for signature semantics
****************************************************************************/
#include "flrsigaxioms.fli"


/****************************************************************************
   common axioms for HiLog predicates
****************************************************************************/
#include "flrcommon_pred.fli"



/****************************************************************************
   rule for user defined functions and HiLog 
****************************************************************************/
UDFHILOGPREDICATENAME(Predicate,Arity,ReturnValue,ReturnOrigPred,_CallerInfo) :-
	Predicate=..[Functor,Name|Args],
	(Functor \== WRAP_HILOG -> PredicateBase = Predicate
	; flrsynonym:flora_op_synonym(Name,BaseName),
	    PredicateBase =.. [Functor,BaseName|Args]
	; BaseName = Name,
	    PredicateBase =.. [Functor,BaseName|Args]
	),
	flrregistry:flora_defined_udf_registry(FLORA_THIS_MODULE_NAME,_,Arity,PredicateBase,_,CallCode),
	arg(1,CallCode,ReturnValue),
	%% No cut: flora_op_synonym/2 can have many matches if Name is a var!
	%% !,
	machine:call0(CallCode).

UDFHILOGPREDICATENAME(Predicate,_Arity,Predicate,UDFHILOG_RETURN_ORIG_PRED,_CallerInfo).
