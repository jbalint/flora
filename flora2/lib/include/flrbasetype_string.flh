/* File:      include/flrbasetype_string.flh
**
** Author(s): Michael Kifer
**
** Contact:   kifer@cs.stonybrook.edu
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2013.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**      http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
**
*/


:- export
	?[_startsWith(?)],
	?[_endsWith(?)],
    	?[_contains(?)],
	?[_concat(?)->?],
	?[_reverse->?],
	?[_length->?],
	?[_toUpper->?],
	?[_toLower->?],
	?[_substring(?,?)->?].

// startsWith
?X^^_string[_startsWith(?Y^^_string)] :-  // dead code
	!,
    	flora_match_substring(?Y._rawValue,?X._rawValue,0)@_prolog(flrporting).
?X[_startsWith(?Y)] :-
    	atom(?X)@_prolog, atom(?Y)@_prolog,
	!,
	flratom_begins_with(?X._rawValue,?Y._rawValue)@_prolog(flora_ground).

// endsWith
?X^^_string[_endsWith(?Y^^_string)] :-  // dead code
	!,
	flratom_ends_with(?X._rawValue,?Y._rawValue)@_prolog(flora_ground).
?X[_endsWith(?Y)] :-
    	atom(?X)@_prolog, atom(?Y)@_prolog,
	!,
	flratom_ends_with(?X._rawValue,?Y._rawValue)@_prolog(flora_ground).

// contains
?X^^_string[_contains(?Y^^_string)] :-  // dead code
	!,
    	flora_match_substring(?Y._rawValue,?X._rawValue,?)@_prolog(flrporting).
?X[_contains(?Y)] :-
    	atom(?X)@_prolog, atom(?Y)@_prolog,
    	flora_match_substring(?Y._rawValue,?X._rawValue,?)@_prolog(flrporting).

// concat
?X^^_string[_concat(?Y^^_string) -> ?R] :-
	!,
    	flora_concat_atoms([?X._rawValue,?Y._rawValue],?R1)@_prolog(flrporting),
	_string[_toType(?R1)->?R].
?X[_concat(?Y) -> ?R] :-
    	atom(?X)@_prolog, atom(?Y)@_prolog,
	(_isstring(?X), _isstring(?Y)),
	!,
    	flora_concat_atoms([?X._rawValue,?Y._rawValue],?R1)@_prolog(flrporting),
	flora_concat_atoms([FL_STRING_TYPE_PREFIX,?R1],?R)@_prolog(flrporting).
/*
// this is replaced with _symbol[_concat(List) -> ?R]
?X[_concat(?Y) -> ?R] :-
    	atom(?X)@_prolog, atom(?Y)@_prolog,
	!,
    	flora_concat_atoms([?X._rawValue,?Y._rawValue],?R)@_prolog(flrporting).
*/
?X[_concat(?Y) -> ?R] :-
        _ischarlist(?X), _ischarlist(?Y),
	!,
	append(?X,?Y,?R)@_prolog(basics).

// reverse
?X^^_string[_reverse -> ?R] :-  // dead code
	!,
	atom_codes(?X._rawValue,?Codes)@_prolog,
	reverse(?Codes,?CodesR)@_prolog(basics),
	atom_codes(?R1,?CodesR)@_prolog,
	_string[_toType(?R1)->?R].
?X[_reverse -> ?R] :-
    	_isstring(?X),
	!,
	atom_codes(?X,?Codes)@_prolog,
	?Codes=[?p1,?p2|?CodesRaw],
	reverse(?CodesRaw,?CodesRvrs)@_prolog(basics),
	atom_codes(?R,[?p1,?p2|?CodesRvrs])@_prolog.
?X[_reverse -> ?R] :-
    	_isatom(?X),
	?X\=[],
	!,
	atom_codes(?X,?Codes)@_prolog,
	reverse(?Codes,?CodesRvrs)@_prolog(basics),
	atom_codes(?R,?CodesRvrs)@_prolog.
/*
// this is done by the list type routines
?X[_reverse -> ?R] :-
    	_ischarlist(?X),
	!,
	reverse(?X,?R)@_prolog(basics).
*/

// length
?X^^_string[_length -> ?N] :-
	!,
    	flora_atom_length(?X._rawValue,?N)@_prolog(flrporting).
?X[_length -> ?N] :-
	// this takes care of ^^_strings and atoms
    	_isatom(?X),
	!,
    	flora_atom_length(?X._rawValue,?N)@_prolog(flrporting).

// toUpper
?X^^_string[_toUpper -> ?R] :-  // dead code
	!,
	flora_toUpper(?X._rawValue,?R1)@_prolog(flrdatatype_utils),
	_string[_toType(?R1)->?R].
?X[_toUpper -> ?R] :-
    	_isstring(?X),
	!,
	flora_toUpper(?X._rawValue,?R1)@_prolog(flrdatatype_utils),
	flora_concat_atoms([FL_STRING_TYPE_PREFIX,?R1],?R)@_prolog(flrporting).
?X[_toUpper -> ?R] :-
    	atom(?X)@_prolog,
	!,
	flora_toUpper(?X,?R)@_prolog(flrdatatype_utils).
?X[_toUpper -> ?R] :-
        _ischarlist(?X),
	!,
	flora_toUpper(?X._rawValue,?R1)@_prolog(flrdatatype_utils),
	atom_codes(?R1,?R)@_prolog.

// toLower
?X^^_string[_toLower -> ?R] :-  // dead code
	!,
	flora_toLower(?X._rawValue,?R1)@_prolog(flrdatatype_utils),
	_string[_toType(?R1)->?R].
?X[_toLower -> ?R] :-
    	_isstring(?X),
	!,
	flora_toLower(?X._rawValue,?R1)@_prolog(flrdatatype_utils),
	flora_concat_atoms([FL_STRING_TYPE_PREFIX,?R1],?R)@_prolog(flrporting).
?X[_toLower -> ?R] :-
    	atom(?X)@_prolog,
	!,
	flora_toLower(?X,?R)@_prolog(flrdatatype_utils).
?X[_toLower -> ?R] :-
        _ischarlist(?X),
	!,
	flora_toLower(?X._rawValue,?R1)@_prolog(flrdatatype_utils),
	atom_codes(?R1,?R)@_prolog.

// substring
?X^^_string[_substring(?Beg,?End) -> ?R] :-  // dead code
	!,
	flora_get_substring(?X._rawValue,?Beg,?End,?R1)@_prolog(flrporting),
	_string[_toType(?R1)->?R].
?X[_substring(?Beg,?End) -> ?R] :-
    	_isstring(?X),
	_isinteger(?Beg), _isinteger(?End),
	!,
	flora_get_substring(?X._rawValue,?Beg,?End,?R1)@_prolog(flrporting),
	flora_concat_atoms([FL_STRING_TYPE_PREFIX,?R1],?R)@_prolog(flrporting).
?X[_substring(?Beg,?End) -> ?R] :-
    	(atom(?X), integer(?Beg), integer(?End))@_prolog,
	!,
	flora_get_substring(?X,?Beg,?End,?R)@_prolog(flrporting).
?X[_substring(?Beg,?End) -> ?R] :-
        _ischarlist(?X),
	_isinteger(?Beg), _isinteger(?End),
	!,
	atom_codes(?XX,?X)@_prolog,
	flora_get_substring(?XX,?Beg,?End,?R1)@_prolog(flrporting),
	atom_codes(?R1,?R)@_prolog.
// ?Beg/?End unbound
?X[_substring(?Beg,?End) -> ?Y] :-
    	(_isatom(?X) ; _ischarlist(?X)),
	(_isatom(?Y) ; _ischarlist(?Y)),
	!,
    	flora_match_substring(?Y._rawValue,?X._rawValue,forward,?Beg,?End)@_prolog(flrporting).
// error
?X[_substring(?Beg,?End) -> ?R] :-
        %abort(['In ?Str[_substring(?Beg,?End)->?Sub]@_basetype:\n\t?Str must be a string/symbol/charlist and either\n\t?Sub must be a string/symbol/charlist or ?Beg, ?End must be integers.\n\tActual call: ',
	        ?X, '[_substring(', ?Beg, ',', ?End, ')->', ?R, ']'])@_system.
