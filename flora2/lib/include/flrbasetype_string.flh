/* File:      include/flrbasetype_string.flh
**
** Author(s): Michael Kifer
**
** Contact:   flora-users@lists.sourceforge.net
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2013.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**      http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
**
*/


:- export
	?[startsWith(?)],
	?[endsWith(?)],
    	?[contains(?)],
	?[concat(?)->?],
	?[reverse->?],
	?[length->?],
	?[toUpper->?],
	?[toLower->?],
	?[substring(?,?)->?].

// startsWith
?X^^\string[startsWith(?Y^^\string)] :-  // dead code
	!,
    	flora_match_substring(?Y.rawValue,?X.rawValue,0)@\prolog(flrporting).
?X[startsWith(?Y)] :-
    	atom(?X)@\prolog, atom(?Y)@\prolog,
	!,
	flratom_begins_with(?X.rawValue,?Y.rawValue)@\prolog(flora_ground).

// endsWith
?X^^\string[endsWith(?Y^^\string)] :-  // dead code
	!,
	flratom_ends_with(?X.rawValue,?Y.rawValue)@\prolog(flora_ground).
?X[endsWith(?Y)] :-
    	atom(?X)@\prolog, atom(?Y)@\prolog,
	!,
	flratom_ends_with(?X.rawValue,?Y.rawValue)@\prolog(flora_ground).

// contains
?X^^\string[contains(?Y^^\string)] :-  // dead code
	!,
    	flora_match_substring(?Y.rawValue,?X.rawValue,?)@\prolog(flrporting).
?X[contains(?Y)] :-
    	atom(?X)@\prolog, atom(?Y)@\prolog,
    	flora_match_substring(?Y.rawValue,?X.rawValue,?)@\prolog(flrporting).

// concat
?X^^\string[concat(?Y^^\string) -> ?R] :-
	!,
    	flora_concat_atoms([?X.rawValue,?Y.rawValue],?R1)@\prolog(flrporting),
	\string[toType(?R1)->?R].
?X[concat(?Y) -> ?R] :-
    	atom(?X)@\prolog, atom(?Y)@\prolog,
	(\isstring(?X), \isstring(?Y)),
	!,
    	flora_concat_atoms([?X.rawValue,?Y.rawValue],?R1)@\prolog(flrporting),
	flora_concat_atoms([FL_STRING_TYPE_PREFIX,?R1],?R)@\prolog(flrporting).
/*
// this is replaced with \symbol[concat(List) -> ?R]
?X[concat(?Y) -> ?R] :-
    	atom(?X)@\prolog, atom(?Y)@\prolog,
	!,
    	flora_concat_atoms([?X.rawValue,?Y.rawValue],?R)@\prolog(flrporting).
*/
?X[concat(?Y) -> ?R] :-
        \ischarlist(?X), \ischarlist(?Y),
	!,
	append(?X,?Y,?R)@\prolog(basics).

// reverse
?X^^\string[reverse -> ?R] :-  // dead code
	!,
	atom_codes(?X.rawValue,?Codes)@\prolog,
	reverse(?Codes,?CodesR)@\prolog(basics),
	atom_codes(?R1,?CodesR)@\prolog,
	\string[toType(?R1)->?R].
?X[reverse -> ?R] :-
    	\isstring(?X),
	!,
	atom_codes(?X,?Codes)@\prolog,
	?Codes=[?p1,?p2|?CodesRaw],
	reverse(?CodesRaw,?CodesRvrs)@\prolog(basics),
	atom_codes(?R,[?p1,?p2|?CodesRvrs])@\prolog.
?X[reverse -> ?R] :-
    	\isatom(?X),
	?X\=[],
	!,
	atom_codes(?X,?Codes)@\prolog,
	reverse(?Codes,?CodesRvrs)@\prolog(basics),
	atom_codes(?R,?CodesRvrs)@\prolog.
/*
// this is done by the list type routines
?X[reverse -> ?R] :-
    	\ischarlist(?X),
	!,
	reverse(?X,?R)@\prolog(basics).
*/

// length
?X^^\string[length -> ?N] :-
	!,
    	flora_atom_length(?X.rawValue,?N)@\prolog(flrporting).
?X[length -> ?N] :-
	// this takes care of ^^\strings and atoms
    	\isatom(?X),
	!,
    	flora_atom_length(?X.rawValue,?N)@\prolog(flrporting).

// toUpper
?X^^\string[toUpper -> ?R] :-  // dead code
	!,
	flora_toUpper(?X.rawValue,?R1)@\prolog(flrdatatype_utils),
	\string[toType(?R1)->?R].
?X[toUpper -> ?R] :-
    	\isstring(?X),
	!,
	flora_toUpper(?X.rawValue,?R1)@\prolog(flrdatatype_utils),
	flora_concat_atoms([FL_STRING_TYPE_PREFIX,?R1],?R)@\prolog(flrporting).
?X[toUpper -> ?R] :-
    	atom(?X)@\prolog,
	!,
	flora_toUpper(?X,?R)@\prolog(flrdatatype_utils).
?X[toUpper -> ?R] :-
        \ischarlist(?X),
	!,
	flora_toUpper(?X.rawValue,?R1)@\prolog(flrdatatype_utils),
	atom_codes(?R1,?R)@\prolog.

// toLower
?X^^\string[toLower -> ?R] :-  // dead code
	!,
	flora_toLower(?X.rawValue,?R1)@\prolog(flrdatatype_utils),
	\string[toType(?R1)->?R].
?X[toLower -> ?R] :-
    	\isstring(?X),
	!,
	flora_toLower(?X.rawValue,?R1)@\prolog(flrdatatype_utils),
	flora_concat_atoms([FL_STRING_TYPE_PREFIX,?R1],?R)@\prolog(flrporting).
?X[toLower -> ?R] :-
    	atom(?X)@\prolog,
	!,
	flora_toLower(?X,?R)@\prolog(flrdatatype_utils).
?X[toLower -> ?R] :-
        \ischarlist(?X),
	!,
	flora_toLower(?X.rawValue,?R1)@\prolog(flrdatatype_utils),
	atom_codes(?R1,?R)@\prolog.

// substring
?X^^\string[substring(?Beg,?End) -> ?R] :-  // dead code
	!,
	flora_get_substring(?X.rawValue,?Beg,?End,?R1)@\prolog(flrporting),
	\string[toType(?R1)->?R].
?X[substring(?Beg,?End) -> ?R] :-
    	\isstring(?X),
	\isinteger(?Beg), \isinteger(?End),
	!,
	flora_get_substring(?X.rawValue,?Beg,?End,?R1)@\prolog(flrporting),
	flora_concat_atoms([FL_STRING_TYPE_PREFIX,?R1],?R)@\prolog(flrporting).
?X[substring(?Beg,?End) -> ?R] :-
    	(atom(?X), integer(?Beg), integer(?End))@\prolog,
	!,
	flora_get_substring(?X,?Beg,?End,?R)@\prolog(flrporting).
?X[substring(?Beg,?End) -> ?R] :-
        \ischarlist(?X),
	\isinteger(?Beg), \isinteger(?End),
	!,
	atom_codes(?XX,?X)@\prolog,
	flora_get_substring(?XX,?Beg,?End,?R1)@\prolog(flrporting),
	atom_codes(?R1,?R)@\prolog.
// ?Beg/?End unbound
?X[substring(?Beg,?End) -> ?Y] :-
    	(\isatom(?X) ; \ischarlist(?X)),
	(\isatom(?Y) ; \ischarlist(?Y)),
	!,
    	flora_match_substring(?Y.rawValue,?X.rawValue,forward,?Beg,?End)@\prolog(flrporting).
// error
?X[substring(?Beg,?End) -> ?R] :-
        abort(['In ?Str[substring(?Beg,?End)->?Sub]@\basetype:\n\t?Str must be a string/symbol/charlist and either\n\t?Sub must be a string/symbol/charlist or ?Beg, ?End must be integers.\n\tActual call: ',
	        ?X, '[substring(', ?Beg, ',', ?End, ')->', ?R, ']'])@\system.
