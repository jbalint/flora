/* File:      include/flrbasetype_string.flh
**
** Author(s): Michael Kifer
**
** Contact:   flora-users@lists.sourceforge.net
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2013.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**      http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
**
*/


:- export
	?[startsWith(?)],
	?[endsWith(?)],
    	?[contains(?)],
	?[concat(?)->?],
	?[reverse->?],
	?[length->?],
	?[toUpper->?],
	?[toLower->?],
	?[substring(?,?)->?].

// startsWith
?X^^_string[startsWith(?Y^^_string)] :-  // dead code
	!,
    	flora_match_substring(?Y.rawValue,?X.rawValue,0)@_prolog(flrporting).
?X[startsWith(?Y)] :-
    	atom(?X)@_prolog, atom(?Y)@_prolog,
	!,
	flratom_begins_with(?X.rawValue,?Y.rawValue)@_prolog(flora_ground).

// endsWith
?X^^_string[endsWith(?Y^^_string)] :-  // dead code
	!,
	flratom_ends_with(?X.rawValue,?Y.rawValue)@_prolog(flora_ground).
?X[endsWith(?Y)] :-
    	atom(?X)@_prolog, atom(?Y)@_prolog,
	!,
	flratom_ends_with(?X.rawValue,?Y.rawValue)@_prolog(flora_ground).

// contains
?X^^_string[contains(?Y^^_string)] :-  // dead code
	!,
    	flora_match_substring(?Y.rawValue,?X.rawValue,?)@_prolog(flrporting).
?X[contains(?Y)] :-
    	atom(?X)@_prolog, atom(?Y)@_prolog,
    	flora_match_substring(?Y.rawValue,?X.rawValue,?)@_prolog(flrporting).

// concat
?X^^_string[concat(?Y^^_string) -> ?R] :-
	!,
    	flora_concat_atoms([?X.rawValue,?Y.rawValue],?R1)@_prolog(flrporting),
	_string[toType(?R1)->?R].
?X[concat(?Y) -> ?R] :-
    	atom(?X)@_prolog, atom(?Y)@_prolog,
	(_isstring(?X), _isstring(?Y)),
	!,
    	flora_concat_atoms([?X.rawValue,?Y.rawValue],?R1)@_prolog(flrporting),
	flora_concat_atoms([FL_STRING_TYPE_PREFIX,?R1],?R)@_prolog(flrporting).
/*
// this is replaced with _symbol[concat(List) -> ?R]
?X[concat(?Y) -> ?R] :-
    	atom(?X)@_prolog, atom(?Y)@_prolog,
	!,
    	flora_concat_atoms([?X.rawValue,?Y.rawValue],?R)@_prolog(flrporting).
*/
?X[concat(?Y) -> ?R] :-
        _ischarlist(?X), _ischarlist(?Y),
	!,
	append(?X,?Y,?R)@_prolog(basics).

// reverse
?X^^_string[reverse -> ?R] :-  // dead code
	!,
	atom_codes(?X.rawValue,?Codes)@_prolog,
	reverse(?Codes,?CodesR)@_prolog(basics),
	atom_codes(?R1,?CodesR)@_prolog,
	_string[toType(?R1)->?R].
?X[reverse -> ?R] :-
    	_isstring(?X),
	!,
	atom_codes(?X,?Codes)@_prolog,
	?Codes=[?p1,?p2|?CodesRaw],
	reverse(?CodesRaw,?CodesRvrs)@_prolog(basics),
	atom_codes(?R,[?p1,?p2|?CodesRvrs])@_prolog.
?X[reverse -> ?R] :-
    	_isatom(?X),
	?X\=[],
	!,
	atom_codes(?X,?Codes)@_prolog,
	reverse(?Codes,?CodesRvrs)@_prolog(basics),
	atom_codes(?R,?CodesRvrs)@_prolog.
/*
// this is done by the list type routines
?X[reverse -> ?R] :-
    	_ischarlist(?X),
	!,
	reverse(?X,?R)@_prolog(basics).
*/

// length
?X^^_string[length -> ?N] :-
	!,
    	flora_atom_length(?X.rawValue,?N)@_prolog(flrporting).
?X[length -> ?N] :-
	// this takes care of ^^_strings and atoms
    	_isatom(?X),
	!,
    	flora_atom_length(?X.rawValue,?N)@_prolog(flrporting).

// toUpper
?X^^_string[toUpper -> ?R] :-  // dead code
	!,
	flora_toUpper(?X.rawValue,?R1)@_prolog(flrdatatype_utils),
	_string[toType(?R1)->?R].
?X[toUpper -> ?R] :-
    	_isstring(?X),
	!,
	flora_toUpper(?X.rawValue,?R1)@_prolog(flrdatatype_utils),
	flora_concat_atoms([FL_STRING_TYPE_PREFIX,?R1],?R)@_prolog(flrporting).
?X[toUpper -> ?R] :-
    	atom(?X)@_prolog,
	!,
	flora_toUpper(?X,?R)@_prolog(flrdatatype_utils).
?X[toUpper -> ?R] :-
        _ischarlist(?X),
	!,
	flora_toUpper(?X.rawValue,?R1)@_prolog(flrdatatype_utils),
	atom_codes(?R1,?R)@_prolog.

// toLower
?X^^_string[toLower -> ?R] :-  // dead code
	!,
	flora_toLower(?X.rawValue,?R1)@_prolog(flrdatatype_utils),
	_string[toType(?R1)->?R].
?X[toLower -> ?R] :-
    	_isstring(?X),
	!,
	flora_toLower(?X.rawValue,?R1)@_prolog(flrdatatype_utils),
	flora_concat_atoms([FL_STRING_TYPE_PREFIX,?R1],?R)@_prolog(flrporting).
?X[toLower -> ?R] :-
    	atom(?X)@_prolog,
	!,
	flora_toLower(?X,?R)@_prolog(flrdatatype_utils).
?X[toLower -> ?R] :-
        _ischarlist(?X),
	!,
	flora_toLower(?X.rawValue,?R1)@_prolog(flrdatatype_utils),
	atom_codes(?R1,?R)@_prolog.

// substring
?X^^_string[substring(?Beg,?End) -> ?R] :-  // dead code
	!,
	flora_get_substring(?X.rawValue,?Beg,?End,?R1)@_prolog(flrporting),
	_string[toType(?R1)->?R].
?X[substring(?Beg,?End) -> ?R] :-
    	_isstring(?X),
	_isinteger(?Beg), _isinteger(?End),
	!,
	flora_get_substring(?X.rawValue,?Beg,?End,?R1)@_prolog(flrporting),
	flora_concat_atoms([FL_STRING_TYPE_PREFIX,?R1],?R)@_prolog(flrporting).
?X[substring(?Beg,?End) -> ?R] :-
    	(atom(?X), integer(?Beg), integer(?End))@_prolog,
	!,
	flora_get_substring(?X,?Beg,?End,?R)@_prolog(flrporting).
?X[substring(?Beg,?End) -> ?R] :-
        _ischarlist(?X),
	_isinteger(?Beg), _isinteger(?End),
	!,
	atom_codes(?XX,?X)@_prolog,
	flora_get_substring(?XX,?Beg,?End,?R1)@_prolog(flrporting),
	atom_codes(?R1,?R)@_prolog.
// ?Beg/?End unbound
?X[substring(?Beg,?End) -> ?Y] :-
    	(_isatom(?X) ; _ischarlist(?X)),
	(_isatom(?Y) ; _ischarlist(?Y)),
	!,
    	flora_match_substring(?Y.rawValue,?X.rawValue,forward,?Beg,?End)@_prolog(flrporting).
// error
?X[substring(?Beg,?End) -> ?R] :-
        abort(['In ?Str[substring(?Beg,?End)->?Sub]@_basetype:\n\t?Str must be a string/symbol/charlist and either\n\t?Sub must be a string/symbol/charlist or ?Beg, ?End must be integers.\n\tActual call: ',
	        ?X, '[substring(', ?Beg, ',', ?End, ')->', ?R, ']'])@_system.
