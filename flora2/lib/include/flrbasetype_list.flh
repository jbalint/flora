/* File:      include/flrbasetype_list.flh
**
** Author(s): Michael Kifer
**
** Contact:   flora-users@lists.sourceforge.net
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2013.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**      http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
**
*/


:- export
	?[startsWith(?)],
	?[endsWith(?)],
    	?[contains(?)],
    	?[member(?)],
	?[append(?)->?],
	?[length->?],
	?[reverse->?],
	?[sort->?],
	?[subset(?)].


// startsWith
?X^^_list[startsWith(?Y^^_list)] :-
    !,
    flora_startsWith_list(?X.rawValue,?Y.rawValue)@_prolog(flrdatatype_utils).
?X[startsWith(?Y)] :-
    is_list(?X)@_prolog,
    flora_startsWith_list(?X,?Y)@_prolog(flrdatatype_utils).

// endsWith
?X^^_list[endsWith(?Y^^_list)] :-
    !,
    reverse(?X.rawValue,?RX)@_prolog(basics),
    reverse(?Y.rawValue,?RY)@_prolog(basics),
    flora_startsWith_list(?RX,?RY)@_prolog(flrdatatype_utils).
?X[endsWith(?Y)] :-
    is_list(?X)@_prolog,
    reverse(?X,?RX)@_prolog(basics),
    reverse(?Y,?RY)@_prolog(basics),
    flora_startsWith_list(?RX,?RY)@_prolog(flrdatatype_utils).

// contains
?X^^_list[contains(?Y^^_list)] :-
    !,
    subseq(?X.rawValue,?Y.rawValue,?)@_prolog(basics).
?X[contains(?Y)] :-
    is_list(?X)@_prolog,
    is_list(?Y)@_prolog,
    subseq(?X,?Y,?)@_prolog(basics).

// member
?X^^_list[member(?Y)] :-
    !,
    member(?Y.rawValue,?X.rawValue)@_prolog(basics).
?X[member(?Y)] :-
    is_list(?X)@_prolog,
    member(?Y,?X)@_prolog(basics).

// append
?X^^_list[append(?Y^^_list) -> ?R] :-
    !,
    append(?X.rawValue,?Y.rawValue,?R)@_prolog(basics).
?X[append(?Y) -> ?R] :-
    is_list(?X)@_prolog,
    is_list(?Y)@_prolog,
    append(?X,?Y,?R)@_prolog(basics).

// length
?X^^_list[length -> ?R] :-
    (_isvar(?R), ! ; integer(?R)@_plg),
    !,
    length(?X.rawValue,?R)@_prolog(basics).
?X[length -> ?R] :-
    (_isvar(?R), ! ; integer(?R)@_plg),
    is_list(?X)@_prolog,
    length(?X,?R)@_prolog(basics).

// reverse
?X^^_list[reverse -> ?R] :-
    !,
    reverse(?X.rawValue,?R)@_prolog(basics).
?X[reverse -> ?R] :-
    is_list(?X)@_prolog,
    reverse(?X,?R)@_prolog(basics).

// sort
?X^^_list[sort -> ?R] :-
    !,
    sort(?X.rawValue,?R)@_prolog.
?X[sort -> ?R] :-
    is_list(?X)@_prolog,
    sort(?X,?R)@_prolog.

// subset
?X^^_list[subset(?Y^^_list)] :-
    !,
    subset(?Y.rawValue,?X.rawValue)@_prolog(basics).
?X[subset(?Y)] :-
    is_list(?X)@_prolog,
    is_list(?Y)@_prolog,
    subset(?Y,?X)@_prolog(basics).


