/* File:      include/flrbasetype_list.flh
**
** Author(s): Michael Kifer
**
** Contact:   flora-users@lists.sourceforge.net
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2013.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**      http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
**
*/


:- export{
	?[startsWith(?)],
	?[endsWith(?)],
    	?[contains(?)],
    	?[member(?)],
	?[append(?)->?],
	?[length->?],
	?[reverse->?],
	?[sort->?],
	?[subset(?)]}.


// startsWith
?X^^\list[startsWith(?Y^^\list)] :-
    !,
    flora_startsWith_list(?X.rawValue,?Y.rawValue)@\prolog(flrdatatype_utils).
?X[startsWith(?Y)] :-
    is_list(?X)@\prolog,
    flora_startsWith_list(?X,?Y)@\prolog(flrdatatype_utils).

// endsWith
?X^^\list[endsWith(?Y^^\list)] :-
    !,
    reverse(?X.rawValue,?RX)@\prolog(basics),
    reverse(?Y.rawValue,?RY)@\prolog(basics),
    flora_startsWith_list(?RX,?RY)@\prolog(flrdatatype_utils).
?X[endsWith(?Y)] :-
    is_list(?X)@\prolog,
    reverse(?X,?RX)@\prolog(basics),
    reverse(?Y,?RY)@\prolog(basics),
    flora_startsWith_list(?RX,?RY)@\prolog(flrdatatype_utils).

// contains
?X^^\list[contains(?Y^^\list)] :-
    !,
    subseq(?X.rawValue,?Y.rawValue,?)@\prolog(basics).
?X[contains(?Y)] :-
    is_list(?X)@\prolog,
    is_list(?Y)@\prolog,
    subseq(?X,?Y,?)@\prolog(basics).

// member
?X^^\list[member(?Y)] :-
    !,
    member(?Y.rawValue,?X.rawValue)@\prolog(basics).
?X[member(?Y)] :-
    is_list(?X)@\prolog,
    member(?Y,?X)@\prolog(basics).

// append
?X^^\list[append(?Y^^\list) -> ?R] :-
    !,
    append(?X.rawValue,?Y.rawValue,?R)@\prolog(basics).
?X[append(?Y) -> ?R] :-
    is_list(?X)@\prolog,
    is_list(?Y)@\prolog,
    append(?X,?Y,?R)@\prolog(basics).

// length
?X^^\list[length -> ?R] :-
    (isvar{?R}, ! ; integer(?R)@\plg),
    !,
    length(?X.rawValue,?R)@\prolog(basics).
?X[length -> ?R] :-
    (isvar{?R}, ! ; integer(?R)@\plg),
    is_list(?X)@\prolog,
    length(?X,?R)@\prolog(basics).

// reverse
?X^^\list[reverse -> ?R] :-
    !,
    reverse(?X.rawValue,?R)@\prolog(basics).
?X[reverse -> ?R] :-
    is_list(?X)@\prolog,
    reverse(?X,?R)@\prolog(basics).

// sort
?X^^\list[sort -> ?R] :-
    !,
    sort(?X.rawValue,?R)@\prolog.
?X[sort -> ?R] :-
    is_list(?X)@\prolog,
    sort(?X,?R)@\prolog.

// subset
?X^^\list[subset(?Y^^\list)] :-
    !,
    subset(?Y.rawValue,?X.rawValue)@\prolog(basics).
?X[subset(?Y)] :-
    is_list(?X)@\prolog,
    is_list(?Y)@\prolog,
    subset(?Y,?X)@\prolog(basics).


