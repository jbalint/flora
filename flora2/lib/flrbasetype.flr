/* File:      flrbasetype.flr
**
** Author(s): Michael Kifer
**
** Contact:   flora-users@lists.sourceforge.net
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2013.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**      http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
**
*/



#include "flora_terms.flh"

:- export
        ?[_toSymbol->?],
        ?[_rawValue->?],
        ?[_typeName->?],
        ?[_equals(?)],
        ?[_isTypeOf(?)],
        ?[_lessThan(?)],
        ?[_add(?) -> ?],
	// non-strict convert to type: fail for args of wrong types
        ?[_toType(?)->?],                   // all types
        ?[_toType(?,?,?,?,?,?)->?],         // _time/6 
        ?[_toType(?,?,?,?,?,?,?)->?],       // _date/7, _uri/7, _duration/7
        ?[_toType(?,?,?,?,?,?,?,?,?,?)->?], // _dateTime/10

	?[_hour->?],
	?[_minute->?],
	?[_second->?],
	?[_dateSign->?],
	?[_year->?],
	?[_month->?],
	?[_day->?],
	?[_zoneSign->?],
	?[_zoneHour->?],
	?[_zoneMinute->?].

:- ignore_depchk %abort(?)@_system.
:- ignore_depchk ?[%mustDefine(?)]@_sys, ?[%mustDefine(?,?)]@_sys.


?D[?M->?] :-
	_isvar(?M),
	!,
	%abort(['Attempt to apply an unbound method ', ?M,
	        ' to a basic data type object ', ?D])@_sys.
?D[?M->?] :-
	_isvar(?D),
	!,
	%abort(['Attempt to apply method ', ?M,
	        ' to an unbound basic data type object ', ?D])@_sys.

// time
?D^^_time[_hour->?V] :- hour(?D,?V)@_prolog(flrdatatype), !.
?D^^_time[_minute->?V] :- minute(?D,?V)@_prolog(flrdatatype), !.
?D^^_time[_second->?V] :- second(?D,?V)@_prolog(flrdatatype), !.
?D^^_time[_zoneSign->?V] :- zoneSign(?D,?V)@_prolog(flrdatatype), !.
?D^^_time[_zoneHour->?V] :- zoneHour(?D,?V)@_prolog(flrdatatype), !.
?D^^_time[_zoneMinute->?V] :- zoneMinute(?D,?V)@_prolog(flrdatatype), !.
?D^^_time[_lessThan(?D2^^_time)] :-
	flora_type_numeric_value(?D,?V)@_prolog(flrdatatype),
	flora_type_numeric_value(?D2,?V2)@_prolog(flrdatatype),
	?V @< ?V2.

// date
?D^^_date[_dateSign->?V] :- datesign(?D,?V)@_prolog(flrdatatype), !.
?D^^_date[_year->?V] :- year(?D,?V)@_prolog(flrdatatype), !.
?D^^_date[_month->?V] :- month(?D,?V)@_prolog(flrdatatype), !.
?D^^_date[_day->?V] :- day(?D,?V)@_prolog(flrdatatype), !.
?D^^_date[_zoneSign->?V] :- zoneSign(?D,?V)@_prolog(flrdatatype), !.
?D^^_date[_zoneHour->?V] :- zoneHour(?D,?V)@_prolog(flrdatatype), !.
?D^^_date[_zoneMinute->?V] :- zoneMinute(?D,?V)@_prolog(flrdatatype), !.
?D^^_date[_lessThan(?D2^^_date)] :-
	flora_type_numeric_value(?D,?V)@_prolog(flrdatatype),
	flora_type_numeric_value(?D2,?V2)@_prolog(flrdatatype),
	?V @< ?V2.

// dateTime
?D^^_dateTime[_hour->?V] :- hour(?D,?V)@_prolog(flrdatatype), !.
?D^^_dateTime[_minute->?V] :- minute(?D,?V)@_prolog(flrdatatype), !.
?D^^_dateTime[_second->?V] :- second(?D,?V)@_prolog(flrdatatype), !.
?D^^_dateTime[_dateSign->?V] :- datesign(?D,?V)@_prolog(flrdatatype), !.
?D^^_dateTime[_year->?V] :- year(?D,?V)@_prolog(flrdatatype), !.
?D^^_dateTime[_month->?V] :- month(?D,?V)@_prolog(flrdatatype), !.
?D^^_dateTime[_day->?V] :- day(?D,?V)@_prolog(flrdatatype), !.
?D^^_dateTime[_zoneSign->?V] :- zoneSign(?D,?V)@_prolog(flrdatatype), !.
?D^^_dateTime[_zoneHour->?V] :- zoneHour(?D,?V)@_prolog(flrdatatype), !.
?D^^_dateTime[_zoneMinute->?V] :- zoneMinute(?D,?V)@_prolog(flrdatatype), !.
?D^^_dateTime[_lessThan(?D2^^_dateTime)] :-
	flora_type_numeric_value(?D,?V)@_prolog(flrdatatype),
	flora_type_numeric_value(?D2,?V2)@_prolog(flrdatatype),
	?V @< ?V2.


// _duration
?D^^_duration[_hour->?V] :- hour(?D,?V)@_prolog(flrdatatype), !.
?D^^_duration[_minute->?V] :- minute(?D,?V)@_prolog(flrdatatype), !.
?D^^_duration[_second->?V] :- second(?D,?V)@_prolog(flrdatatype), !.
?D^^_duration[_dateSign->?V] :- datesign(?D,?V)@_prolog(flrdatatype), !.
?D^^_duration[_year->?V] :- year(?D,?V)@_prolog(flrdatatype), !.
?D^^_duration[_month->?V] :- month(?D,?V)@_prolog(flrdatatype), !.
?D^^_duration[_day->?V] :- day(?D,?V)@_prolog(flrdatatype), !.
?D^^_duration[_lessThan(?D2^^_duration)] :-
	flora_type_numeric_value(?D,?V)@_prolog(flrdatatype),
	flora_type_numeric_value(?D2,?V2)@_prolog(flrdatatype),
	?V @< ?V2.

// numbers
?N[_lessThan(?N2)] :- number(?N)@_prolog, number(?N2)@_prolog, ?N < ?N2.
?N[_lessThan(?N2)] :-
	?N[_rawValue->?V],
	?N2[_rawValue->?V2],
	number(?V)@_prolog, number(?V2)@_prolog, ?V < ?V2.

// strings
?N[_lessThan(?N2)] :- ?N:_string, ?N2:_string, ?N._rawValue @< ?N2._rawValue.

// symbols
?N[_lessThan(?N2)] :- ?N : FL_SYMBOL, N2 : FL_SYMBOL, ?N._rawValue @< ?N2._rawValue.

?D[_rawValue->?V] :- flora_datatype_raw_value(?D,?V)@_prolog(flrdatatype), !.
?D[_typeName->?V] :- flora_datatype_name(?D,?V)@_prolog(flrdatatype), !.

?_D[_equals(?_D)] :- !.

?T[_isTypeOf(?V)] :- flora_datatype_name(?V,?T)@_prolog(flrdatatype), !.
// catch cases when class methods are applied to instances by mistake
?T[_isTypeOf(?)] :- class_type_error(?T,'_isTypeOf(?) -> ?').

// these are supposed to fail, if no error
?T[_toType(?)->?] :- class_type_error(?T,'_toType(?) -> ?').
?T[_toType(?,?,?,?,?,?)->?] :-                                        // 6 args
	class_type_error(?T,'_toType(?) -> ?').
?T[_toType(?,?,?,?,?,?,?)->?] :-                                      // 7 args
	class_type_error(?T,'_toType(?) -> ?').
?T[_toType(?,?,?,?,?,?,?,?,?,?)->?] :-                                // 10 args
	class_type_error(?T,'_toType(?) -> ?').


/*
?T[_toType(?V)->?] :- 
	?V[_typeName->?TN],
	?TN \== ?T,
	flora_decode_oid_as_atom(?T,?PrintableT)@_prolog(flrdecode),
	flora_decode_oid_as_atom(?V,?PrintableV)@_prolog(flrdecode),
	%abort([?PrintableT,'[_toType(',?PrintableV,')->?]: argument ',
	        ?PrintableV,' must be a literal of type ',?PrintableT])@_system.
*/


// The 1-argument version is for:
//      FL_LONG, FL_DOUBLE, FL_STRING, FL_CHARLIST, FL_BOOL
// Also for FL_DATE, FL_TIME, FL_URI, and FL_DATETIME, but we need to implement
// this in flrdatatype_parse.P
// These use the no-check versions of flora_make_datatype/3, which
// fail if argument is not convertible to the target data type
FL_SYMBOL[_toType(?A)->?Obj] :- !, ?A[_toSymbol->?Obj].
?T[_toType(?A)->?Obj] :-
	?ParsedRepr =.. [?T,?A],
	// FL_STRING, FL_IRI
	flora_special_datatype_internal_representation(?ParsedRepr,?Obj)@_prolog(flrdatatype),
	!.
?T[_toType(?A)->?Obj] :-
	?A[_rawValue->?RA],
	flora_make_datatype(?T,(?RA),?Obj1)@_prolog(flrdatatype_parse),
	// special treatment for IRIs - hide their data type
	if ?T == _iri then ?Obj1[_toSymbol->?Obj]
        else ?Obj = ?Obj1.

// the 6-arg is for FL_TIME
?T[_toType(?A1,?A2,?A3,?A4,?A5,?A6)->?Obj] :-
	flora_make_datatype(?T,(?A1,?A2,?A3,?A4,?A5,?A6),?Obj)@_prolog(flrdatatype_parse).
// the 7-arg is for FL_DATE, FL_TIME, FL_URI, FL_DURATION
?T[_toType(?A1,?A2,?A3,?A4,?A5,?A6,?A7)->?Obj] :-
	flora_make_datatype(?T,(?A1,?A2,?A3,?A4,?A5,?A6,?A7),?Obj1)@_prolog(flrdatatype_parse),
	// special treatment for IRIs - hide their data type
	if ?T == _iri then ?Obj1[_toSymbol->?Obj]
        else ?Obj = ?Obj1.
// this 10-argument version is for FL_DATETIME
?T[_toType(?A1,?A2,?A3,?A4,?A5,?A6,?A7,?A8,?A9,?A10)->?Obj] :-
	flora_make_datatype(?T,(?A1,?A2,?A3,?A4,?A5,?A6,?A7,?A8,?A9,?A10),?Obj)@_prolog(flrdatatype_parse).

// this is supposed to fail, if everything is right
// ?Typ must be a string data type or an atom?
class_type_error(?Typ,?Meth) :-
	flora_builtin_datatype(?BI)@_prolog(flrdatatype),
	if (Method[%mustDefine(?Mode)]@_sys, ?Mode==on)
	then Method[%mustDefine(off)]@_sys,
	if (?Typ : ?BI, ?BI !== _string)
        then Method[%mustDefine(?Mode)]@_sys
        else (Method[%mustDefine(?Mode)]@_sys, fail),
	flora_decode_oid_as_atom(?Typ,?PrintableT)@_prolog(flrdecode),
	%abort([?PrintableT, '[', ?Meth, ']: ',
	        ?PrintableT, ' must be a data type'])@_system.


// addition of types
?T[_add(?T1) -> ?T2] :-
	(_ground(?T), _ground(?T1)
        -->> flora_dt_add(?T,?T1,?T2)@_prolog(flrdatatype)
        ; flora_decode_goal_as_atom_substitute_vars(${?T[_add(?T1) -> ?T2]},?Code)@_plg(flrdecode),
	  flora_decode_goal_as_atom_substitute_vars(?T,?TCode)@_plg(flrdecode),
	  flora_decode_goal_as_atom_substitute_vars(?T1,?T1Code)@_plg(flrdecode),
	  %abort(['In ', ?Code, ': ',
		  ?TCode, ' and ', ?T1Code, ' must be ground data types'])@_system
	).



// Included stuff
#include "flrbasetype_iri.flh"

#include "flrbasetype_signatures.flh"
#include "flrbasetype_double.flh"
#include "flrbasetype_string.flh"
#include "flrbasetype_symbol.flh"
#include "flrbasetype_list.flh"

