/* File:      flrbasetype.flr
**
** Author(s): Michael Kifer
**
** Contact:   flora-users@lists.sourceforge.net
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2013.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**      http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
**
*/

:- nontabled_module.

:- prolog class_type_error/2.

#include "flora_terms.flh"

:- suppress_rule_signatures.
:- export
        ?[toSymbol->?],
        ?[rawValue->?],
        ?[typeName->?],
        ?[equals(?)],
        ?[isTypeOf(?)],
        ?[lessThan(?)],
        ?[add(?) -> ?],
	// non-strict convert to type: fail for args of wrong types
        ?[toType(?)->?],                   // all types
        ?[toType(?,?,?,?,?,?)->?],         // _time/6 
        ?[toType(?,?,?,?,?,?,?)->?],       // _date/7, _uri/7, _duration/7
        ?[toType(?,?,?,?,?,?,?,?,?,?)->?], // _dateTime/10

	?[hour->?],
	?[minute->?],
	?[second->?],
	?[dateSign->?],
	?[year->?],
	?[month->?],
	?[day->?],
	?[zoneSign->?],
	?[zoneHour->?],
	?[zoneMinute->?].

:- ignore_depchk abort(?)@_system.
:- ignore_depchk ?[mustDefine(?)]@_sys, ?[mustDefine(?,?)]@_sys.


?D[?M->?] :-
	_isvar(?M),
	!,
	abort(['Attempt to apply an unbound method ', ?M,
	        ' to a basic data type object ', ?D])@_sys.
?D[?M->?] :-
	_isvar(?D),
	!,
	abort(['Attempt to apply method ', ?M,
	        ' to an unbound basic data type object ', ?D])@_sys.

// time
?D^^_time[hour->?V] :- hour(?D,?V)@_prolog(flrdatatype), !.
?D^^_time[minute->?V] :- minute(?D,?V)@_prolog(flrdatatype), !.
?D^^_time[second->?V] :- second(?D,?V)@_prolog(flrdatatype), !.
?D^^_time[zoneSign->?V] :- zoneSign(?D,?V)@_prolog(flrdatatype), !.
?D^^_time[zoneHour->?V] :- zoneHour(?D,?V)@_prolog(flrdatatype), !.
?D^^_time[zoneMinute->?V] :- zoneMinute(?D,?V)@_prolog(flrdatatype), !.
?D^^_time[lessThan(?D2^^_time)] :-
	flora_type_numeric_value(?D,?V)@_prolog(flrdatatype),
	flora_type_numeric_value(?D2,?V2)@_prolog(flrdatatype),
	?V @< ?V2.

// date
?D^^_date[dateSign->?V] :- datesign(?D,?V)@_prolog(flrdatatype), !.
?D^^_date[year->?V] :- year(?D,?V)@_prolog(flrdatatype), !.
?D^^_date[month->?V] :- month(?D,?V)@_prolog(flrdatatype), !.
?D^^_date[day->?V] :- day(?D,?V)@_prolog(flrdatatype), !.
?D^^_date[zoneSign->?V] :- zoneSign(?D,?V)@_prolog(flrdatatype), !.
?D^^_date[zoneHour->?V] :- zoneHour(?D,?V)@_prolog(flrdatatype), !.
?D^^_date[zoneMinute->?V] :- zoneMinute(?D,?V)@_prolog(flrdatatype), !.
?D^^_date[lessThan(?D2^^_date)] :-
	flora_type_numeric_value(?D,?V)@_prolog(flrdatatype),
	flora_type_numeric_value(?D2,?V2)@_prolog(flrdatatype),
	?V @< ?V2.

// dateTime
?D^^_dateTime[hour->?V] :- hour(?D,?V)@_prolog(flrdatatype), !.
?D^^_dateTime[minute->?V] :- minute(?D,?V)@_prolog(flrdatatype), !.
?D^^_dateTime[second->?V] :- second(?D,?V)@_prolog(flrdatatype), !.
?D^^_dateTime[dateSign->?V] :- datesign(?D,?V)@_prolog(flrdatatype), !.
?D^^_dateTime[year->?V] :- year(?D,?V)@_prolog(flrdatatype), !.
?D^^_dateTime[month->?V] :- month(?D,?V)@_prolog(flrdatatype), !.
?D^^_dateTime[day->?V] :- day(?D,?V)@_prolog(flrdatatype), !.
?D^^_dateTime[zoneSign->?V] :- zoneSign(?D,?V)@_prolog(flrdatatype), !.
?D^^_dateTime[zoneHour->?V] :- zoneHour(?D,?V)@_prolog(flrdatatype), !.
?D^^_dateTime[zoneMinute->?V] :- zoneMinute(?D,?V)@_prolog(flrdatatype), !.
?D^^_dateTime[lessThan(?D2^^_dateTime)] :-
	flora_type_numeric_value(?D,?V)@_prolog(flrdatatype),
	flora_type_numeric_value(?D2,?V2)@_prolog(flrdatatype),
	?V @< ?V2.


// _duration
?D^^_duration[hour->?V] :- hour(?D,?V)@_prolog(flrdatatype), !.
?D^^_duration[minute->?V] :- minute(?D,?V)@_prolog(flrdatatype), !.
?D^^_duration[second->?V] :- second(?D,?V)@_prolog(flrdatatype), !.
?D^^_duration[dateSign->?V] :- datesign(?D,?V)@_prolog(flrdatatype), !.
?D^^_duration[year->?V] :- year(?D,?V)@_prolog(flrdatatype), !.
?D^^_duration[month->?V] :- month(?D,?V)@_prolog(flrdatatype), !.
?D^^_duration[day->?V] :- day(?D,?V)@_prolog(flrdatatype), !.
?D^^_duration[lessThan(?D2^^_duration)] :-
	flora_type_numeric_value(?D,?V)@_prolog(flrdatatype),
	flora_type_numeric_value(?D2,?V2)@_prolog(flrdatatype),
	?V @< ?V2.

// numbers
?N[lessThan(?N2)] :- number(?N)@_prolog, number(?N2)@_prolog, ?N < ?N2.
?N[lessThan(?N2)] :-
	?N[rawValue->?V],
	?N2[rawValue->?V2],
	number(?V)@_prolog, number(?V2)@_prolog, ?V < ?V2.

// strings
?N[lessThan(?N2)] :- ?N:_string, ?N2:_string, ?N.rawValue @< ?N2.rawValue.

// symbols
?N[lessThan(?N2)] :- ?N : FL_SYMBOL, ?N2 : FL_SYMBOL, ?N.rawValue @< ?N2.rawValue.
// IRIs
?N[lessThan(?N2)] :- ?N : FL_IRI, ?N2 : FL_IRI, ?N.rawValue @< ?N2.rawValue.

?D[rawValue->?V] :- flora_datatype_raw_value(?D,?V)@_prolog(flrdatatype), !.
?D[typeName->?V] :- flora_datatype_name(?D,?V)@_prolog(flrdatatype), !.

?_D[equals(?_D)] :- !.

?T[isTypeOf(?V)] :- flora_datatype_name(?V,?T)@_prolog(flrdatatype), !.
// catch cases when class methods are applied to instances by mistake
?T[isTypeOf(?)] :- class_type_error(?T,'_isTypeOf(?) -> ?').

// these are supposed to fail, if no error
?T[toType(?)->?] :- class_type_error(?T,'toType(?) -> ?').
?T[toType(?,?,?,?,?,?)->?] :-                                        // 6 args
	class_type_error(?T,'toType(?) -> ?').
?T[toType(?,?,?,?,?,?,?)->?] :-                                      // 7 args
	class_type_error(?T,'toType(?) -> ?').
?T[toType(?,?,?,?,?,?,?,?,?,?)->?] :-                                // 10 args
	class_type_error(?T,'toType(?) -> ?').


/*
?T[toType(?V)->?] :- 
	?V[typeName->?TN],
	?TN \== ?T,
	flora_decode_oid_as_atom(?T,?PrintableT)@_prolog(flrdecode),
	flora_decode_oid_as_atom(?V,?PrintableV)@_prolog(flrdecode),
	abort([?PrintableT,'[toType(',?PrintableV,')->?]: argument ',
	        ?PrintableV,' must be a literal of type ',?PrintableT])@_system.
*/


// The 1-argument version is for:
//      FL_LONG, FL_DOUBLE, FL_STRING, FL_CHARLIST, FL_BOOL
// Also for FL_DATE, FL_TIME, FL_URI, and FL_DATETIME, but we need to implement
// this in flrdatatype_parse.P
// These use the no-check versions of flora_make_datatype/3, which
// fail if argument is not convertible to the target data type
FL_SYMBOL[toType(?A)->?Obj] :- !, ?A[toSymbol->?Obj].
?T[toType(?A)->?Obj] :-
	?ParsedRepr =.. [?T,?A],
	// FL_STRING, FL_IRI
	flora_special_datatype_internal_representation(?ParsedRepr,?Obj)@_prolog(flrdatatype),
	!.
?T[toType(?A)->?Obj] :-
	?A[rawValue->?RA],
	flora_make_datatype(?T,(?RA),?Obj1)@_prolog(flrdatatype_parse),
	// special treatment for IRIs - hide their data type
	if ?T == _iri then ?Obj1[toSymbol->?Obj]
        else ?Obj = ?Obj1.

// the 6-arg is for FL_TIME
?T[toType(?A1,?A2,?A3,?A4,?A5,?A6)->?Obj] :-
	flora_make_datatype(?T,(?A1,?A2,?A3,?A4,?A5,?A6),?Obj)@_prolog(flrdatatype_parse).
// the 7-arg is for FL_DATE, FL_TIME, FL_URI, FL_DURATION
?T[toType(?A1,?A2,?A3,?A4,?A5,?A6,?A7)->?Obj] :-
	flora_make_datatype(?T,(?A1,?A2,?A3,?A4,?A5,?A6,?A7),?Obj1)@_prolog(flrdatatype_parse),
	// special treatment for IRIs - hide their data type
	if ?T == _iri then ?Obj1[toSymbol->?Obj]
        else ?Obj = ?Obj1.
// this 10-argument version is for FL_DATETIME
?T[toType(?A1,?A2,?A3,?A4,?A5,?A6,?A7,?A8,?A9,?A10)->?Obj] :-
	flora_make_datatype(?T,(?A1,?A2,?A3,?A4,?A5,?A6,?A7,?A8,?A9,?A10),?Obj)@_prolog(flrdatatype_parse).

// this is supposed to fail, if everything is right
// ?Typ must be a string data type or an atom?
class_type_error(?Typ,?Meth) :-
	flora_builtin_datatype(?BI)@_prolog(flrdatatype),
	if (Method[mustDefine(?Mode)]@_sys, ?Mode==on)
	then Method[mustDefine(off)]@_sys,
	if (?Typ : ?BI, ?BI !== _string)
        then Method[mustDefine(?Mode)]@_sys
        else (Method[mustDefine(?Mode)]@_sys, fail),
	flora_decode_oid_as_atom(?Typ,?PrintableT)@_prolog(flrdecode),
	abort([?PrintableT, '[', ?Meth, ']: ',
	        ?PrintableT, ' must be a data type'])@_system.


// addition of types
?T[add(?T1) -> ?T2] :-
	(_ground(?T), _ground(?T1)
        -->> flora_dt_add(?T,?T1,?T2)@_prolog(flrdatatype)
        ; flora_decode_goal_as_atom_substitute_vars(${?T[add(?T1) -> ?T2]},?Code)@_plg(flrdecode),
	  flora_decode_goal_as_atom_substitute_vars(?T,?TCode)@_plg(flrdecode),
	  flora_decode_goal_as_atom_substitute_vars(?T1,?T1Code)@_plg(flrdecode),
	  abort(['In ', ?Code, ': ',
		  ?TCode, ' and ', ?T1Code, ' must be ground data types'])@_system
	).



// Included stuff
#include "flrbasetype_iri.flh"

#include "flrbasetype_signatures.flh"
#include "flrbasetype_double.flh"
#include "flrbasetype_string.flh"
#include "flrbasetype_symbol.flh"
#include "flrbasetype_list.flh"

