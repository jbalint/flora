/* File:      flrtypeconstraint.flr
**
** Author(s): Hui Wan
**
** Contact:   flora-users@lists.sourceforge.net
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2013.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**      http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
**
*/

/*
  This module MUST be tabled. Otherwise, if this module is imported then calls
  to Type[check(...) will loop. This is because Type[check(Frame)@_typecheck
  calls Frame@caller, and Frame@caller will call (through importaxioms.fli)
  Frame@_typecheck. Since the latter is not tabled, we run into an
  infinite loop.
*/
//:- nontabled_module.

#include "flora_terms.flh"

:- suppress_rule_signatures.
:- symbol_context check(?), check(?,?,?).

:- prolog boundViolated/5, 
	not_complies_with_type_list/3, checkBounds/2.
:- prolog is_native/1, typeCheckInternal/6, typeCheckBoolInternal/6.

:- export
       ?[check(?,?)],
       ?[check(?)].

Cardinality[check(?Atom)] :-
	?Atom !~ ?Obj[?Meth => ?]@?Mod,
	?Atom !~ ?Obj[?Meth {?LowBound:?HighBound} => ?]@?Mod,
	?Atom !~ ?Obj[?Meth *=> ?]@?Mod,
	?Atom !~ ?Obj[?Meth {?LowBound:?HighBound} *=> ?]@?Mod,
	flora_decode_goal_as_atom(?Atom,?AtmString)@_prolog(flrdecode),
	abort(['Cardinality[check(',
		 ?AtmString,
		 ')]@_typecheck: Invalid signature argument'])@_sys.

Cardinality[check(?Atom)] :-
	( ?Atom ~ ?Obj[?Meth => ?]@?Mod
        ; ?Atom ~ ?Obj[?Meth {?LowBound:?HighBound} => ?]@?Mod
        ),
	// ?Mod==FLSYSMODTYPECHECK, if module wasn't specified
	if ?Mod == FLSYSMODTYPECHECK then caller{?RealMod} else ?RealMod=?Mod,
	checkBounds(?LowBound,?HighBound),
	(is_native(${?[?Meth->?]@?RealMod})
         ; is_native(${?[?Meth=>?]@?RealMod})
         ; is_native(${?[?Meth*=>?]@?RealMod})
        ),
	?Obj[?Meth {?Low:?High}  => ?]@?RealMod,
	?Count = count{?V | ?Obj[?Meth -> ?V]@?RealMod},
	// use @> to compare ?Count and ?High since ?High may be '*'
	(?Count < ?Low ; ?Count @> ?High),
	boundViolated(?Count,?Low,?High,?LowBound,?HighBound).
	

Cardinality[check(?Atom)] :-
	( ?Atom ~ ?Obj[?Meth *=> ?]@?Mod
        ; ?Atom ~ ?Obj[?Meth {?LowBound:?HighBound} *=> ?]@?Mod
        ),
	// ?Mod==FLSYSMODTYPECHECK, if module wasn't specified
	if ?Mod == FLSYSMODTYPECHECK then caller{?RealMod} else ?RealMod=?Mod,
	checkBounds(?LowBound,?HighBound),
	(is_native(${?[?Meth*->?]@?RealMod})
	 ; is_native(${?[?Meth*=>?]@?RealMod})
        ),
	?Obj[?Meth {?Low:?High} *=> ?]@?RealMod,
	?Count = count{?V | ?Obj[?Meth *-> ?V]@?RealMod},
	// use @> to compare ?Count and ?High since ?High may be '*'
	(?Count < ?Low ; ?Count @> ?High),
	boundViolated(?Count,?Low,?High,?LowBound,?HighBound).

/*****************************************************************************
    Utilities for cardinality check
*****************************************************************************/

/*****************************************************************************
	    checkBounds(-LowBound,-HighBound)

  Verify that ?LowBound and ?HighBound should be unbound variables,
  and should not be equal.
*****************************************************************************/
checkBounds(?LowBound,?HighBound) :-
	if ?HighBound == ?LowBound  then
	    abort('Error in Cardinality[check(?[?Method {?Low:?High} => ?])]@_typecheck: Low and high bounds must be different')@_sys,
	if _isnonvar(?LowBound) then  
	    abort('Error in Cardinality[check(?[?Method {?Low:?High} => ?])]@_typecheck: ?Low must be an unbound variable')@_sys,
	if _isnonvar(?HighBound) then 
	    abort('Error in Cardinality[check(?[?Method {?Low:?High} => ?])]@_typecheck: ?High must be an unbound variable')@_sys.


/*****************************************************************************
	    boundViolated(+Count,+Low,+High,-LowBound,-HighBound)

  ?Count is the actual cardinality, ?Low and ?High are the bounds,
  ?LowBound and ?HighBound signal the violated bounds.
*****************************************************************************/
boundViolated(?Count,?Low,?High,?LowBound,?HighBound) :-
	if ?Count < ?Low then
	    ?LowBound = ?Low // The lower bound is violated, bind ?LowBound
          	             // to the violated lower bound; else, bind to 'ok'.
	else ?LowBound = NOT_VIOLATED,
	if ?Count @> ?High then
	    ?HighBound = ?High // The higher bound is violated, bind ?HighBound
	                       // to the violated high bound; else bind to 'ok'.
	else ?HighBound = NOT_VIOLATED.



/******************************************************************************
   Type checking;
	  Type[typeCheck(+?Atom,-?Result)
          If ?Atom = -> then both -> and *-> are checked. Missing types flagged
             ?Atom = *-> then only *-> are checked. Missing types not flagged
             ?Atom = => then ->, *-> are checked. Missing types not flagged
                        (semistructured data)
             ?Atom = *=> then only *-> are checked. Missing types not flagged
******************************************************************************/

Type[check(?Atom,?Result)] :-
	caller{?CallerMod},
        Method[mustDefine(?Stat(?CallerMod))]@_sys,
        Method[mustDefine(off(?CallerMod))]@_sys,
	?Result = collectset{?Res|true{Type[check(?Atom,?CallerMod,?Res)]}},
        Method[mustDefine(?Stat(?CallerMod))]@_sys.

// check/3 - internal
Type[check(?Atom,?CallerMod,?Result)] :-
	?Atom ~ ?Class[?Meth -> ?]@?,
	_isloaded(?CallerMod),
	!,
	typeCheckInternal(?,?,?Class,?Meth,?CallerMod,?Result).

Type[check(?Atom,?CallerMod,?Result)] :-
	?Atom ~ ?Class[?Meth *-> ?]@?,
	_isloaded(?CallerMod),
	!,
	typeCheckInternal(defaultonly,?,?Class,?Meth,?CallerMod,?Result).

Type[check(?Atom,?CallerMod,?Result)] :-
	?Atom ~ ?Class[?Meth => ?]@?,
	_isloaded(?CallerMod),
	!,
	typeCheckInternal(?,nonstrict,?Class,?Meth,?CallerMod,?Result).

Type[check(?Atom,?CallerMod,?Result)] :-
	?Atom ~ ?Class[?Meth *=> ?]@?,
	_isloaded(?CallerMod),
	!,
	typeCheckInternal(defaultonly,nonstrict,?Class,?Meth,?CallerMod,?Result).

// For Boolean methods
Type[check(?Atom,?CallerMod,?Result)] :-
	?Atom ~ ?Class[?Meth]@?,
	_isloaded(?CallerMod),
	!,
	typeCheckBoolInternal(?,?,?Class,?Meth,?CallerMod,?Result).

Type[check(?Atom,?CallerMod,?Result)] :-
	?Atom ~ ?Class[*?Meth]@?,
	_isloaded(?CallerMod),
	!,
	typeCheckBoolInternal(defaultonly,?,?Class,?Meth,?CallerMod,?Result).

Type[check(?Atom,?CallerMod,?Result)] :-
	?Atom ~ ?Class[=>?Meth]@?,
	_isloaded(?CallerMod),
	!,
	typeCheckBoolInternal(?,nonstrict,?Class,?Meth,?CallerMod,?Result).

Type[check(?Atom,?CallerMod,?Result)] :-
	?Atom ~ ?Class[*=>?Meth]@?,
	_isloaded(?CallerMod),
	!,
	typeCheckBoolInternal(defaultonly,nonstrict,?Class,?Meth,?CallerMod,?Result).

Type[check(?Atom,?_Mod,?_Result)] :-
	flora_decode_goal_as_atom(?Atom,?AtmString)@_prolog(flrdecode),
	abort(['Type[check(',
		 ?AtmString,',?Result',
		 ')]@_typecheck: Invalid first argument'])@_sys.


	
// wrong type, nondefault, nonstrict
typeCheckInternal(allsigns,?,?Class,?Method,?Module,?Result) :- 
	_isloaded(?Module),
	(is_native(${?[?Method->?]@?Module})
	; is_native(${?[?Method*->?]@?Module})
        ),
	?O[?Method->?Val, ?Method=>?Type]@?Module,
	if _isnonvar(?Class) then ?O:?Class@?Module,
	naf ?Val:?Type@?Module,
	?Result ~ ?O[?Method->?Val, ?Method=>?Type]@?Module.

// missing type, nondefault sign, strict
typeCheckInternal(allsigns,strict,?Class,?Method,?Module,?Result) :-
	_isloaded(?Module),
	(is_native(${?[?Method  ->?]@?Module})
	; is_native(${?[?Method*->?]@?Module})
        ),
        (?O[?Method -> ?Val], naf ?O[?Method => ?])@?Module,
	if _isnonvar(?Class) then ?O:?Class@?Module,
	?Result ~ ?O[?Method -> ?Val]@?Module.

// wrong type, default sign, nonstrict
typeCheckInternal(?,?,?Class,?Method,?Module,?Result) :- 
	_isloaded(?Module),
	is_native(${?[?Method*->?]@?Module}),
	?O[?Method*->?Val, ?Method*=>?Type]@?Module,
	if _isnonvar(?Class) then ?O:?Class@?Module,
	naf ?Val:?Type@?Module,
	?Result ~ ?O[?Method*->?Val, ?Method*=>?Type]@?Module.

// missing type, default sign, strict (not checked if nonstrict)
typeCheckInternal(?,strict,?Class,?Method,?Module,?Result) :-
	_isloaded(?Module),
	is_native(${?[?Method*->?]@?Module}),
        (?O[?Method *-> ?Val], naf ?O[?Method *=> ?])@?Module,
	if _isnonvar(?Class) then ?O:?Class@?Module,
	?Result ~ ?O[?Method *-> ?Val]@?Module.



// Same for Boolean methods
// wrong type, nondefault, nonstrict
typeCheckBoolInternal(allsigns,?,?Class,?Method,?Module,?Result) :- 
	_isloaded(?Module),
	(is_native(${?[?Method]@?Module})
	; is_native(${?[*?Method]@?Module})
        ),
	?O[?Method]@?Module,
	generalize_method(?Method,?MethodType,?MethArgs,?Types)@_plg(flrauxil),
	?O[=>?MethodType]@?Module,
	if _isnonvar(?Class) then ?O:?Class@?Module,
	not_complies_with_type_list(?MethArgs,?Types,?Module),
	?Result ~ ?O[?Method, =>?MethodType]@?Module.

// missing type, nondefault sign, strict
typeCheckBoolInternal(allsigns,strict,?Class,?Method,?Module,?Result) :-
	_isloaded(?Module),
	(is_native(${?[?Method]@?Module})
	; is_native(${?[*?Method]@?Module})
        ),
        ?O[?Method]@?Module,
	generalize_method(?Method,?MethodType,?,?)@_plg(flrauxil),
	naf ?O[=>?MethodType]@?Module,
	if _isnonvar(?Class) then ?O:?Class@?Module,
	?Result ~ ?O[?Method]@?Module.

// wrong type, default sign, nonstrict
typeCheckBoolInternal(?,?,?Class,?Method,?Module,?Result) :- 
	_isloaded(?Module),
	is_native(${?[*?Method]@?Module}),
	?O[*?Method]@?Module,
	generalize_method(?Method,?MethodType,?MethArgs,?Types)@_plg(flrauxil),
	?O[*=>?MethodType]@?Module,
	if _isnonvar(?Class) then ?O:?Class@?Module,
	not_complies_with_type_list(?MethArgs,?Types,?Module),
	?Result ~ ?O[*?Method, *=>?MethodType]@?Module.

// missing type, default sign, strict (not checked if nonstrict)
typeCheckBoolInternal(?,strict,?Class,?Method,?Module,?Result) :-
	_isloaded(?Module),
	is_native(${?[*?Method]@?Module}),
        ?O[*?Method]@?Module,
	generalize_method(?Method,?MethodType,?,?)@_plg(flrauxil),
	naf ?O[*=>?MethodType]@?Module,
	if _isnonvar(?Class) then ?O:?Class@?Module,
	?Result ~ ?O[*?Method]@?Module.


/*************************************************************************
  Utilities
*************************************************************************/
not_complies_with_type_list([], [], ?) :- !, fail.
not_complies_with_type_list([?Arg|?], [?Type|?], ?Module) :-
	naf ?Arg : ?Type@?Module,
	!.
not_complies_with_type_list([?Arg|?ArgList], [?Type|?TypeList], ?Module) :-
	?Arg : ?Type@?Module,
	not_complies_with_type_list(?ArgList,?TypeList,?Module).

// tests if ?Call has been defined in its module
// this blocks out various imported modules
is_native(?Call) :-
	clause{?Call,?},
	!.
is_native(?Call) :- _isbasefact(?Call).
