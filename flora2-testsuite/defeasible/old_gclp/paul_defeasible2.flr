
:- use_argumentation_theory{ogcl}.
?- [ogclp>>ogcl].

/*
  Note: ?X != ?Y will not work because the query
  ?- _opposes(price(bread,1),?O).
  won't return anything without explicit grounding of ?X and ?Y.
*/
_opposes(price(bread,?X),price(bread,?Y)) :-
	value(?X),
	value(?Y),
	?X != ?Y.

@{an,a} price(bread,1).
@{bn,b} price(bread,2).
@{c,cn} price(bread,3).

value(1).
value(2).
value(3).
value(4).

_overrides(a,c).
_overrides(b,c).

/* Desired conclusions: naf price(bread,1), naf price(bread,2), price(bread,3).
   Intuitive justification:  price(bread,1) and price(bread,2)
   have unresolved conflict. price(bread,3) is both refuted and rebutted
   by price(bread,1) and price(bread,2). The latter is true, since neither
   price(bread,1) nor price(bread,2) is compromised: to be compromised they
   must be refuted, but they are not. So, price(bread,1) is also defeated.

   status(a,price(bread,1))[conflictsWith->?X]@ogcl.
   status(a,price(bread,1))[howDefeated->?X]@ogcl.
*/

%tst1 :- false{price(bread,1)}, false{price(bread,2)}, false{price(bread,3)},
	 writeln(tst1=ok)@_plg.

%tst2 :- collectset{?X|status(a,price(bread,1))[info->conflictsWith(?T,?H)]@ogcl, ?X=(?T,?H)} = ?L,
	 writeln(tst2=?L)@_io.

%tst3 :- collectset{?X|status(b,price(bread,2))[howDefeated->?X]@ogcl} = ?L,
	 writeln(tst3=?L)@_io.

%tst4 :- collectset{?O|status(?I,price(bread,2))[howDefeated->?X]@ogcl,
	               ?O=?I+?X} = ?L,
         writeln(tst4=?L)@_io.

%tst5 :- collectset{?X|status(c,price(bread,3))[howDefeated->?X]@ogcl} = ?L,
	 writeln(tst5=?L)@_io.

%tst6 :- collectset{?X|status(a,price(bread,1))[howDefeated->?X]@ogcl} = ?L,
	 writeln(tst6=?L)@_io.


%pretest :- %tst1, %tst2, %tst3, %tst4, %tst5, %tst6.

%test :- tell(temp)@_plg(),
	Method[mustDefine(on)]@_sys,
	%pretest,
	Method[mustDefine(off)]@_sys,
	abolish_all_tables,
	%pretest,
	told@_plg.
