/* This demo shows various cases of non-monotonic inheritance */

//q.q[]. path expression is illegal in rule head now.

a[b *-> c].
a[b1 *-> c1].
aa:a.
aa[b->d].

%tst1 :- aa[b->?X], writeln(?X)@_plg(), fail.      // X=d
%tst1 :- true.

aaa::a.
%tst2 :- aaa[?U*->?Y],
	write(?U)@_plg(), write('  ')@_plg(), writeln(?Y)@_plg(), fail.
%tst2 :- true.

a1[b *-> d].
aaaa:a1.
aaaa:a.
%tst3 :- aaaa[?U->?Y],
	write(?U)@_plg(), write('  ')@_plg(), writeln(?Y)@_plg(), fail.
%tst3 :- true.

//------------------


ab[b *-> {cc,dd}].
ab[b2 *-> {cc2,dd2}].

abb:ab.
abb[b -> tt].
%tst4 :- abb[?M -> ?K],
	write(?M)@_plg(), write('  ')@_plg(), writeln(?K)@_plg(), fail.
%tst4 :- true.

aabb:ab.
%tst5 :- aabb[?M -> ?K],
	write(?M)@_plg(), write('  ')@_plg(), writeln(?K)@_plg(), fail.
%tst5 :- true.

abbb::ab.
abbb[b *-> e].
%tst6 :- abbb[?M *-> ?K],
	write(?M)@_plg(), write('  ')@_plg(), writeln(?K)@_plg(), fail.
%tst6 :- true.

ab1[b *-> ttt].
ab1::ab.
bbb[b2 *-> {e}].
aabb1:bbb.
aabb1:ab1.

%tst7 :- aabb1[?M -> ?K],
	write(?M)@_plg(),write('  ')@_plg(),writeln(?K)@_plg(),fail.
%tst7 :- true.

%pretest :- %tst1, %tst2, %tst3, %tst4, %tst5, %tst6, %tst7.

%test :- tell(temp)@_plg(),
	Method[mustDefine(on)]@_sys,
	%pretest,
	Method[mustDefine(off)]@_sys,
	%pretest,
	told@_plg().


