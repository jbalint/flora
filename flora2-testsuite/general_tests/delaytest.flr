:- setsemantics{tabling(incremental)}.

?- insert{p1(?X,?Y) :- ?X!=?Z,?Z!=?Y}.

p(?X) :-
	?X!=?Z,?Z!=?Y, r(?Y), qq(?Z).

%pp(?X) :-
	?X!=?Z,?Z!=?Y, qqq(?Y),
	?L = setof{?P[?G]| ?P != ?G, (?Y=?P;?X=?P), r(?G)},
	q(?Z),
	write(lll=?L)@_plg.
q(?Z) :- ?Z=3.
q(5) :- ?_X =:= 2.

r(4).
qq(1).
qq(2).
qq(3) :- ?_X > 1.

qqq(1), qqq(2).


%tst1 :- write('test1: ')@_plg,
	 (%pp(5), fail; true),
	 nl@_plg.
%tst2 :- write('test2: ')@_plg,
	 catch{%pp(4),?,writeln('unbound ?_X=:=1')@_plg}.
%tst3 :- write('test3: ')@_plg,
	 p(3),
	 writeln(success)@_plg.
%tst4 :- write('test4: ')@_plg,
	 catch{p(2),?,writeln('unbound ?_X > 2')@_plg}.

pqr(a).
// testing dynamic creation of rules with delayed builtins
?- ?H ~abc(?X), ?B ~ (?Y > 2, ?Y=3, pqr(?X)), insertrule{?H:-?B}.
?- ?R = ${o[abc->?X] :- ?Y > 2, ?Y=3, pqr(?X)}, insertrule{?R}.

%tst5 :- write('test5: ')@_plg,
	abc(?X),
	o[abc->?Y],
	writeln(?X+?Y)@_plg.


%pretest :- %tst1, %tst2, %tst3, %tst4, %tst5.

%test :- tell(temp)@_plg(),
        Method[mustDefine(on)]@_sys,
        %pretest,
        Method[mustDefine(off)]@_sys,
        %pretest,
        told@_plg().
