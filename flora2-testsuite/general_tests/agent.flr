
// Agent that can do Modus Ponens
?- Method[mustDefine(off,${q(?)@_@})]@_sys.

john[believes-> ${p(a)}].
john[believes-> ${constr(?)}].
john[believes-> ${q(?X) :- constr(?), p(?X)}].
constr(?Y) :- ?Y > 2,?Y=3.

john[believes-> ${bob[likes->?X] :- mary[likes->?X]}].
john[believes-> ${mary[likes->sally]}].

john[believes-> ?A] :-
	// block john[believes-> ${A :- B}] from matching the head of this rule
	if (_isnonvar(?A), ?A = ${?_H :- ?_B}) then fail,
	john[believes-> ${?A :- ?B}]
        and john[believes-> ?B].

john[believes-> (?A,?B)] :-
	john[believes-> ?A],
	len(?A,?NA),
	?NA < 2,  // allow only non-and answers
        john[believes-> ?B],
	len(?B,?NB),
	?NB < 2,  // allow only non-and answers
	?B != ?A,
	true.

// used to limit term depth
len(?X,1) :- _isvar(?X), !.
len(?X,1)  :- _isnonvar(?X), ?X \= (?,?), !.
len((?X,?Y),?N) :-
	len(?X,?N1),
	len(?Y,?N2),
	?N is ?N1+?N2.

/*
   Test 1 answers:
test1: q(a)
test1: p(a)
test1: constr(?A)
test1: @!{?A} q(?D) :- (constr(?G), p(?D))
test1: @!{?A} bob[likes -> ?E] :- mary[likes -> ?E]
test1: mary[likes -> sally]

  But sometimes it NONDETERMINISTICALLY looses
test1: @!{?A} bob[likes -> ?E] :- mary[likes -> ?E]

  Weird!!
*/
%tst1 :-
	john[believes->?X],
	?X \= (?,?),  // display only non-compound answers
	write('test1: ')@_plg(),
	flora_write_goal_substitute_vars(?X)@_plg(flrdecode), nl@_plg(), fail.
%tst1 :- true.

%tst2 :-
	write('test2: ')@_plg(),
	john[believes-> ?X], ?X = ${?_A :- ?_B}, insert{?X, p(a)}, q(?Z),
	writeln(Z=?Z)@_plg.

%pretest :- %tst1, %tst2.

%test :- tell(temp)@_plg(),
	Method[mustDefine(on)]@_sys,
	%pretest,
	Method[mustDefine(off)]@_sys,
	!,
	abolish_all_tables,
	%pretest,
	told@_plg.
