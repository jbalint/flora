:- ignore_depchk %writeln(?_)@_io, %q(?_,?_).

// Some tests for intermodule negation

?- insert{p[a]}.
?- insertrule_z{(%p(?X) :- naf p[?X])}.
?- newmodule{foo}.
?- insertrule_z{(%q(?X) :- caller{?Y},
			 %writeln(tst1_caller=?Y)@_io,%p(?X)@main)@foo}.
%tst1 :- naf %q(a)@foo, !, writeln('tst1: succeeded')@_plg().
%tst1 :- writeln('tst1: failed')@_plg().

// caller{...} should return Z=foo
w[a(?X)->?P] :- caller{?Z}, %writeln(test22_caller=?Z)@_io, %q(?X,?P).
?- insertrule_z{(%q :- caller{?X}, %writeln(tst2_caller=?X)@_io,
		    naf w[a(?_)->?_]@main)@foo}.
%tst2 :- insert{%q(a,b), %q(a,c)},
	if %q@foo
        then writeln('tst2 failed')@_plg()
	else writeln('tst2 succeeded')@_plg().

%tst3 :- delete{%q(a,b), %q(a,c)}, refresh{w[a(?_)->?_]},
	if %q@foo
        then writeln('tst3 succeeded')@_plg()
	else writeln('tst3 failed')@_plg().

%pretest :- %tst1, %tst2, %tst3.

%test :-
	tell(temp)@_plg(),
	Method[mustDefine(on)]@_sys,
        %pretest,
        Method[mustDefine(off)]@_sys,
	abolish_all_tables,
        %pretest,
	told@_plg().



