:- use_argumentation_theory.
?- newmodule{foo}.

?- Method[%mustDefine(off,${ppp7(?)@?})]@_sys.

@!{rule1[defeasible,tag->tag1,foo->1,bar->2]} ppp(?X) :- qqq(?X).
@!{rule2[strict,tag->tag1,foo->1,bar->3]} ppp2(?X) :- qqq(?X).
@!{rule4[strict,tag->tag2,foo->2,bar->2]} ppp4(?X) :- qqq(?X).
@!{_@![strict,tag->tag2,foo->2,bar->3]} ppp5(?X) :- qqq(?X).
@!{_@![strict,tag->tag2,foo->1,bar->2]} ppp7(?X) :- qqq(?X).
qqq(a).

add1 :- insert{@!{rule3[defeasible,tag->tag2,foo->2,bar->3]} ppp8(?X) :- qqq(?X)}.
add2 :- insert{@!{rule33[defeasible,tag->tag1,foo->1,bar->3]} ppp8(?X) :- qqq(?X)}.
add3 :- insertrule{@!{_@![defeasible,tag->tag1,foo->1,bar->2]} ppp9(?X) :- qqq(?X)}.
add4 :- insertrule{@!{rule11[defeasible,tag->tag1,foo->2,bar->3]} ppp6(?X) :- qqq(?X)}.
add5 :- insertrule{@!{rule12[defeasible,tag->tag1,foo->2,bar->1]} ppp6(?X) :- qqq(?X)}.

%addfoo :- 
	insert{(@!{rule3f[defeasible,tag->tag2,foo->2,bar->3]} ppp8(?X) :- qqq(?X))@foo, qqq(b)@foo},
	insert{(@!{rule33[defeasible,tag->tag1,foo->1,bar->3]} ppp8(?X) :- qqq(?X))@foo},
	insert{(@!{rule33f[defeasible,tag->tag1,foo->1,bar->3]} ppp8(?X) :- qqq(?X))@foo},
	insertrule{(@!{_@![defeasible,tag->tag1,foo->1,bar->2]} ppp9(?X) :- qqq(?X))@foo},
	insertrule{(@!{rule11f[defeasible,tag->tag1,foo->2,bar->3]} ppp6(?X) :- qqq(?X))@foo},
	insertrule{(@!{_@![tag->tag2,foo->2,bar->3]} ppp1(?X) :- qqq(?X))@foo},
	insertrule{(@!{rule12f[defeasible,tag->tag1,foo->2,bar->1]} ppp6(?X) :- qqq(?X))@foo}.


// deletes  rule11
del1 :- deleterule{@!{?X[defeasible,tag->tag1,foo->2,bar->3]} ?H :- ?}.
// deletes  rule12
del2 :- deleterule{@!{?X[tag->tag1,foo->2,bar->1]} ?H :- ?}.
// deletes ppp9/1
del3 :- deleterule{@!{?X[foo->1,bar->2]} ?H :- ?}.

// deletes  rule11 in foo
delfoo1 :- delete{(@!{?X[defeasible,tag->tag1,foo->2,bar->3]} ?H :- ?)@foo}.
// deletes  rule12 in foo
delfoo2 :- deleterule{(@!{?X[tag->tag1,foo->2,bar->1]} ?H :- ?)@foo}.
// deletes ppp9/1 in foo
delfoo3 :- deleterule{(@!{?X[foo->1,bar->2]} ?H :- ?)@foo}.

%tst1 :- @!{?R[tag->tag1,foo->1]}, write('test1 = ')@_plg, 
	 writeln(?R)@_plg,
	 fail.
%tst1 :- true.
%tst2 :- @!{?R[tag->tag2,foo->2,bar->3]}, write('test2 = ')@_plg, 
	 writeln(?R)@_plg,
	 fail.
%tst2 :- true.
%tst3 :- //add1,
	 @!{?R[tag->tag2,foo->2,bar->3]}, write('test3 = ')@_plg, 
	 writeln(?R)@_plg,
	 fail.
%tst3 :- true.
%tst4 :- //add2, add3,
         @!{?R[tag->tag1,foo->1]}, write('test4 = ')@_plg, 
	 writeln(?R)@_plg,
	 fail.
%tst4 :- true.
%tst5 :- //add4, add5,
         @!{?R[foo->2,bar->3]}, write('test5 = ')@_plg, 
	 writeln(?R)@_plg,
	 fail.
%tst5 :- true.
%tst6 :- @!{?R[foo->2,defeasible,bar->3]}, write('test6 = ')@_plg, 
	 writeln(?R)@_plg,
	 fail.
%tst6 :- true.
%tst7 :- ppp6(?), del1, del2,
	 write('test7 = ')@_plg, 
	 if ppp6(?) then writeln(wrong)@_plg else writeln(ok)@_plg.
%tst8 :- ppp7(?), ppp9(?), del3,
	 write('test8 = ')@_plg, 
	 if ((naf ppp7(?)); ppp9(?))
         then writeln(wrong)@_plg else writeln(ok)@_plg.

%tst9 :- // like test 5
         @!{?R[tag->tag1,foo->1]@foo}, write('test9 = ')@_plg, 
	 writeln(?R)@_plg,
	 fail.
%tst9 :- true.
%tst10 :- // like test 3
         @!{?R[tag->tag2,foo->2,bar->3]@foo}, write('test10 = ')@_plg, 
	 writeln(?R)@_plg,
	 fail.
%tst10 :- true.
%tst11 :- // like test 7
          ppp6(?)@foo, delfoo1, delfoo2,
	  !,
	  write('test11 = ')@_plg, 
	  if ppp6(?)@foo then writeln(wrong)@_plg else writeln(ok)@_plg.
%tst12 :- // like test 8
          naf ppp7(?)@foo, ppp9(?)@foo, delfoo3,
	  write('test12 = ')@_plg, 
	  if ((naf ppp7(?)@foo), ppp9(?)@foo)
	  then writeln(wrong)@_plg else writeln(ok)@_plg.

%pretest :-
	%tst1, %tst2,
	add1,
	%tst3,
	add2, add3,
	%tst4,
	add4, add5,
	%tst5,
	%tst6, %tst7, %tst8,
	// Check later: bug in XSB. If we uncomment the below and change
	// catch(abolish_all_tables, ...) in flrutils.P to just 
	// abolish_all_tables, then %pretest causes the 
	// !!! deleting improper sob 0x2d87580 Segfault!!!
	//newmodule{bar},
	%addfoo,
	%tst9, %tst10, %tst11, %tst12.

%test :- tell(temp)@_plg(),
        Method[%mustDefine(on)]@_sys,
        %pretest,
        Method[%mustDefine(off)]@_sys,
        told@_plg().


