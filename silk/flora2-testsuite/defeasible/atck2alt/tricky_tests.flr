
:- use_argumentation_theory{gcle}.
?- [gclpe>>gcle].

/*
  Group 1
  Here neg A1 and B1 refute each other and are disqualigied
  (transitively defeat each other).
*/
@{t1} neg A1.
@{tt1} B1.
_opposes(tt1,B1,t1,neg A1).

%tst1 :- write('test1: ')@_plg,
	 ?L = collectset{?R|status(?I,neg A1)[howDefeated->?Z]@gcle, ?R=(?I/(neg A1),?Z)},
	 %writeln(?L)@_io.
%tst2 :- write('test2: ')@_plg,
	 ?L = collectset{?R|status(?I,B1)[howDefeated->?Z]@gcle, ?R=(?I/B1,?Z)},
	 %writeln(?L)@_io.

/*
  Group 2
    Here B2 > A2 and A2 > C2, and B2 > C2
    B2 does not oppose C2, but A2 opposes everything.

  ATCK2 differs from GCLP (new and old) and from ATCK1
    B2  is true, C2 is true, A2 is false. - ***The C2 part is strange!!

  New GCL:
    B2 is true, A2 is false. c2/C2 is disqualified with truth value
    unknown.  So, it is defeated with truth value unknown, and so its
    truth value is unknown also.

  Old GCL and ATCK1:
    The only difference is that c2/C2 is false rather than unknown.
    It is false because it is refuted.
*/

@{a2} A2.
@{b2} B2.
@{c2} C2.

_overrides(b2,a2).
_overrides(a2,c2).
_overrides(b2,c2).  // this transitivity has no effect on ATCK1/2 or GCLPs
_opposes(A2,B2).
_opposes(A2,C2).

%tst3 :- write('test3: ')@_plg,
          true{B2}, false{C2}, false{A2}, writeln(success)@_plg.
// this test first time does not return anything. XSB bug? Omit.
%tst4 :- write('test4: ')@_plg,
          ?L = collectset{?R|status(?I,A2)[howDefeated->?Z]@gcle, ?R=(?I/A2,?Z)},
          %writeln(?L)@_io.
%tst5 :- write('test5: ')@_plg,
          ?L = collectset{?R | status(?I,C2)[howDefeated->?Z]@gcle,
	                       ?R = (?I/C2 , ?Z)},
          %writeln(?L)@_io.

/*
  Group 3
  B3 > A3 > C3

  GCLPs and ATCK1,2:
      B3 - true
      A3, C3 - defeated
  ATCK3: nothing is defeated
*/

@{a3} A3.
@{b3} B3.
@{c3} C3.

_overrides(a3,c3).
_overrides(b3,a3).
_overrides(b3,c3). 
_opposes(A3,B3).
_opposes(A3,C3).
_opposes(B3,C3).

%tst6 :- write('test6: ')@_plg,
          true{B3}, false{C3}, false{A3}, writeln(success)@_plg.

/*
  Group 4
  t4 > r4
  t4<->tt4 - conflict, A4/neg A4 - conflict
  Here t4 refutes r4. (r4 is therefore never rebutted)
  So, r4/A4 is false.
  tt4/B4 and t4/A4 rebut each other, so they are false.
  t4/neg A4 remains true.
  s4/neg A4 is not defeated because it is not rebutted by r4/A4, and
  it does not oppose tt4/B4 (so tt4/B4 does not rebut s4/neg A4 either.
*/

@{r4} A4.
@{s4} neg A4.

@{t4} neg A4.
@{tt4} B4.

_overrides(t4,r4).
_opposes(tt4,B4,t4,neg A4).


%tst7 :- write('test7: ')@_plg,
         false{B4}, true{neg A4}, false{A4}, writeln(success)@_plg.
%tst8 :- write('test8: ')@_plg,
         ?L = collectset{?R|status(r4,A4)[howDefeated->?Z]@gcle, ?R=(r4/A4,?Z)},
          %writeln(?L)@_io.
%tst9 :- write('test9: ')@_plg,
         ?L = collectset{?R|status(s4,neg A4)[info->?Z]@gcle, ?R=(s4/A4,?Z)},
	 numbervars(?L)@_plg(num_vars),
	 %writeln(?L)@_io.

// test 4 is omitted: misbehaves. The first time ?L = [].
// Only the second time it returns the right answer.
%pretest :- %tst1, %tst2, %tst3, %tst5, %tst6, %tst7, %tst8, %tst9.

%test :- tell(temp)@_plg(),
	Method[%mustDefine(on)]@_sys,
	%pretest,
	Method[%mustDefine(off)]@_sys,
	abolish_all_tables,
	%pretest,
	told@_plg.
