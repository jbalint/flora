
:- use_defeasible_theory.  // default defeasible theory, GCL.

/* Each situation exists at a particular time. */
Situation [time{1:1}=>symbol].

/**/


/* parent is alive in a Situation with time t0, but joe is not */
@{_#} a(p)(_#:Situation[time->t0]).
@{_#} neg a(j)(?s0) :- ?s0:Situation[time->t0].

/* if parent is alive in some Situation with time t2, then joe is
alive in a Situation with time t3 */

@{_#} a(j)(_#:Situation[time->t3]) :- a(p)(?_s2:Situation[time->t2]). 

/* if joe is alive in a Situation with time t3, then he time travels
to a Situation with time t1 (then returns to s3) */

@{_#} t(j,?s3:Situation,_#:Situation[time->t1]) :- a(j)(?s3:Situation[time->t3]).

/* if joe time travels, then he fires the gun at parent in s1 */

@{_#} f(j,p)(?s1:Situation) :- t(j,?_s3:Situation[time->t3],?s1:Situation[time->t1]).

/* if the gun is fired at parent at t1, then the parent is dead in all
Situations having t2 */

@{_#} neg a(p)(?s2) :- f(j,p)(?_s1:Situation[time->t1]), ?s2:Situation[time->t2].

// possible alternate to consider:
/* if the gun is fired at parent at t1, then the parent is dead in a
Situation having t2 */
// @{_#} _#2:Situation[time->t2], neg a(p)(_#2) :- f(j,p)(?_s1:Situation[time->t1]).


//////////////////////

/* persistence axioms about aliveness 
   Note: There's an intentional asymmetry in this version.
     The positive axioms say
     if X is alive at time t in some Situation, then 
       there *exists* a Situation having time t+1 in which he's alive
     The negative axioms say:
     if X is not alive at time t in some Situation, then 
       *forall* Situations with time t+1 he's not alive
*/
@{pe} a(p)(_#:Situation[time->t1]) :- a(p)(?_s0:Situation[time->t0]).
@{pe} neg a(p)(?s1) :- ?s0:Situation[time->t0], neg a(p)(?s0), ?s1:Situation[time->t1].
@{pe} a(p)(_#:Situation[time->t2]) :- a(p)(?_s1:Situation[time->t1]).
@{pe} neg a(p)(?s2) :- ?s1:Situation[time->t1], neg a(p)(?s1), ?s2:Situation[time->t2].
@{pe} a(p)(_#:Situation[time->t3]) :- a(p)(?_s2:Situation[time->t2]).
@{pe} neg a(p)(?s3) :- ?s2:Situation[time->t2], neg a(p)(?s2), ?s3:Situation[time->t3].

@{pe} a(j)(_#:Situation[time->t1]) :- a(j)(?_s0:Situation[time->t0]).
@{pe} neg a(j)(?s1) :- ?s0:Situation[time->t0], neg a(j)(?s0), ?s1:Situation[time->t1].
@{pe} a(j)(_#:Situation[time->t2]) :- a(j)(?_s1:Situation[time->t1]).
@{pe} neg a(j)(?s2) :- ?s1:Situation[time->t1], neg a(j)(?s1), ?s2:Situation[time->t2].
@{pe} a(j)(_#:Situation[time->t3]) :- a(j)(?_s2:Situation[time->t2]).
@{pe} neg a(j)(?s3) :- ?s2:Situation[time->t2], neg a(j)(?s2), ?s3:Situation[time->t3].


_overrides(?,pe) :- ? != pe.  /* persistence rules are lowest-pri */
// != is much faster than not :=:. But one can't see that in this tiny example.
// _overrides(?,pe) :- not ? :=: pe.

%pretest :-
    write('Test #1: ')@_plg,
    // all should be unknown
    if ( unknown{a(p)(?s2:Situation[time->t2])},
         unknown{neg a(p)(?s2:Situation[time->t2])},
	 unknown{a(j)(?s3:Situation[time->t3])},
	 unknown{neg a(j)(?s3:Situation[time->t3])},
	 unknown{t(j,?s3:Situation[time->t3],?s1:Situation[time->t1])},
	 unknown{f(j,p)(?s1:Situation[time->t1])} )
    then
       writeln(passed1)@_plg
    else
       writeln(failed1)@_plg,

    write('Test #2: ')@_plg,
    // none should be true
    if ( true{a(p)(?s2:Situation[time->t2])} ;
         true{neg a(p)(?s2:Situation[time->t2])} ;
	 true{a(j)(?s3:Situation[time->t3])} or
	 true{neg a(j)(?s3:Situation[time->t3])} ;
	 true{t(j,?s3:Situation[time->t3],?s1:Situation[time->t1])} ;
	 true{f(j,p)(?s1:Situation[time->t1])} )
    then
       writeln(failed2)@_plg
    else
       writeln(passed2)@_plg,

    write('Test #3: ')@_plg,
    // none should be false
    if ( false{a(p)(?s2:Situation[time->t2])} or
         false{neg a(p)(?s2:Situation[time->t2])} or
	 false{a(j)(?s3:Situation[time->t3])} or
	 false{neg a(j)(?s3:Situation[time->t3])} or
	 false{t(j,?s3:Situation[time->t3],?s1:Situation[time->t1])} or
	 false{f(j,p)(?s1:Situation[time->t1])} )
    then
       writeln(failed3)@_plg
    else
       writeln(passed3)@_plg.

%test :- tell(temp)@_plg(),
	Method[%mustDefine(on)]@_sys,
	%pretest,
	Method[%mustDefine(off)]@_sys,
	abolish_all_tables,
	%pretest,
	told@_plg().
