
:- use_defeasible_theory.

/*
  Note: ?X != ?Y will not work because the query
  ?- _opposes(price(bread,1),?O).
  won't return anything without explicit grounding of ?X and ?Y.
*/
_opposes(price(bread,?X),price(bread,?Y)) :-
	value(?X),
	value(?Y),
	?X != ?Y.

@{a} price(bread,1).
@{b} price(bread,2).
@{c} price(bread,3).

value(1).
value(2).
value(3).
value(4).

_overrides(a,c).
_overrides(b,c).

/* Desired conclusions: naf price(bread,1), naf price(bread,2), price(bread,3).
   Intuitive justification:  price(bread,1) and price(bread,2)
   have unresolved conflict. Even though both beat
   price(bread,3), they defeat each other and price(bread,3) survives.

   status(a,price(bread,1))[conflictsWith->?X]@_gcl.
   status(a,price(bread,1))[defeatedBy->?X]@_gcl.
*/

%tst1 :- false{price(bread,1)}, false{price(bread,2)}, true{price(bread,3)},
	 writeln(tst1=ok)@_plg.

%tst2 :- collectset{?X|status(a,price(bread,1))[conflictsWith->?X]@_gcl} = ?L,
	 %writeln(tst2=?L)@_io.

%tst3 :- status(b,price(bread,2))[defeatedBy->?X]@_gcl,
	 %writeln(tst3=?X)@_io.

%tst4 :- collectset{?O|status(?I,price(bread,2))[disqualifiedDueTo->?X]@_gcl, ?O=?I+?X} = ?L, %writeln(tst4=?L)@_io.

%pretest :- %tst1, %tst2, %tst3, %tst4.

%test :- tell(temp)@_plg(),
	Method[%mustDefine(on)]@_sys,
	%pretest,
	Method[%mustDefine(off)]@_sys,
	abolish_all_tables,
	%pretest,
	told@_plg.
