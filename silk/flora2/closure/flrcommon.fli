/*******************************************************************************
  file: closure/flrcommon.fli - The common part of all trailers

  Author(s): Guizhen Yang

  Contact:   kifer@cs.stonybrook.edu

  Copyright (C) by
       The Research Foundation of the State University of New York, 1999-2010.

  All rights reserved.

  For information about licensing terms, please see
  http://silk.projects.semwebcentral.org/flora2-license.html

*******************************************************************************/


#include "flora_wspredicates.flh"
#include "flora_porting.flh"
#include "flora_exceptions.flh"

%% checkCallerInfo is just for debugging
:- import 
	checkCallerInfo/3,
	flora_abort/1
   from flrutils.

:- import flora_optimizer_registry/2 from flrregistry.
:- import when/2 from constraintLib.

:- WRAP_COPY_UNQUOTED 'FLORA_THIS_MODULE_NAME'.


#include "flrtypes.fli"

#include "flrcommon_neg.inc"


/***************************************************************************
  inferred predicates

  These wrapper predicates with the 'inferred_' prefix (FLTRAILERPREFIX)
  are needed to make the trailer dynamically loadable. Note that the
  program rules use wrapper predicates with the 'derived_', prefix, i.e.,
  FLHEADPREFIX.
***************************************************************************/
FLTRAILERPREFIX(WRAP_SUB)(X,Y,CallerInfo) :-
	%% checkCallerInfo is just for debugging
	checkCallerInfo(WRAP_SUB(X,Y),'FLORA_THIS_MODULE_NAME',CallerInfo),
	FLHEADPREFIX(WRAP_SUB)(X,Y,CallerInfo).
FLTRAILERPREFIX(WRAP_ISA)(O,C,CallerInfo) :-
	checkCallerInfo(WRAP_ISA(O,C),'FLORA_THIS_MODULE_NAME',CallerInfo),
	FLHEADPREFIX(WRAP_ISA)(O,C,CallerInfo).
FLTRAILERPREFIX(WRAP_MVD)(O,A,V,CallerInfo) :-
	checkCallerInfo(WRAP_MVD(O,A,V),'FLORA_THIS_MODULE_NAME',CallerInfo),
	FLHEADPREFIX(WRAP_MVD)(O,A,V,CallerInfo).
FLTRAILERPREFIX(WRAP_IMVD)(C,A,V,CallerInfo) :-
	checkCallerInfo(WRAP_IMVD(C,A,V),'FLORA_THIS_MODULE_NAME',CallerInfo),
	FLHEADPREFIX(WRAP_IMVD)(C,A,V,CallerInfo).
FLTRAILERPREFIX(WRAP_MVDDEF)(O,A,CallerInfo) :-
	checkCallerInfo(WRAP_MVDDEF(O,A),'FLORA_THIS_MODULE_NAME',CallerInfo),
	FLHEADPREFIX(WRAP_MVDDEF)(O,A,CallerInfo).
FLTRAILERPREFIX(WRAP_IMVDDEF)(C,A,CallerInfo) :-
	checkCallerInfo(WRAP_IMVDDEF(C,A),'FLORA_THIS_MODULE_NAME',CallerInfo),
	FLHEADPREFIX(WRAP_IMVDDEF)(C,A,CallerInfo).
FLTRAILERPREFIX(WRAP_MVDSIG)(O,MethodArgs,R,CallerInfo) :-
	checkCallerInfo(WRAP_MVDSIG(O,MethodArgs,R),'FLORA_THIS_MODULE_NAME',CallerInfo),
	FLHEADPREFIX(WRAP_MVDSIG)(O,MethodArgs,R,CallerInfo).
FLTRAILERPREFIX(WRAP_MVDCONDEF)(O,MethodArgs,L,H,CallerInfo) :-
	checkCallerInfo(WRAP_MVDCONDEF(O,MethodArgs,L,H),'FLORA_THIS_MODULE_NAME',CallerInfo),
	FLHEADPREFIX(WRAP_MVDCONDEF)(O,MethodArgs,L,H,CallerInfo),
	( integer(L) ->
	     true
	;
	     flora_concat_items(['Lower bound ',L,' of cardinality
	constraint of ',O,'[',MethodArgs,'=>?]  is not an integer.'],ErrorMsg),
	     flora_abort(FLORA_CARDINALITY_CONSTRAINT_EXCEPTION(ErrorMsg))
	),
	( ((integer(H),H>=0);H=='*') ->
	     true
	;
	     flora_concat_items(['Higher bound ',H,' of cardinality
	constraint of ',O,'[',MethodArgs,'=>?]  is not a non-negative integer or infinity(*).'],ErrorMsg),
	     flora_abort(FLORA_CARDINALITY_CONSTRAINT_EXCEPTION(ErrorMsg))
	).
FLTRAILERPREFIX(WRAP_MVDSIGDEF)(O,MethodArgs,CallerInfo) :-
	checkCallerInfo(WRAP_MVDSIGDEF(O,MethodArgs),'FLORA_THIS_MODULE_NAME',CallerInfo),
	FLHEADPREFIX(WRAP_MVDSIGDEF)(O,MethodArgs,CallerInfo).
FLTRAILERPREFIX(WRAP_IMVDSIG)(O,MethodArgs,R,CallerInfo) :-
	checkCallerInfo(WRAP_IMVDSIG(O,MethodArgs,R),'FLORA_THIS_MODULE_NAME',CallerInfo),
	FLHEADPREFIX(WRAP_IMVDSIG)(O,MethodArgs,R,CallerInfo).
FLTRAILERPREFIX(WRAP_IMVDCONDEF)(O,MethodArgs,L,H,CallerInfo) :-
	checkCallerInfo(WRAP_IMVDCONDEF(O,MethodArgs,L,H),'FLORA_THIS_MODULE_NAME',CallerInfo),
	FLHEADPREFIX(WRAP_IMVDCONDEF)(O,MethodArgs,L,H,CallerInfo),
	( integer(L) ->
	     true
	;
	     flora_concat_items(['Lower bound ',L,' of cardinality
	constraint of ',O,'[',MethodArgs,'*=>?]  is not an integer.'],ErrorMsg),
	     flora_abort(FLORA_CARDINALITY_CONSTRAINT_EXCEPTION(ErrorMsg))
	),
	( ((integer(H),H>=0);H=='*') ->
	     true
	;
	     flora_concat_items(['Higher bound ',H,' of cardinality
	constraint of ',O,'[',MethodArgs,'*=>?]  is not a non-negative integer or infinity(*).'],ErrorMsg),
	     flora_abort(FLORA_CARDINALITY_CONSTRAINT_EXCEPTION(ErrorMsg))
	).
FLTRAILERPREFIX(WRAP_IMVDSIGDEF)(O,MethodArgs,CallerInfo) :-
	checkCallerInfo(WRAP_IMVDSIGDEF(O,MethodArgs),'FLORA_THIS_MODULE_NAME',CallerInfo),
	FLHEADPREFIX(WRAP_IMVDSIGDEF)(O,MethodArgs,CallerInfo).
FLTRAILERPREFIX(WRAP_METH)(O,M,CallerInfo) :-
	checkCallerInfo(WRAP_METH(O,M),'FLORA_THIS_MODULE_NAME',CallerInfo),
	FLHEADPREFIX(WRAP_METH)(O,M,CallerInfo).
FLTRAILERPREFIX(WRAP_IMETH)(C,M,CallerInfo) :-
	checkCallerInfo(WRAP_IMETH(C,M),'FLORA_THIS_MODULE_NAME',CallerInfo),
	FLHEADPREFIX(WRAP_IMETH)(C,M,CallerInfo).
FLTRAILERPREFIX(WRAP_BOOLSIG)(O,M,CallerInfo) :-
	checkCallerInfo(WRAP_BOOLSIG(O,M),'FLORA_THIS_MODULE_NAME',CallerInfo),
	FLHEADPREFIX(WRAP_BOOLSIG)(O,M,CallerInfo).
FLTRAILERPREFIX(WRAP_IBOOLSIG)(C,M,CallerInfo) :-
	checkCallerInfo(WRAP_IBOOLSIG(C,M),'FLORA_THIS_MODULE_NAME',CallerInfo),
	FLHEADPREFIX(WRAP_IBOOLSIG)(C,M,CallerInfo).
FLTRAILERPREFIX(WRAP_TRANSIG)(O,M,CallerInfo) :-
	checkCallerInfo(WRAP_TRANSIG(O,M),'FLORA_THIS_MODULE_NAME',CallerInfo),
	FLHEADPREFIX(WRAP_TRANSIG)(O,M,CallerInfo).
FLTRAILERPREFIX(WRAP_ITRANSIG)(C,M,CallerInfo) :-
	checkCallerInfo(WRAP_ITRANSIG(C,M),'FLORA_THIS_MODULE_NAME',CallerInfo),
	FLHEADPREFIX(WRAP_ITRANSIG)(C,M,CallerInfo).
FLTRAILERPREFIX(WRAP_TRAN)(O,T,CallerInfo) :-
	checkCallerInfo(WRAP_TRAN(O,T),'FLORA_THIS_MODULE_NAME',CallerInfo),
	FLHEADPREFIX(WRAP_TRAN)(O,T,CallerInfo).
FLTRAILERPREFIX(WRAP_OBJEQL)(X,Y,CallerInfo) :-
	checkCallerInfo(WRAP_OBJEQL(X,Y),'FLORA_THIS_MODULE_NAME',CallerInfo),
	FLHEADPREFIX(WRAP_OBJEQL)(X,Y,CallerInfo).
FLTRAILERPREFIX(WRAP_EXISTS)(X,CallerInfo) :-
	checkCallerInfo(WRAP_EXISTS(X),'FLORA_THIS_MODULE_NAME',CallerInfo),
	FLHEADPREFIX(WRAP_EXISTS)(X,CallerInfo).


/***************************************************************************
  multivalued attributes inclusion
***************************************************************************/
WRAP_MVDINC(_O,_M,[],CallerInfo) :- !.
WRAP_MVDINC(O,M,[H|T],CallerInfo) :-
    	WRAP_MVD(O,M,H,CallerInfo), WRAP_MVDINC(O,M,T,CallerInfo).


WRAP_IMVDINC(_O,_M,[],CallerInfo) :- !.
WRAP_IMVDINC(O,M,[H|T],CallerInfo) :-
    	WRAP_IMVD(O,M,H,CallerInfo), WRAP_IMVDINC(O,M,T,CallerInfo).


/****************************************************************************
  multivalued attributes aggregation

  Note: (1) These two predicates always succeeds.
        (2) These two predicates are not tabled.
****************************************************************************/
WRAP_MVDTOLIST(O,M,L,CallerInfo) :-
	WRAP_MVDDEF(O,M,CallerInfo),
	findall(V,WRAP_MVD(O,M,V,CallerInfo),L).

WRAP_MVDTOLIST(O,M,[],CallerInfo) :-
	FLORA_TNOT(WRAP_MVDDEF(O,M,CallerInfo)).


WRAP_IMVDTOLIST(O,M,L,CallerInfo) :-
	WRAP_IMVDDEF(O,M,CallerInfo),
	findall(V,WRAP_IMVD(O,M,V,CallerInfo),L).
 
WRAP_IMVDTOLIST(O,M,[],CallerInfo) :-
	FLORA_TNOT(WRAP_IMVDDEF(O,M,CallerInfo)).


/****************************************************************************
   Odd-lot predicates
****************************************************************************/
%% These are tabled in genincludes/flrtable.fli
FL_TRUTHVALUE_TABLED_CALL(X) :- call(X).
FL_TABLED_UNNUMBER_CALL(GGoal) :-
    	num_vars:unnumbervars(GGoal,VGoal),
	call(VGoal).


/****************************************************************************
  WRAP_EXISTS/1
****************************************************************************/
WRAP_EXISTS(X,CallerInfo) :- WRAP_MVD(X,_,_,CallerInfo).
WRAP_EXISTS(X,CallerInfo) :- WRAP_MVD(_,_,X,CallerInfo).
WRAP_EXISTS(X,CallerInfo) :- WRAP_MVDDEF(X,_,CallerInfo).
WRAP_EXISTS(X,CallerInfo) :- WRAP_IMVD(X,_,_,CallerInfo).
WRAP_EXISTS(X,CallerInfo) :- WRAP_IMVD(_,_,X,CallerInfo).
WRAP_EXISTS(X,CallerInfo) :- WRAP_IMVDDEF(X,_,CallerInfo).

WRAP_EXISTS(X,CallerInfo) :- WRAP_METH(X,_,CallerInfo).
WRAP_EXISTS(X,CallerInfo) :- WRAP_IMETH(X,_,CallerInfo).

%% We need to restrict these so that one could not infer existence merely
%% due to standard classes such as _symbol, _object, (?;?), etc.
WRAP_EXISTS(X,CallerInfo) :- WRAP_ISA(X,C,CallerInfo). %%, \+ silent_isa(X,C,CallerInfo).
WRAP_EXISTS(X,CallerInfo) :- WRAP_ISA(O,X,CallerInfo). %%, \+ silent_isa(O,X,CallerInfo).
WRAP_EXISTS(X,CallerInfo) :- WRAP_SUB(X,C,CallerInfo). %%, \+ silent_sub(X,C,CallerInfo).
WRAP_EXISTS(X,CallerInfo) :- WRAP_SUB(C,X,CallerInfo). %%, \+ silent_sub(C,X,CallerInfo).

/* Ensure that objects corresponding to the standard data types "exist" */
WRAP_EXISTS(FL_TOPTYPE,_CallerInfor).
WRAP_EXISTS(FL_LONG,_CallerInfor).
WRAP_EXISTS(FL_INTEGER,_CallerInfor).
WRAP_EXISTS(FL_DECIMAL,_CallerInfor).
WRAP_EXISTS(FL_DOUBLE,_CallerInfor).
WRAP_EXISTS(FL_SYMBOL,_CallerInfor).
WRAP_EXISTS(FL_STRING,_CallerInfor).
WRAP_EXISTS(FL_DATETIME,_CallerInfor).
WRAP_EXISTS(FL_DATE,_CallerInfor).
WRAP_EXISTS(FL_DURATION,_CallerInfor).
WRAP_EXISTS(FL_TIME,_CallerInfor).
WRAP_EXISTS(FL_IRI,_CallerInfor).
WRAP_EXISTS(FL_BOOL,_CallerInfor).
WRAP_EXISTS(FL_LISTTYPE,_CallerInfor).

%% Have to assert, because flora_defined_class/1 gets its content from
%% different modules. Using compiled rules would cause each module to
%% override another
?- assert((
       flora_defined_class(X) :-
	    FLTRAILERPREFIX(WRAP_SUB)(X, _,_Caller) ;
	    FLTRAILERPREFIX(WRAP_SUB)(_, X,_Caller) ;
	    FLTRAILERPREFIX(WRAP_ISA)(_, X,_Caller)
    )).

FLORA_SYMBOL('class')(X) :-
	FLTRAILERPREFIX(WRAP_SUB)(X, _,_Caller) ;
	FLTRAILERPREFIX(WRAP_SUB)(_, X,_Caller) ;
	FLTRAILERPREFIX(WRAP_ISA)(_, X,_Caller).


#include "flrequality_none.inc"


/****************************************************************************
    Introduced in support of the debugger
****************************************************************************/
%% like WRAP_SUB, but the debugger won't trace it
silent_sub(C,S,CallerInfo) :- WRAP_SUB(C,S,CallerInfo).
%%WRAP_ISA(O,C,CallerInfo) :- silent_isa(O,C,CallerInfo).
%% like WRAP_SUB, but the debugger will print it specially and won't trace inside
inheritance_sub(C,S,CallerInfo) :- WRAP_SUB(C,S,CallerInfo).
inheritance_isa(C,S,CallerInfo) :- WRAP_ISA(C,S,CallerInfo).

%% Like inferred_* but the debugger (actually the decoder, flrdecode.P)
%% will print them in a special way
inheritance_imvd(C,M,V,CallerInfo) :- FLTRAILERPREFIX(WRAP_IMVD)(C,M,V,CallerInfo).
inheritance_imvddef(C,M,CallerInfo) :- FLTRAILERPREFIX(WRAP_IMVDDEF)(C,M,CallerInfo).

inheritance_imvd_eql(C,M,V,CallerInfo) :- FLTRAILERPREFIX(WRAP_IMVD_EQL)(C,M,V,CallerInfo).
inheritance_imvddef_eql(C,M,CallerInfo) :- FLTRAILERPREFIX(WRAP_IMVDDEF_EQL)(C,M,CallerInfo).

inheritance_imeth(C,M,CallerInfo) :- FLTRAILERPREFIX(WRAP_IMETH)(C,M,CallerInfo).
inheritance_imeth_eql(C,M,CallerInfo) :- FLTRAILERPREFIX(WRAP_IMETH_EQL)(C,M,CallerInfo).


FL_SILENT_EQUAL(X,X).


/****************************************************************************
   axioms for signature semantics
****************************************************************************/
#include "flrsigaxioms.fli"


/****************************************************************************
   common axioms for HiLog predicates
****************************************************************************/
#include "flrcommon_pred.fli"
