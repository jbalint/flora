/* File:      flrundefined.P  -- Catcher of undefined predicates and methods
**
** Author(s): Chang Zhao
**
** Contact:   kifer@cs.stonybrook.edu
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2013;
**      and Vulcan, Inc., 2013.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**      http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
**
*/


:- compiler_options([xpp_on]).

#include "flora_terms.flh"
#include "flora_characters.flh"
#include "flora_exceptions.flh"
#include "flora_porting.flh"

#define FLDNEWVAR  'fldnewvar'

/*********************************************************************
  flora_debug_code(+CompileRuleList,+CompileFactList,+File)
  Extract from facts and rule heads the skeletons that will be loaded
  into fld storage and write them to File
**********************************************************************/
flora_debug_code(RuleList,FactList,File) :-
	retractall(term_seen(_)),
	flora_build_debug_inter_codelist(RuleList,RuleCodeList),
        assert_term_seen(RuleCodeList),
	!,
	flora_build_debug_inter_codelist(FactList,FactCodeList),
        assert_term_seen(FactCodeList),
	telling(PreOut),
	tell(File),
	flora_current_out_line('#include "flrheader.flh"'),
	flora_current_out_line('#include "flr_fld_standardtypes.flh"'),
	nl,
	generate_patches,
	told,
	tell(PreOut).

%% remove duplication
assert_term_seen([]) :- !.
assert_term_seen([H|L]) :-
        %%(term_seen(H) -> true; assert(term_seen(H))),
	%% now term_seen/1 is trie-indexed, so no need to check before asserting
	assert(term_seen(H)),
	assert_term_seen(L).

/*********************************************************************
  flora_build_debug_inter_codelist(+CompilerCodeList,-SkeletonList)
**********************************************************************/
flora_build_debug_inter_codelist([],[]) :- !.

flora_build_debug_inter_codelist([T|L],CodeList) :-
	flora_build_debug_inter_code(T,TCode),
        ( nonvar(TCode) ->
            ( TCode = [Sub,Super] ->
                %% only c1::c2 can produce 2 skeletons
                CodeList = [Sub,Super|LCode]
            ;
                CodeList = [TCode|LCode]
            )
        ;
            CodeList = LCode
        ),
	flora_build_debug_inter_codelist(L,LCode).

flora_build_debug_inter_code(Term,Code) :-
	(is_prrule(Term,Head,_) ; is_prfact(Term,Head)),
        flora_reset_newvar,
	flora_build_debug_skeleton(Head,Code),
        !.

flora_build_debug_inter_code(_Term,_Code).

/*********************************************************************
  flora_build_debug_skeleton(+Term, -Code)
  builds the intermediate form of the skeletons of all facts
  and rule heads

  NOTE: This always generated NON-NEGATED atoms for FLD storage - even
        if the input is negated - saved a lot of coding.
**********************************************************************/
flora_build_debug_skeleton(Head,PRATOMLIT([A|NewCallerList],NO_INDEX)) :-
	is_pratomlit(Head,CODER_HEAD_CONTEXT,_Wrap,[A|CallerList],_Index),
	!,
	( flora_prlgdef(A,0) -> fail
	; ( CallerList == [] -> NewCallerList = []
	  ; prvar_list(1,NewCallerList)
	  )
	).

flora_build_debug_skeleton(Head,PRTRANSACTIONALATOMLIT([A,NewCaller],NO_INDEX)) :-
        is_prtransactionalatomlit(Head,CODER_HEAD_CONTEXT,_Wrap,[A,_Caller],_Index),
	!,
	prvar_list(1,[NewCaller]).

flora_build_debug_skeleton(Head,Sk) :-
	is_prtermlit(Head,CODER_HEAD_CONTEXT,_Wrap,FObj,ObjList),
	!,
	length(ObjList,N),
	( is_pratom(FObj,FAtom,_Index), flora_prlgdef(FAtom, N)
	->
	    fail
	;
	    prvar_list(N,ObjListCode),
	    Sk = PRTERMLIT(FCode,N,ObjListCode),
	    flora_build_debug_term_skeleton(FObj,FCode)
	).

flora_build_debug_skeleton(Head,Sk) :-
	is_prtransactionaltermlit(Head,CODER_HEAD_CONTEXT,_Wrap,FObj,ObjList),
	!,
	length(ObjList,N),
	( is_pratom(FObj,FAtom,_Index), flora_prlgdef(FAtom, N)
	->
	    fail
	;
	    prvar_list(N,ObjListCode),
	    Sk = PRTRANSACTIONALTERMLIT(FCode,N,ObjListCode),
	    flora_build_debug_term_skeleton(FObj,FCode)
	).


flora_build_debug_skeleton(Head,Sk) :-
	flora_build_debug_skeleton_flogic(Head,Sk),
        !.

%% The remaining heads are all F-logic types
%% The last new variable in templates below is for the Caller argument
flora_build_debug_skeleton_flogic(Head,PRSUB(NV1,CCode,NV2)) :-
	(is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_ISA),[_Obj1,Obj2|_])
	; is_flogic(Head,CODER_HEAD_CONTEXT,FLNEGHEADPREFIX(WRAP_ISA),[_Obj1,Obj2|_])),
	!,
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV1),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV2),
	pr_generalize_last_arg_strip_index(Obj2,CCode).

flora_build_debug_skeleton_flogic(Head,CCode) :-
	(is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_SUB),[Obj1,Obj2|_])
	; is_flogic(Head,CODER_HEAD_CONTEXT,FLNEGHEADPREFIX(WRAP_SUB),[Obj1,Obj2|_])),
	!,
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV1),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV2),
	( pr_generalize_last_arg_strip_index(Obj1,Sk1) ->
            ( pr_generalize_last_arg_strip_index(Obj2,Sk2) ->
                CCode = [PRSUB(NV1,Sk1,NV2),PRSUB(NV1,Sk2,NV2)]
            ;
                CCode = PRSUB(NV1,Sk1,NV2)
            )
        ;
            ( pr_generalize_last_arg_strip_index(Obj2,Sk2) ->
                CCode = PRSUB(NV1,Sk2,NV2)
            ;
                fail
            )
        ).

flora_build_debug_skeleton_flogic(Head,PRMVD(NV1,ACode,NV2,NV3)) :-
	(is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_MVD),[_Obj,Att,_Val|_])
	; is_flogic(Head,CODER_HEAD_CONTEXT,FLNEGHEADPREFIX(WRAP_MVD),[_Obj,Att,_Val|_])),
	!,
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV1),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV2),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV3),
	flora_build_debug_term_skeleton(Att,ACode).

flora_build_debug_skeleton_flogic(Head,PRIMVD(NV1,ACode,NV2,NV3)) :-
	(is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_IMVD),[_Obj,Att,_Val|_])
	; is_flogic(Head,CODER_HEAD_CONTEXT,FLNEGHEADPREFIX(WRAP_IMVD),[_Obj,Att,_Val|_])),
	!,
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV1),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV2),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV3),
	flora_build_debug_term_skeleton(Att,ACode).

flora_build_debug_skeleton_flogic(Head,PRMETH(NV1,MCode,NV2)) :-
	(is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_METH),[_Obj1,Meth|_])
	; is_flogic(Head,CODER_HEAD_CONTEXT,FLNEGHEADPREFIX(WRAP_METH),[_Obj1,Meth|_])),
	!,
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV1),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV2),
	flora_build_debug_term_skeleton(Meth,MCode).

flora_build_debug_skeleton_flogic(Head,PRIMETH(NV1,MCode,NV2)) :-
	(is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_IMETH),[_Obj1,IMeth|_])
	; is_flogic(Head,CODER_HEAD_CONTEXT,FLNEGHEADPREFIX(WRAP_IMETH),[_Obj1,IMeth|_])),
	!,
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV1),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV2),
	flora_build_debug_term_skeleton(IMeth,MCode).

flora_build_debug_skeleton_flogic(Head,PRMVDDEF(NV1,ACode,NV2)) :-
	(is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_MVDDEF),[_Obj,Attr|_])
	; is_flogic(Head,CODER_HEAD_CONTEXT,FLNEGHEADPREFIX(WRAP_MVDDEF),[_Obj,Attr|_])),
	!,
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV1),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV2),
	flora_build_debug_term_skeleton(Attr,ACode).

flora_build_debug_skeleton_flogic(Head,PRIMVDDEF(NV1,ACode,NV2)) :-
	(is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_IMVDDEF),[_Obj,Attr|_])
	; is_flogic(Head,CODER_HEAD_CONTEXT,FLNEGHEADPREFIX(WRAP_IMVDDEF),[_Obj,Attr|_])),
	!,
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV1),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV2),
	flora_build_debug_term_skeleton(Attr,ACode).

flora_build_debug_skeleton_flogic(Head,PRTRAN(NV1,TCode,NV2)) :-
	(is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_TRAN),[_Obj,Tran|_])
	; is_flogic(Head,CODER_HEAD_CONTEXT,FLNEGHEADPREFIX(WRAP_TRAN),[_Obj,Tran|_])),
	!,
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV1),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV2),
	flora_build_debug_term_skeleton(Tran,TCode).

flora_build_debug_skeleton_flogic(Head,PRBOOLSIG(NV1,ACode,NV2)) :-
	(is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_BOOLSIG),[_Obj,Att|_])
	; is_flogic(Head,CODER_HEAD_CONTEXT,FLNEGHEADPREFIX(WRAP_BOOLSIG),[_Obj,Att|_])),
	!,
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV1),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV2),
	flora_build_debug_term_skeleton(Att,ACode).

flora_build_debug_skeleton_flogic(Head,PRMVDSIG(NV1,ACode,NV2,NV3)) :-
	(is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_MVDSIG),[_Obj,Att,_Val|_])
	; is_flogic(Head,CODER_HEAD_CONTEXT,FLNEGHEADPREFIX(WRAP_MVDSIG),[_Obj,Att,_Val|_])),
	!,
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV1),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV2),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV3),
	flora_build_debug_term_skeleton(Att,ACode).

flora_build_debug_skeleton_flogic(Head,PRIMVDSIG(NV1,ACode,NV2,NV3)) :-
	(is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_IMVDSIG),[_Obj,Att,_Val|_])
	; is_flogic(Head,CODER_HEAD_CONTEXT,FLNEGHEADPREFIX(WRAP_IMVDSIG),[_Obj,Att,_Val|_])),
	!,
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV1),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV2),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV3),
	flora_build_debug_term_skeleton(Att,ACode).

flora_build_debug_skeleton_flogic(Head,PRIBOOLSIG(NV1,ACode,NV2)) :-
	(is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_IBOOLSIG),[_Obj,Att|_])
	; is_flogic(Head,CODER_HEAD_CONTEXT,FLNEGHEADPREFIX(WRAP_IBOOLSIG),[_Obj,Att|_])),
	!,
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV1),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV2),
	flora_build_debug_term_skeleton(Att,ACode).

flora_build_debug_skeleton_flogic(Head,PRTRANSIG(NV1,ACode,NV2)) :-
	(is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_TRANSIG),[_Obj,Att|_])
	; is_flogic(Head,CODER_HEAD_CONTEXT,FLNEGHEADPREFIX(WRAP_TRANSIG),[_Obj,Att|_])),
	!,
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV1),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV2),
	flora_build_debug_term_skeleton(Att,ACode).

flora_build_debug_skeleton_flogic(Head,PRITRANSIG(NV1,ACode,NV2)) :-
	(is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_ITRANSIG),[_Obj,Att|_])
	; is_flogic(Head,CODER_HEAD_CONTEXT,FLNEGHEADPREFIX(WRAP_ITRANSIG),[_Obj,Att|_])),
	!,
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV1),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV2),
	flora_build_debug_term_skeleton(Att,ACode).

flora_build_debug_skeleton_flogic(Head,PRMVDCON(NV1,ACode,NV2,NV3,NV4)) :-
	(is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_MVDCON),[_Obj,Att,_Lower,_Upper|_])
	; is_flogic(Head,CODER_HEAD_CONTEXT,FLNEGHEADPREFIX(WRAP_MVDCON),[_Obj,Att,_Lower,_Upper|_])),
	!,
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV1),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV2),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV3),
	flora_new_varobj(FLDNEWVAR,NO_INDEX,NV4),
	flora_build_debug_term_skeleton(Att,ACode).

flora_build_debug_skeleton_flogic(Head,PRMVDCONDEF(NV1,ACode,NV2,NV3,NV4)) :-
	(is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_MVDCONDEF),[_Obj,Att,_Lower,_Upper,_Type|_])
	; is_flogic(Head,CODER_HEAD_CONTEXT,FLNEGHEADPREFIX(WRAP_MVDCONDEF),[_Obj,Att,_Lower,_Upper,_Type|_])),
	!,
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV1),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV2),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV3),
	flora_new_varobj(FLDNEWVAR,NO_INDEX,NV4),
	flora_build_debug_term_skeleton(Att,ACode).

flora_build_debug_skeleton_flogic(Head,PRIMVDCON(NV1,ACode,NV2,NV3,NV4)) :-
	(is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_IMVDCON),[_Obj,Att,_Lower,_Upper|_])
	; is_flogic(Head,CODER_HEAD_CONTEXT,FLNEGHEADPREFIX(WRAP_IMVDCON),[_Obj,Att,_Lower,_Upper|_])),
	!,
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV1),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV2),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV3),
	flora_new_varobj(FLDNEWVAR,NO_INDEX,NV4),
	flora_build_debug_term_skeleton(Att,ACode).

flora_build_debug_skeleton_flogic(Head,PRIMVDCONDEF(NV1,ACode,NV2,NV3,NV4)) :-
	(is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_IMVDCONDEF),[_Obj,Att,_Lower,_Upper,_Type|_])
	; is_flogic(Head,CODER_HEAD_CONTEXT,FLNEGHEADPREFIX(WRAP_IMVDCONDEF),[_Obj,Att,_Lower,_Upper,_Type|_])),
	!,
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV1),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV2),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV3),
	flora_new_varobj(FLDNEWVAR,NO_INDEX,NV4),
	flora_build_debug_term_skeleton(Att,ACode).

/* These cannot occur in a rule head
flora_build_debug_skeleton_flogic(Head,PRMVDINC(NV1,ACode,NV2,NV3)) :-
	(is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_MVDINC),[_Obj,Att,_Val|_])
	; is_flogic(Head,CODER_HEAD_CONTEXT,FLNEGHEADPREFIX(WRAP_MVDINC),[_Obj,Att,_Val|_])),
	!,
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV1),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV2),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV3),
	flora_build_debug_term_skeleton(Att,ACode).

flora_build_debug_skeleton_flogic(Head,PRIMVDINC(NV1,ACode,NV2,NV3)) :-
	(is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_IMVDINC),[_Obj,Att,_Val|_])
	; is_flogic(Head,CODER_HEAD_CONTEXT,FLNEGHEADPREFIX(WRAP_IMVDINC),[_Obj,Att,_Val|_])),
	!,
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV1),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV2),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV3),
	flora_build_debug_term_skeleton(Att,ACode).

flora_build_debug_skeleton_flogic(Head,PRMVDTOLIST(NV1,ACode,NV2,NV3)) :-
	(is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_MVDTOLIST),[_Obj,Att,_Val|_])
	; is_flogic(Head,CODER_HEAD_CONTEXT,FLNEGHEADPREFIX(WRAP_MVDTOLIST),[_Obj,Att,_Val|_])),
	!,
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV1),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV2),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV3),
	flora_build_debug_term_skeleton(Att,ACode).

flora_build_debug_skeleton_flogic(Head,PRIMVDTOLIST(NV1,ACode,NV2,NV3)) :-
	(is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_IMVDTOLIST),[_Obj,Att,_Val|_])
	; is_flogic(Head,CODER_HEAD_CONTEXT,FLHEADPREFIX(WRAP_IMVDTOLIST),[_Obj,Att,_Val|_])),
	!,
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV1),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV2),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV3),
	flora_build_debug_term_skeleton(Att,ACode).
*/


flora_build_debug_term_skeleton(Head,PRTERM(FCode,N,ObjListCode)) :-
	%% HiLog term, but not predicate - don't lop off the last argument
	is_prterm(Head,FObj,N,ObjList),
	!,
	( is_pratom(FObj,FAtom,_Index), flora_prlgdef(FAtom,N) ->
	    fail
	;
	    pr_generalize_last_arg_strip_index(FObj,FCode),
	    pr_generalize_last_arg_strip_index(ObjList,ObjListCode)
	).

flora_build_debug_term_skeleton(Head,Sk) :-
	pr_generalize_last_arg_strip_index(Head,Sk).

/*********************************************************************
  prvar_list(+N,-VarList)
  generate a list of N new variables
**********************************************************************/
prvar_list(0,[]) :- !.
prvar_list(N,[NV|Rest]) :-
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV),
	M is N-1,
	prvar_list(M, Rest).

/*********************************************************************
  pr_generalize_last_arg_strip_index(+Term,-NewTerm)

  Recursively descend into a compiled term and generalize last caller arg in
  Flora predicates. Return new term unless the input is a PRVARIABLE or
  PRTRANSACTIONALVARIABLE term.
**********************************************************************/
pr_generalize_last_arg_strip_index(Term,NewTerm) :-
	\+ is_prvariable(Term,_,_),
	\+ is_prtransactionalvariable(Term,_,_),
	pr_generalize_last_strip_idx1(Term,NewTerm).


pr_generalize_last_strip_idx1(Term,PRATOM(Atom,NO_INDEX)) :-
	is_pratom(Term,Atom,_Index),
	!.

pr_generalize_last_strip_idx1(Term,PRBUILTIN_IDENTIFIER(Atom,NO_INDEX)) :-
	is_prbuiltin_identifier(Term,Atom,_Index),
	!.

pr_generalize_last_strip_idx1(Term,PRVARIABLE(Name,NO_INDEX)) :-
	is_prvariable(Term,Name,_Index),
	!.

pr_generalize_last_strip_idx1(Term,PRTRANSACTIONALVARIABLE(Name,NO_INDEX)) :-
	is_prtransactionalvariable(Term,Name,_Index),
	!.

pr_generalize_last_strip_idx1(Term,PRATOMLIT([A|NewCallerList],NO_INDEX)) :-
        is_pratomlit(Term,CODER_HEAD_CONTEXT,_Wrap,[A|CallerList],_Index),
	!,
        ( CallerList == [] ->
	    NewCallerList = []
	;
	    prvar_list(1,NewCallerList)
	).

pr_generalize_last_strip_idx1(Term,PRTRANSACTIONALATOMLIT([A,NewCaller],NO_INDEX)) :-
        is_prtransactionalatomlit(Term,CODER_HEAD_CONTEXT,_Wrap,[A,_Caller],_Index),
	!,
	prvar_list(1,[NewCaller]).

pr_generalize_last_strip_idx1(Term,NewTerm) :-
	is_prtermlit(Term,CODER_HEAD_CONTEXT,_Wrap,FObj,ObjList),
	!,
        flrtrim_last(ObjList,ObjListWOCaller),
        pr_generalize_last_strip_idx1(FObj,NF),
        pr_generalize_last_strip_idx1(ObjListWOCaller,NObjListWOCaller),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV),
        flora_add_last(NObjListWOCaller,NObjList,NV),
	length(NObjList,N),
        NewTerm = PRTERMLIT(NF,N,NObjList).

pr_generalize_last_strip_idx1(Term,NewTerm) :-
	is_prtransactionaltermlit(Term,CODER_HEAD_CONTEXT,_Wrap,FObj,ObjList),
	!,
        flrtrim_last(ObjList,ObjListWOCaller),
        pr_generalize_last_strip_idx1(FObj,NF),
        pr_generalize_last_strip_idx1(ObjListWOCaller,NObjListWOCaller),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV),
        flora_add_last(NObjListWOCaller,NObjList,NV),
	length(NObjList,N),
        NewTerm = PRTRANSACTIONALTERMLIT(NF,N,NObjList).

pr_generalize_last_strip_idx1(Term,NewTerm) :-
	is_flogic(Term,CODER_HEAD_CONTEXT,_FLogic,_OL),
	!,
        Term =.. [Wrapper|ObjList],
        flrtrim_last(ObjList,ObjListWOCaller),
        pr_generalize_last_strip_idx1(ObjListWOCaller,NObjListWOCaller),
        flora_new_varobj(FLDNEWVAR,NO_INDEX,NV),
        flora_add_last(NObjListWOCaller,NObjList,NV),
        NewTerm =.. [Wrapper|NObjList]. 

pr_generalize_last_strip_idx1(Term,NewTerm) :-
	is_prterm(Term,FObj,N,ObjList),
	!,
        NewTerm = PRTERM(NF,N,NObjList),
        pr_generalize_last_strip_idx1(FObj,NF),
        pr_generalize_last_strip_idx1(ObjList,NObjList).

pr_generalize_last_strip_idx1(Term,NewTerm) :-
        is_list(Term),
        !,
        pr_generalize_ans_strip_index_in_list(Term,NewTerm).

pr_generalize_last_strip_idx1(Term,NewTerm) :-
	compound(Term),
	!,
	Term =.. [Func|L],
	pr_generalize_last_strip_idx1(L,NL),
	NewTerm =.. [Func|NL].

pr_generalize_last_strip_idx1(Term,NewTerm) :-
	atomic(Term),
	!,
	NewTerm = Term.

pr_generalize_ans_strip_index_in_list([],[]) :- !.

pr_generalize_ans_strip_index_in_list([H|L],[NH|NL]) :-
	pr_generalize_last_strip_idx1(H,NH),
	pr_generalize_ans_strip_index_in_list(L,NL).


/*********************************************************************
  generate_patches
**********************************************************************/
generate_patches :-
	!,
	( term_seen(Term),
	    flora_write_struct(Term,CODER_GENERIC_CONTEXT,Status),
	    flora_coder_error(Status),
	    put(CH_DOT),
	    nl,
	    fail
	;
	    true
	),
	!.


/*********************************************************************
  utilities for flora_build_skeleton
**********************************************************************/
%% Canonical wrappers are the ones that will get into the fld tries.

is_class_hierarchy_wrapper(WRAP_ISA).
is_class_hierarchy_wrapper(WRAP_SUB).
is_class_hierarchy_wrapper(FLNEGPREFIX(WRAP_ISA)).
is_class_hierarchy_wrapper(FLNEGPREFIX(WRAP_SUB)).

is_subclass_wrapper(WRAP_SUB).
is_subclass_wrapper(FLNEGPREFIX(WRAP_SUB)).

%% for 3-param wrappers
canonic_flogic_wrapper(WRAP_ISA,WRAP_SUB).
canonic_flogic_wrapper(FLNEGPREFIX(WRAP_ISA),WRAP_SUB).
canonic_flogic_wrapper(WRAP_SUB,WRAP_SUB).
canonic_flogic_wrapper(FLNEGPREFIX(WRAP_SUB),WRAP_SUB).
canonic_flogic_wrapper(WRAP_METH,WRAP_METH).
canonic_flogic_wrapper(FLNEGPREFIX(WRAP_METH),WRAP_METH).
canonic_flogic_wrapper(WRAP_IMETH,WRAP_IMETH).
canonic_flogic_wrapper(FLNEGPREFIX(WRAP_IMETH),WRAP_IMETH).
canonic_flogic_wrapper(WRAP_MVDDEF,WRAP_MVDDEF).
canonic_flogic_wrapper(FLNEGPREFIX(WRAP_MVDDEF),WRAP_MVDDEF).
canonic_flogic_wrapper(WRAP_IMVDDEF,WRAP_IMVDDEF).
canonic_flogic_wrapper(FLNEGPREFIX(WRAP_IMVDDEF),WRAP_IMVDDEF).
canonic_flogic_wrapper(WRAP_BOOLSIG,WRAP_BOOLSIG).
canonic_flogic_wrapper(FLNEGPREFIX(WRAP_BOOLSIG),WRAP_BOOLSIG).
canonic_flogic_wrapper(WRAP_IBOOLSIG,WRAP_IBOOLSIG).
canonic_flogic_wrapper(FLNEGPREFIX(WRAP_IBOOLSIG),WRAP_IBOOLSIG).
canonic_flogic_wrapper(WRAP_TRANSIG,WRAP_TRANSIG).
canonic_flogic_wrapper(WRAP_ITRANSIG,WRAP_ITRANSIG).
canonic_flogic_wrapper(WRAP_TRAN,WRAP_TRAN).

%% for 4-param wrappers
canonic_flogic_wrapper(WRAP_MVDSIG,WRAP_MVDSIG).
canonic_flogic_wrapper(FLNEGPREFIX(WRAP_MVDSIG),WRAP_MVDSIG).
canonic_flogic_wrapper(WRAP_IMVDSIG,WRAP_IMVDSIG).
canonic_flogic_wrapper(FLNEGPREFIX(WRAP_IMVDSIG),WRAP_IMVDSIG).
canonic_flogic_wrapper(WRAP_MVDCONDEF,WRAP_MVDCONDEF).
canonic_flogic_wrapper(WRAP_IMVDCONDEF,WRAP_IMVDCONDEF).
canonic_flogic_wrapper(WRAP_MVD,WRAP_MVD).
canonic_flogic_wrapper(FLNEGPREFIX(WRAP_MVD),WRAP_MVD).
canonic_flogic_wrapper(WRAP_IMVD,WRAP_IMVD).
canonic_flogic_wrapper(FLNEGPREFIX(WRAP_IMVD),WRAP_IMVD).
canonic_flogic_wrapper(WRAP_MVDINC,WRAP_MVDINC).
canonic_flogic_wrapper(WRAP_IMVDINC,WRAP_IMVDINC).
canonic_flogic_wrapper(WRAP_MVDTOLIST,WRAP_MVDTOLIST).
canonic_flogic_wrapper(WRAP_IMVDTOLIST,WRAP_IMVDTOLIST).

%% For HiLog predicate wrappers
canonic_hilog_wrapper(WRAP_NONTABLED_HILOG,WRAP_NONTABLED_HILOG).
canonic_hilog_wrapper(WRAP_TABLED_HILOG,WRAP_TABLED_HILOG).
canonic_hilog_wrapper(FLNEGPREFIX(WRAP_TABLED_HILOG),WRAP_TABLED_HILOG).

canonic_wrapper(X,Y) :- canonic_hilog_wrapper(X,Y), !.
canonic_wrapper(X,Y) :- canonic_flogic_wrapper(X,Y), !.

/*********************************************************************
    build_skeleton_predicate(+[Wrap|Args],+ModName,SkeletonPred)
    build_canonic_skeleton_predicate(+[Wrap|Args],+ModName,SkeletonPred)
  Builds skeleton and then constructs a predicate out of it
*********************************************************************/
build_skeleton_predicate(QCode,ModName,SkeletonPred) :-
	( flora_build_skeleton(QCode,Skeleton), !
	; Skeleton=QCode
	),
	Skeleton = [Funct|SkelArgs],
	flora_module_predicate(Funct,SkelArgs,ModName,SkeletonPred).

build_canonic_skeleton_predicate([Wrap|Args],ModName,SkeletonPred) :-
	canonic_wrapper(Wrap,CWrap),
	QCode = [CWrap|Args],
	( flora_build_skeleton(QCode,Skeleton), !
	; Skeleton=QCode
	),
	Skeleton = [Funct|SkelArgs],
	flora_module_predicate(Funct,SkelArgs,ModName,SkeletonPred).

/*********************************************************************
  flora_build_skeleton(+Term, -Code)
  builds the skeleton of Term
  This is similar to flora_build_debug_skeleton, but the term is not
  in intermediate form.
  This predicate is called at run time (in the shell or to insert
  skeletons for facts that were added to FDB storage)
**********************************************************************/
flora_build_skeleton([Wrap,F|Arg],[Wrap,FSkeleton|VList]) :-
	canonic_hilog_wrapper(Wrap,_),
	!,
	length(Arg,N),
	var_list(N, VList),
	generalize_last_arg_recursively(F,FSkeleton).

%% SUB, ISA, etc.
flora_build_skeleton([Wrap,_Obj1,Obj2,_Caller],[Wrap,_,OCode,_]) :-
	is_class_hierarchy_wrapper(Wrap),
        !,
	nonvar(Obj2),
        generalize_last_arg_recursively(Obj2,OCode).

%% For 3-param F-logic wrappers
flora_build_skeleton([Wrap,_Obj,Att,_Caller],[Wrap,_,ACode,_]) :-
        !,
        flora_build_term_skeleton(Att,ACode).

% For 4-param F-logic wrappers
flora_build_skeleton([Wrap,_Obj,Att,_Val,_Caller],[Wrap,_,ACode,_,_]) :-
	!,
	flora_build_term_skeleton(Att,ACode).


/****************************************************************************
        flora_build_term_skeleton(+Term,-NewTerm)
  If a HiLog term, create a skeleton for it by replacing args with new vars.
  If a Prolog term, just return it.
  If FLORA-2 callable predicate, replace CallerVar with a new var.
****************************************************************************/
flora_build_term_skeleton(Term,Term) :-
        var(Term),
        !.

flora_build_term_skeleton(Term,NewTerm) :-
        %% HiLog Term
        functor(Term,WRAP_HILOG,N),
        N>0,
        !,
        Term =.. [WRAP_HILOG,Funct|_Args],
        M is N-1,
        var_list(M,VList),
        generalize_last_arg_recursively(Funct,FCode),
        NewTerm =.. [WRAP_HILOG,FCode|VList].

flora_build_term_skeleton(Term,NewTerm) :-
        generalize_last_arg_recursively(Term,NewTerm).
        

/*********************************************************************
	generalize_last_arg_recursively(+Term,-NewTerm)

 Decend into terms and generalize the last caller argument in Flora predicates.
*********************************************************************/
generalize_last_arg_recursively(Term,NewTerm) :-
	generalize_last_recursively1(Term,NewTerm).

generalize_last_recursively1(Term,Term) :-
	(atomic(Term) ; var(Term)),
	!.
generalize_last_recursively1(Term,NewTerm) :-
	(is_flora_callable_literal(Term)
	-> flora_generalize_last(Term,GTerm)
	; GTerm = Term
	),
	GTerm =.. [Func|Args],
        generalize_last_in_list(Args,NewArgs),
        NewTerm =.. [Func|NewArgs].

generalize_last_in_list([],[]) :- !.
generalize_last_in_list([H|L],[NH|NL]) :-
        generalize_last_recursively1(H,NH),
        generalize_last_in_list(L,NL).


%% New list of distinct variables
var_list(N, VarList) :- length(VarList,N).


/*****************************************
* flora_define_predicate(+Predicate)
* compute the skeleton of Predicate and insert it to FldStorage
* This is used in syslib/flrdynrule.P
* (for the heads of dynamically inserted rules)
*****************************************/
flora_define_predicate(Predicate) :-
        flora_decode_predicate(Predicate,_PType,MName,_WPrefix,Wrapper,AList),
	QCode = [Wrapper|AList],
	( is_class_hierarchy_wrapper(Wrapper),
	    canonic_flogic_wrapper(Wrapper,CWrapper)
	->
	    AList = [C1,_C2|Rest],
	    QCode1 = [CWrapper,_,C1|Rest]  % make ?::C1 also defined
	;
	    true
	),
        flora_fld_storage_name(MName,FldStorage),
        ( build_canonic_skeleton_predicate(QCode,MName,Skeleton)
	->
	    flora_db_insert_base(FldStorage,Skeleton)
        ;
            true
        ),
        ( nonvar(QCode1),
	    build_canonic_skeleton_predicate(QCode1,MName,Skeleton1)
	->
	    flora_db_insert_base(FldStorage,Skeleton1)
        ;
            true
        ).


/*****************************************************************************
*    flora_temp_protect_call(+Predicate,+Id)
*    flora_temp_unprotect_call(+Id) :-
* +Predicate is the call to be recorded as temporarily protected
*            from the undefinedness check.
* +Id is a unique Id that is used to delete the call from the registry.
*
* This is similar to flora_define_predicate/1 above.
*
* Compute the skeleton of Predcate and insert it to a temporary storage
* to prevent signalling undefinedness errrors. This is used for calls
* like Call@Var in flrdynmod.P, because when Var is a variable then
* undefinedness check for Call doesn't make sense.
*****************************************************************************/
flora_temp_protect_call(Predicate,Id) :-
        flora_decode_predicate(Predicate,_PType,MName,_WPrefix,Wrap,AList),
	build_skeleton_predicate([Wrap|AList],MName,Skeleton),
	asserta(flora_disabled_undefinedness_check_registry(MName,Id,Skeleton)).

flora_temp_unprotect_call(Id) :-
	retractall(flora_disabled_undefinedness_check_registry(_,Id,_)).

%% Tell if call is protected
temporarily_protected_call(PredCode,ModName) :-
	build_skeleton_predicate(PredCode,ModName,Skeleton),
	flora_disabled_undefinedness_check_registry(_Mod,_Id,Skeleton).


/****************************************************************************
**  defined_by(+What,-ByWhat)
**  +What is a list that represents a query.
**  -ByWhat is a representation of a rule head that might define the call.
****************************************************************************/
%% The use [A1|Alist] makes sure that only true HiLog predicates user defined_by
defined_by([WRAP_TABLED_HILOG|[A1|Alist]],[Wrap|[A1|Alist]]) :-
	Wrap = WRAP_TABLED_HILOG ; Wrap = FLNEGPREFIX(WRAP_TABLED_HILOG).
defined_by([FLNEGPREFIX(WRAP_TABLED_HILOG)|[A1|Alist]],[Wrap|[A1|Alist]]) :-
	Wrap = WRAP_TABLED_HILOG ; Wrap = FLNEGPREFIX(WRAP_TABLED_HILOG).
defined_by([WRAP_NONTABLED_HILOG|Alist],[WRAP_NONTABLED_HILOG|Alist]).

defined_by([WRAP_ISA,_X,Y,_],[Wrap,_,Y,_]) :-
	Wrap = WRAP_ISA ; Wrap = WRAP_SUB
	; Wrap = FLNEGPREFIX(WRAP_ISA) ; Wrap = FLNEGPREFIX(WRAP_SUB).
defined_by([FLNEGPREFIX(WRAP_ISA),_X,Y,_],[Wrap,_,Y,_]) :-
	Wrap = WRAP_ISA ; Wrap = WRAP_SUB
	; Wrap = FLNEGPREFIX(WRAP_ISA) ; Wrap = FLNEGPREFIX(WRAP_SUB).
defined_by([WRAP_ISA,_X,Y,_],[Wrap,Y,_,_]) :-
	Wrap = WRAP_SUB ; Wrap = FLNEGPREFIX(WRAP_SUB).
defined_by([WRAP_SUB,_X,Y,_],[Wrap,_,Y,_]) :-
	Wrap = WRAP_ISA ; Wrap = WRAP_SUB
	; Wrap = FLNEGPREFIX(WRAP_ISA) ; Wrap = FLNEGPREFIX(WRAP_SUB).
defined_by([FLNEGPREFIX(WRAP_SUB),_X,Y,_],[Wrap,_,Y,_]) :-
	Wrap = WRAP_ISA ; Wrap = WRAP_SUB
	; Wrap = FLNEGPREFIX(WRAP_ISA) ; Wrap = FLNEGPREFIX(WRAP_SUB).
defined_by([WRAP_SUB,_X,Y,_],[Wrap,Y,_,_]) :-
	Wrap = WRAP_SUB ; Wrap = FLNEGPREFIX(WRAP_SUB).
defined_by([FLNEGPREFIX(WRAP_SUB),_X,Y,_],[Wrap,Y,_,_]) :-
	Wrap = WRAP_SUB ; Wrap = FLNEGPREFIX(WRAP_SUB).

defined_by([WRAP_METH,X,Y,_],[Wrap,X,Y,_]) :-
	Wrap = WRAP_METH ; Wrap = WRAP_IMETH
	; Wrap = FLNEGPREFIX(WRAP_METH) ; Wrap = FLNEGPREFIX(WRAP_IMETH).
defined_by([FLNEGPREFIX(WRAP_METH),X,Y,_],[Wrap,X,Y,_]) :-
	Wrap = WRAP_METH ; Wrap = WRAP_IMETH
	; Wrap = FLNEGPREFIX(WRAP_METH) ; Wrap = FLNEGPREFIX(WRAP_IMETH).
defined_by([WRAP_IMETH,X,Y,_],[Wrap,X,Y,_]) :-
	Wrap = WRAP_IMETH ; Wrap = FLNEGPREFIX(WRAP_IMETH).
defined_by([FLNEGPREFIX(WRAP_IMETH),X,Y,_],[Wrap,X,Y,_]) :-
	Wrap = WRAP_IMETH ; Wrap = FLNEGPREFIX(WRAP_IMETH).

defined_by([WRAP_MVD,X,Y,Z,_],[Wrap,X,Y,Z,_]) :-
	Wrap = WRAP_MVD ; Wrap = WRAP_IMVD
	; Wrap = FLNEGPREFIX(WRAP_MVD) ; Wrap = FLNEGPREFIX(WRAP_IMVD).
defined_by([WRAP_MVD,X,Y,_Z,_],[Wrap,X,Y,_]) :-
	Wrap = WRAP_MVDDEF; Wrap = WRAP_IMVDDEF
	; Wrap = FLNEGPREFIX(WRAP_MVDDEF); Wrap = FLNEGPREFIX(WRAP_IMVDDEF).
defined_by([FLNEGPREFIX(WRAP_MVD),X,Y,Z,_],[Wrap,X,Y,Z,_]) :-
	Wrap = WRAP_MVD ; Wrap = WRAP_IMVD
	; Wrap = FLNEGPREFIX(WRAP_MVD) ; Wrap = FLNEGPREFIX(WRAP_IMVD).
defined_by([FLNEGPREFIX(WRAP_MVD),X,Y,_Z,_],[Wrap,X,Y,_]) :-
	Wrap = WRAP_MVDDEF; Wrap = WRAP_IMVDDEF
	; Wrap = FLNEGPREFIX(WRAP_MVDDEF); Wrap = FLNEGPREFIX(WRAP_IMVDDEF).

defined_by([WRAP_IMVD,X,Y,Z,_],[Wrap,X,Y,Z,_]) :-
	Wrap = WRAP_IMVD ; Wrap = FLNEGPREFIX(WRAP_IMVD).
defined_by([WRAP_IMVD,X,Y,_Z,_],[Wrap,X,Y,_]) :-
	Wrap = WRAP_IMVDDEF ; Wrap = FLNEGPREFIX(WRAP_IMVDDEF).
defined_by([FLNEGPREFIX(WRAP_IMVD),X,Y,Z,_],[Wrap,X,Y,Z,_]) :-
	Wrap = WRAP_IMVD ; Wrap = FLNEGPREFIX(WRAP_IMVD).
defined_by([FLNEGPREFIX(WRAP_IMVD),X,Y,_Z,_],[Wrap,X,Y,_]) :-
	Wrap = WRAP_IMVDDEF ; Wrap = FLNEGPREFIX(WRAP_IMVDDEF).

defined_by([WRAP_MVDDEF,X,Y,_],[Wrap,X,Y,_Z,_]) :-
	Wrap = WRAP_MVD ; Wrap = WRAP_IMVD
	; Wrap = FLNEGPREFIX(WRAP_MVD) ; Wrap = FLNEGPREFIX(WRAP_IMVD).
defined_by([WRAP_MVDDEF,X,Y,_],[Wrap,X,Y,_]) :-
	Wrap = WRAP_MVDDEF; Wrap = WRAP_IMVDDEF
	; Wrap = FLNEGPREFIX(WRAP_MVDDEF); Wrap = FLNEGPREFIX(WRAP_IMVDDEF).
defined_by([FLNEGPREFIX(WRAP_MVDDEF),X,Y,_],[Wrap,X,Y,_Z,_]) :-
	Wrap = WRAP_MVD ; Wrap = WRAP_IMVD
	; Wrap = FLNEGPREFIX(WRAP_MVD) ; Wrap = FLNEGPREFIX(WRAP_IMVD).
defined_by([FLNEGPREFIX(WRAP_MVDDEF),X,Y,_],[Wrap,X,Y,_]) :-
	Wrap = WRAP_MVDDEF; Wrap = WRAP_IMVDDEF
	; Wrap = FLNEGPREFIX(WRAP_MVDDEF); Wrap = FLNEGPREFIX(WRAP_IMVDDEF).

defined_by([WRAP_IMVDDEF,X,Y,_],[Wrap,X,Y,_Z,_]) :-
	Wrap = WRAP_IMVD ; Wrap = FLNEGPREFIX(WRAP_IMVD).
defined_by([WRAP_IMVDDEF,X,Y,_],[Wrap,X,Y,_]) :-
	Wrap = WRAP_IMVDDEF ; Wrap = FLNEGPREFIX(WRAP_IMVDDEF).
defined_by([FLNEGPREFIX(WRAP_IMVDDEF),X,Y,_],[Wrap,X,Y,_Z,_]) :-
	Wrap = WRAP_IMVD ; Wrap = FLNEGPREFIX(WRAP_IMVD).
defined_by([FLNEGPREFIX(WRAP_IMVDDEF),X,Y,_],[Wrap,X,Y,_]) :-
	Wrap = WRAP_IMVDDEF ; Wrap = FLNEGPREFIX(WRAP_IMVDDEF).

defined_by([WRAP_MVDSIG,X,Y,Z,_],[Wrap,X,Y,Z,_]) :-
	Wrap = WRAP_MVDSIG ; Wrap = WRAP_IMVDSIG
	; Wrap = FLNEGPREFIX(WRAP_MVDSIG) ; Wrap = FLNEGPREFIX(WRAP_IMVDSIG).
defined_by([WRAP_MVDSIG,X,Y,_Z,_],[Wrap,X,Y,_]) :-
	Wrap = WRAP_MVDSIGDEF ; Wrap = WRAP_IMVDSIGDEF
	; Wrap = FLNEGPREFIX(WRAP_MVDSIGDEF) ; Wrap = FLNEGPREFIX(WRAP_IMVDSIGDEF).
defined_by([FLNEGPREFIX(WRAP_MVDSIG),X,Y,Z,_],[Wrap,X,Y,Z,_]) :-
	Wrap = WRAP_MVDSIG ; Wrap = WRAP_IMVDSIG
	; Wrap = FLNEGPREFIX(WRAP_MVDSIG) ; Wrap = FLNEGPREFIX(WRAP_IMVDSIG).
defined_by([FLNEGPREFIX(WRAP_MVDSIG),X,Y,_Z,_],[Wrap,X,Y,_]) :-
	Wrap = WRAP_MVDSIGDEF ; Wrap = WRAP_IMVDSIGDEF
	; Wrap = FLNEGPREFIX(WRAP_MVDSIGDEF) ; Wrap = FLNEGPREFIX(WRAP_IMVDSIGDEF).

defined_by([WRAP_IMVDSIG,X,Y,Z,_],[Wrap,X,Y,Z,_]) :-
	Wrap = WRAP_IMVDSIG ; Wrap = FLNEGPREFIX(WRAP_IMVDSIG).
defined_by([WRAP_IMVDSIG,X,Y,_Z,_],[Wrap,X,Y,_]) :-
	Wrap = WRAP_IMVDSIGDEF ; Wrap = FLNEGPREFIX(WRAP_IMVDSIGDEF).
defined_by([FLNEGPREFIX(WRAP_IMVDSIG),X,Y,Z,_],[Wrap,X,Y,Z,_]) :-
	Wrap = WRAP_IMVDSIG ; Wrap = FLNEGPREFIX(WRAP_IMVDSIG).
defined_by([FLNEGPREFIX(WRAP_IMVDSIG),X,Y,_Z,_],[Wrap,X,Y,_]) :-
	Wrap = WRAP_IMVDSIGDEF ; Wrap = FLNEGPREFIX(WRAP_IMVDSIGDEF).

defined_by([WRAP_BOOLSIG,X,Y,_],[Wrap,X,Y,_]) :-
	Wrap = WRAP_BOOLSIG ; Wrap = WRAP_IBOOLSIG
	; Wrap = FLNEGPREFIX(WRAP_BOOLSIG) ; Wrap = FLNEGPREFIX(WRAP_IBOOLSIG).
defined_by([FLNEGPREFIX(WRAP_BOOLSIG),X,Y,_],[Wrap,X,Y,_]) :-
	Wrap = WRAP_BOOLSIG ; Wrap = WRAP_IBOOLSIG
	; Wrap = FLNEGPREFIX(WRAP_BOOLSIG) ; Wrap = FLNEGPREFIX(WRAP_IBOOLSIG).

defined_by([WRAP_IBOOLSIG,X,Y,_],[Wrap,X,Y,_]) :-
	Wrap = WRAP_IBOOLSIG ; Wrap = FLNEGPREFIX(WRAP_IBOOLSIG).
defined_by([FLNEGPREFIX(WRAP_IBOOLSIG),X,Y,_],[Wrap,X,Y,_]) :-
	Wrap = WRAP_IBOOLSIG ; Wrap = FLNEGPREFIX(WRAP_IBOOLSIG).

%% SIGDEF occurs when we have a[b=> ()]
defined_by([WRAP_MVDSIGDEF,X,Y,_],[Wrap,X,Y,_]) :-
	Wrap = WRAP_MVDSIGDEF ; Wrap = WRAP_IMVDSIGDEF
	; Wrap = FLNEGPREFIX(WRAP_MVDSIGDEF)
	; Wrap = FLNEGPREFIX(WRAP_IMVDSIGDEF).
defined_by([FLNEGPREFIX(WRAP_MVDSIGDEF),X,Y,_],[Wrap,X,Y,_]) :-
	Wrap = WRAP_MVDSIGDEF ; Wrap = WRAP_IMVDSIGDEF
	; Wrap = FLNEGPREFIX(WRAP_MVDSIGDEF)
	; Wrap = FLNEGPREFIX(WRAP_IMVDSIGDEF).
defined_by([WRAP_MVDSIGDEF,X,Y,_],[Wrap,X,Y,_Z,_]) :-
	Wrap = WRAP_MVDSIG ; Wrap = WRAP_IMVDSIG
	; Wrap = FLNEGPREFIX(WRAP_MVDSIG) ; Wrap = FLNEGPREFIX(WRAP_IMVDSIG).
defined_by([FLNEGPREFIX(WRAP_MVDSIGDEF),X,Y,_],[Wrap,X,Y,_Z,_]) :-
	Wrap = WRAP_MVDSIG ; Wrap = WRAP_IMVDSIG
	; Wrap = FLNEGPREFIX(WRAP_MVDSIG) ; Wrap = FLNEGPREFIX(WRAP_IMVDSIG).

defined_by([WRAP_IMVDSIGDEF,X,Y,_],[WRAP_IMVDSIGDEF,X,Y,_]) :-
	Wrap = WRAP_IMVDSIGDEF ; Wrap = FLNEGPREFIX(WRAP_IMVDSIGDEF).
defined_by([FLNEGPREFIX(WRAP_IMVDSIGDEF),X,Y,_],[WRAP_IMVDSIGDEF,X,Y,_]) :-
	Wrap = WRAP_IMVDSIGDEF ; Wrap = FLNEGPREFIX(WRAP_IMVDSIGDEF).
defined_by([WRAP_IMVDSIGDEF,X,Y,_],[Wrap,X,Y,_Z,_]) :-
	Wrap = WRAP_IMVDSIG ; Wrap = FLNEGPREFIX(WRAP_IMVDSIG).
defined_by([FLNEGPREFIX(WRAP_IMVDSIGDEF),X,Y,_],[Wrap,X,Y,_Z,_]) :-
	Wrap = WRAP_IMVDSIG ; Wrap = FLNEGPREFIX(WRAP_IMVDSIG).

defined_by([WRAP_TRANSIG,X,Y,_],[WRAP_TRANSIG,X,Y,_]).
defined_by([WRAP_TRANSIG,X,Y,_],[WRAP_ITRANSIG,X,Y,_]).
defined_by([WRAP_ITRANSIG,X,Y,_],[WRAP_ITRANSIG,X,Y,_]).
defined_by([WRAP_MVDCONDEF,W,X,Y,Z,T,_],[WRAP_MVDCONDEF,W,X,Y,Z,T,_]).
defined_by([WRAP_MVDCONDEF,W,X,Y,Z,T,_],[WRAP_IMVDCONDEF,W,X,Y,Z,T,_]).
defined_by([WRAP_IMVDCONDEF,W,X,Y,Z,T,_],[WRAP_IMVDCONDEF,W,X,Y,Z,T,_]).
defined_by([WRAP_TRAN,X,Y,_],[WRAP_TRAN,X,Y,_]).
defined_by([WRAP_MVDINC,X,Y,Z,_],[WRAP_MVD,X,Y,Z,_]).
defined_by([WRAP_MVDINC,X,Y,Z,_],[WRAP_IMVD,X,Y,Z,_]).
defined_by([WRAP_IMVDINC,X,Y,Z,_],[WRAP_IMVD,X,Y,Z,_]).
defined_by([WRAP_MVDTOLIST,X,Y,Z,_],[WRAP_MVD,X,Y,Z,_]).
defined_by([WRAP_MVDTOLIST,X,Y,Z,_],[WRAP_IMVD,X,Y,Z,_]).
defined_by([WRAP_IMVDTOLIST,X,Y,Z,_],[WRAP_IMVD,X,Y,Z,_]).


%% Check if any of the skeletons unify with the base facts. If so,
%% consider the skeleton to be defined by the inserted facts
check_candidate_list_against_FDB([],_,_,[]) :- !.
check_candidate_list_against_FDB([Candidate|L],ModName,FdbStorage,CandList) :-
	(check_candidate_against_FDB(Candidate,ModName,FdbStorage)
	-> CandList = [Candidate|RestCandList]
	;  CandList = RestCandList
	),
	check_candidate_list_against_FDB(L,ModName,FdbStorage,RestCandList).

check_candidate_against_FDB(Candidate,ModName,FdbStorage) :-
	%% check FDB for each possible non-canonical relative of Wrap
	build_skeleton_predicate(Candidate,ModName,Call),
	flora_db_find_base(FdbStorage,Call),
	!.

%% Check skeletons in the candidate list against temporarily protected calls
%% Succeeds, if matches
check_temporarily_protected_calls([PredCode|L],ModName) :-
	temporarily_protected_call(PredCode,ModName), !;
	check_temporarily_protected_calls(L,ModName).

flora_error_notexported(Predicate):-
	flora_decode_predicate(Predicate,_PType,MName,_WrapPref,_Wrap,_AList),
	flora_decode_goal_as_atom(Predicate,PrintablePred),
	MainMsg = 'Call to unexported method/predicate or attempt to update a non-updatable method/predicate ',
	flora_concat_items([MainMsg,PrintablePred,' in module ',MName],ErrMsg),
	flora_abort(FLORA_NOT_EXPORTED_EXCEPTION(Predicate,ErrMsg)).


flora_error_invalid_export(Predicate) :-
	flora_abort(FLORA_NOT_EXPORTED_EXCEPTION(Predicate,'Attempt to export from an invalid or uninstantiated module/term.')).


/******************************************************************************
* flora_error_undefined(+Predicate)
*
* Is called when the skeleton of Predicate is not in the FLD storage.
* Because the skeleton of a fact is not 
* inserted into the FLD storage when the fact is inserted into the FDB storage,
* Predicate might have been defined by some inserted facts.
* flora_error_undefined(+Predicate) searches the FDB storage to see whether
* such a fact exists. If yes, the skeleton of the fact is inserted into the
* FLD storage; otherwise, a FLORA_UNDEFINED_EXCEPTION is thrown.
*
* This predicate FAILS if there is no error. Otherwise it gives an error
* and control goes to the top loop.
******************************************************************************/
flora_error_undefined(Predicate) :-
	flora_decode_predicate(Predicate,PType,MName,_WPrefix, Wrapper, AList),
        flora_fdb_storage_name(MName,FdbStorage),
        flora_fld_storage_name(MName,FldStorage),

	findall(QCode,defined_by([Wrapper|AList],QCode),CandList),

	( check_candidate_list_against_FDB(CandList,MName,FdbStorage,FCodeList),
	    FCodeList \= []
	->
	    insert_found_candidates_in_FLD(FCodeList,MName,FldStorage),
	    !,
	    fail % flora_error_undefined should fail, if things are good
	; check_temporarily_protected_calls(CandList,MName)
	->  fail

	; %% ISA & composite class construct
	    PType == flogic,
	    is_class_hierarchy_wrapper(Wrapper),
	    AList = [O,C|Rest],
	    nonvar(C), 
	    ((C=(C1,C2)); (C=(C1;C2)); (C=(C1-C2))), % C is a composite class
	    flora_module_predicate(Wrapper,[O,C1|Rest],MName,P1),
	    flora_module_predicate(Wrapper,[O,C2|Rest],MName,P2),
	    not flora_error_undefined(P1),
	    not flora_error_undefined(P2),
	    !,
	    fail
        ;  %% If none of the above fails then we have an error
	    ( PType==flogic,
		is_class_hierarchy_wrapper(Wrapper),
	        predicate_msg(Wrapper, AList, PMsg),
		TypeMsg = 'undefined class'
	    ; PType==flogic
	    ->
	        predicate_msg(Wrapper, AList, PMsg),
	 	TypeMsg = 'undefined method'
	    ;
	        hilog_predicate_msg(AList, PMsg1),
                ( Wrapper == WRAP_NONTABLED_HILOG ->
		    %% If it was nontabled HiLog, then add FL_TRAN = `%'
                    flora_concat_atoms([FL_TRAN,PMsg1],PMsg)
                ;
                    PMsg=PMsg1
                ),
		TypeMsg = 'undefined predicate'
	    ),
	    flora_concat_items([TypeMsg,' ',PMsg,' in module ',MName],ErrMsg)
	),
	flora_abort(FLORA_UNDEFINED_EXCEPTION(Predicate,ErrMsg)).

insert_found_candidates_in_FLD([],_,_) :- !.
insert_found_candidates_in_FLD([FCode|Rest],MName,FldStorage) :-
	FCode = [FDBWrap|FAList],
	(is_subclass_wrapper(FDBWrap)
	-> FAList = [Class1,_Class2|FARest],
	    FCode1 = [FDBWrap,_,Class1|FARest]
	; true
	),
	%% build_canonic_skeleton_predicate uses canonical form of the wrapper
	%% so only canonical form is inserted in FldStorage
	build_canonic_skeleton_predicate(FCode,MName,FSk),
	flora_db_insert_base(FldStorage,FSk),
	( nonvar(FCode1)
	->
	    build_canonic_skeleton_predicate(FCode1,MName,FSk1),
	    flora_db_insert_base(FldStorage,FSk1)
	;
	    true
	),
	insert_found_candidates_in_FLD(Rest,MName,FldStorage).

/*********************************************************************
  predicate_msg(+ArgList, -PMsg)
  predicate_msg(+Wrapper, +ArgList, -PMsg)
  generate a user-readable string from the predicate
**********************************************************************/
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% predicate_msg(+ArgList, -PMsg)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
predicate_msg(Term,Term) :-
	atom(Term),
	!.

predicate_msg(Term,'?') :-
	var(Term),
	!.

predicate_msg(Term,TC) :-
	number(Term),
	!,
	term_to_atom(Term,TC).

%% This is used when we have a HiLog predicate (tabled or nontabled),
%% which is itself a term:  foo(...)(...)(...). It then looks like
%% WRAP_HILOG(WRAP_HILOG(WRAP_HILOG(foo, ...), ...), ...)
predicate_msg(Term,PMsg) :-
	Term =.. [WRAP_HILOG,MainFunct|ArgList],
	!,
	predicate_msg(MainFunct, FMsg),
	( ArgList = [] ->
	    PMsg = FMsg
	;
	    varlist_to_str(ArgList, VMsg),
	    flora_concat_atoms([FMsg,'(',VMsg,')'],PMsg)
	).
predicate_msg(Reified,PMsg) :-
        flora_decode_goal_as_atom(Reified,PMsg).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% predicate_msg(+Wrapper, +ArgList, -PMsg)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
predicate_msg(WRAP_ISA,[_O1, O2,_], PMsg) :-
	!,
	predicate_msg(O2, O2Msg),
	flora_concat_atoms(['?:', O2Msg],PMsg).

predicate_msg(WRAP_SUB,[_O1, O2,_], PMsg) :-
	!,
	predicate_msg(O2, O2Msg),
	flora_concat_atoms(['?::', O2Msg],PMsg).

predicate_msg(WRAP_METH,[_O1, O2,_], PMsg) :-
	!,
	predicate_msg(O2, O2Msg),
	flora_concat_atoms(['?[ ',O2Msg,' ]'],PMsg).

predicate_msg(WRAP_IMETH,[_O1, O2,_], PMsg) :-
	!,
	predicate_msg(O2, O2Msg),
	flora_concat_atoms(['?[ *',O2Msg,' ]'],PMsg).

predicate_msg(WRAP_MVDDEF,[_O1, O2,_], PMsg) :-
	!,
	predicate_msg(O2, O2Msg),
	flora_concat_atoms(['?.',O2Msg,'[]'],PMsg).

predicate_msg(WRAP_IMVDDEF,[_O1, O2,_], PMsg) :-
	!,
	predicate_msg(O2, O2Msg),
	flora_concat_atoms(['?!',O2Msg,'[]'],PMsg).

predicate_msg(WRAP_TRAN,[_O1, O2,_], PMsg) :-
	!,
	predicate_msg(O2, O2Msg),
	flora_concat_atoms(['?[ %',O2Msg,' ]'],PMsg).

predicate_msg(WRAP_BOOLSIG,[_Obj, Att,_], PMsg) :-
	!,
	predicate_msg(Att, AMsg),
	flora_concat_atoms(['?[ => ',AMsg,']'],PMsg).

predicate_msg(WRAP_IBOOLSIG,[_Obj, Att,_], PMsg) :-
	!,
	predicate_msg(Att, AMsg),
	flora_concat_atoms(['?[ *=> ',AMsg,']'],PMsg).

predicate_msg(WRAP_TRANSIG,[_Obj, Att,_], PMsg) :-
	!,
	predicate_msg(Att, AMsg),
	flora_concat_atoms(['?[ => %',AMsg,']'],PMsg).

predicate_msg(WRAP_ITRANSIG,[_Obj, Att,_], PMsg) :-
	!,
	predicate_msg(Att, AMsg),
	flora_concat_atoms(['?[ *=> %',AMsg,']'],PMsg).

predicate_msg(WRAP_MVDSIG, [_Obj, Att, _Val,_], PMsg) :- 
	!,
	predicate_msg(Att,AMsg),
	flora_concat_atoms(['?[',AMsg,' => ?]'],PMsg).

predicate_msg(WRAP_MVDCONDEF, [_Obj, Att, _Lower, _Upper,_Type,_], PMsg) :- 
	!,
	predicate_msg(Att,AMsg),
	flora_concat_atoms(['?[',AMsg,' {?:?}=> ?]'],PMsg).

predicate_msg(WRAP_IMVDSIG, [_Obj, Att, _Val,_], PMsg) :- 
	!,
	predicate_msg(Att,AMsg),
	flora_concat_atoms(['?[',AMsg,' *=> ?]'],PMsg).

predicate_msg(WRAP_IMVDCONDEF, [_Obj, Att, _Lower, _Upper,_Type,_], PMsg) :- 
	!,
	predicate_msg(Att,AMsg),
	flora_concat_atoms(['?[',AMsg,' {?:?}*=> ?]'],PMsg).

predicate_msg(WRAP_MVD, [_Obj, Att, _Val,_], PMsg) :- 
	!,
	predicate_msg(Att,AMsg),
	flora_concat_atoms(['?[',AMsg,' -> ?]'],PMsg).

predicate_msg(WRAP_IMVD, [_Obj, Att, _Val,_], PMsg) :- 
	!,
	predicate_msg(Att,AMsg),
	flora_concat_atoms(['?[',AMsg,' *-> ?]'],PMsg).

hilog_predicate_msg(ArgList, PMsg) :-
	ArgList = [PredicateSymbol|_],
	predicate_msg(PredicateSymbol, PredMsg),
	length(ArgList, N),
	N1 is N-2, % chop off the extra Caller argument & the HiLog pred symbol
	flora_concat_items([PredMsg,'/',N1],PMsg).

/*****************************************************
 * varlist_to_str(+List, -String)
 * produce a string of ?'s separated by comma
 * the number of ?'s is the same as the number
 * of elements in the input list
 *****************************************************/
varlist_to_str([_], '?') :- !.
varlist_to_str([_H|T], Str) :-
	varlist_to_str(T, RestStr),
	flora_concat_atoms(['?,',RestStr],Str).
