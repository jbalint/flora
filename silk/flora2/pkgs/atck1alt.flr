/* File:      gclpe.flr
**
** Author(s): Michael Kifer
**
** Contact:   kifer@cs.stonybrook.edu
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 2008 - 2010;
**      and Vulcan, Inc., 2009 - 2010.
**
** All rights reserved.
**
** For information about licensing terms, please see
** http://silk.projects.semwebcentral.org/flora2-license.html
**
**
*/


/*** This argumentation theory, also known as ATCK1 (alternative formulation),
     allows k-ary exclusion constraints:
     Courteous Logic with General Exclusion Constraints.
     This argumentation theory also supports cancellation.
*/

#include "flora_terms.flh"

// All the FL_* names are defined in flora_terms.flh to make it easier to change
:- export FL_UNDEFEATED(?,?,?), %refresh.
:- export ?[howDefeated -> ?],
	  ?[info->?].
// These are exported for debugging
:- export
	  ?[opposers(?)->?],
	  ?[FL_BEATER(?)->?],
          FL_BEATER(?,?,?),
          opposes(?,?),
	  overrides(?,?).

:- ignore_depchk %abort(?)@_system.
?- Method[%mustDefine(off, ?:_Exclusion@?)]@_system,
   Method[%mustDefine(off, ?::_Exclusion@?)]@_system.

/*
  Note 1: FL_UNDEFEATED/3 must be called with the third argument bound to
          the user module name in which defeasible theory is invoked.
          This is done by the compiler.
  Note 2: We should make sure that ?R and ?Mod are ground.
          If ?Mod is not ground, it is an error (should catch).
          If ?R is non-ground, the result is incorrect: false{defeated} ==
          not Exists defeated, while we need Exists not defeated.
*/
FL_UNDEFEATED(?I,?H,?_Mod) :-
	//flora_trim_last(?H,?Htrimmed)@_prolog(flrtrim),
	//\+ ground(?Htrimmed)@_prolog(),
	\+ flora_ground(?H)@_prolog(flrtrim),
	!,
	flora_decode_oid_as_atom(?I,?Iatom)@_prolog(flrdecode),
	flora_decode_goal_as_atom(?H,?Hatom)@_prolog(flrdecode),
	%abort(['Invocation of nonground defeasible rule.\n\tLabel: ',
		 ?Iatom, '\n\tRule head: ',
		 ?Hatom])@_system.
FL_UNDEFEATED(?I,?H,?Mod) :-
	not FL_DEFEATED((?I,?H),?Mod).
        // cannot use 't not': ?H might not be ground
	//'t not'(FL_DEFEATED((?I,?H),?Mod)@ _@)@_prolog(tables).

// These two are for debugging only, to inspect what the AT sees
// as being opposed and overridden; they are exported
// Can also use ?Exclusion[opposers(?Mod)->?Opposer], to inspect k-ary mutexes
opposes(?L1,?L2) :-
	caller{?Mod},
	FL_OPPOSES_AUX(?Mod,?L1,?L2).
overrides(?R1,?R2) :-
	caller{?Mod},
	FL_OVERRIDES_AUX(?Mod,?R1,?R2).

// Axioms for Courteous LP with general exclusions

FL_DEFEATED(?R,?Mod) :-
	?R=(?,?H),
	?Exclusion[opposers(?Mod)->?H],
	not ?Exclusion[FL_BEATER(?Mod)->?H].
FL_DEFEATED(?R,?Mod) :-
	?R=(?,?H),
	// this incorporates the classical mutex and user-defined _opposes/2
	FL_OPPOSES_AUX(?Mod,?R,?Other),
	?Other=(?_OtherL,?OtherH),
	not FL_BEATER(?H,?OtherH,?Mod).
FL_DEFEATED(?R,?Mod) :- FL_DISQUALIFIED(?R,?Mod).

/***************************** FL_BEATER ************************************/
?Exclusion[FL_BEATER(?Mod)->?H] :-
	beater_aux(?H,?,?Exclusion,?Mod).
// auxiliary FL_BEATER predicate
beater_aux(?H,?Beaten,?Exclusion,?Mod) :-
	FL_COMPETES(?H,?Beaten,?Exclusion,?Mod),
	FL_DOMINATES(?H,?Beaten,?Mod).
/*
  The FL_BEATER predicate for binary exclusions (_opposes)
  This corresponds to something like exclusion(?H,?_Beaten)[FL_BEATER(?Mod)->?H]
  In other words, ?Beaten is part of the exclusion Id and can't be eliminated
*/
FL_BEATER(?H,?Beaten,?Mod) :-
	FL_COMPETES(?H,?Beaten,?Mod),
	FL_DOMINATES(?H,?Beaten,?Mod).

/******************** FL_DISQUALIFIED **************************************/
FL_DISQUALIFIED(?R,?Mod) :- FL_CANCEL_AUX(?Mod,?R).

/* FL_DISQUALIFIED_AUX is defined in genincludes/flrdefeasible.fli
   roughly by axioms of the form:
   FL_DISQUALIFIED((?Id1,_cancel(?Id2,?Head2))) :-
                       _overrides(?Id2,?Head2,?Id1,_cancel(?Id2,?Head2)).
   FL_DISQUALIFIED((?Id1,_cancel(?Id2))) :-
                       _overrides(?Id2,?,?Id1,_cancel(?Id2)).
*/
FL_DISQUALIFIED(?R,?Mod) :- FL_DISQUALIFIED_AUX(?R,?Mod).

// FL_REFUTES/4   Note: 1st arg is a head, second - a handle
FL_REFUTES(?H1,?R2,?Exclusion,?Mod) :-
	?R1 = (?_L1,?H1), ?R2 = (?_L2,?H2),
	FL_COMPETES(?H1,?H2,?Exclusion,?Mod),
	FL_OVERRIDES_AUX(?Mod,?R1,?R2),
	FL_CANDIDATE(?R1,?Mod).
// FL_REFUTES/3   Note: 1st arg is a head, not handle
FL_REFUTES(?H1,?R2,?Mod) :-
	?R1 = (?_L1,?H1), ?R2 = (?_L2,?H2),
	FL_COMPETES(?H1,?H2,?Mod),
	FL_OVERRIDES_AUX(?Mod,?R1,?R2),
	FL_CANDIDATE(?R1,?Mod).

// FL_REBUTS/4
FL_REBUTS(?H1,?H2,?Exclusion,?Mod)  :-
	FL_COMPETES(?H1,?H2,?Exclusion,?Mod),
	?R1 = (?,?H1),
	FL_CANDIDATE(?R1,?Mod),
	not FL_REFUTES(?H2,?R1,?Exclusion,?Mod).
// FL_REBUTS/3
FL_REBUTS(?H1,?H2,?Mod)  :-
	FL_COMPETES(?H1,?H2,?Mod),
	?R1 = (?,?H1),
	FL_CANDIDATE(?R1,?Mod),
	not FL_REFUTES(?H2,?R1,?Mod).


/************************ Competition **************************************/
FL_COMPETES(?H1,?H2,?Exclusion,?Mod) :-
	?Exclusion[opposers(?Mod)->{?H1,?H2}],
	?H1 != ?H2.
FL_COMPETES(?H1,?H2,?Mod) :-
	FL_OPPOSES_AUX(?Mod,(?,?H1),(?,?H2)),
	?H1 != ?H2.

competitors(?H1,?H2,?Mod) :-
	FL_COMPETES(?H1,?H2,?_Exclusion,?Mod)
        or
        FL_COMPETES(?H1,?H2,?Mod).


/*********************** FL_DOMINATES ****************************************
** FL_DOMINATES(?Lit,?Dominee) =def=
**    Forall ?DomineeTag ( candidate(?DomineeTag,?Dominee) ~~>
**                 Exists ?Tag ( candidate(?Tag,?Lit) and
**                               _overrides((?Tag,?Lit),(?DomineeTag,?Dominee))
**                             )
**                       )
  Question: should it be _overrides((?Tag,?Lit),(?DomineeTag,?Dominee)) or
                         _overrides(?Tag,?DomineeTag)
****************************************************************************/
FL_DOMINATES(?Lit,?Dominee,?Mod) :-
	tag{?,?Lit},
	// tag{?,?Dominee} - must not be used: binary dominee may have no tag 
	competitors(?Lit,?Dominee,?Mod),
	not existsRuleWithNoOverrider(?Lit,?Dominee,?Mod).
existsRuleWithNoOverrider(?Lit,?Dominee,?Mod) :-
	FL_CANDIDATE((?DomineeTag,?Dominee),?Mod),
	not((
	     FL_CANDIDATE((?Tag,?Lit),?Mod),
	     FL_OVERRIDES_AUX(?Mod,(?Tag,?Lit),(?DomineeTag,?Dominee))
	   )).


/************************ Debugging ***************************************/

/*
   FL_STATUS(Id,Head)[howDefeated->Reason] can be used to find out what is defeated
   and why. No need to reify the ?H argument or attach the module to it.
   This method finds out the caller module and replaces the module of Head
   with the caller module.
*/

FL_STATUS(?_L,?H)[howDefeated -> notBeaterFor(?Exclusion)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
        ?Exclusion[opposers(?Mod)->?HM],
	not ?Exclusion[FL_BEATER(?Mod)->?HM].
FL_STATUS(?L,?H)[howDefeated -> notBeaterFor(binaryExclusion(?HM,?Beaten))] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	?R1 = (?L,?HM),
	FL_OPPOSES_AUX(?Mod,?R1,?R2),
	?R2 = (?_L2,?Beaten),
	not FL_BEATER(?HM,?Beaten,?Mod).
FL_STATUS(?L,?H)[howDefeated -> canceled] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_CANCEL_AUX(?Mod,(?L,?HM)).

FL_STATUS(?_L,?H)[info -> dominates(?Dominee)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_DOMINATES(?HM,?Dominee,?Mod).

FL_STATUS(?_L,?H)[info -> refutes(?Refuted)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_REFUTES(?HM,?Refuted,?Mod).
FL_STATUS(?_L,?H)[info -> refutes(?Refuted)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_REFUTES(?HM,?Refuted,?_Exclusion,?Mod).

FL_STATUS(?_L,?H)[info -> rebuts(?Rebutted)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_REBUTS(?HM,?Rebutted,?Mod).
FL_STATUS(?_L,?H)[info -> rebuts(?Rebutted)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_REBUTS(?HM,?Rebutted,?_Exclusion,?Mod).

FL_STATUS(?_L,?H)[info->beats(?Exclusion,?Beaten)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	beater_aux(?HM,?Beaten,?Exclusion,?Mod).
FL_STATUS(?_L,?H)[info->beats(?Beaten)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_BEATER(?HM,?Beaten,?Mod).

FL_STATUS(?_L,?H)[info->competes(?Exclusion,?Competitor)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_COMPETES(?HM,?Competitor,?Exclusion,?Mod),
	FL_CANDIDATE((?,?Competitor),?Mod).
FL_STATUS(?_L,?H)[info->competes(?Competitor)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_COMPETES(?HM,?Competitor,?Mod),
	FL_CANDIDATE((?,?Competitor),?Mod).

FL_STATUS(?I,?H)[info->candidate] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_CANDIDATE((?I,?HM),?Mod).


change_module(?InA,?Mod,?OutA) :-
	flora_change_module(?InA,?OutA,?Mod,['In ',FL_STATUS,'(Id,Head)[...]@',_@,': Head must be bound'])@_prolog(flrwrapper).


/***************************** Auxiliary Predicates ***********************/
// Given a rule Id and possibly Head, find body and test if it is satisfied.
// This predicate's tables are abolished after each query by an
// after-query hook because sometimes it is called with RId/Head as a var.
// It may succeed for one query and will be tabled.
// If it is, then when called for another query, wrong result may be returned.
FL_CANDIDATE((?RId,?Head),?Mod) :-
	tag{?RId,?Head},
	clause{@{?RId} ?Head@?Mod, ?Body},
	call(?Body).

// opposer without the rule tag
?Exclusion[opposers(?Mod)->?HH] :-
	(?Exclusion:_Exclusion[_opposers->?H])@?Mod,
	?HH = ?H@?Mod.


// FL_OPPOSES_AUX/3, FL_OVERRIDES_AUX/3, FL_CANCEL_AUX/2 are defined in
// genincludes/flrdefeasible.fli


/***** refresh the tables used by the defeasible theory ********************/

%refresh :-
	refresh{?(?,?,?), ?(?,?)},
	flora_abolish_table_call(FL_OPPOSES_AUX(?,?,?))@_prolog(flrtables),
	flora_abolish_table_call(FL_OVERRIDES_AUX(?,?,?))@_prolog(flrtables),
	flora_abolish_table_call(FL_CANCEL_AUX(?,?))@_prolog(flrtables),
	caller{?Mod},
	refresh{FL_OPPOSES(?,?)@?Mod, FL_OPPOSES(?,?,?,?)@?Mod},
	refresh{FL_OVERRIDES(?,?)@?Mod, FL_OVERRIDES(?,?,?,?)@?Mod},
	refresh{FL_CANCEL(?)@?Mod, FL_CANCEL(?,?)@?Mod}.

// Hook for abolishing FL_CANDIDATE/1 after each query
FL_DEFEASIBLE_CLEANUP(?,?) :- flora_abolish_table_call(${FL_CANDIDATE(?,?)})@_prolog(flrtables).

?- flora_add_hook(_@,QUERYHOOK,after,0,FL_DEFEASIBLE_CLEANUP(?,?))@_prolog(flrhooks).

// must have this in order for FL_STATUS to have right argument translation
?- flora_set_argdef(FL_STATUS,2,[FL_OID,FL_BODYFORMULA],_@)@_prolog(flrarguments).
