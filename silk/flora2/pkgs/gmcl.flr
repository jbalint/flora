/* File:      gmcl.flr
**
** Author(s): Michael Kifer
**
** Contact:   kifer@cs.stonybrook.edu
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 2008, 2009;
**      and Vulcan, Inc., 2009.
**
** All rights reserved.
**
** For information about licensing terms, please see
** http://silk.projects.semwebcentral.org/flora2-license.html
**
**
*/


/*** This argumentation theory allows k-ary mutexes:
     General Mutex Courteous Logic.
     This argumentation theory also supports cancellation.
*/

#include "flora_terms.flh"

// All the FL_* names are defined in flora_terms.flh to make it easier to change
:- export FL_UNDEFEATED(?,?,?), %refresh.
:- export ?[howDefeated -> ?],
	  ?[info->?].
// These are exported for debugging
:- export
	  ?[opposers(?)->?],
          opposes(?,?),
	  overrides(?,?).

:- ignore_depchk %abort(?)@_system.

/*
  Note 1: FL_UNDEFEATED/3 must be called with the third argument bound to
          the user module name in which defeasible theory is invoked.
          This is done by the compiler.
  Note 2: We should make sure that ?R and ?Mod are ground.
          If ?Mod is not ground, it is an error (should catch).
          If ?R is non-ground, the result is incorrect: false{defeated} ==
          not Exists defeated, while we need Exists not defeated.
*/
FL_UNDEFEATED(?I,?H,?_Mod) :-
	//flora_trim_last(?H,?Htrimmed)@_prolog(flrtrim),
	//\+ ground(?Htrimmed)@_prolog(basics),
	\+ flora_ground(?H)@_prolog(flrtrim),
	!,
	flora_decode_oid_as_atom(?I,?Iatom)@_prolog(flrdecode),
	flora_decode_goal_as_atom(?H,?Hatom)@_prolog(flrdecode),
	%abort(['Invocation of nonground defeasible rule.\n\tLabel: ',
		 ?Iatom, '\n\tRule head: ',
		 ?Hatom])@_system.
FL_UNDEFEATED(?I,?H,?Mod) :-
	not FL_DEFEATED((?I,?H),?Mod).
        // cannot use 't not': ?H might not be ground
	//'t not'(FL_DEFEATED((?I,?H),?Mod)@ _@)@_prolog(tables).

// These are for debugging only; exported
// Can also use ?Mutex[opposers(?Mod)->?Opposer],
opposes(?L1,?L2) :-
	caller{?Mod},
	FL_OPPOSES_AUX(?Mod,?L1,?L2).
overrides(?R1,?R2) :-
	caller{?Mod},
	FL_OVERRIDES_AUX(?Mod,?R1,?R2).

// Axioms for Courteous LP

FL_DEFEATED(?R,?Mod) :-
	?Mutex[opposers(?Mod)->?R],
	not ?Mutex[beater(?Mod)->?R].
FL_DEFEATED(?R,?Mod) :-
	FL_OPPOSES_AUX(?Mod,?R,?),
	not beater(?R,?Mod).
FL_DEFEATED(?R,?Mod) :- FL_DISQUALIFIED(?R,?Mod).

?Mutex[beater(?Mod)->?B] :-
	competes(?B,?Other,?Mutex,?Mod),
	not FL_REBUTS(?Other,?B,?Mutex,?Mod).
beater(?B,?Mod) :-
	competes(?B,?Other,?Mod),
	not FL_REBUTS(?Other,?B,?Mod).

FL_DISQUALIFIED(?R,?Mod) :- FL_CANCEL_AUX(?Mod,?R).
FL_DISQUALIFIED(?R,?Mod) :- FL_DISQUALIFIED_AUX(?R,?Mod).

// FL_REFUTES/4
FL_REFUTES(?R1,?R2,?Mutex,?Mod) :-
	competes(?R1,?R2,?Mutex,?Mod),
	FL_OVERRIDES_AUX(?Mod,?R1,?R2),
	FL_CANDIDATE(?R1,?Mod).
// FL_REFUTES/3
FL_REFUTES(?R1,?R2,?Mod) :-
	competes(?R1,?R2,?Mod),
	FL_OVERRIDES_AUX(?Mod,?R1,?R2),
	FL_CANDIDATE(?R1,?Mod).

// FL_REBUTS/4
FL_REBUTS(?R1,?R2,?Mutex,?Mod)  :-
	competes(?R1,?R2,?Mutex,?Mod),
	FL_CANDIDATE(?R1,?Mod),
	not FL_REFUTES(?R2,?R1,?Mutex,?Mod).
// FL_REBUTS/3
FL_REBUTS(?R1,?R2,?Mod)  :-
	competes(?R1,?R2,?Mod),
	FL_CANDIDATE(?R1,?Mod),
	not FL_REFUTES(?R2,?R1,?Mod).

competes(?R1,?R2,?Mutex,?Mod) :-
	?Mutex[opposers(?Mod)->{?R1,?R2}], ?R1 != ?R2.
competes(?R1,?R2,?Mod) :-
	FL_OPPOSES_AUX(?Mod,?R1,?R2).

/***** refresh the tables used by the defeasible theory ********************/

%refresh :-
	refresh{?(?,?,?), ?(?,?)},
	flora_abolish_table_call(FL_OPPOSES_AUX(?,?,?))@_prolog(flrtables),
	flora_abolish_table_call(FL_OVERRIDES_AUX(?,?,?))@_prolog(flrtables),
	flora_abolish_table_call(FL_CANCEL_AUX(?,?))@_prolog(flrtables),
	caller{?Mod},
	refresh{FL_OPPOSES(?,?)@?Mod, FL_OPPOSES(?,?,?,?)@?Mod},
	refresh{FL_OVERRIDES(?,?)@?Mod, FL_OVERRIDES(?,?,?,?)@?Mod},
	refresh{FL_CANCEL(?)@?Mod, FL_CANCEL(?,?)@?Mod}.

/************************ Debugging ***************************************/

/*
   starus(Id,Head)[howDefeated->Reason] can be used to find out what is defeated
   and why. No need to reify the ?H argument or attach the module to it.
   This method finds out the caller module and replaces the module of Head
   with the caller module.
*/

status(?I,?H)[howDefeated -> notBeaterFor(?Mutex)] :-
	caller{?Mod},
	?R = (?I,?H),
        ?Mutex[opposers(?Mod)->?R],
	not ?Mutex[beater(?Mod)->?R].
status(?I,?H)[howDefeated -> notBeaterFor(classicalMutex)] :-
	caller{?Mod},
	?R = (?I,?H),
	FL_OPPOSES_AUX(?Mod,?R,?),
	not beater(?R,?Mod).
status(?I,?H)[howDefeated -> canceled] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_CANCEL_AUX(?Mod,(?I,?HM)).

status(?I,?H)[info -> refutes(?Refuted)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_REFUTES((?I,?HM),?Refuted,?Mod).
status(?I,?H)[info -> refutes(?Refuted)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_REFUTES((?I,?HM),?Refuted,?_Mutex,?Mod).
status(?I,?H)[info -> rebuts(?Rebutted)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_REBUTS((?I,?HM),?Rebutted,?Mod).
status(?I,?H)[info -> rebuts(?Rebutted)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_REBUTS((?I,?HM),?Rebutted,?_Mutex,?Mod).

status(?I,?H)[info->candidate] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_CANDIDATE((?I,?HM),?Mod).

change_module(?InA,?_Mod,?_OutA) :-
	var(?InA),
	!,
	%abort('In status(Id,Head)[...]@_gcl: Head must be bound')@_system.
change_module(?InA,?Mod,?OutA) :-
	?InA =.. [?T(?A,?)|?Rest],
	?OutAGeneric =.. [?T(?A,?Mod)|?Rest],
	convert_to_body_literal(?OutAGeneric,?OutA)@_prolog(flrcanon),
	!.
change_module(?InA,?Mod,?OutA) :-
	?InA@?Mod = ?OutA.

/***************************** Auxiliary Predicates ***********************/
// Given a rule Id and possibly Head, find body and test if it is satisfied.
// This predicate's tables are abolished after each query by an
// after-query hook because sometimes it is called with RId/Head as a var.
// It may succeed for one query and will be tabled.
// If it is, then when called for another query, wrong result may be returned.
FL_CANDIDATE((?RId,?Head),?Mod) :-
	// show_rule_signature/9 in flrcanon.P
	show_rule_signature(?RId,?,?Mod,?Head,?Body,?,?DefeatCond,?,?)@_prolog(flrcanon),
	?DefeatCond !== NULL,
	call(?Body).

// suck in the opposersdeclared by the user
?Mutex[opposers(?Mod)->(?L,?HH)] :-
	(?Mutex:_Mutex[_opposers->(?L,?H)])@?Mod,
	?HH = ?H@?Mod.
// opposer without the rule label
?Mutex[opposers(?Mod)->(?,?HH)] :-
	(?Mutex:_Mutex[_opposers->?H])@?Mod,
	?H != (?,?),
	?HH = ?H@?Mod.


// FL_OPPOSES_AUX/3, FL_OVERRIDES_AUX/3, FL_CANCEL_AUX/2 are defined in
// genincludes/flrdefeasible.fli


// Hook for abolishing FL_CANDIDATE/1 after each query
'_flrdefesible_cleanup'(?,?) :- flora_abolish_table_call(${FL_CANDIDATE(?,?)})@_prolog(flrtables).

?- flora_add_hook(_@,QUERYHOOK,after,0,'_flrdefesible_cleanup'(?,?))@_prolog(flrhooks).

