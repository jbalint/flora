/* File:      gclpe.flr
**
** Author(s): Michael Kifer
**
** Contact:   kifer@cs.stonybrook.edu
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 2008, 2009;
**      and Vulcan, Inc., 2009.
**
** All rights reserved.
**
** For information about licensing terms, please see
** http://silk.projects.semwebcentral.org/flora2-license.html
**
**
*/


/*** This argumentation theory allows k-ary exclusion constraints:
     Courteous Logic with General Exclusion Constraints.
     This argumentation theory also supports cancellation.
*/

#include "flora_terms.flh"

// All the FL_* names are defined in flora_terms.flh to make it easier to change
:- export FL_UNDEFEATED(?,?,?), %refresh.
:- export ?[howDefeated -> ?],
	  ?[info->?].
// These are exported for debugging
:- export
	  ?[opposers(?)->?],
	  ?[beater(?)->?],
          beater(?,?,?),
          opposes(?,?),
	  overrides(?,?).

:- ignore_depchk %abort(?)@_system.
?- Method[%mustDefine(off, ?:_Exclusion@?)]@_system,
   Method[%mustDefine(off, ?::_Exclusion@?)]@_system.

/*
  Note 1: FL_UNDEFEATED/3 must be called with the third argument bound to
          the user module name in which defeasible theory is invoked.
          This is done by the compiler.
  Note 2: We should make sure that ?R and ?Mod are ground.
          If ?Mod is not ground, it is an error (should catch).
          If ?R is non-ground, the result is incorrect: false{defeated} ==
          not Exists defeated, while we need Exists not defeated.
*/
FL_UNDEFEATED(?I,?H,?_Mod) :-
	//flora_trim_last(?H,?Htrimmed)@_prolog(flrtrim),
	//\+ ground(?Htrimmed)@_prolog(basics),
	\+ flora_ground(?H)@_prolog(flrtrim),
	!,
	flora_decode_oid_as_atom(?I,?Iatom)@_prolog(flrdecode),
	flora_decode_goal_as_atom(?H,?Hatom)@_prolog(flrdecode),
	%abort(['Invocation of nonground defeasible rule.\n\tLabel: ',
		 ?Iatom, '\n\tRule head: ',
		 ?Hatom])@_system.
FL_UNDEFEATED(?I,?H,?Mod) :-
	not FL_DEFEATED((?I,?H),?Mod).
        // cannot use 't not': ?H might not be ground
	//'t not'(FL_DEFEATED((?I,?H),?Mod)@ _@)@_prolog(tables).

// These two are for debugging only, to inspect what the AT sees
// as being opposed and overridden; they are exported
// Can also use ?Exclusion[opposers(?Mod)->?Opposer], to inspect k-ary mutexes
opposes(?L1,?L2) :-
	caller{?Mod},
	FL_OPPOSES_AUX(?Mod,?L1,?L2).
overrides(?R1,?R2) :-
	caller{?Mod},
	FL_OVERRIDES_AUX(?Mod,?R1,?R2).

// Axioms for Courteous LP with general exclusions

FL_DEFEATED(?R,?Mod) :-
	?R=(?,?H),
	?Exclusion[opposers(?Mod)->?H],
	not ?Exclusion[beater(?Mod)->?H].
FL_DEFEATED(?R,?Mod) :-
	?R=(?,?H),
	// this brings in the classical mutex and user-defined _opposes/2
	FL_OPPOSES_AUX(?Mod,?R,?Other),
	?Other=(?_OtherL,?OtherH),
	not beater(?H,?OtherH,?Mod).
FL_DEFEATED(?R,?Mod) :- FL_DISQUALIFIED(?R,?Mod).

?Exclusion[beater(?Mod)->?H] :-
	beater(?H,?_OtherH,?Exclusion,?Mod).
beater(?H,?OtherH,?Exclusion,?Mod) :-
	competes(?H,?OtherH,?Exclusion,?Mod),
	not FL_REBUTS(?OtherH,?H,?Exclusion,?Mod).
beater(?H,?OtherH,?Mod) :-
	competes(?H,?OtherH,?Mod),
	not FL_REBUTS(?OtherH,?H,?Mod).

FL_DISQUALIFIED(?R,?Mod) :- FL_CANCEL_AUX(?Mod,?R).
/* FL_DISQUALIFIED_AUX is defined in genincludes/flrdefeasible.fli
   roughly by axioms of the form:
   FL_DISQUALIFIED((?Id1,_cancel(?Id2,?Head2))) :-
                       _overrides(?Id2,?Head2,?Id1,_cancel(?Id2,?Head2)).
   FL_DISQUALIFIED((?Id1,_cancel(?Id2))) :-
                       _overrides(?Id2,?,?Id1,_cancel(?Id2)).
*/
FL_DISQUALIFIED(?R,?Mod) :- FL_DISQUALIFIED_AUX(?R,?Mod).

// FL_REFUTES/4   Note: 1st arg is a head, second - a handle
FL_REFUTES(?H1,?R2,?Exclusion,?Mod) :-
	?R1 = (?_L1,?H1), ?R2 = (?_L2,?H2),
	competes(?H1,?H2,?Exclusion,?Mod),
	FL_OVERRIDES_AUX(?Mod,?R1,?R2),
	FL_CANDIDATE(?R1,?Mod).
// FL_REFUTES/3   Note: 1st arg is a head, not handle
FL_REFUTES(?H1,?R2,?Mod) :-
	?R1 = (?_L1,?H1), ?R2 = (?_L2,?H2),
	competes(?H1,?H2,?Mod),
	FL_OVERRIDES_AUX(?Mod,?R1,?R2),
	FL_CANDIDATE(?R1,?Mod).

// FL_REBUTS/4
FL_REBUTS(?H1,?H2,?Exclusion,?Mod)  :-
	competes(?H1,?H2,?Exclusion,?Mod),
	?R1 = (?,?H1),
	FL_CANDIDATE(?R1,?Mod),
	not FL_REFUTES(?H2,?R1,?Exclusion,?Mod).
// FL_REBUTS/3
FL_REBUTS(?H1,?H2,?Mod)  :-
	competes(?H1,?H2,?Mod),
	?R1 = (?,?H1),
	FL_CANDIDATE(?R1,?Mod),
	not FL_REFUTES(?H2,?R1,?Mod).

competes(?H1,?H2,?Exclusion,?Mod) :-
	?Exclusion[opposers(?Mod)->{?H1,?H2}],
	?H1 != ?H2.
competes(?H1,?H2,?Mod) :-
	FL_OPPOSES_AUX(?Mod,(?,?H1),(?,?H2)),
	?H1 != ?H2.

/***** refresh the tables used by the defeasible theory ********************/

%refresh :-
	refresh{?(?,?,?), ?(?,?)},
	flora_abolish_table_call(FL_OPPOSES_AUX(?,?,?))@_prolog(flrtables),
	flora_abolish_table_call(FL_OVERRIDES_AUX(?,?,?))@_prolog(flrtables),
	flora_abolish_table_call(FL_CANCEL_AUX(?,?))@_prolog(flrtables),
	caller{?Mod},
	refresh{FL_OPPOSES(?,?)@?Mod, FL_OPPOSES(?,?,?,?)@?Mod},
	refresh{FL_OVERRIDES(?,?)@?Mod, FL_OVERRIDES(?,?,?,?)@?Mod},
	refresh{FL_CANCEL(?)@?Mod, FL_CANCEL(?,?)@?Mod}.

/************************ Debugging ***************************************/

/*
   starus(Id,Head)[howDefeated->Reason] can be used to find out what is defeated
   and why. No need to reify the ?H argument or attach the module to it.
   This method finds out the caller module and replaces the module of Head
   with the caller module.
*/

status(?_L,?H)[howDefeated -> notBeaterFor(?Exclusion)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
        ?Exclusion[opposers(?Mod)->?HM],
	not ?Exclusion[beater(?Mod)->?HM].
status(?L,?H)[howDefeated -> notBeaterFor(binaryExclusion(?HM,?OtherH))] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	?R1 = (?L,?HM),
	FL_OPPOSES_AUX(?Mod,?R1,?R2),
	?R2 = (?_L2,?OtherH),
	not beater(?HM,?OtherH,?Mod).
status(?L,?H)[howDefeated -> canceled] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_CANCEL_AUX(?Mod,(?L,?HM)).

status(?_L,?H)[info -> refutes(?Refuted)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_REFUTES(?HM,?Refuted,?Mod).
status(?_L,?H)[info -> refutes(?Refuted)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_REFUTES(?HM,?Refuted,?_Exclusion,?Mod).

status(?_L,?H)[info -> rebuts(?Rebutted)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_REBUTS(?HM,?Rebutted,?Mod).
status(?_L,?H)[info -> rebuts(?Rebutted)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_REBUTS(?HM,?Rebutted,?_Exclusion,?Mod).

status(?_L,?H)[info->beats(?Exclusion,?Beaten)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	beater(?HM,?Beaten,?Exclusion,?Mod).
status(?_L,?H)[info->beats(?Beaten)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	beater(?HM,?Beaten,?Mod).

status(?_L,?H)[info->competes(?Exclusion,?Competitor)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	competes(?HM,?Competitor,?Exclusion,?Mod).
status(?_L,?H)[info->competes(?Competitor)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	competes(?HM,?Competitor,?Mod).

status(?I,?H)[info->candidate] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_CANDIDATE((?I,?HM),?Mod).

change_module(?InA,?_Mod,?_OutA) :-
	var(?InA),
	!,
	%abort('In status(Id,Head)[...]@_gcl: Head must be bound')@_system.
change_module(?InA,?Mod,?OutA) :-
	?InA =.. [?T(?A,?)|?Rest],
	?OutAGeneric =.. [?T(?A,?Mod)|?Rest],
	convert_to_body_literal(?OutAGeneric,?OutA)@_prolog(flrcanon),
	!.
change_module(?InA,?Mod,?OutA) :-
	?InA@?Mod = ?OutA.

/***************************** Auxiliary Predicates ***********************/
// Given a rule Id and possibly Head, find body and test if it is satisfied.
// This predicate's tables are abolished after each query by an
// after-query hook because sometimes it is called with RId/Head as a var.
// It may succeed for one query and will be tabled.
// If it is, then when called for another query, wrong result may be returned.
FL_CANDIDATE((?RId,?Head),?Mod) :-
	clause{@{?RId} ?Head@?Mod, ?Body},
	call(?Body).

// opposer without the rule label
?Exclusion[opposers(?Mod)->?HH] :-
	(?Exclusion:_Exclusion[_opposers->?H])@?Mod,
	?HH = ?H@?Mod.


// FL_OPPOSES_AUX/3, FL_OVERRIDES_AUX/3, FL_CANCEL_AUX/2 are defined in
// genincludes/flrdefeasible.fli


// Hook for abolishing FL_CANDIDATE/1 after each query
FL_DEFEASIBLE_CLEANUP(?,?) :- flora_abolish_table_call(${FL_CANDIDATE(?,?)})@_prolog(flrtables).

?- flora_add_hook(_@,QUERYHOOK,after,0,FL_DEFEASIBLE_CLEANUP(?,?))@_prolog(flrhooks).

