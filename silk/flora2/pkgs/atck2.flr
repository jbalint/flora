/* File:      atck2.flr
**
** Author(s): Michael Kifer
**
** Contact:   kifer@cs.stonybrook.edu
**
** Copyright (C) by
**     The Research Foundation of the State University of New York, 2008 - 2010;
**     and Vulcan, Inc., 2009 - 2011.
**
** All rights reserved.
**
** For information about licensing terms, please see
** http://silk.projects.semwebcentral.org/flora2-license.html
**
**
*/


/*** This argumentation theory is also known as ATCK2 or ATCK3 - depending on
     whether ATCK3 is #define'd
     It allows k-ary exclusion constraints:
     Courteous Logic with General Exclusion Constraints.
     This argumentation theory also supports cancellation.
*/

// #define ATCK3

#include "flora_terms.flh"

// All the FL_* names are defined in flora_terms.flh to make it easier to change
:- export FL_UNDEFEATED(?,?,?), %refresh.
:- export ?[howDefeated -> ?],
	  ?[info->?].
// These are exported for debugging
:- export
	  ?[opposers(?)->?],
	  ?[FL_BEATER(?)->?],
          FL_BEATER(?,?,?),
	  FL_STOMPED(?,?),
	  FL_DOMINATES(?,?,?),
          opposes(?,?),
	  overrides(?,?),
	  defeated(?).

:- ignore_depchk %abort(?)@_system.

?- Method[%mustDefine(off, ?:_Exclusion@?)]@_system,
   Method[%mustDefine(off, ?::_Exclusion@?)]@_system.

//?- Method[%mustDefine(on)]@_system.

/*
  Note 1: FL_UNDEFEATED/3 must be called with the third argument bound to
          the user module name in which defeasible theory is invoked.
          This is done by the compiler.
  Note 2: We should make sure that ?R and ?Mod are ground.
          If ?Mod is not ground, it is an error (should catch).
          If ?R is non-ground, the result is incorrect: false{defeated} ==
          not Exists defeated, while we need Exists not defeated.
*/
/*
FL_UNDEFEATED(?I,?H,?_Mod) :-
	//flora_trim_last(?H,?Htrimmed)@_prolog(flrtrim),
	//\+ ground(?Htrimmed)@_prolog(),
	\+ flrground(?H)@_prolog(flora_ground),
	!,
	flora_decode_oid_as_atom(?I,?Iatom)@_prolog(flrdecode),
	flora_decode_goal_as_atom(?H,?Hatom)@_prolog(flrdecode),
	%abort(['Invocation of nonground defeasible rule.\n\tLabel: ',
		 ?Iatom, '\n\tRule head: ',
		 ?Hatom])@_system.
*/
FL_UNDEFEATED(?I,?H,?Mod) :-
	not FL_DEFEATED((?I,?H),?Mod).

// These are mostly for debugging
// Note: when ?H,?H1,?H2 are bound by the user, they should be reified
// For instance: defeated((?I,${neg a}))@_gcl.
defeated((?T,?H)) :-
	caller{?Mod},
	change_module_nocheck(?H,?Mod,?RealMod,?MH),
	FL_DEFEATED((?T,?MH),?RealMod).

// Can also use ?Exclusion[opposers(?Mod)->?Opposer], to inspect k-ary mutexes
opposes((?T1,?H1),(?T2,?H2)) :-
	caller{?Mod},
	change_module_nocheck(?H1,?Mod,?RealMod,?MH1),
	change_module_nocheck(?H2,?Mod,?RealMod,?MH2),
	FL_OPPOSES_AUX(?RealMod,(?T1,?MH1),(?T2,?MH2)).

overrides((?T1,?H1),(?T2,?H2)) :-
	caller{?Mod},
	change_module_nocheck(?H1,?Mod,?RealMod,?MH1),
	change_module_nocheck(?H2,?Mod,?RealMod,?MH2),
	FL_OVERRIDES_AUX(?RealMod,(?T1,?MH1),(?T2,?MH2)).

check_module_to_AT_association(?Mod) :-
	\+flora_defeasible_module_registry(?Mod,_@)@_prolog(flrregistry),
	?Mod \== _@,
	!,
	%abort(['User module ', ?Mod,
	        ' is not associated with the argumentation theory residing in module ',
		 _@])@_system.
check_module_to_AT_association(?) :- true.


// Axioms for Courteous LP with general exclusions

FL_DEFEATED(?R,?Mod) :-
	?R=(?,?H),
	?Exclusion[opposers(?Mod)->?H],
	not ?Exclusion[FL_BEATER(?Mod)->?H].
FL_DEFEATED(?R,?Mod) :-
	?R=(?,?H),
	// this incorporates the classical mutex and user-defined _opposes/2
	FL_OPPOSES_AUX(?Mod,?R,?Other),
	?Other=(?_OtherL,?OtherH),
	not FL_BEATER(?H,?OtherH,?Mod).
FL_DEFEATED(?R,?Mod) :- FL_DISQUALIFIED(?R,?Mod).

/***************************** FL_BEATER ************************************/
?Exclusion[FL_BEATER(?Mod)->?H] :-
	beater_aux(?H,?,?Exclusion,?Mod).
// auxiliary FL_BEATER predicate
beater_aux(?H,?Beaten,?Exclusion,?Mod) :-
	FL_COMPETES(?H,?Beaten,?Exclusion,?Mod),
	(FL_DOMINATES(?H,?Beaten,?Mod)
         or
#ifdef ATCK3
         neg ?Beaten
#else   // ATCK2
         FL_STOMPED(?Beaten,?Mod)
#endif
        ).
/*
  The FL_BEATER predicate for binary exclusions (_opposes)
  This corresponds to something like exclusion(?H,?_Beaten)[FL_BEATER(?Mod)->?H]
  In other words, ?Beaten is part of the exclusion Id and can't be eliminated
*/
FL_BEATER(?H,?Beaten,?Mod) :-
	FL_COMPETES(?H,?Beaten,?Mod),
	(FL_DOMINATES(?H,?Beaten,?Mod)
         or
#ifdef ATCK3
         neg ?Beaten
#else   // ATCK2
         FL_STOMPED(?Beaten,?Mod)
#endif
        ).

/******************** FL_DISQUALIFIED **************************************/
FL_DISQUALIFIED(?R,?Mod) :- FL_CANCEL_AUX(?Mod,?R).

/* FL_DISQUALIFIED_AUX is defined in genincludes/flrdefeasible.fli
   roughly by axioms of the form:
   FL_DISQUALIFIED((?Id1,_cancel(?Id2,?Head2))) :-
                       _overrides(?Id2,?Head2,?Id1,_cancel(?Id2,?Head2)).
   FL_DISQUALIFIED((?Id1,_cancel(?Id2))) :-
                       _overrides(?Id2,?,?Id1,_cancel(?Id2)).
*/

FL_DISQUALIFIED(?R,?Mod) :- FL_DISQUALIFIED_AUX(?R,?Mod).


/************************ Competition **************************************/
FL_COMPETES(?H1,?H2,?Exclusion,?Mod) :-
	?Exclusion[opposers(?Mod)->{?H1,?H2}],
	?H1 != ?H2.
FL_COMPETES(?H1,?H2,?Mod) :-
	FL_OPPOSES_AUX(?Mod,(?,?H1),(?,?H2)),
	?H1 != ?H2.

competitors(?H1,?H2,?Mod) :-
	FL_COMPETES(?H1,?H2,?_Exclusion,?Mod)
        or
        FL_COMPETES(?H1,?H2,?Mod).


/*********************** FL_DOMINATES ****************************************
** FL_DOMINATES(?Lit,?Dominee) =def=
**    Forall ?DomineeTag ( candidate(?DomineeTag,?Dominee) ~~>
**                 Exists ?Tag ( candidate(?Tag,?Lit) and
**                               _overrides((?Tag,?Lit),(?DomineeTag,?Dominee))
**                             )
**                       )
  Question: should it be _overrides((?Tag,?Lit),(?DomineeTag,?Dominee)) or
                         _overrides(?Tag,?DomineeTag)
****************************************************************************/
FL_DOMINATES(?Lit,?Dominee,?Mod) :-
	tag{?,?Lit},
	// tag{?,?Dominee} - must not be used: binary dominee may have no tag 
	competitors(?Lit,?Dominee,?Mod),
	not existsRuleWithNoOverrider(?Lit,?Dominee,?Mod).
existsRuleWithNoOverrider(?Lit,?Dominee,?Mod) :-
	FL_CANDIDATE((?DomineeTag,?Dominee),?Mod),
	not _exists ?Tag^((
	     FL_CANDIDATE((?Tag,?Lit),?Mod),
	     FL_OVERRIDES_AUX(?Mod,(?Tag,?Lit),(?DomineeTag,?Dominee))
	   )).


/********* FL_REBUTS, FL_REFUTES *****************************************/
// FL_REFUTES/4   Note: 1st arg is a head, second - a handle
FL_REFUTES(?H1,?R2,?Exclusion,?Mod) :-
	?R1 = (?_L1,?H1), ?R2 = (?_L2,?H2),
	FL_COMPETES(?H1,?H2,?Exclusion,?Mod),
	FL_OVERRIDES_AUX(?Mod,?R1,?R2),
	FL_CANDIDATE(?R1,?Mod).
// FL_REFUTES/3   Note: 1st arg is a head, not handle
FL_REFUTES(?H1,?R2,?Mod) :-
	?R1 = (?_L1,?H1), ?R2 = (?_L2,?H2),
	FL_COMPETES(?H1,?H2,?Mod),
	FL_OVERRIDES_AUX(?Mod,?R1,?R2),
	FL_CANDIDATE(?R1,?Mod).

// FL_REBUTS/4
FL_REBUTS(?H1,?H2,?Exclusion,?Mod)  :-
	FL_COMPETES(?H1,?H2,?Exclusion,?Mod),
	?R1 = (?,?H1),
	FL_CANDIDATE(?R1,?Mod),
	not FL_REFUTES(?H2,?R1,?Exclusion,?Mod).
// FL_REBUTS/3
FL_REBUTS(?H1,?H2,?Mod)  :-
	FL_COMPETES(?H1,?H2,?Mod),
	?R1 = (?,?H1),
	FL_CANDIDATE(?R1,?Mod),
	not FL_REFUTES(?H2,?R1,?Mod).


/************************ Stomping *****************************************
** FL_STOMPED(?Lit) =def=
**         tightExclusion(?Excl,?Lit) and
**         Forall ?Competitor ( FL_COMPETES(?Competitor,?Lit,?Excl) ~~>
**                                           FL_DOMINATES(?Competitor,?Lit)
**                            )
****************************************************************************/
FL_STOMPED(?Lit,?Mod) :-
	tightExclusion(?Excl,?Lit,?Mod),
	not existsCompetitorWhoDoesNotDominate(?Lit,?Excl,?Mod).
existsCompetitorWhoDoesNotDominate(?Lit,?Excl,?Mod) :-
	FL_COMPETES(?Lit,?Competitor,?Excl,?Mod),
	not FL_DOMINATES(?Competitor,?Lit,?Mod).
// binary version of stomping
FL_STOMPED(?Lit,?Mod) :-
	tag{?,?Lit},
	tightBinaryExclusion(?Competitor,?Lit,?Mod),
	if FL_COMPETES(?Competitor,?Lit,?Mod)
	then FL_DOMINATES(?Competitor,?Lit,?Mod).


/*********************** Tight Exclusion ***********************************
**  tightExclusion(?Excl,?Lit) =def=
**       candidate(?Tag,?Lit) and
**           Forall ?Competitor (
**                     FL_COMPETES(?Competitor,?Lit,?Excl) ~~>
**                       Exists ?CompetitorTag (
**                                  candidate(?CompetitorTag,?Competitor) and
**                                  not FL_STOMPED(?Competitor)  --- for ATCK2
**                                             )
**                               )
****************************************************************************/
tightExclusion(?Excl,?Lit,?Mod) :-
	?Excl:_Exclusion@?Mod,
	FL_CANDIDATE((?,?Lit),?Mod),
	not existsCompetitorNonCadidateOrStomped(?Excl,?Lit,?Mod).
existsCompetitorNonCadidateOrStomped(?Excl,?Lit,?Mod) :-
	// tag{?,?Competitor} - must not use: binary competitor may have no tag
	FL_COMPETES(?Lit,?Competitor,?Excl,?Mod),
	not((FL_CANDIDATE((?,?Competitor),?Mod),
	     // not FL_STOMPED in some exclusion
	     not FL_STOMPED(?Competitor,?Mod))).

// for binary exclusions (_opposes)
tightBinaryExclusion(?Competitor,?Lit,?Mod) :-
	// tag{?,?Competitor} - must not use: binary competitor may have no tag
	FL_CANDIDATE((?,?Lit),?Mod),
	if FL_COMPETES(?Competitor,?Lit,?Mod)
        then (
	    FL_CANDIDATE((?,?Competitor),?Mod),
	    not FL_STOMPED(?Competitor,?Mod)
	).


/********************* Conflictful Exclusion *******************************
**  ConflictfulExclusion(?Excl,?Mod) =def=
**       Forall ?Opposer ( opposerOf(?Excl,?Opposer) ~~>
**                              Exists ?Tag candidate(?Tag,?Opposer)
**                       )
****************************************************************************/
// **** NOT USED *****
ConflictfulExclusion(?Excl,?Mod) :-
	?Excl:_Exclusion@?Mod,
	not existsOpposerWithNoCandidates(?Excl,?Mod).
existsOpposerWithNoCandidates(?Excl,?Opposer,?Mod) :-
	// tag{?,?Opposer}  - must not use: binary opposer may have no tag
	?Excl[opposers(?Mod)->?Opposer]@?Mod,
	not _exists ?Tag^((tag{?Tag,?}, FL_CANDIDATE((?Tag,?Opposer),?Mod))).


/************************ Debugging ***************************************/

/*
   FL_STATUS(Id,Head)[howDefeated->Reason] can be used to find out what is
   defeated and why. No need to reify the ?H argument or attach a module to it.
   This method finds out the caller module and replaces the module of Head
   with the caller module.
*/
FL_STATUS(?_L,?H)[howDefeated -> notBeaterFor(?Exclusion)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
        ?Exclusion[opposers(?RealMod)->?HM],
	not ?Exclusion[FL_BEATER(?RealMod)->?HM].
FL_STATUS(?L,?H)[howDefeated -> notBeaterFor(binaryExclusion(?HM,?Beaten))] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	?R1 = (?L,?HM),
	FL_OPPOSES_AUX(?RealMod,?R1,?R2),
	?R2 = (?_L2,?Beaten),
	not FL_BEATER(?HM,?Beaten,?RealMod).
FL_STATUS(?L,?H)[howDefeated -> canceled] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_CANCEL_AUX(?RealMod,(?L,?HM)).

FL_STATUS(?_L,?H)[info -> dominates(?Dominee)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_DOMINATES(?HM,?Dominee,?RealMod).

FL_STATUS(?_L,?H)[info -> refutes(?Refuted)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_REFUTES(?HM,?Refuted,?RealMod).
FL_STATUS(?_L,?H)[info -> refutes(?Refuted)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_REFUTES(?HM,?Refuted,?_Exclusion,?RealMod).

FL_STATUS(?_L,?H)[info -> rebuts(?Rebutted)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_REBUTS(?HM,?Rebutted,?RealMod).
FL_STATUS(?_L,?H)[info -> rebuts(?Rebutted)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_REBUTS(?HM,?Rebutted,?_Exclusion,?RealMod).

FL_STATUS(?_L,?H)[info->beats(?Exclusion,?Beaten)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	beater_aux(?HM,?Beaten,?Exclusion,?RealMod).
FL_STATUS(?_L,?H)[info->beats(?Beaten)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_BEATER(?HM,?Beaten,?RealMod).

FL_STATUS(?_L,?H)[info->competes(?Exclusion,?Competitor)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_COMPETES(?HM,?Competitor,?Exclusion,?RealMod),
	FL_CANDIDATE((?,?Competitor),?RealMod).
FL_STATUS(?_L,?H)[info->competes(?Competitor)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_COMPETES(?HM,?Competitor,?RealMod),
	FL_CANDIDATE((?,?Competitor),?RealMod).

FL_STATUS(?I,?H)[info->candidate] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_CANDIDATE((?I,?HM),?RealMod).


// if ?InA has module _@, change it to ?Mod
// ?RealNewMod is the module of the final OutA
// (the module is not changed if it is not _@).
change_module(?InA,?Mod,?RealNewMod,?OutA) :-
	flora_change_module(?InA,?OutA,(_@,?Mod),?RealNewMod,['In ',FL_STATUS,'(Id,Head)[...]@',_@,': Head must be bound'])@_prolog(flrwrapper),
	check_module_to_AT_association(?RealNewMod).


change_module_nocheck(?InA,?,?,?OutA) :-
	var(?InA),
	!,
	?OutA = ?InA.
// if ?InA has module _@, change it to ?Mod
change_module_nocheck(?InA,?Mod,?RealNewMod,?OutA) :-
	flora_change_module(?InA,?OutA,(_@,?Mod),?RealNewMod,'In defeated/overrides/opposes: something wrong')@_prolog(flrwrapper),
	check_module_to_AT_association(?RealNewMod).


/***************************** Auxiliary Predicates ***********************/
// Given a rule Id and possibly Head, find body and test if it is satisfied.
// This predicate's tables are abolished after each query by an
// after-query hook because sometimes it is called with RId/Head as a var.
// It may succeed for one query and will be tabled.
// If it is, then when called for another query, wrong result may be returned.
FL_CANDIDATE((?RId,?Head),?Mod) :-
	tag{?RId,?Head},
	clause{@{?RId} ?Head@?Mod, ?Body},
	call(?Body).

// opposer without the rule tag
?Exclusion[opposers(?Mod)->?HH] :-
	(?Exclusion:_Exclusion[_opposers->?H])@?Mod,
	?HH = ?H@?Mod.


// FL_OPPOSES_AUX/3, FL_OVERRIDES_AUX/3, FL_CANCEL_AUX/2 are defined in
// genincludes/flrdefeasible.fli


/***** refresh the tables used by the defeasible theory ********************/

%refresh :-
	refresh{?(?,?,?), ?(?,?)},
	caller{?Mod},
	refresh{FL_OPPOSES(?,?)@?Mod, FL_OPPOSES(?,?,?,?)@?Mod},
	refresh{FL_OVERRIDES(?,?)@?Mod, FL_OVERRIDES(?,?,?,?)@?Mod},
	refresh{FL_CANCEL(?)@?Mod, FL_CANCEL(?,?)@?Mod}.

// Hook for abolishing FL_CANDIDATE/1 after each query
FL_DEFEASIBLE_CLEANUP(?,?) :- flora_abolish_table_call(${FL_CANDIDATE(?,?)})@_prolog(flrtables).

?- flora_add_hook(_@,QUERYHOOK,after,0,FL_DEFEASIBLE_CLEANUP(?,?))@_prolog(flrhooks).

// must have this in order for FL_STATUS to have right argument translation
?- flora_set_argdef(FL_STATUS,2,[FL_OID,FL_BODYFORMULA],_@)@_prolog(flrarguments).
