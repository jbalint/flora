/* File:      flrnegation.P
**
** Author(s): Michael Kifer
**
** Contact:   kifer@cs.stonybrook.edu
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2010.
**
** All rights reserved.
**
** For information about licensing terms, please see
** http://silk.projects.semwebcentral.org/flora2-license.html
**
**
*/



:- compiler_options([xpp_on]).
#include "flora_terms.flh"
#include "flora_porting.flh"
#include "flora_prefix.flh"
#include "flora_exceptions.flh"

#include "flora_tabling_methods.flh"

#define MAX_NEGATION_NESTING_DEPTH 10000


%% Identical to XSB's sk_not, but allows us to clean up the intermediate
%% tables created while computing the negation

%% Variables temporarily changed to ground and tnot 
%% call is made.  Should give existential semantics to nonground negative
%% calls.  That is
%%	...:- FLORA_TNOT_PREDICATE(p(X)),...
%% is like
%%	... :- tnot(pp),...
%%	pp :- p(X).
%% where pp is a new proposition.

:- import numbervars/4 from num_vars.
:- import copy_term/2 from basics.
:- import
	table_state/4,
	get_calls/3,
	't not'/1
   from tables.
:- import incr_invalidate_call/1 from increval.
:- import
	flora_abolish_table_call/1
   from flrtables.
:- import
	flora_abort/2,
	flora_match_substring/3
   from flrporting.
:- import flora_module_predicate/4 from flrwrapper.
:- import flora_decode_goal_as_atom/2 from flrdecode.

%% need to import that to match the error's module
:- import error/3 from usermod.

:- export
	flora_unwrap_negation/2,
	flora_cleanup_negation/1, 
	flora_apply_negation_wrapper/3,
	FLORA_TNOT_PREDICATE/3,
	FLORA_TNOT_PREDICATE/1.


FLORA_TNOT_PREDICATE(Goal) :- FLORA_TNOT_PREDICATE(Goal,NULL,NULL).

FLORA_TNOT_PREDICATE(Goal,Line,File) :-
	flora_unwrap_negation_nocheck(Goal,UnwrappedGoal),
	make_negated_goal(UnwrappedGoal,Goal,NewGoal),
	catch(NewGoal,error(typed_table_error(incremental_tabling),_,_),incr_tabling_error_handler(Line,File,UnwrappedGoal)).

	
	
%% Delete tables for FLORA_THIS_WORKSPACE(tabled_unnumber_call)/1, which
%% defined in closure/flrcommon.fli
%% Invalidate for incremental tabling
flora_cleanup_negation(Call) :-
	(curr_sym:predicate_property(Call,incremental)
	->
	    (get_calls(Call,Handle,_Template),
		table_state(Handle,_PredType,_CallType,AnsSetStatus),
		AnsSetStatus == incomplete
	    -> true
	    ; 
		%% ignore incremental tabling errors that might arise
		%%incr_invalidate_call(Call)
		catch(incr_invalidate_call(Call),
		      error(typed_table_error(incremental_tabling),_,_),
		      true)
	    )
	;
	    flrcanon:convert_to_body_literal(Call,Call1),
	    flora_abolish_table_call(Call1)
	),
	!.

%% unwrap Call = FLORA_THIS_WORKSPACE(FL_TABLED_UNNUMBER_CALL)(Unwrapped)
flora_unwrap_negation(Call,Unwrapped) :-
	functor(Call,F,1),
	flora_match_substring(FL_TABLED_UNNUMBER_CALL,F,_),
	!,
	arg(1,Call,Unwrapped).
flora_unwrap_negation(Call,Call).

flora_unwrap_negation_nocheck(Call,Unwrapped) :-
	arg(1,Call,Unwrapped).


flora_apply_negation_wrapper(Goal,Workspace,GoalWrapped) :-
	flora_module_predicate(FL_TABLED_UNNUMBER_CALL,[Goal],Workspace,GoalWrapped).


incr_tabling_error_handler(Line,File,Goal) :-
	((Line == NULL ; var(Line)) -> LineMsg = '(unknown)'
	; LineMsg = Line
	),
	((File == NULL ; var(File)) -> FileMsg = '(unknown)'
	; FileMsg = File
	),
	((var(Line) ; var(File)) -> EndingMsg = ' (The offending statement may have been created dynamically and passed down as an argument.)'
	; EndingMsg = ''
	),
	MainMsg1 = 'Attempt to perform a side-effectful action "',
	MainMsg2 = '" in an IF- or UNLESS-condition, or in the scope of the default negation operator. Such actions must be wrapped inside hypotheticals.',
	flora_decode_goal_as_atom(Goal,GoalAtm),
	flora_abort(['Line: ', LineMsg, ', file: ', FileMsg, '. ',
		     MainMsg1, GoalAtm, MainMsg2, EndingMsg],
		    FLORA_ABORT_NOTRACE).


make_negated_goal(FLLIBHYPOTHETICAL(Type,Goal),_OrigGoal, FLLIBHYPOTHETICAL(ReverseType,Goal)) :-
	!,
	(Type == FL_POSSIBLE -> ReverseType = FL_IMPOSSIBLE
	; ReverseType = FL_POSSIBLE
	).

make_negated_goal(_UnwrappedGoal,OrigGoal,'t not'(TempGoal)) :-
	copy_term(OrigGoal,TempGoal),
	%% make TempGoal ground, so no checks would be necessary in 't not'
	numbervars(TempGoal,0,_,[attvar(bind)]),
	%% we are checking for incomplete tables: Should be safe?
	flora_cleanup_negation(TempGoal).


/*
   Instead of catching the errors, we might want to instead examine
   if we are abolishing incomplete dependent tables. Table dependency
   in incremental tabling can be found using the following idiom:

          predicate_property(Skel,incremental),
	    increval:get_calls_incr(Skel,_Hndl),
	       incr_trans_depends(Skel,Call).

   Direct dependency can be checked using:

	    incr_directly_depends(Skel,Call)
*/
