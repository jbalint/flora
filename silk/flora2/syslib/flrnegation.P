/* File:      flrnegation.P
**
** Author(s): Michael Kifer
**
** Contact:   kifer@cs.stonybrook.edu
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2010.
**
** All rights reserved.
**
** For information about licensing terms, please see
** http://silk.projects.semwebcentral.org/flora2-license.html
**
*/

:- compiler_options([xpp_on]).
#include "trie_defs.h"
#include "flora_terms.flh"
#include "flora_porting.flh"
#include "flora_prefix.flh"
#include "flora_exceptions.flh"

#include "flora_tabling_methods.flh"

%%#define NEGATION_DEBUG_STATS 1

:- import numbervars/4 from num_vars.
:- import
	member/2,
	copy_term/2
   from basics.
:- import
	call0/1,
	is_cyclic/1,
	term_arg/3
   from machine.
%%:- import
%%	't not'/1
%%   from tables.
:- import
	incr_invalidate_call/1
   from increval.
:- import predicate_property/2 from curr_sym.
:- import
	flora_has_incomplete_incr_dependent_table/1,
	flora_abolish_table_call/1
   from flrtables.
:- import
	flora_abort/2,
	flora_concat_atoms/2,
	flora_match_substring/3
   from flrporting.
:- import
	flora_is_transactional_call/1,
	flora_decode_predicate/7,
	flora_module_predicate/4
   from flrwrapper.
:- import flora_decode_goal_as_atom/2 from flrdecode.

%% need to import that to match the error's module
:- import error/3 from usermod.

:- import
	storage_delete_fact/3,
	storage_find_fact/2
   from storage.

:- import
	flora_storage_fast_insert_fact/3
   from flrstoragebase.

/* update_counter is a pair (HiNum,LowNum). We use a pair so we could
   use large numbers even on a 32 bit machine */
:- dynamic update_counter/2.
:- local update_counter/2.
:- index(update_counter/2,0).

:- dynamic convert_to_table_cache/2, convert_to_table_cache_failed/1.
:- local convert_to_table_cache/2, convert_to_table_cache_failed/1.

:- export
	flora_unwrap_negation/2,
	flora_apply_negation_wrapper/3,
	incr_flora_update_counter/0,
	FLORA_TNOT_PREDICATE/3,
	FLORA_TNOT_PREDICATE/1.


%% Similar to XSB's sk_not, but allows us to clean up the intermediate
%% tables created while computing negation. Also, tries to deal with
%% various builtins, like var, integer, =, directly.

%% Variables temporarily changed to ground and tnot 
%% call is made.  Should give existential semantics to nonground negative
%% calls.  That is
%%	...:- FLORA_TNOT_PREDICATE(p(X)),...
%% is like
%%	... :- tnot(pp),...
%%	pp :- p(X).
%% where pp is a new proposition.

FLORA_TNOT_PREDICATE(Goal) :- FLORA_TNOT_PREDICATE(Goal,NULL,NULL).

FLORA_TNOT_PREDICATE(Goal,_Line,_File) :-
	is_cyclic(Goal),
	!,
	fail.
FLORA_TNOT_PREDICATE(Goal,_Line,_File) :-
#ifdef NEGATION_DEBUG_STATS
	flrporting:flora_increment_counter(negtotal,1,_,_),
#endif
	flora_unwrap_negation_nocheck(Goal,UnwrappedGoal),
	%% only tabled predicates can pass the next test
	convert_flora_call_to_tabled(UnwrappedGoal,NewCall),
	ground(NewCall),
	!,
	%% this will call body-predicates in flrpreddef_NAF.fli, which
	%% will then call FLORA_TNOT_PREDICATE2/1 below
	call0(NewCall).
FLORA_TNOT_PREDICATE(Goal,Line,File) :-
	flora_unwrap_negation_nocheck(Goal,UnwrappedGoal),
	%% acyclicity of the goal is checked upfront
	make_negated_goal(UnwrappedGoal,Goal,NewGoal),
	%%call0(NewGoal).
	catch(call0(NewGoal),error(typed_table_error(incremental_tabling),_,_),
	      incr_tabling_error_handler(Line,File,UnwrappedGoal)).

:- export FLORA_TNOT_PREDICATE2/1.
%% optimization for ground tabled negated subgoals
%% Note: this is ground, so no need to check for Goal acyclicity!
FLORA_TNOT_PREDICATE2(Goal) :-
#ifdef NEGATION_DEBUG_STATS
	flrporting:flora_increment_counter(negtabled,1,_,_),
#endif
	tnot(Goal).


	
%% Delete tables for FLORA_THIS_WORKSPACE(TABLED_UNNUMBER_CALL)/1, which
%% is defined in closure/flrcommon.fli
cleanup_negation(Call) :-
	donot_cleanup_negation(Call),
	!.
cleanup_negation(Call) :-
	(predicate_property(Call,incremental)
	-> ( flora_has_incomplete_incr_dependent_table(Call) -> true
	   ; incr_invalidate_call(Call)
	   )
	;
	    flora_abolish_table_call(Call)
	).


%% unwrap Call = FLORA_THIS_WORKSPACE(FL_TABLED_UNNUMBER_CALL)(Unwrapped)
flora_unwrap_negation(Call,Unwrapped) :-
	functor(Call,F,1),
	flora_match_substring(FL_TABLED_UNNUMBER_CALL,F,_),
	!,
	arg(1,Call,Unwrapped).
flora_unwrap_negation(Call,Call).

flora_unwrap_negation_nocheck(Call,Unwrapped) :-
	%%arg(1,Call,Unwrapped).
	term_arg(Call,1,Unwrapped).


flora_apply_negation_wrapper(Goal,Workspace,GoalWrapped) :-
	flora_module_predicate(FL_TABLED_UNNUMBER_CALL,[Goal],Workspace,GoalWrapped).


incr_tabling_error_handler(Line,File,Goal) :-
	((Line == NULL ; var(Line)) -> LineMsg = '(unknown)'
	; LineMsg = Line
	),
	((File == NULL ; var(File)) -> FileMsg = '(unknown)'
	; FileMsg = File
	),
	((var(Line) ; var(File)) -> EndingMsg = ' (The offending statement may have been created dynamically and passed down as an argument.)'
	; EndingMsg = ''
	),
	MainMsg1 = 'Attempt to perform a side-effectful action "',
	MainMsg2 = '" in an IF- or UNLESS-condition, or in the scope of the default negation operator. Such actions must be wrapped inside hypotheticals.',
	flora_decode_goal_as_atom(Goal,GoalAtm),
	flora_abort(['Line: ', LineMsg, ', file: ', FileMsg, '. ',
		     MainMsg1, GoalAtm, MainMsg2, EndingMsg],
		    FLORA_ABORT_NOTRACE).

%% optimizations for common cases. more to be added as the need arises
%% may add write predicates here
%% May push through conjunctions and disjunctions later
make_negated_goal('='(Left,Right),   _OrigGoal, '\='(Left,Right))   :- !.
make_negated_goal('!='(Left,Right),   _OrigGoal, '='(Left,Right))   :- !.
make_negated_goal('\='(Left,Right),  _OrigGoal, '='(Left,Right))    :- !.
make_negated_goal('=='(Left,Right),  _OrigGoal, '\=='(Left,Right))  :- !.
make_negated_goal('\=='(Left,Right), _OrigGoal, '=='(Left,Right))   :- !.
make_negated_goal('<'(Left,Right),   _OrigGoal, '>='(Left,Right))   :- !.
make_negated_goal('=<'(Left,Right),  _OrigGoal, '>'(Left,Right))    :- !.
make_negated_goal('>'(Left,Right),   _OrigGoal, '=<'(Left,Right))   :- !.
make_negated_goal('>='(Left,Right),  _OrigGoal, '<'(Left,Right))    :- !.
make_negated_goal('@<'(Left,Right),  _OrigGoal, '@>='(Left,Right))  :- !.
make_negated_goal('@=<'(Left,Right), _OrigGoal, '@>'(Left,Right))   :- !.
make_negated_goal('@>'(Left,Right),  _OrigGoal, '@=<'(Left,Right))  :- !.
make_negated_goal('@>='(Left,Right), _OrigGoal, '@<'(Left,Right))   :- !.
make_negated_goal(FL_ISSKOLEM(V),    _OrigGoal, \+FL_ISSKOLEM(V))   :- !.
make_negated_goal(FL_ISBASEFACT(V),  _OrigGoal, \+FL_ISBASEFACT(V)) :- !.
make_negated_goal(\+(V),             _OrigGoal, V)                  :- !.
make_negated_goal(var(V),            _OrigGoal, nonvar(V))          :- !.
make_negated_goal(nonvar(V),         _OrigGoal, var(V))             :- !.
make_negated_goal(integer(V),        _OrigGoal, \+integer(V))       :- !.
make_negated_goal(float(V),          _OrigGoal, \+float(V))         :- !.
make_negated_goal(number(V),         _OrigGoal, \+number(V))        :- !.
make_negated_goal(is_list(V),        _OrigGoal, \+is_list(V))       :- !.
make_negated_goal(is_charlist(V),    _OrigGoal, \+is_charlist(V))   :- !.
make_negated_goal(is(V,W),           _OrigGoal, \+is(V,W))          :- !.
make_negated_goal(true,              _OrigGoal, fail)               :- !.
make_negated_goal(fail,              _OrigGoal, true)               :- !.
make_negated_goal(false,             _OrigGoal, true)               :- !.
make_negated_goal(flrground(G), _OrigGoal, flora_ground:flrnonground(G)) :- !.
make_negated_goal(_:flrground(G), _OrigGoal, flora_ground:flrnonground(G)) :- !.

make_negated_goal(FLLIBHYPOTHETICAL(Type,Goal), _OrigGoal, FLLIBHYPOTHETICAL(ReverseType,Goal)) :-
	!,
#ifdef NEGATION_DEBUG_STATS
	flrporting:flora_increment_counter(neghypo,1,_,_),
#endif
	(Type == FL_POSSIBLE -> ReverseType = FL_IMPOSSIBLE
	; ReverseType = FL_POSSIBLE
	).

%% Simplification for ground calls: no need to numbervar and copy_term
make_negated_goal(UnwrappedGoal,OrigGoal,tnot(OrigGoal)) :-
	ground(UnwrappedGoal),
	!,
#ifdef NEGATION_DEBUG_STATS
	flrporting:flora_increment_counter(negground,1,_,_),
#endif
	cleanup_negation(OrigGoal),
	%% register_negated_call MUST come after cleanup_negation
	register_negated_call(OrigGoal).

%% TRANSACTIONAL: This is more rare than TABLED, so it comes after
make_negated_goal(UnwrappedGoal,_OrigGoal,\+(UnwrappedGoal)) :-
	flora_is_transactional_call(UnwrappedGoal),
#ifdef NEGATION_DEBUG_STATS
	flrporting:flora_increment_counter(negtransactional,1,_,_),
#endif
	!.
	
%% General case
make_negated_goal(_UnwrappedGoal,OrigGoal,tnot(TempGoal)) :-
#ifdef NEGATION_DEBUG_STATS
	flrporting:flora_increment_counter(neggenerl,1,_,_),
#endif
	copy_term(OrigGoal,TempGoal),
	%% make TempGoal ground, so no checks would be necessary in tnot
	numbervars(TempGoal,0,_,[attvar(bind)]),
	%% cleanup_negation/1 is checking for incomplete tables to be safe
	cleanup_negation(TempGoal),
	%% register_negated_call MUST come after cleanup_negation
	register_negated_call(TempGoal),
	!.

%% update_counter business
#define NEG_MGT_TRIE  FLORA_SYMBOL('neg_mgt_trie')
?- assert(update_counter(0,0)).
%% tells when not to clean up tables for TABLED_UNNUMBER_CALL
donot_cleanup_negation(Call) :-
	update_counter(CurrL,CurrR),
	(storage_find_fact(NEG_MGT_TRIE,negated_calls_cache(Call,CallFlag))
	-> (CurrL,CurrR) = CallFlag
	; true
	).
incr_flora_update_counter :-
	%%update_counter(H,L),
	retract(update_counter(H,L)),
	current_prolog_flag(max_integer,MaxInt),
	(L < MaxInt -> L1 is L+1, H1 is H
	; L1 = 0, H1 is H+1
	),
	assert(update_counter(H1,L1)).

%% saves Call in a trie-cache
register_negated_call(Call) :-
	%% get current flag
	update_counter(L,R),
	CurrFlag = (L,R),
	(storage_find_fact(NEG_MGT_TRIE,negated_calls_cache(Call,CurrFlag))
	-> true
	;
	    storage_delete_fact(NEG_MGT_TRIE,negated_calls_cache(Call,_),_),
	    %%!,   %% cut here has no effect
	    flora_storage_fast_insert_fact(NEG_MGT_TRIE,
					   NON_INCREMENTAL_TRIE,
					   negated_calls_cache(Call,CurrFlag))
	).


%% cache for successful conversions
convert_flora_call_to_tabled(Call,NewCall) :-
	convert_to_table_cache(Call,NewCall),
	!.
%% cache for failed conversions
convert_flora_call_to_tabled(Call,_NewCall) :-
	convert_to_table_cache_failed(Call),
	!,
	fail.
convert_flora_call_to_tabled(Call,NewCall) :-
#ifdef NEGATION_DEBUG_STATS
	flrporting:flora_set_counter(negtotal,1),
	flrporting:flora_set_counter(negtabled,0),
	flrporting:flora_set_counter(negground,0),
	flrporting:flora_set_counter(negtransactional,0),
	flrporting:flora_set_counter(neghypo,0),
	flrporting:flora_set_counter(neggenerl,0),
#endif
	flora_decode_predicate(Call,CallType,ModuleName,FullWrapper,
			       WrapPref,BaseWrapper,ArgList),
	atom(ModuleName),
	WrapPref == FLBodyPREFIX,
	member(CallType,[flogic,hilog,neg_flogic,neg_hilog]),
	BaseWrapper \== WRAP_TRAN,
	BaseWrapper \== WRAP_NONTABLED_HILOG,
	!,
	flora_concat_atoms([FL_NAFPREFIX,FullWrapper],NafWrapper),
	flora_module_predicate(NafWrapper,ArgList,ModuleName,NewCall),
	save_in_convert_to_table_cache(Call,NewCall),
	!.
%% failures are also cached
convert_flora_call_to_tabled(Call,_NewCall) :-
	save_in_convert_to_table_cache_failed(Call),
	!,
	fail.

save_in_convert_to_table_cache(Call,NewCall) :-
	functor(Call,Fun,N),
	functor(NewCall,NewFun,N),
	functor(CallTempl,Fun,N),
	CallTempl =.. [_|Args],
	NewCallTempl =.. [NewFun|Args],
	assert(convert_to_table_cache(CallTempl,NewCallTempl)).
save_in_convert_to_table_cache_failed(Call) :-
	functor(Call,Fun,N),
	functor(CallTempl,Fun,N),
	assert(convert_to_table_cache_failed(CallTempl)).


#ifdef NEGATION_DEBUG_STATS
:- export get_negation_stats/0.
get_negation_stats :-
	gensym:conget(negtotal,Total),
	gensym:conget(negtabled,Tabled),
	gensym:conget(negground,Ground),
	gensym:conget(negtransactional,Trans),
	gensym:conget(neghypo,Hypo),
	gensym:conget(neggenerl,Gen),
	Builtins is Total-Tabled-Ground-Trans-Hypo-Gen,
	writeln(2,'Statistics for negation use:'),
	writeln(2,'total '=Total),
	writeln(2,tabled=Tabled),
	writeln(2,ground=Ground),
	writeln(2,transl=Trans),
	writeln(2,'hypo  '=Trans),
	writeln(2,bltins=Builtins),
	writeln(2,generl=Gen).
#endif
