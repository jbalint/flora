/* File:      flrstoragebase.P - access to base facts
**
** Author(s): Michael Kifer
**
** Contact:   kifer@cs.stonybrook.edu
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2010.
**
** All rights reserved.
**
** For information about licensing terms, please see
** http://silk.projects.semwebcentral.org/flora2-license.html
**
**
*/



%% This file exists in order to isolate Flora's access to base facts
%% and make it possible to easily switch the access methods

:- compiler_options([xpp_on]).

#include "flora_terms.flh"
#include "flora_porting.flh"
#include "trie_defs.h"

:- export
	flora_db_insert_base/2,
	flora_db_delete_base/2,
	flora_db_insert_base_bt/2,
	flora_db_delete_base_bt/2,
	flora_db_find_base/2,
	flora_db_delete_all/1,
	flora_new_db_storage/1,
	flora_db_commit/1,
	flora_db_reclaim_space/1,
	flora_storage_insert_fact_bt/3,
	flora_storage_delete_fact_bt/3,
	flora_storage_insert_fact/3,
	flora_storage_delete_fact/3,
	flora_storage_find_fact/2.


:- import
	storage_insert_fact_bt/5,
	storage_insert_fact/3,
	storage_delete_fact_bt/5,
	storage_delete_fact/3,
	incr_storage_insert_fact_bt/3,
	incr_storage_insert_fact/3,
	incr_storage_delete_fact_bt/3,
	incr_storage_delete_fact/3
   from storage.
:- import
	storage_find_fact/2,
	storage_reclaim_space/1,
	storage_delete_all/1,
	storage_handle/4,
	storage_commit/1
   from storage.

:- import flora_refresh_tables/1 from flrtables.

:- import flora_call_hooks/5 from flrhooks.

:- import flora_trim_last/2 from flrtrim.

:- import
	flora_storage_module/2,
	flora_is_fdb_storage/1
   from flrwrapper.

:- import flora_trailer_registry/2 from flrregistry.


%% Lop off the last argument before inserting/querying the database
%% exported
flora_db_insert_base(StorageName,Call) :-
	flora_trim_last(Call, CallSansCaller),
	flora_storage_module(StorageName,Module),
	%% Hooks get CallSansCaller as an argument.
	%% CallSansCaller is used by around-hooks to pass info from
	%% before hooks to after hooks
	call_if_fdb_storage(StorageName,
			    flora_call_hooks(Module,INSERTFACT,CallSansCaller,before,AroundHookLink)),
	flora_storage_insert_fact(StorageName,CallSansCaller,_ResultFlag),
	call_if_fdb_storage(StorageName,
			    flora_call_hooks(Module,INSERTFACT,CallSansCaller,after,AroundHookLink)).

%% exported
/*
   Logic for interacting with DB interface:
      delete from database is in the after-hook
      If Call is in memory or in DB:
          Since we are calling flora_db_delete_base, we must have queried
	    Call before and the result was true. So, we first delete
	    from memory and then the afterhook deletes from DB, if any.
      If Call is not in memory or in DB, we don't even get here.
          This is because flora_db_delete_base is called only after
	  we queried that Call is true. (Such a query will also check the DB.)
*/
flora_db_delete_base(StorageName,Call) :-
	flora_trim_last(Call, CallSansCaller),
	flora_storage_module(StorageName,Module),
	call_if_fdb_storage(StorageName,
			    flora_call_hooks(Module,DELETEFACT,CallSansCaller,before,AroundHookLink)),
	%%may or may not be present in main memory.
	flora_storage_delete_fact(StorageName,CallSansCaller,_ResultFlag),
	call_if_fdb_storage(StorageName,
			    flora_call_hooks(Module,DELETEFACT,CallSansCaller,after,AroundHookLink)).

%% exported
flora_db_insert_base_bt(StorageName,Call) :-
	flora_trim_last(Call, CallSansCaller),
	flora_storage_module(StorageName,Module),
	call_if_fdb_storage(StorageName,
			    flora_call_hooks(Module,INSERTFACT,CallSansCaller,before,AroundHookLink)),
	flora_storage_insert_fact_bt(StorageName,CallSansCaller,Call,_ResultFlag),
	call_if_fdb_storage(StorageName,
			    flora_call_hooks(Module,INSERTFACT,CallSansCaller,after,AroundHookLink)).

%% exported
flora_db_delete_base_bt(StorageName,Call) :-
	flora_trim_last(Call, CallSansCaller),
	flora_storage_module(StorageName,Module),
	call_if_fdb_storage(StorageName,
			    flora_call_hooks(Module,DELETEFACT,CallSansCaller,before,AroundHookLink)),
	flora_storage_delete_fact_bt(StorageName,CallSansCaller,Call,_ResultFlag),
	call_if_fdb_storage(StorageName,
			    flora_call_hooks(Module,DELETEFACT,CallSansCaller,after,AroundHookLink)).


%% Used to search database of facts
%% exported
flora_db_find_base(StorageName,Call) :-
	flora_trim_last(Call, CallSansCaller),
	flora_storage_module(StorageName,Module),
	call_if_fdb_storage(StorageName,
			    flora_call_hooks(Module,FINDFACT,CallSansCaller,before,AroundHookLink)),
	flora_storage_find_fact(StorageName,CallSansCaller),
	call_if_fdb_storage(StorageName,
			    flora_call_hooks(Module,FINDFACT,CallSansCaller,after,AroundHookLink)).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Here we need to implement backtrackable updates using assert and retract_nr


%% Inserts facts. On backtracking, the fact is deleted.
flora_storage_insert_fact_bt(StorageName,Fact,Call,Inserted) :-	
	flora_storage_module(StorageName,Module),
	(
	  flora_trailer_registry(Module,FL_TABLING(FL_INCREMENTAL)),
	  flora_is_fdb_storage(StorageName)
	-> incr_storage_insert_fact_bt(StorageName,Fact,Inserted)
	;
	    storage_insert_fact_bt(StorageName,Fact,Inserted,
				   true,
				   %% Refresh on backtracking. Forward refresh
				   %% is done in flrbtdbop.P and flrdbop.P
				   %% Forward refresh can't be done here, since
				   %% flora_storage_insert_fact is too low
				   %% level and is used elsewhere. Refreshing
				   %% of tables on forward execution here is
				   %% too low level and can be dangerous
				   flora_refresh_tables(Call))
	).


%% Nonbacktrackable insert
flora_storage_insert_fact(StorageName,Fact,Inserted) :-	
	flora_storage_module(StorageName,Module),
	(
	  flora_trailer_registry(Module,FL_TABLING(FL_INCREMENTAL)),
	  flora_is_fdb_storage(StorageName)
	-> incr_storage_insert_fact(StorageName,Fact,Inserted)
	;
	    storage_insert_fact(StorageName,Fact,Inserted)
	).


%% Backtrackable delete.
%% Doesn't remove anything, but instead "marks" for deletion.
%% On backtracking: unmarks facts that are marked for deletion
flora_storage_delete_fact_bt(StorageName,Fact,Call,Deleted) :-
	flora_storage_module(StorageName,Module),
	(
	  flora_trailer_registry(Module,FL_TABLING(FL_INCREMENTAL)),
	  flora_is_fdb_storage(StorageName)
	-> incr_storage_delete_fact_bt(StorageName,Fact,Deleted)
	;
	  storage_delete_fact_bt(StorageName,Fact,Deleted,
				 true,
				 %% Refresh on backtracking. Forward refresh is
				 %% done in flrbtdbop.P and flrdbop.P
				 %% Forward refresh can't be done here, since
				 %% flora_storage_delete_fact is too low level
				 %% and is used elsewhere. Refreshing of tables
				 %% on forward execution here is too low level
				 %% and can be dangerous
				 flora_refresh_tables(Call))
	).

%% Nonbacktrackable delete
flora_storage_delete_fact(StorageName,Fact,Deleted) :-
	flora_storage_module(StorageName,Module),
	(
	  flora_trailer_registry(Module,FL_TABLING(FL_INCREMENTAL)),
	  flora_is_fdb_storage(StorageName)
	-> incr_storage_delete_fact(StorageName,Fact,Deleted)
	;
	  storage_delete_fact(StorageName,Fact,Deleted)
	).

%% deletes the whole trie
%% exported
flora_db_delete_all(StorageName) :- storage_delete_all(StorageName).

%%flora_new_db_storage(StorageName) :- storage_handle(StorageName,NON_INCREMENTAL_TRIE,_,_).
flora_new_db_storage(StorageName) :- storage_handle(StorageName,INCREMENTAL_TRIE,_,_).


%% Find fact in storage
flora_storage_find_fact(StorageName,Fct) :- 
	storage_find_fact(StorageName,Fct).


%% Commit changes to the storage trie associated with StorageName
%% (only if storage has been changed)
%% exported
flora_db_commit(StorageName) :- storage_commit(StorageName).

%% Reclaims space by removing nodes from the backtrackable insert/keypair trie
%% which were marked for deletion. This should be done only at the top 
%% level of a query.
%% exported
flora_db_reclaim_space(StorageName) :- storage_reclaim_space(StorageName).


%% Call Goal, if StorageName is FDB storage (and not FLD storage)
call_if_fdb_storage(StorageName,Goal) :-
	(flora_is_fdb_storage(StorageName) -> Goal; true).
