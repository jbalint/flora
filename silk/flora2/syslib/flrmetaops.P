/* File:      flrmetaops.P
**
** Author(s): Michael Kifer
**
** Contact:   kifer@cs.stonybrook.edu
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2009;
**      and Vulcan, Inc., 2008-2009.
**
** All rights reserved.
**
** For information about licensing terms, please see
** http://silk.projects.semwebcentral.org/flora2-license.html
**
**
*/


:- compiler_options([xpp_on]).
#include "flora_terms.flh"
#include "flora_porting.flh"

:- import append/3, length/2 from basics.

:- import
	negate_wrapper/2,
       flora_module_predicate/4,
       is_flora_callable_literal/1,
       flora_decode_predicate/7
   from flrwrapper.


:- import
	get_canonical_form/2,
	convert_to_body_literal/2,
        flora_check_dynmod_type_consistency/1
    from flrcanon.

:- import
	flora_generalize_last/2,
	flora_add_last/3
   from flrtrim.

:- import flrtrim_last/2 from flora_ground.

:- import
	flora_decode_goal_as_atom/2
   from flrdecode.

:- import flora_list2conjunct/2 from flrutils.


/******************************************************************************
 utilities for dealing with FLLIBMODOBJ
******************************************************************************/
collect_libmodobj(Var,Var,[]) :-
        var(Var),
        !.

collect_libmodobj((A,B),P,O) :-
        !,
        collect_libmodobj(A,PA,OA),
        collect_libmodobj(B,PB,OB),
        ( PA == [] -> P = PB
        ; PB == [] -> P = PA
        ; P = (PA,PB)
        ),
        append(OA,OB,O).

collect_libmodobj(FLLIBMODLIT(FL_LIBMOD,Args,M,Caller),FLLIBMODLIT(FL_LIBMOD,P,M,Caller),O) :-
        nonvar(Args),
        Args = (A,B),
        !,
        collect_libmodobj(A,PA,OA),
        collect_libmodobj(B,PB,OB),
        ( PA == [] -> P = PB
        ; PB == [] -> P = PA
        ; P = (PA,PB)
        ),
        append(OA,OB,O).

collect_libmodobj(FLLIBMODLIT(FL_NEGLIBMOD,Args,M,Caller),FLLIBMODLIT(FL_NEGLIBMOD,P,M,Caller),O) :-
        nonvar(Args),
        Args = (A,B),
        !,
        collect_libmodobj(A,PA,OA),
        collect_libmodobj(B,PB,OB),
        ( PA == [] -> P = PB
        ; PB == [] -> P = PA
        ; P = (PA,PB)
        ),
        append(OA,OB,O).

collect_libmodobj(FLLIBMODLIT(FL_TRANSLIBMOD,Args,M,Caller),FLLIBMODLIT(FL_TRANSLIBMOD,P,M,Caller),O) :-
        nonvar(Args),
        Args = (A,B),
        !,
        collect_libmodobj(A,PA,OA),
        collect_libmodobj(B,PB,OB),
        ( PA == [] -> P = PB
        ; PB == [] -> P = PA
        ; P = (PA,PB)
        ),
        append(OA,OB,O).


collect_libmodobj(FLLIBMODOBJ(W,A,M,C,P),[],[FLLIBMODOBJ(W,A,M,C,P)]) :- !.

collect_libmodobj(P,P,[]).

matching_libmodobj([],_) :- !.
matching_libmodobj(_,[]) :- !.
matching_libmodobj([FLLIBMODOBJ(W1,A1,M1,C1,P1)|L1],[FLLIBMODOBJ(W2,A2,M2,C2,P2)|L2]) :- 
        ( P1==P2 ->
            FLLIBUNIVEQFORM(FLLIBMODLIT(W1,A1,M1,C1),FLLIBMODLIT(W2,A2,M2,C2))
        ;
            true
        ),
        matching_libmodobj([FLLIBMODOBJ(W1,A1,M1,C1,P1)],L2),
        matching_libmodobj(L1,L2). 

checking_libmodobj([]) :- !.
checking_libmodobj([FLLIBMODOBJ(W,A,M,C,P)|L]) :-
        ( nonvar(P) ->
            FLLIBUNIVEQFORM(FLLIBMODLIT(W,A,M,C),P)
        ;
            true
        ),
        checking_libmodobj(L).

/******************************************************************************
  FLLIBUNIVEQFORM(?X,?Y)
  The meta predicate ~
******************************************************************************/
FLLIBUNIVEQFORM(X,X) :-
	var(X),
	!.

FLLIBUNIVEQFORM(X,Y) :-
	var(X),
	!,
        flora_check_dynmod_type_consistency(Y),
        X = Y.

FLLIBUNIVEQFORM(X,Y) :-
	var(Y),
	!,
        flora_check_dynmod_type_consistency(X),
        X = Y.

%% speed up the case where X unifies with Y
FLLIBUNIVEQFORM(X,Y) :-
        atomic(X),
        atomic(Y),
        !,
        X=Y.

%% We ignore pre-and-post body and rule Ids and meta info in such unification
FLLIBUNIVEQFORM(FLSYSRULEUPDATE(_Id,_DescrVarTerm,_DescrMetaFacts,H1,B1,HV,BV,_PreBody,_PostBody,_DefeatCond),FLSYSRULEUPDATE(_Id2,_DescrVarTerm2,_DescrMetaFacts2,H2,B2,HV,BV,_PreBody2,_PostBody2,_DefeatCond)) :-
	!,
	flora_list2conjunct(H1,H1C),
	flora_list2conjunct(H2,H2C),
	FLLIBUNIVEQFORM(H1C,H2C),
	FLLIBUNIVEQFORM(B1,B2).

FLLIBUNIVEQFORM(X,Y) :-
        X \= FLLIBMODLIT(_,_,_,_), X \= (FLLIBMODLIT(_,_,_,_), _),
        Y \= FLLIBMODLIT(_,_,_,_), Y \= (FLLIBMODLIT(_,_,_,_), _),
        X=Y,
        !.

FLLIBUNIVEQFORM(FLLIBMODLIT(WrapX,X,M,_Caller1),FLLIBMODLIT(WrapY,Y,M,_Caller2)) :-
	WrapX == WrapY,
        var(X),
        var(Y),
        !,
        X=Y.

%% ?X ~ %?Y@Mod fails if both variables are unbound
%% Also %?X@Mod ~ ?Y and the same with neg.
FLLIBUNIVEQFORM(FLLIBMODLIT(WrapX,X,_M1,_Caller1),FLLIBMODLIT(WrapY,Y,_M2,_Caller2)) :-
	WrapX \== WrapY,
        var(X),
        var(Y),
        !,
        fail.

FLLIBUNIVEQFORM(FLLIBMODLIT(WrapX,X,M,C1),FLLIBMODLIT(W,A,M2,C2)) :-
        var(X),
	(WrapX == FL_LIBMOD ; WrapX == FL_NEGLIBMOD),
        !,
        flora_check_dynmod_type_consistency(FLLIBMODLIT(W,A,M2,C2)),
        get_canonical_form(FLLIBMODLIT(W,A,M2,C2),FLCANON(Wrap,Args,M,P,Type)),
	(Type == FL_TABLED ; Type == FL_TABLED_NEG),
        (var(M2) -> M2 = M ; true),
        (nonvar(P) -> X = P
        ; var(Wrap) -> X = A
        ; WrapX == FL_LIBMOD -> X = FLLIBMODLIT(Wrap,Args,M,C1)
	; WrapX == FL_NEGLIBMOD ->
	    negate_wrapper(Wrap,NWrap),
	    X = FLLIBMODLIT(NWrap,Args,M,C1)
	).

FLLIBUNIVEQFORM(FLLIBMODLIT(FL_TRANSLIBMOD,X,M,C1),FLLIBMODLIT(W,A,M2,C2)) :-
        var(X),
        !,
        flora_check_dynmod_type_consistency(FLLIBMODLIT(W,A,M2,C2)),
        get_canonical_form(FLLIBMODLIT(W,A,M2,C2),FLCANON(Wrap,Args,M,P,FL_NOTTABLED)),
        (var(M2) -> M2 = M ; true),
        (nonvar(P) -> X = P
        ; var(Wrap) -> X = A
        ; X = FLLIBMODLIT(Wrap,Args,M,C1)
	).

FLLIBUNIVEQFORM(FLLIBMODLIT(W,A,M2,C2),FLLIBMODLIT(WrapY,Y,M,C1)) :-
        var(Y),
	(WrapY == FL_LIBMOD ; WrapY == FL_NEGLIBMOD),
        !,
        flora_check_dynmod_type_consistency(FLLIBMODLIT(W,A,M2,C2)),
        get_canonical_form(FLLIBMODLIT(W,A,M2,C2),FLCANON(Wrap,Args,M,P,Type)),
	(Type == FL_TABLED ; Type == FL_TABLED_NEG),
        (var(M2) -> M2 = M; true),
        (nonvar(P) -> Y = P
        ; var(Wrap) -> Y = A
        ; WrapY == FL_LIBMOD -> Y = FLLIBMODLIT(Wrap,Args,M,C1)
	; WrapY == FL_NEGLIBMOD ->
	    negate_wrapper(Wrap,NWrap),
	    Y = FLLIBMODLIT(NWrap,Args,M,C1)
	).

FLLIBUNIVEQFORM(FLLIBMODLIT(W,A,M2,C2),FLLIBMODLIT(FL_TRANSLIBMOD,Y,M,C1)) :-
        var(Y),
        !,
        flora_check_dynmod_type_consistency(FLLIBMODLIT(W,A,M2,C2)),
        get_canonical_form(FLLIBMODLIT(W,A,M2,C2),FLCANON(Wrap,Args,M,P,FL_NOTTABLED)),
        (var(M2) -> M2 = M; true),
        (nonvar(P) -> Y = P
        ; var(Wrap) -> Y = A
        ; Y=FLLIBMODLIT(Wrap,Args,M,C1)).

%% Now neither X nor Y are variables
FLLIBUNIVEQFORM(X,Y) :-
        collect_libmodobj(X,PX,OX),
        collect_libmodobj(Y,PY,OY),
        (OX \= []; OY \= []),
        !,
        FLLIBUNIVEQFORM(PX,PY),
        matching_libmodobj(OX,OY),
        checking_libmodobj(OX),
        checking_libmodobj(OY).

FLLIBUNIVEQFORM((X,XX),(Y,YY)) :-
        !,
	FLLIBUNIVEQFORM(X,Y),
	FLLIBUNIVEQFORM(XX,YY).

FLLIBUNIVEQFORM((X;XX),(Y;YY)) :-
        !,
	FLLIBUNIVEQFORM(X,Y),
	FLLIBUNIVEQFORM(XX,YY).

%% LibModWrap is FL_LIBMOD, FL_TRANSLIBMOD
FLLIBUNIVEQFORM(FLLIBMODLIT(LibModWrap,(X,XX),Mod,Caller),(Y,YY)) :-
	(LibModWrap == FL_LIBMOD ; LibModWrap == FL_TRANSLIBMOD),
        !,
	FLLIBUNIVEQFORM(FLLIBMODLIT(LibModWrap,X,Mod,Caller),Y),
	FLLIBUNIVEQFORM(FLLIBMODLIT(LibModWrap,XX,Mod,Caller),YY).

FLLIBUNIVEQFORM(FLLIBMODLIT(LibModWrap,(X;XX),Mod,Caller),(Y;YY)) :-
	(LibModWrap == FL_LIBMOD ; LibModWrap == FL_TRANSLIBMOD),
        !,
	FLLIBUNIVEQFORM(FLLIBMODLIT(LibModWrap,X,Mod,Caller),Y),
	FLLIBUNIVEQFORM(FLLIBMODLIT(LibModWrap,XX,Mod,Caller),YY).

FLLIBUNIVEQFORM((Y,YY),FLLIBMODLIT(LibModWrap,(X,XX),Mod,Caller)) :-
	(LibModWrap == FL_LIBMOD ; LibModWrap == FL_TRANSLIBMOD),
        !,
	FLLIBUNIVEQFORM(FLLIBMODLIT(LibModWrap,X,Mod,Caller),Y),
	FLLIBUNIVEQFORM(FLLIBMODLIT(LibModWrap,XX,Mod,Caller),YY).

FLLIBUNIVEQFORM((Y;YY),FLLIBMODLIT(LibModWrap,(X;XX),Mod,Caller)) :-
	(LibModWrap == FL_LIBMOD ; LibModWrap == FL_TRANSLIBMOD),
        !,
	FLLIBUNIVEQFORM(FLLIBMODLIT(LibModWrap,X,Mod,Caller),Y),
	FLLIBUNIVEQFORM(FLLIBMODLIT(LibModWrap,XX,Mod,Caller),YY).

FLLIBUNIVEQFORM(FLLIBMODLIT(LibModWrap,(X,XX),Mod1,Caller1),FLLIBMODLIT(LibModWrap,(Y,YY),Mod2,Caller2)) :-
	(LibModWrap == FL_LIBMOD ; LibModWrap == FL_TRANSLIBMOD),
        !,
	FLLIBUNIVEQFORM(FLLIBMODLIT(LibModWrap,X,Mod1,Caller1),FLLIBMODLIT(LibModWrap,Y,Mod2,Caller2)),
	FLLIBUNIVEQFORM(FLLIBMODLIT(LibModWrap,XX,Mod1,Caller1),FLLIBMODLIT(LibModWrap,YY,Mod2,Caller2)).

FLLIBUNIVEQFORM(FLLIBMODLIT(LibModWrap,(X;XX),Mod1,Caller1),FLLIBMODLIT(LibModWrap,(Y;YY),Mod2,Caller2)) :-
	(LibModWrap == FL_LIBMOD ; LibModWrap == FL_TRANSLIBMOD),
        !,
	FLLIBUNIVEQFORM(FLLIBMODLIT(LibModWrap,X,Mod1,Caller1),FLLIBMODLIT(LibModWrap,Y,Mod2,Caller2)),
	FLLIBUNIVEQFORM(FLLIBMODLIT(LibModWrap,XX,Mod1,Caller1),FLLIBMODLIT(LibModWrap,YY,Mod2,Caller2)).


%% FL_NEGLIBMOD - change ; to , and vice versa
FLLIBUNIVEQFORM(FLLIBMODLIT(FL_NEGLIBMOD,(X,XX),Mod,Caller),(Y;YY)) :-
        !,
	FLLIBUNIVEQFORM(FLLIBMODLIT(FL_NEGLIBMOD,X,Mod,Caller),Y),
	FLLIBUNIVEQFORM(FLLIBMODLIT(FL_NEGLIBMOD,XX,Mod,Caller),YY).

FLLIBUNIVEQFORM(FLLIBMODLIT(FL_NEGLIBMOD,(X;XX),Mod,Caller),(Y,YY)) :-
        !,
	FLLIBUNIVEQFORM(FLLIBMODLIT(FL_NEGLIBMOD,X,Mod,Caller),Y),
	FLLIBUNIVEQFORM(FLLIBMODLIT(FL_NEGLIBMOD,XX,Mod,Caller),YY).

FLLIBUNIVEQFORM((Y,YY),FLLIBMODLIT(FL_NEGLIBMOD,(X;XX),Mod,Caller)) :-
        !,
	FLLIBUNIVEQFORM(FLLIBMODLIT(FL_NEGLIBMOD,X,Mod,Caller),Y),
	FLLIBUNIVEQFORM(FLLIBMODLIT(FL_NEGLIBMOD,XX,Mod,Caller),YY).

FLLIBUNIVEQFORM((Y;YY),FLLIBMODLIT(FL_NEGLIBMOD,(X,XX),Mod,Caller)) :-
        !,
	FLLIBUNIVEQFORM(FLLIBMODLIT(FL_NEGLIBMOD,X,Mod,Caller),Y),
	FLLIBUNIVEQFORM(FLLIBMODLIT(FL_NEGLIBMOD,XX,Mod,Caller),YY).

FLLIBUNIVEQFORM(FLLIBMODLIT(FL_NEGLIBMOD,(X,XX),Mod1,Caller1),FLLIBMODLIT(FL_NEGLIBMOD,(Y;YY),Mod2,Caller2)) :-
        !,
	FLLIBUNIVEQFORM(FLLIBMODLIT(FL_NEGLIBMOD,X,Mod1,Caller1),FLLIBMODLIT(FL_NEGLIBMOD,Y,Mod2,Caller2)),
	FLLIBUNIVEQFORM(FLLIBMODLIT(FL_NEGLIBMOD,XX,Mod1,Caller1),FLLIBMODLIT(FL_NEGLIBMOD,YY,Mod2,Caller2)).

FLLIBUNIVEQFORM(FLLIBMODLIT(FL_NEGLIBMOD,(X;XX),Mod1,Caller1),FLLIBMODLIT(FL_NEGLIBMOD,(Y,YY),Mod2,Caller2)) :-
        !,
	FLLIBUNIVEQFORM(FLLIBMODLIT(FL_NEGLIBMOD,X,Mod1,Caller1),FLLIBMODLIT(FL_NEGLIBMOD,Y,Mod2,Caller2)),
	FLLIBUNIVEQFORM(FLLIBMODLIT(FL_NEGLIBMOD,XX,Mod1,Caller1),FLLIBMODLIT(FL_NEGLIBMOD,YY,Mod2,Caller2)).


%% Speed up the case of  nonvar1@Var1 ~ nonvar2@Var2
FLLIBUNIVEQFORM(FLLIBMODLIT(WrapX,X,MX,_Caller1),FLLIBMODLIT(WrapY,Y,MY,_Caller2)) :-
	WrapX \== FL_LIBMOD, WrapX \== FL_NEGLIBMOD, WrapX \== FL_TRANSLIBMOD,
	WrapY \== FL_LIBMOD, WrapY \== FL_NEGLIBMOD, WrapY \== FL_TRANSLIBMOD,
        !,
	WrapX = WrapY,
        univeqform_list(X,Y),
	MX=MY.

%% lists of formulas. Note: [a,b] ~ [A,B] fails because [] means flload
%% when reified
FLLIBUNIVEQFORM([],[]).
FLLIBUNIVEQFORM([H1|T1],[H2|T2]) :-
	!,
	FLLIBUNIVEQFORM(H1,H2),
	FLLIBUNIVEQFORM(T1,T2).


%% Speed up the case of nonvar1@nonvarmod1 ~ nonvar2@nonvarmod2
FLLIBUNIVEQFORM(X,Y) :-
	X \= FLLIBMODLIT(_,_,_,_),
	Y \= FLLIBMODLIT(_,_,_,_),
	!,
        ( is_flora_callable_literal(X) ->
            convert_to_body_literal(X,BX),
            convert_to_body_literal(Y,BY),
            flora_generalize_last(BX,GX),
            flora_generalize_last(BY,GY)
        ;
            GX = X,
            GY = Y
        ),
        GX =.. XList,
        GY =.. YList,
        univeqform_list(XList,YList).

%% Common (expensive) case
FLLIBUNIVEQFORM(X,Y) :-
        flora_check_dynmod_type_consistency(X),
        flora_check_dynmod_type_consistency(Y),
	get_canonical_form(X,FLCANON(Wrap1,Args1,Mod1,Callable1,TableFlag1)),
	get_canonical_form(Y,FLCANON(Wrap2,Args2,Mod2,Callable2,TableFlag2)),
	(TableFlag1 == TableFlag2
	; TableFlag1 == FL_TABLED, var(Args1),  % X was ?Var@Mod
	    negate_predicate_type(TableFlag1,TableFlag2)
	; TableFlag2 == FL_TABLED, var(Args2), % Y was ?Var@Mod
	    negate_predicate_type(TableFlag1,TableFlag2)
	),
        ( Mod1==FL_INVALIDMODULE ->
            ( Mod2==FL_INVALIDMODULE -> true; Mod=Mod2)
        ;
            ( Mod2==FL_INVALIDMODULE -> Mod=Mod1; Mod=Mod1,Mod=Mod2)
        ),
        (nonvar(Args1),nonvar(Args2)
	-> univeqform_list(Args1,Args2)
	;
	    Args1=Args2
	),
        (nonvar(Args1)
	-> compare_wrappers(Wrap1,Wrap2)
	;
	    true
	),
	( var(Callable1),nonvar(Wrap1),nonvar(Args1),nonvar(Mod)
	-> flora_module_predicate(Wrap1,Args1,Mod,Callable1)
	;
	    true
	),
	( var(Callable2),nonvar(Wrap2),nonvar(Args1),nonvar(Mod)
	->
	    flora_module_predicate(Wrap2,Args1,Mod,Callable2)
	;
	    true
	),
	convert_to_body_literal(Callable1,Callable),
	convert_to_body_literal(Callable2,Callable),
	( var(Callable), nonvar(Wrap1), nonvar(Args1)
	%% Cases like a(X)@M ~ Y@Z where module stays unbound
	-> Callable = FLLIBMODLIT(Wrap1,Args1,Mod,_Caller)
	;  var(Callable), nonvar(Wrap2), nonvar(Args1)
	%% Cases like Y@Z ~ a(X)@M where module stays unbound
	-> Callable = FLLIBMODLIT(Wrap2,Args1,Mod,_Caller)
	;  true
	).

univeqform_list([],[]) :- !.
univeqform_list([H1|L1], [H2|L2]) :-
        FLLIBUNIVEQFORM(H1,H2),
        univeqform_list(L1,L2).

/******************************************************************************
  FLLIBMETAUNIV(?X,?Y)
  The meta predicate =..
******************************************************************************/
FLLIBMETAUNIV(X,Y) :-
	nonvar(X),
	!,
	flora_decode_predicate(X,PredType,WS,FullWrapper,_Prefix,BaseWrap,Args),
	( PredType == (prolog)
	-> (FullWrapper==WRAP_HILOG %% HiLog term
	   -> Args = [HiLogFunctor|FunctorArgs], Y = [WRAP_HILOG(hilog,HiLogFunctor)|FunctorArgs]
	   ; logical_operator(FullWrapper,FL_HYPOTHETICAL) ->
	       Args = [HypoOp|Goal], Y = [WRAP_HILOG(FL_HYPOTHETICAL,HypoOp)|Goal]
	   ; logical_operator(FullWrapper,OpWrap,Op) ->
	       Y = [WRAP_HILOG(OpWrap,Op)|Args]
	   %% libraries like insert
	   ; fllib_wrapper(FullWrapper) -> fail
	   %% Aggregates look like (fllibavg(...), ...)
	   ; Args=[Head|_], nonvar(Head), Head=..[Library|_],
	       fllib_wrapper(Library)
	   -> fail
	   ; Y = [BaseWrap|Args]
	   )
	;
	    PredType == (hilog)
	->
	    flrtrim_last(Args,ArgsTrimmed),
	    ArgsTrimmed = [HiLogPredName|PredArgs],
	    (BaseWrap==WRAP_TABLED_HILOG
	    %% The two WRAP_HILOG's here are used to create HiLog terms
	    -> Y = [WRAP_HILOG(hilog,HiLogPredName,WS)|PredArgs]
	    ;  Y = [WRAP_HILOG('%hilog',HiLogPredName,WS)|PredArgs]
	    )

	;
	    PredType == (neg_hilog)
	->
	    flrtrim_last(Args,ArgsTrimmed),
	    ArgsTrimmed = [HiLogPredName|PredArgs],
	    (BaseWrap==WRAP_TABLED_HILOG
	    %% The two WRAP_HILOG's here are used to create HiLog terms
	    -> Y = [WRAP_HILOG(neg_hilog,HiLogPredName,WS)|PredArgs]
	    %% Currently we do not negate transactional HiLog, so the case
	    %% below is impossible
	    ;  Y = [WRAP_HILOG('%hilog',HiLogPredName,WS)|PredArgs]
	    )

	;
	    PredType == (flogic)
	->
	    flrtrim_last(Args,ArgsTrimmed),
	    %% convert wrapper names to arrows
	    flogic_wrapper(BaseWrap,FlogicSymbol,_),
	    Y = [WRAP_HILOG(flogic,FlogicSymbol,WS)|ArgsTrimmed] 

	;
	    PredType == (neg_flogic)
	->
	    flrtrim_last(Args,ArgsTrimmed),
	    %% convert wrapper names to arrows
	    flogic_wrapper(BaseWrap,FlogicSymbol,_),
	    Y = [WRAP_HILOG(neg_flogic,FlogicSymbol,WS)|ArgsTrimmed] 
	),
	!.

FLLIBMETAUNIV(X,Y) :-
	is_list(Y),
	Y = [Head|Args],
	(atom(Head)
	-> X =.. Y
	;
	    Head = WRAP_HILOG(hilog,FunctName) %% HiLog term
	->
	    X =.. [WRAP_HILOG,FunctName|Args]
	;   %% Tabled hilog pred (note: hilog -- not %hilog)
	    Head = WRAP_HILOG(hilog,BaseWrap,WS)
	->
	    flora_add_last(Args,AugmentedArgs,[WS,_]),
	    flora_module_predicate(FLBodyPREFIX(WRAP_TABLED_HILOG),[BaseWrap|AugmentedArgs],WS,X)
	;   %% Tabled neg_hilog pred (note: neghilog -- not hilog)
	    Head = WRAP_HILOG(FLNEGPREFIX(hilog),BaseWrap,WS)
	->
	    flora_add_last(Args,AugmentedArgs,[WS,_]),
	    flora_module_predicate(FLNEGBodyPREFIX(WRAP_TABLED_HILOG),[BaseWrap|AugmentedArgs],WS,X)
	;   %% Nontabled hilog pred (note: %hilog -- not hilog)
	    Head = WRAP_HILOG('%hilog',BaseWrap,WS)
	->
	    flora_add_last(Args,AugmentedArgs,[WS,_]),
	    flora_module_predicate(FLBodyPREFIX(WRAP_HILOG),[BaseWrap|AugmentedArgs],WS,X)
	;
	    Head = WRAP_HILOG('%hilog',BaseWrap)
	->
	    flora_decode_goal_as_atom(X,Xdecoded),
	    flora_decode_goal_as_atom(Y,Ydecoded),
	    flora_abort([Xdecoded,'=..',Ydecoded,
			 ' :  wrong syntax on the right side of =..'])
	;
	    Head = WRAP_HILOG(flogic,FlogicSymbol,WS)
	->
	    flogic_wrapper(FullWrapper,FlogicSymbol,ArgNo),
	    (length(Args,ArgNo) -> true
	    ;
		flora_decode_goal_as_atom(X,Xdecoded),
		flora_decode_goal_as_atom(Y,Ydecoded),
		flora_abort([Xdecoded,'=..',Ydecoded,
			     ' :  wrong number of components on the right side of =..'])
	    ),
	    flora_add_last(Args,AugmentedArgs,[WS,_]),
	    flora_module_predicate(FullWrapper,AugmentedArgs,WS,X)
	;
	    Head = WRAP_HILOG(FLNEGPREFIX(flogic),FlogicSymbol,WS)
	->
	    flogic_wrapper(FullWrapper,FlogicSymbol,ArgNo),
	    (length(Args,ArgNo) -> true
	    ;
		flora_decode_goal_as_atom(X,Xdecoded),
		flora_decode_goal_as_atom(Y,Ydecoded),
		flora_abort([Xdecoded,'=..',Ydecoded,
			     ' :  wrong number of components on the right side of =..'])
	    ),
	    flora_add_last(Args,AugmentedArgs,[WS,_]),
	    flrwrapper:negate_wrapper(FullWrapper,FullWrapperNeg),
	    flora_module_predicate(FullWrapperNeg,AugmentedArgs,WS,X)
	;
	    Head = WRAP_HILOG(FL_HYPOTHETICAL,Op)
	->
	    logical_operator(Library,FL_HYPOTHETICAL),
	    X =.. [Library,Op|Args]
	;
	    Head = WRAP_HILOG(FL_NEGATION,Op)
	->
	    logical_operator(Predicate,FL_NEGATION,Op),
	    X =.. [Predicate|Args]
	;
	    Head = WRAP_HILOG(flogic,_)
	->
	    flora_decode_goal_as_atom(X,Xdecoded),
	    flora_decode_goal_as_atom(Y,Ydecoded),
	    flora_abort([Xdecoded,'=..',Ydecoded,
			 ' :  wrong syntax on the right side of =..'])
	),
	!.

%% Currently, this predicate fails for most of the wrong syntax


%% Arguments: Flogic wrapper, visual symbol, #of required arguments
flogic_wrapper(WRAP_MVD, '->', 3).
flogic_wrapper(WRAP_IMVD, '*->', 3).
flogic_wrapper(WRAP_MVDSIG, '=>', 3).
flogic_wrapper(WRAP_IMVDSIG, '*=>', 3).
flogic_wrapper(WRAP_MVDCONDEF, '{:}', 4).
flogic_wrapper(WRAP_IMVDCONDEF, '{:}*', 4).
flogic_wrapper(WRAP_MVDINC, '+>', 3).
flogic_wrapper(WRAP_IMVDINC, '*+>', 3).
flogic_wrapper(WRAP_MVDTOLIST, '->->', 3).
flogic_wrapper(WRAP_IMVDTOLIST, '*->->', 3).
flogic_wrapper(WRAP_ISA, ':', 2).
flogic_wrapper(WRAP_SUB, '::', 2).
flogic_wrapper(WRAP_METH, 'boolean', 2).
flogic_wrapper(WRAP_IMETH, '*boolean', 2).
flogic_wrapper(WRAP_TRAN, '%boolean', 2).
flogic_wrapper(WRAP_BOOLSIG, '=>boolean', 2).
flogic_wrapper(WRAP_IBOOLSIG, '*=>boolean', 2).
flogic_wrapper(WRAP_TRANSIG, '=>%boolean', 2).
flogic_wrapper(WRAP_ITRANSIG, '*=>%boolean', 2).
%% These still have not been worked out for =..
flogic_wrapper(WRAP_OBJEQL, ':=:', 2).
flogic_wrapper(WRAP_EXISTS, '[]', 1).

%% used to skip internal libraries in decomposition of prolog terms
%% =.. simply fails on such libraries
fllib_wrapper(FLLIBINSERT).
fllib_wrapper(FLLIBINSERTALL).
fllib_wrapper(FLLIBDELETE).
fllib_wrapper(FLLIBDELETEALL).
fllib_wrapper(FLLIBERASE).
fllib_wrapper(FLLIBERASEALL).
fllib_wrapper(FLLIBBTINSERT).
fllib_wrapper(FLLIBBTDELETEALL).
fllib_wrapper(FLLIBBTDELETEALL).
fllib_wrapper(FLLIBBTERASE).
fllib_wrapper(FLLIBBTERASEALL).

fllib_wrapper(FLLIBREFRESH).
fllib_wrapper(FLLIBINSERTRULE_A).
fllib_wrapper(FLLIBINSERTRULE_Z).
fllib_wrapper(FLLIBDELETERULE_A).
fllib_wrapper(FLLIBDELETERULE_Z).
fllib_wrapper(FLLIBDELETERULE).

fllib_wrapper(FLLIBNEWMODULE).
fllib_wrapper(FLLIBERASEMODULE).
fllib_wrapper(FLLIBCLAUSE).
fllib_wrapper(FLLIBNEWOID).
fllib_wrapper(FLLIBCATCH).
fllib_wrapper(FLLIBTHROW).

fllib_wrapper(FLLIBIFTHENELSE).
fllib_wrapper(FLLIBIFTHEN).
fllib_wrapper(FLLIBUNLESSDO).
fllib_wrapper(FLLIBWHILEDO).
fllib_wrapper(FLLIBDOUNTIL).
fllib_wrapper(FLLIBWHILELOOP).
fllib_wrapper(FLLIBLOOPUNTIL).

fllib_wrapper(FLLIBAVG).
fllib_wrapper(FLLIBSUM).
fllib_wrapper(FLLIBMAX).
fllib_wrapper(FLLIBMIN).
fllib_wrapper(FLLIBCOUNT).

logical_operator(FLORA_TNOT_PREDICATE, FL_NEGATION, FL_NOT).
logical_operator(FL_NAF, FL_NEGATION, FL_NAF).
logical_operator(FLLIBHYPOTHETICAL, FL_HYPOTHETICAL).

compare_wrappers(Wrap1,Wrap2) :- Wrap1 = Wrap2, !.
compare_wrappers(Wrap1,Wrap2) :-
	(Wrap1 == WRAP_NONTABLED_HILOG -> Wrap1new = FLBodyPREFIX(WRAP_NONTABLED_HILOG)
	; Wrap1 == WRAP_TABLED_HILOG -> Wrap1new = FLBodyPREFIX(WRAP_TABLED_HILOG)
	; Wrap1new = Wrap1
	),
	(Wrap2 == WRAP_NONTABLED_HILOG -> Wrap2new = FLBodyPREFIX(WRAP_NONTABLED_HILOG)
	; Wrap2 == WRAP_TABLED_HILOG -> Wrap2new = FLBodyPREFIX(WRAP_TABLED_HILOG)
	; Wrap2new = Wrap2
	),
	Wrap1new = Wrap2new,
	!.
	

negate_predicate_type(FL_TABLED,FL_TABLED_NEG).
negate_predicate_type(FL_TABLED_NEG,FL_TABLED).
negate_predicate_type(FL_NOTTABLED,FL_NOTTABLED).
