/* File:        flranswer.P
**
** Author(s): Guizhen Yang
**            Michael Kifer 
**
** Contact:   kifer@cs.stonybrook.edu
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2009.
**      and Vulcan, Inc., 2008-2009.
**
** All rights reserved.
**
** For information about licensing terms, please see
** http://silk.projects.semwebcentral.org/flora2-license.html
**
**
*/


:- compiler_options([xpp_on]).

#include "char_defs.h"
#include "standard.h"
#include "flora_terms.flh"

/* Request number of getting the delay register */
#define DELAY_REG  2


:- import cputime/1 from standard.

:- import windows_os/0 from xsb_configuration.

:- import length/2 from basics.

:- import
	close_open_tables/0,
	xwam_state/2
   from machine.

:- import shell/5 from shell.

:- import flora_builtin_datatype/1 from flrdatatype.

%%:- import flora_abolish_table_predicate/1 from flrtables.

:- import
	flora_stdfdbk_string/2,
	flora_stdfdbk_string/1,
	flora_stdfdbk_nl/0,
	flora_stdfdbk_line/1
   from flrprint.

:- import flora_call_hooks/5 from flrhooks.

:- import flora_commit_storage/0, flora_reclaim_storage_space/0 from flrutils.

:- import flora_display_feedback/1 from flrdisplay.

:- import
	flora_handle_trace/0,
	flora_handle_notrace/0,
	flora_switch/1
   from flrdebugger.



/********************************************************************/
fllibshellans(Gs,NVs) :-
	flora_switch(all),
	!,
	flora_print_all(Gs,NVs).

fllibshellans(Gs,NVs) :-
	flora_print_one(Gs,NVs).


/********************************************************************/
fllibprogramans(Gs,NVs) :-
	flora_print_all(Gs,NVs).
/* The business of getting just one answer from a program query 
 * needs to be rethought. */
/*
	flora_switch(all),
	!,
	flora_print_all(Gs,NVs).

fllibprogramans(Gs,NVs) :-
	flora_print_one(Gs,NVs).
*/


/********************************************************************
  NVs is a list of output variables
  Gs is a list of goals to evaluate
********************************************************************/
flora_print_all(Gs,NVs) :-
	NVs == [],
	!,
	cputime(T0),
	( flora_call(Gs),
	    close_open_tables
	->
	    (
	      xwam_state(DELAY_REG,RegVal),
	      cputime(T1),
	      T is T1-T0,
	      ( flora_switch(chatter) ->
		  flora_stdfdbk_string('~nElapsed time ~w seconds~n', [T])
	      ; true
	      ),
	      flora_write_Yes_or_Unknown(RegVal)
	    ),
	    fail
	;
	    flora_write_No
	).

flora_print_all(Gs,NVs) :-
	cputime(T0),
	%% Construct a temporary trie-indexed predicate, FL_QUERY_PREDICATE
	%% All answers are asserted into that predicate.
	%% Since it is trie-indexed, duplicates are deleted.
	%% Reason: some answer lists might have thousands and
	%% millions of items, which takes a long time to sort. Sometimes
	%% sort runs out of memory and crashes XSB. 
	%% Having a trie-asserted query predicate adds a very small
	%% penalty to each query, but overall speeds up 
	%% returning the answers, and sometimes avoids crashes.
	QueryTemplate =.. [FL_QUERY_PREDICATE|NVs],
	length(NVs,QueryArity),
	dynamic(FL_QUERY_PREDICATE/QueryArity),
	index(FL_QUERY_PREDICATE/QueryArity,trie),
	
	flora_call_hooks(_Mod,QUERYHOOK,QueryTemplate,before,AroundHookLink),
	catch(
	      flora_findall((NVs,RegVal),
		      (flora_call(Gs),
			  (\+ QueryTemplate -> assert(QueryTemplate)),
			  xwam_state(DELAY_REG,RegVal)
		      ),
		      TempL
		     ),
	      Exception,
	      flranswer_all_answers_query_handler(Exception,QueryTemplate,AroundHookLink)
	     ),
	cputime(T1),
	T is T1-T0,
	flora_call_hooks(_Mod,QUERYHOOK,QueryTemplate,after,AroundHookLink),
	flora_reclaim_storage_space,
	abolish(FL_QUERY_PREDICATE/QueryArity),
	sort(TempL,L),
	length(L,N),
	( N == 0 -> flora_write_No, fail
	;
	    flora_write_matches(L),
	    ( flora_switch(chatter) ->
		flora_stdfdbk_string('~n~w solution(s) in ~w seconds~n', [N,T])
	    ;
		true
	    ),
	    flora_write_Yes,
	    !,
	    fail
	).


/********************************************************************/
flora_print_one(Gs,NVs) :-
	NVs == [],
	!,
	(flora_call(Gs)
	->
	    xwam_state(DELAY_REG,RegVal),
	    flora_write_Yes_or_Unknown(RegVal)
	;
	    flora_write_No
	).
flora_print_one(Gs,NVs) :-
	    ( flora_call(Gs),
		xwam_state(DELAY_REG,RegVal),
		flora_write_pairs(NVs,RegVal),
		flora_fail_unless_return
	    ;
		flora_write_No
	    ),
	    flora_reclaim_storage_space.


/********************************************************************/
/*
flora_if_then_else(Condition,Then,_Else) :-
	call(Condition),
	call(Then).

flora_if_then_else(_Condition,_Then,Else) :-
	call(Else).
*/


/********************************************************************/
%% If the user types RETURN, then succeed. Otherwise, assume the user wants
%% more answers, so fail in order to provide another answer.
flora_fail_unless_return :- 
	get0(C),
	(C =:= CH_NEWLINE; C =:= CH_EOF_P), !,
	flora_write_Yes.
flora_fail_unless_return :- flora_fail_unless_return, fail.


/********************************************************************/
flora_write_Yes :- flora_stdfdbk_line('~nYes~n').
flora_write_No  :- flora_stdfdbk_line('~nNo~n').
flora_write_Yes_or_Unknown(DelayRegVal) :-
	(DelayRegVal =:= 0 -> flora_stdfdbk_line('~nYes~n')
	; flora_stdfdbk_line('~nYes  - unknown~n')
	).


/********************************************************************/
%% Hookup to the Flora debugger
%% flora_call is a wrapper around XSB call
%% Used only in top-level queries
flora_call(Goal) :- 
    	flora_handle_trace,
    	call(Goal),
	flora_commit_storage,
	flora_handle_end_of_call.

flora_call(_Goal) :-
	flora_handle_notrace,
	fail.


/********************************************************************/
flora_write_matches([]).

flora_write_matches([(M,DelayRegVal)|Ms]) :-
	flora_write_pairs(M,DelayRegVal),
	flora_stdfdbk_nl,
	flora_write_matches(Ms).


flora_write_pairs([],_).

flora_write_pairs([N=V|NVs],DelayRegVal) :-
	flora_stdfdbk_nl,
	flora_stdfdbk_string('~w = ',[N]),
	flora_display_feedback(V),
	flora_write_if_undefined(DelayRegVal),
	flora_write_pairs(NVs,DelayRegVal).

flora_write_if_undefined(DelayRegVal) :-
	(DelayRegVal =:= 0 -> true
	; flora_stdfdbk_string('  - unknown')
	).


/********************************************************************/
%% This turns off trace, so that flora internal stuff done after a
%% subgoal call won''t be traced. However, on backtracking, this turns
%% trace on and fails, thereby allowing to backtrack over the previous
%% subgoal.
flora_handle_end_of_call :- flora_handle_notrace.
flora_handle_end_of_call :- flora_handle_trace, fail.

/********************************************************************/

/********************************************************************
    filters to get rid of some classes
********************************************************************/

flora_noncomposite_class(C) :-
	C \= (_;C1), var(C1), C \= (C2;_), var(C2),
	C \= (_,C3), var(C3), C \= (C4,_), var(C4),
	C \= (_ - C5), var(C5), C \= (C6 - _), var(C6).

flora_nonbuiltin_class(C) :- \+flora_builtin_datatype(C).


%% clean up after query, if error
flranswer_all_answers_query_handler(Exception,QueryTemplate,AroundHookLink) :-
	flora_call_hooks(_Mod,QUERYHOOK,QueryTemplate,after,AroundHookLink),
	flora_reclaim_storage_space,
	%%retractall(QueryTemplate),
	abolish(QueryTemplate),
	throw(Exception).


%% to silence the tracer
flora_findall(X,Y,Z) :- findall(X,Y,Z).
