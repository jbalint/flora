/* File:      flrclause.P
**
** Author(s): Chang Zhao
**
** Contact:   kifer@cs.stonybrook.edu
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2009;
**      and Vulcan, Inc., 2008-2009.
**
** All rights reserved.
**
** For information about licensing terms, please see
** http://silk.projects.semwebcentral.org/flora2-license.html
**
**
*/


:- compiler_options([xpp_on]).

#include "flora_terms.flh"
#include "flora_exceptions.flh"


:- import
	reverse/2,
	append/3,
	copy_term/2
   from basics.

:- import
        matching_rule_signature/6,
        flora_build_pred_signature/2,
        flora_preprocess_headlist/2
   from flrcanon.
:- import
	flora_decode_predicate/6
   from flrwrapper.

:- import
        flora_warning_line/2
   from flrprint.

:- import flora_record_rule_signature/9 from flrcanon.


/**********************************************************************
 flora_clause_prefix(+Mode,-Prefix)
************************************************************************/ 
flora_clause_prefix(NULL,          _Prefix).
flora_clause_prefix(STATIC_CLAUSE, FL_HEADPREFIX).
flora_clause_prefix(STATIC_CLAUSE, FL_NEGHEADPREFIX).
flora_clause_prefix(DYNA_CLAUSE,   FL_DYNAPREFIX).
flora_clause_prefix(DYNA_CLAUSE,   FL_NEGDYNAPREFIX).
flora_clause_prefix(DYNZ_CLAUSE,   FL_DYNZPREFIX).
flora_clause_prefix(DYNZ_CLAUSE,   FL_NEGDYNZPREFIX).
flora_clause_prefix(DYNAMIC_CLAUSE,FL_DYNAPREFIX).
flora_clause_prefix(DYNAMIC_CLAUSE,FL_DYNZPREFIX).
flora_clause_prefix(DYNAMIC_CLAUSE,FL_NEGDYNAPREFIX).
flora_clause_prefix(DYNAMIC_CLAUSE,FL_NEGDYNZPREFIX).


/***********************************************************************
 FLLIBCLAUSE(+Tag,+Meta,+Mode,+HeadList,?RuleBody)
 Mode: STATIC_CLAUSE, DYNA_CLAUSE, DYNZ_CLAUSE, DYNAMIC_CLAUSE
************************************************************************/ 
FLLIBCLAUSE(Tag,Meta,Mode,HeadList,Body) :-
	construct_meta_term(Meta,NewMeta),
	construct_id_term(Tag,NewTag),
        fllibclause_exec(NewTag,NewMeta,Mode,HeadList,Body).

fllibclause_exec(Tag,Meta,Mode,[Head],Body) :-
        !,
        flora_clause_prefix(Mode,Prefix),
        matching_rule_signature(Tag,Prefix,Head,Body,Meta,_RuleSig).

fllibclause_exec(Tag,Meta,Mode,[H|L],Body) :-
        flora_clause_prefix(Mode,Prefix),
        matching_rule_signature(Tag,Prefix,H,Body,Meta,_RuleSig),
        flora_clause_list(Tag,Meta,Prefix,L,Body). 

flora_clause_list(_Tag,_Meta,_Prefix,[],_Body) :- 
        !.

flora_clause_list(Tag,Meta,Prefix,[H|L],Body) :-
        matching_rule_signature(Tag,Prefix,H,Body,Meta,_RuleSig),
        flora_clause_list(Tag,Meta,Prefix,L,Body). 

construct_meta_term(Meta,NewMeta) :-
	(Meta == NULL -> NewMeta = _NewVar
	; Meta = [MVar], var(MVar) -> NewMeta = MVar
	; reverse(Meta,[Last|PrefR]),
	    (var(Last) -> reverse(PrefR,Pref), append(Pref,Last,NewMeta)
	    ; append(Meta,_,NewMeta)
	    )
	).

construct_id_term(Tag,NewTag) :-
	(Tag == NULL -> NewTag = _NewVar
	; NewTag = Tag
	).

        
/***********************************************************************
 FLLIBINSRULESIG(+WS,+HeadList,+RuleBody,+Meta,+DefeatCond,+NewPred)
************************************************************************/ 
FLLIBINSRULESIG(Tag,WS,HeadList,Body,Meta,DefeatCond,NewPred) :-
        %% multiple atoms appear in the rule head
        is_list(HeadList),
        !,
        BridgeRule =.. [FL_IMPLYOP,NewPred,Body],
	%% This copy-term speeds up unification with rule signatures for
	%% multi-headed rules. This is because the variables in Head/Body
	%% would be different from the variables in the head/bridge rules.
	copy_term(BridgeRule,BridgeRule1),
        flora_insrulesig_list(Tag,WS,HeadList,Body,Meta,DefeatCond,NewPred,BridgeRule1).

FLLIBINSRULESIG(Tag,WS,Head,Body,Meta,DefeatCond,_NewPred) :-
        %% only a single atom appears in the rule head
	flora_decode_predicate(Head,Type,_,_,_,_),
	((Type == (hilog) ; Type == (flogic)) -> HeadPrefix = FL_HEADPREFIX
	; Type == (flora) -> HeadPrefix = FL_EMPTYPREFIX
	; Type == neg_flora -> HeadPrefix = FL_NEGPREFIX
	; HeadPrefix = FL_NEGHEADPREFIX
	),
        flora_record_rule_signature(Tag,HeadPrefix,WS,Head,Body,Meta,DefeatCond,[],[]).
        

/****************************************************************************
    BridgeRules:
      A multiheaded rule like  p,q :- r is represented as
	     p :- newpredicateXYZ.
	     q :- newpredicateXYZ.
	     newpredicateXYZ :- r.
      The last rule is called the bridge rule.
****************************************************************************/
flora_insrulesig_list(_Tag,_WS,[],_Body,_Meta,_DefeatCond,_NewPred,_BridgeRule) :- !.
flora_insrulesig_list(Tag,WS,[Head|RestH],Body,Meta,DefeatCond,NewPred,BridgeRule) :- 
	flora_decode_predicate(Head,Type,_,_,_,_),
	((Type == (hilog) ; Type == (flogic)) -> HeadPrefix = FL_HEADPREFIX
	; Type == (flora) -> HeadPrefix = FL_EMPTYPREFIX
	; Type == neg_flora -> HeadPrefix = FL_NEGPREFIX
	; HeadPrefix = FL_NEGHEADPREFIX
	),
	HeadRule =.. [FL_IMPLYOP,Head,NewPred],
	%% This copy-term speeds up unification with rule signatures for
	%% multi-headed rules. This is because the variables in Head/Body
	%% would be different from the variables in the head/bridge rules.
	copy_term(HeadRule,HeadRule1),
	copy_term(DefeatCond,DefeatCond1),
        flora_record_rule_signature(Tag,HeadPrefix,WS,Head,Body,Meta,DefeatCond1,[HeadRule1],[BridgeRule]),
        flora_insrulesig_list(Tag,WS,RestH,Body,Meta,DefeatCond,NewPred,BridgeRule).
