
#include "flora_terms.flh"
#include "flora_porting.flh"
#include "atco.flh"

?- Method[%mustDefine(on)]@_system.

:- symbol_context
        prlg beaten_by_strict_rule(?,?,?,?,?).

:- table FL_CANDIDATE/3, FL_STRICT_CANDIDATE/3.
:- prolog FL_UNDEFEATED/4.
:- prolog FL_REFUTED/3.
:- prolog strongcandicate/3.

:- prolog
        naf_literal/2,
	stronglit/1,
	headlit/3.
:- prolog
	defeated_rule/3,
	defeated_lit/2,
	stronglydefeated_lit/2,
	overriden_cancellation_rule/3,
	beaten_by_strict_rule/3,
	beaten_by_strict_rule/5,
	disqualified_rule/3,
	disqualified_lit/2,
	not_disqualified_rule/3,
	opposing_rules/5.
:- prolog
        supportedargument/3,
	hassupportedargument/2,
	attemptedsupportedargument/3.
:- prolog
        dominates_lit_lit/3,
        dominates_lit_rule/4,
	dominates_rule_lit/4,
	atco_overrides/5,
    	beats_lit_rule/4,
	beats_lit_lit/3.
:- prolog
	exists_cand_not_overridden/4,
	no_refutable_bodylits/3,
	not_beats_supported_argument/3.


FL_UNDEFEATED(?r,?_vars,?_h,?mod) :-
	is_strict_rule(?r,?mod)@_prolog(flrdescriptor_support),
	!.
// we may have to pass variables ?vars down: heads might not be enough
// since ?vars may include body vars
FL_UNDEFEATED(?r,?_vars,?h,?mod) :-
	naf defeated_rule(?r,?h,?mod),
	naf defeated_lit(?h,?mod).

defeated_rule(?r,?h,?mod) :-
	FL_REFUTED(?r,?h,?mod).
defeated_rule(?r,?h,?mod) :-
	disqualified_rule(?r,?h,?mod).

defeated_lit(?h,?mod) :-
	FL_REFUTED(?_r,?h,?mod).
defeated_lit(?h,?mod) :-
	disqualified_lit(?h,?mod).

FL_REFUTED(?r,?h,?mod) :-
	FL_CANDIDATE(?r,?h,?mod),
	opposing_rules(?r,?h,?r2,?h2,?mod),
	supportedargument(?r2,?h2,?mod),
	naf beats_lit_rule(?h,?r2,?h2,?mod).

disqualified_rule(?r,?h,?mod) :- beaten_by_strict_rule(?r,?h,?mod).
disqualified_rule(?r,?h,?mod) :-
	get_tag_descriptor_info(?r,?mod,?t,?)@_prolog(flrdescriptor_support),
	FL_CANCEL_AUX(?mod,?t,?h).
// FL_OVERRIDEN_CANCELLATION expresses interaction  of defeat and cancellation:
// Cancellation rule is disqualified if the rule being canceled has higher
// priority than the cancellation rule itself.
// FL_OVERRIDEN_CANCELLATION/3 is defined in genincludes/flrdefeasible.fli
disqualified_rule(?r,?h,?mod) :-
	overriden_cancellation_rule(?r,?h,?mod).

// This differs from FL_OVERRIDEN_CANCELLATION/3: it uses rule id instead of tag
overriden_cancellation_rule(?r,?h,?mod) :-
	get_tag_descriptor_info(?r,?mod,?t,?)@_prolog(flrdescriptor_support),
	FL_OVERRIDEN_CANCELLATION(?t,?h,?mod).

disqualified_lit(?h,?mod) :-
	naf exist(?r)^not_disqualified_rule(?r,?h,?mod).
not_disqualified_rule(?r,?h,?mod) :-
	FL_CANDIDATE(?r,?h,?mod),
	naf disqualified_rule(?r,?h,?mod).



opposing_rules(?r1,?h1,?r2,?h2,?mod) :-
	get_tag_descriptor_info(?r1,?mod,?t1,?vars)@_prolog(flrdescriptor_support),
	get_tag_descriptor_info(?r2,?mod,?t2,?vars)@_prolog(flrdescriptor_support),
	FL_OPPOSES_AUX(?mod,?t1,?h1,?t2,?h2).

/*
    forall ?rq (cand(?rq,?q) ~~> exist ?rbi (cand(?rbi,?bi), overrid(?rbi,?rq)))
    ==
    naf exists ?rq (cand(?rq,?q),
                    naf exist ?rbi (cand(?rbi,?bi), overrid(?rbi,?rq)))
    ==
    naf exists ?rq (cand(?rq,?q), naf dominates(lit)(rule)(bi,rq)
*/
dominates_lit_lit(?lit1,?lit2,?mod) :-
	naf ((
	      FL_CANDIDATE(?r2,?lit2,?mod),
	      naf dominates_lit_rule(?lit1,?r2,?lit2,?mod)
	)).

// Note: in overriding we take into accounts heads also because tags can
// have variables and head-instantiations may also instantiate tags
// An instance of a literal might dominate only over an instance of a rule.
// This is why we take heads into account.
dominates_lit_rule(?q,?rh,?h,?mod) :- 
	FL_CANDIDATE(?rq,?q,?mod),
	atco_overrides(?rq,?q,?rh,?h,?mod).

dominates_rule_lit(?r,?h,?lit,?mod) :-
	naf exists_cand_not_overridden(?r,?h,?lit,?mod).
exists_cand_not_overridden(?r,?h,?lit,?mod) :-
	FL_CANDIDATE(?rlit,?lit,?mod),
	naf atco_overrides(?r,?h,?rlit,?lit,?mod).

/*
  FL_CANDIDATE is what Benjamin calls "attempted candidate.
  His cand/2 is our "strong candidate.
  This change is made for compatibility with other ATs.

  NOTE: I think strongcandicate/3 is unnecessary. This is why we have
  the EXPERIMENTAL option -- to see which version works better.
*/
FL_CANDIDATE(?r,?h,?mod) :-
	?modH = ?h@?mod,
	is_defeasible_rule(?r,?mod)@_prolog(flrdescriptor_support),
	show_rule_by_id(?r, ?mod, ?modH, ?body)@_plg(flrcanon),
	?body.

FL_STRICT_CANDIDATE(?r,?h,?mod) :-
	?modH = ?h@?mod,
	is_strict_rule(?r,?mod)@_prolog(flrdescriptor_support),
	show_rule_by_id(?r, ?mod, ?modH, ?body)@_plg(flrcanon),
	?body.

// not in Benjamin's
beaten_by_strict_rule(?r,?h,?mod) :- beaten_by_strict_rule(?r,?h,?,?,?mod).
beaten_by_strict_rule(?r,?h,?strictR,?strictH,?mod) :-
	FL_CANDIDATE(?r,?h,?mod),
	opposing_rules(?r,?h,?strictR,?strictH,?mod),
	FL_STRICT_CANDIDATE(?strictR,?strictH,?mod).


/*
  This is Benjamin's cand/2. His attemptedcand/2 is our FL_CANDIDATE/2.
*/
strongcandicate(?r,?h,?mod) :-
	FL_CANDIDATE(?r,?h,?mod)
#ifndef EXPERIMENTAL
        and
	// forall ?rp (cand(?rp,cancel(?rh)) ~~> overrid(?rh,?rp)) 
	naf overriden_cancellation_rule(?r,?h,?mod)
#endif
        .


beats_lit_rule(?q,?rh,?h,?mod) :-
	dominates_lit_rule(?q,?rh,?h,?mod),
	!.


beats_lit_rule(?q,?rh,?h,?mod) :-   
	// Format:  SILK_REFUTABLEBODYLIT(-ruleid,-head,_@,-bodylit)
	SILK_REFUTABLEBODYLIT(?rh,?h,?mod,?bi),
	beats_lit_lit(?q,?bi,?mod).

beats_lit_lit(?q,?bi,?mod) :- 
	stronglit(?bi),
	!,
	// forall ?rbi (supportedargument(?rbi,?bi)~~>beats(lit)(rule)(?q,?rbi))
	naf not_beats_supported_argument(?q,?bi,?mod).
// remove '...' arounf naf ?var once this is supported
beats_lit_lit(?q,'${naf ?bodylit}',?mod) :-  
	/*
	  beats_lit_lit(?q, naf ?bi,?mod) :-  
	      exist ?rbi ( headlit(?rbi,?bi),
			  forall ?bbi (refutablebodylit(?rbi, naf ?bbi) ~~> 
			       beats(lit)(lit)(?q,?bbi) ) ) ; 
	*/
	headlit(?rb,?bodylit,?mod),
	SILK_BODYINFO(?rb,${naf ?bodylit},?mod,
	              ?q,ATCO_BEATS_LIT_LIT,
	              ?_wholebody,?refutable_part),
	?refutable_bodypart.

// ?lit1 naf beats ?lit2 by not beating some rule ?r2 that supports ?lit2
not_beats_supported_argument(?lit1,?lit2,?mod) :-
	supportedargument(?r2,?lit2,?mod),
	naf beats_lit_rule(?lit1,?r2,?lit2,?mod).

supportedargument(?r,?h,?mod) :- 
	attemptedsupportedargument(?r,?h,?mod)
#ifndef EXPERIMENTAL
        and
	// forall ?rp (cand(?rp,cancel(?rh)) ~~> overrid(?rh,?rp)) 
	naf overriden_cancellation_rule(?r,?h,?mod)
#endif
        .

/*
      attemptedsupportedargument/3

  The first case is when there are no refutable body literals in the rule body.
  This is both optimization and also allows us to write FLORA-2 tests
  without explicitly specifying irrefutable literals when it is known
  that all bodylits are irrefutable.
*/
attemptedsupportedargument(?r,?h,?mod) :- 
	no_refutable_bodylits(?r,?h,?mod),
	!,
	FL_CANDIDATE(?r,?h,?mod).
attemptedsupportedargument(?r,?h,?mod) :- 
	headlit(?r,?h,?mod),
	SILK_BODYINFO(?r,?h,?mod,
	              ?,ATCO_ATTEMPTEDSUPPORTED_ARG,
	              ?bodyspec,?_refutable_part),
	?bodyspec.

hassupportedargument(?bodylit,?mod) :- 
	stronglit(?bodylit),
	!,
	supportedargument(?_r,?bodylit,?mod).

// remove '...' arounf naf ?var once this is supported
hassupportedargument('${naf ?lit}',?mod) :-  
	headlit(?r,?lit,?mod),
	SILK_REFUTABLEBODYLIT(?r,?lit,?mod,'${naf ?bodylit}'),
	hassupportedargument(?bodylit,?mod),
	naf stronglydefeated_lit(?bodylit,?mod).
/*
	naf hassupportthrurefutablenaflits_aux(?r,?bodylit).

  hassupportthrurefutablenaflits_aux(?rbi) :-  
	forall ?bbi (refutablebodylit(?rbi, naf ?bbi) ~~>
		     naf( hassupportedargument(?bbi) and 
			  naf stronglydefeated_lit(?bbi) ) ) 
  ie, naf exists ?bbi (refutablebodylit(?rbi, naf ?bbi),
                       hassupportedargument(?bbi),
                       naf stronglydefeated(?bbi))
*/


/*
      stronglydefeated_lit/2

  The first case is when there are no refutable body literals for the rule.
  This is both optimization and also allows us to write FLORA-2 tests
  without explicitly specifying irrefutable literals when it is known
  that all bodylits are irrefutable.
*/
stronglydefeated_lit(?q,?mod) :-
	FL_OPPOSES_AUX(?mod,?,?q,?,?opposer_q),
	no_refutable_bodylits(?r_op_q,?opposer_q,?mod),
	!,
	FL_CANDIDATE(?r_op_q,?opposer_q,?mod).
stronglydefeated_lit(?q,?mod) :-   
	FL_OPPOSES_AUX(?mod,?,?q,?,?opposer_q),
	headlit(?r_op_q,?opposer_q,?mod) and    
        // forall ?rcq ( cand(?rcq,?q) ~~> overrid(?r_op_q,?rcq) )
        // i.e., dominates(rule)(lit)(?rnq,?q)
        dominates_rule_lit(?r_op_q,?opposer_q,?q,?mod),
	SILK_BODYINFO(?r_op_q,?opposer_q,?mod,
	              ?q,ATCO_STRONGLYDEFEATED,
	              ?bodyspec,?_refutable_part),
	?bodyspec.


/***************************** Utilities *************************************/
atco_overrides(?r1,?h1,?r2,?h2,?mod) :-
	// need to intro user-level primitives to get the tags once
	// these APIs settle down
	get_tag_descriptor_info_with_rulehead(?r1,?mod,?t1,?h1,?_vars1)@_prolog(flrdescriptor_support),
	get_tag_descriptor_info(?r2,?mod,?t2,?h2,?_vars2)@_prolog(flrdescriptor_support),
	FL_OVERRIDES_AUX(?mod,?t1,?h1,?t2,?h2).


/*
  A NAF predicate is either
    flrdelaysupport : fllibdelayedliteral(default_negation,?,?,
            [flora_tnot(THIS_WORKSPACE(tabled_unnumber_call)(?Positive)),?,?])
    Can also use flora_tnot/2

    Or it can be just THIS_WORKSPACE(tabled_unnumber_call)(?Positive)
*/
naf_literal(FLDELAYSUPPORTMOD:FLLIBDELAYEDLITERAL(FL_DEFLTNEG,?,?,[?Negated,?,?]),?Positive) :-
	arg(1,?Negated,?NegWrapped),
	!,
	flrnegation:flora_unwrap_negation(?NegWrapped,?Positive).
naf_literal(?NegWrapped,?Positive) :-
	flrnegation:flora_unwrap_negation(?NegWrapped,?Positive).

stronglit(?lit) :- \+ naf_literal(?lit,?).


headlit(?r,?h,?mod) :- get_tag_descriptor_info_with_rulehead(?r,?mod,?,?h,?)@_prolog(flrdescriptor_support).


no_refutable_bodylits(?r,?h,?mod) :-
	headlit(?r,?h,?mod),
	naf SILK_REFUTABLEBODYLIT(?r,?h,?mod,?).


SILK_ATCO_REFUTABLE_WRAP(ATCO_ATTEMPTEDSUPPORTED_ARG,?_extern,?mod,?bodylit) :-
	hassupportedargument(?bodylit,?mod),
	naf stronglydefeated(?bodylit,?mod).
SILK_ATCO_REFUTABLE_WRAP(ATCO_STRONGLYDEFEATED,?extern_lit,?mod,?bodylit) :-
	dominates_lit_lit(?bodylit,?extern_lit,?mod).
SILK_ATCO_REFUTABLE_WRAP(ATCO_BEATS_LIT_LIT,?extern_lit,?mod,?bodylit) :-
	// remove '...' arounf naf ?var once this is supported
	beats_lit_lit(?extern_lit,'${naf ?bodylit}',?mod).
