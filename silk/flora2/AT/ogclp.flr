/* File:      ogclp.flr
**
** Author(s): Michael Kifer
**
** Contact:   kifer@cs.stonybrook.edu
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 2008 - 2012;
**      and Vulcan, Inc., 2008 - 2012.
**
** All rights reserved.
**
** For information about licensing terms, please see
** http://silk.projects.semwebcentral.org/flora2-license.html
**
**
*/


/*** This argumentation theory corresponds to the original Grosof's
     Generalized Courteous Logic Programming.
     This argumentation theory also supports cancellation.
*/

#include "flora_terms.flh"
#include "flora_porting.flh"

:- symbol_context defeated(?,?)@?, candidate(?,?)@?, strict_candidate(?,?)@?.
:- symbol_context prlg beaten_by_strict_rule(?,?,?,?,?).

// if FL_CANDIDATE, FL_STRICT_CANDIDATE are not tabled, memory requirements
// are lower (5-25%) but this may slow things down by 100% or more.
:- table FL_CANDIDATE/3, FL_STRICT_CANDIDATE/3.

:- prolog FL_REFUTES/5, FL_REBUTS/5.
:- prolog FL_DEFEATS/5.
:- prolog FL_REFUTED/3, FL_REBUTTED/3.
:- prolog FL_CONFLICTS/5.
:- prolog FL_DISQUALIFIED/3.
:- prolog FL_DEFEATED/3, FL_DEFEATED_ID/4.
//:- table FL_UNDEFEATED/4.  // DO NOT TABLE - useless
:- prolog FL_UNDEFEATED/4.
:- prolog beaten_by_strict_rule/3, beaten_by_strict_rule/5.

// All the FL_* names are defined in flora_terms.flh to make it easier to change
:- export ?[howDefeated -> ?],
	  ?[info->?].
:- export opposes(?,?,?,?),
	  overrides(?,?,?,?),
	  candidate(?,?),
	  strict_candidate(?,?),
	  defeated(?,?).

:- ignore_depchk %abort(?)@_system.

/*
  Note 1: FL_UNDEFEATED/4 must be called with the 4th argument bound to
          the user module name in which defeasible theory is invoked.
          This is done by the compiler.
  Note 2: ?R and ?Mod must be ground. Otherwise FL_UNDEFEATED is delayed.
          If ?Mod is not ground, it is an error (should catch).
          If ?R is non-ground, the result is incorrect: false{defeated} ==
          naf Exists defeated, while we need Exists not defeated.
*/
FL_UNDEFEATED(?Id,?_Vars,?_H,?Mod) :-
	is_strict_rule(?Id,?Mod)@_prolog(flrdescriptor_support),
	!.
FL_UNDEFEATED(?Id,?Vars,?H,?Mod) :-
	is_defeasible_rule(?Id,?Mod)@_prolog(flrdescriptor_support),
	!,
	naf FL_DEFEATED_ID(?Id,?Vars,?H,?Mod).
FL_DEFEATED_ID(?Id,?Vars,?H,?Mod) :-
	get_tag_descriptor_info(?Id,?Mod,?T,?Vars)@_prolog(flrdescriptor_support),
	FL_DEFEATED(?T,?H,?Mod).

#include "change_module.flh"


// These are mostly for debugging
// Note: when ?H,?H1,?H2 are bound by the user, they should be reified
// For instance: defeated(?T,${neg a})@_gcl.
defeated(?T,?H) :-
	caller{?Mod},
	change_module_nocheck(?H,?Mod,?RealMod,?MH),
	FL_DEFEATED(?T,?MH,?RealMod).

opposes(?T1,?H1,?T2,?H2) :-
	caller{?Mod},
	change_module_nocheck(?H1,?Mod,?RealMod,?MH1),
	change_module_nocheck(?H2,?Mod,?RealMod,?MH2),
	FL_OPPOSES_AUX(?RealMod,?T1,?MH1,?T2,?MH2).

overrides(?T1,?H1,?T2,?H2) :-
	caller{?Mod},
	change_module_nocheck(?H1,?Mod,?RealMod,?MH1),
	change_module_nocheck(?H2,?Mod,?RealMod,?MH2),
	synonymous_tag_with_head(?T1,?RealMod,?T11,?H1)@_plg(flrdescriptor_support),
	synonymous_tag_with_head(?T2,?RealMod,?T22,?H2)@_plg(flrdescriptor_support),
	FL_OVERRIDES_AUX(?RealMod,?T11,?MH1,?T22,?MH2).

candidate(?T,?H) :-
	caller{?Mod},
	FL_CANDIDATE(?T,?H,?Mod).
strict_candidate(?T,?H) :-
	caller{?Mod},
	FL_STRICT_CANDIDATE(?T,?H,?Mod).

// Axioms for Courteous LP

FL_DEFEATED(?T,?H,?Mod) :- FL_DEFEATS(?,?,?T,?H,?Mod).
FL_DEFEATED(?T,?H,?Mod) :- FL_DISQUALIFIED(?T,?H,?Mod).

FL_DEFEATS(?T1,?H1,?T2,?H2,?Mod) :- FL_REFUTES(?T1,?H1,?T2,?H2,?Mod).
FL_DEFEATS(?T1,?H1,?T2,?H2,?Mod) :- FL_REBUTS(?T1,?H1,?T2,?H2,?Mod).

FL_REFUTED(?T,?H,?Mod)   :- FL_REFUTES(?,?,?T,?H,?Mod).
// rebutted/2 is unused in this version of the argumentation theory
FL_REBUTTED(?T,?H,?Mod)  :- FL_REBUTS(?,?,?T,?H,?Mod).

/******************** FL_DISQUALIFIED **************************************/
FL_DISQUALIFIED(?T,?H,?Mod) :- beaten_by_strict_rule(?T,?H,?Mod).
FL_DISQUALIFIED(?T,?H,?Mod) :- FL_CANCEL_AUX(?Mod,?T,?H).
// FL_OVERRIDEN_CANCELLATION expresses interaction  of defeat and cancellation:
// Cancellation rule is disqualified if the rule being canceled has higher
// priority than the cancellation rule itself
FL_DISQUALIFIED(?T,?H,?Mod) :- FL_OVERRIDEN_CANCELLATION(?T,?H,?Mod).

FL_REFUTES(?T1,?H1,?T2,?H2,?Mod) :-
	// This order is potentially better, since normally
	// there are fewer overrides than conflicts.
	nonvar(?T1),
	!,
	synonymous_tag_with_head(?T1,?Mod,?T11,?H1)@_plg(flrdescriptor_support),
	FL_OVERRIDES_AUX(?Mod,?T11,?H1,?T22,?H2),
	synonymous_tag_with_head(?T2,?Mod,?T22,?H2)@_plg(flrdescriptor_support),
	FL_CONFLICTS(?T11,?H1,?T22,?H2,?Mod).
FL_REFUTES(?T1,?H1,?T2,?H2,?Mod) :-
	// This order is potentially better, since normally
	// there are fewer overrides than conflicts.
	synonymous_tag_with_head(?T2,?Mod,?T22,?H2)@_plg(flrdescriptor_support),
	FL_OVERRIDES_AUX(?Mod,?T11,?H1,?T22,?H2),
	synonymous_tag_with_head(?T11,?Mod,?T1,?H1)@_plg(flrdescriptor_support),
	FL_CONFLICTS(?T11,?H1,?T22,?H2,?Mod).

FL_REBUTS(?T1,?H1,?T2,?H2,?Mod)  :-
	FL_CONFLICTS(?T1,?H1,?T2,?H2,?Mod),
	naf FL_REFUTED(?T1,?H1,?Mod),
	naf FL_REFUTED(?T2,?H2,?Mod).


/************************ Debugging ***************************************/

/*
   FL_STATUS(T,Head)[howDefeated->Reason] can be used to find out what is
   defeated and why. No need to reify the ?H argument or attach a module to it.
   This method finds out the caller module and replaces the module of Head
   with the caller module.
*/
FL_STATUS(?T,?H)[howDefeated -> refutedBy(?DT,?DH)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_REFUTES(?DT,?DH,?T,?HM,?RealMod).
FL_STATUS(?T,?H)[howDefeated -> rebuttedBy(?DT,?DH)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_REBUTS(?DT,?DH,?T,?HM,?RealMod).
FL_STATUS(?T,?H)[howDefeated -> canceled] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_CANCEL_AUX(?RealMod,?T,?HM).
FL_STATUS(?T,?H)[howDefeated->beatenByStrictRule(?SH)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	beaten_by_strict_rule(?T,?HM,?,?SH,?RealMod).

FL_STATUS(?T,?H)[info -> refutes(?RefutedT,?RefutedH)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_REFUTES(?T,?HM,?RefutedT,?RefutedH,?RealMod).
FL_STATUS(?T,?H)[info -> rebuts(?RebuttedT,?RebuttedH)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_REBUTS(?T,?HM,?RebuttedT,?RebuttedH,?RealMod).

FL_STATUS(?T,?H)[info->conflictsWith(?ConflictT,?ConflictH)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_CONFLICTS(?T,?HM,?ConflictT,?ConflictH,?RealMod).

FL_STATUS(?T,?H)[info->candidate] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_CANDIDATE(?T,?HM,?RealMod).


/***************************** Auxiliary Predicates ***********************/
// Given a rule Tag and possibly Head, find body and test if it is satisfied.
// This predicate's tables are abolished after each query by an
// after-query hook because sometimes it is called with Tag/Head as a var.
// It may succeed for one query and will be tabled.
// If it is, then when called for another query, wrong result may be returned.
FL_CANDIDATE(?T,?Head,?Mod) :-
	/* Must reset term-depth limit, since get_ruleid_by_tag_or_head/4 can
	   retrieve rules with very large bodies. As terms they will be very
	   deep (>100).
	*/
	current_prolog_flag(max_table_subgoal_depth,?TermDepth)@_prolog,
	set_prolog_flag(max_table_subgoal_depth, 0)@_prolog,
	?ModHead = ?Head@?Mod,
	get_ruleid_by_tag_or_head(?T,?ModHead,?Mod,?Id)@_prolog(flrdescriptor_support),
	is_defeasible_rule(?Id,?Mod)@_prolog(flrdescriptor_support),
	show_rule_by_id(?Id, ?Mod, ?ModHead, ?Body)@_plg(flrcanon),
	?Body,
	set_prolog_flag(max_table_subgoal_depth, ?TermDepth)@_prolog.

// Find out if two rules (Tag,Head) are in conflict
// One of the tags might be a variable
FL_CONFLICTS(?T1,?H1,?T2,?H2,?Mod) :-
	// FL_OPPOSES_AUX(?Mod,?T1,?H1,?T2,?H2) should be at the beginning,
	// since this is a cheap predicate compared to checking candidacy.
	// FL_OPPOSES_AUX is made symmetric in T1,?H1, ?T2,?H2 by an axiom
	// in genincludes/flrdefeasible.fli
	FL_OPPOSES_AUX(?Mod,?T1,?H1,?T2,?H2),
	FL_CANDIDATE(?T1,?H1,?Mod),
	FL_CANDIDATE(?T2,?H2,?Mod).

// FL_OPPOSES_AUX/5, FL_OVERRIDES_AUX/5, FL_CANCEL_AUX/3 are defined in
// genincludes/flrdefeasible.fli


beaten_by_strict_rule(?T,?H,?Mod) :- beaten_by_strict_rule(?T,?H,?,?,?Mod).
beaten_by_strict_rule(?T,?H,?Tstrict,?Hstrict,?Mod) :-
	FL_OPPOSES_AUX(?Mod,?T,?H,?Tstrict,?Hstrict),
	(_isbasefact(?Hstrict), !
	; FL_STRICT_CANDIDATE(?Tstrict,?Hstrict,?Mod)
        ).

FL_STRICT_CANDIDATE(?T,?Head,?Mod) :-
	/* Must reset term-depth limit, since show_rule_by_id/4 can
	   retrieve rules with very large bodies. As terms they will be very
	   deep (>100). */
	current_prolog_flag(max_table_subgoal_depth,?TermDepth)@_prolog,
	set_prolog_flag(max_table_subgoal_depth, 0)@_prolog,
	?ModHead = ?Head@?Mod,
	//get_tag_descriptor_info_with_rulehead(?Id,?Mod,?T,?ModHead,?)@_prolog(flrdescriptor_support),
	get_ruleid_by_tag_or_head(?T,?ModHead,?Mod,?Id)@_prolog(flrdescriptor_support),
	is_strict_rule(?Id,?Mod)@_prolog(flrdescriptor_support),
	show_rule_by_id(?Id, ?Mod, ?ModHead, ?Body)@_plg(flrcanon),
	?Body,
	set_prolog_flag(max_table_subgoal_depth, ?TermDepth)@_prolog.

// Hook for abolishing FL_CANDIDATE/3, FL_STRICT_CANDIDATE/3 after each query
FL_DEFEASIBLE_CLEANUP(?,?) :-
	flora_abolish_table_call(${FL_CANDIDATE(?,?,?)})@_prolog(flrtables),
	flora_abolish_table_call(${FL_STRICT_CANDIDATE(?,?,?)})@_prolog(flrtables).

?- flora_add_hook(_@,QUERYHOOK,after,0,FL_DEFEASIBLE_CLEANUP(?,?))@_prolog(flrhooks).

// must have this in order for FL_STATUS to have right argument translation
?- flora_set_argdef(FL_STATUS,2,[FL_OID,FL_BODYFORMULA],_@)@_prolog(flrarguments).
