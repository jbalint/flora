/* File:      gclpe.flr
**
** Author(s): Michael Kifer
**
** Contact:   kifer@cs.stonybrook.edu
**
** Copyright (C) by
**     The Research Foundation of the State University of New York, 2008 - 2012;
**     and Vulcan, Inc., 2009 - 2012.
**
** All rights reserved.
**
** For information about licensing terms, please see
** http://silk.projects.semwebcentral.org/flora2-license.html
**
**
*/


/*** This argumentation theory is an alternative formulation for
     ATCK2 or ATCK3 - depending on whether ATCK3 is #define'd
     It allows k-ary exclusion constraints:
     Courteous Logic with General Exclusion Constraints.
     This argumentation theory also supports cancellation.
*/

// #define ATCK3

#include "flora_terms.flh"
#include "flora_porting.flh"

:- symbol_context
        defeated(?,?)@?,
        competes(?,?)@?,
        candidate(?,?)@?,
        strict_candidate(?,?)@?,
        prlg FL_COMPETES(?,?,?),
        prlg FL_REFUTES(?,?,?,?,?),
        prlg FL_REBUTS(?,?,?,?),
        prlg beaten_by_strict_rule(?,?,?,?,?),
    	prlg existsOpposerWithNoCandidates(?,?,?).

:- table FL_CANDIDATE/3, FL_STRICT_CANDIDATE/3.
:- prolog FL_REFUTES/4, FL_REFUTES/5.
:- prolog FL_REBUTS/3, FL_REBUTS/4.
:- prolog FL_DISQUALIFIED/3.
:- prolog FL_DEFEATED/3, FL_DEFEATED_ID/4.
:- prolog FL_COMPETES/4, FL_COMPETES/3.
//:- table FL_UNDEFEATED/4.  // DO NOT TABLE - useless
:- prolog FL_UNDEFEATED/4.
:- prolog beaten_by_strict_rule/3, beaten_by_strict_rule/5.
:- prolog existsOpposerWithNoCandidates/2, existsOpposerWithNoCandidates/3.
:- prolog tightExclusion/3, tightBinaryExclusion/3.

// All the FL_* names are defined in flora_terms.flh to make it easier to change
:- export ?[howDefeated -> ?],
	  ?[info->?].
// These are exported for debugging
:- export
	  ?[opposers(?)->?],
	  ?[FL_BEATER(?)->?],
          FL_BEATER(?,?,?),
	  FL_STOMPED(?,?),
	  FL_DOMINATES(?,?,?),
          opposes(?,?,?,?),
	  overrides(?,?,?,?),
	  competes(?,?),
	  competes(?)(?,?),
	  candidate(?,?),
	  strict_candidate(?,?),
	  defeated(?,?).

:- ignore_depchk %abort(?)@_system.

?- Method[%mustDefine(off, ?:_Exclusion@?)]@_system,
   Method[%mustDefine(off, ?::_Exclusion@?)]@_system.

//?- Method[%mustDefine(on)]@_system.

/*
  Note 1: FL_UNDEFEATED/4 must be called with the 4th argument bound to
          the user module name in which defeasible theory is invoked.
          This is done by the compiler.
  Note 2: ?R and ?Mod must be ground. Otherwise FL_UNDEFEATED is delayed.
          If ?Mod is not ground, it is an error (should catch).
          If ?R is non-ground, the result is incorrect: false{defeated} ==
          not Exists defeated, while we need Exists not defeated.
*/
FL_UNDEFEATED(?Id,?_Vars,?_H,?Mod) :-
	is_strict_rule(?Id,?Mod)@_prolog(flrdescriptor_support),
	!.
FL_UNDEFEATED(?Id,?Vars,?H,?Mod) :-
	is_defeasible_rule(?Id,?Mod)@_prolog(flrdescriptor_support),
	!,
	naf FL_DEFEATED_ID(?Id,?Vars,?H,?Mod).
FL_DEFEATED_ID(?Id,?Vars,?H,?Mod) :-
	get_tag_descriptor_info(?Id,?Mod,?T,?Vars)@_prolog(flrdescriptor_support),
	FL_DEFEATED(?T,?H,?Mod).

#include "change_module.flh"


candidate(?T,?H) :-
	caller{?Mod},
	FL_CANDIDATE(?T,?H,?Mod).
strict_candidate(?T,?H) :-
	caller{?Mod},
	FL_STRICT_CANDIDATE(?T,?H,?Mod).

// These are mostly for debugging
// Note: when ?H,?H1,?H2 are bound by the user, they should be reified
// For instance: defeated(?T,${neg a})@_gcl.
defeated(?T,?H) :-
	caller{?Mod},
	change_module_nocheck(?H,?Mod,?RealMod,?MH),
	FL_DEFEATED(?T,?MH,?RealMod).

// Can also use ?Exclusion[opposers(?Mod)->?Opposer], to inspect k-ary mutexes
opposes(?T1,?H1,?T2,?H2) :-
	caller{?Mod},
	change_module_nocheck(?H1,?Mod,?RealMod,?MH1),
	change_module_nocheck(?H2,?Mod,?RealMod,?MH2),
	FL_OPPOSES_AUX(?RealMod,?T1,?MH1,?T2,?MH2).

competes(?E)(?H,?HH) :- FL_COMPETES(?H,?HH,?E,?).
competes(?H,?HH) :- FL_COMPETES(?H,?HH,?).

overrides(?T1,?H1,?T2,?H2) :-
	caller{?Mod},
	change_module_nocheck(?H1,?Mod,?RealMod,?MH1),
	change_module_nocheck(?H2,?Mod,?RealMod,?MH2),
	synonymous_tag_with_head(?T1,?RealMod,?T11,?H1)@_plg(flrdescriptor_support),
	synonymous_tag_with_head(?T2,?RealMod,?T22,?H2)@_plg(flrdescriptor_support),
	FL_OVERRIDES_AUX(?RealMod,?T11,?MH1,?T22,?MH2).


// Axioms for Courteous LP with general exclusions

FL_DEFEATED(?_T,?H,?Mod) :-
	?Exclusion[opposers(?Mod)->{?H1,?H}],
	?H1@?Mod != ?H@?Mod,
	naf ?Exclusion[FL_BEATER(?Mod)->?H].
FL_DEFEATED(?T,?H,?Mod) :-
	// this incorporates the classical mutex and user-defined _opposes/2
	FL_OPPOSES_AUX(?Mod,?T,?H,?_OtherT,?OtherH),
	?OtherH@?Mod != ?H@?Mod,
	naf FL_BEATER(?H,?OtherH,?Mod).
FL_DEFEATED(?T,?H,?Mod) :- FL_DISQUALIFIED(?T,?H,?Mod).

/***************************** FL_BEATER ************************************/
?Exclusion[FL_BEATER(?Mod)->?H] :-
	beater_aux(?H,?,?Exclusion,?Mod).
// auxiliary FL_BEATER predicate
beater_aux(?H,?BeatenH,?Exclusion,?Mod) :-
	FL_COMPETES(?H,?BeatenH,?Exclusion,?Mod),
	(naf FL_REBUTS(?BeatenH,?H,?Exclusion,?Mod)
         or
#ifdef ATCK3
         neg ?BeatenH
#else   // ATCK2
         FL_STOMPED(?BeatenH,?Mod)
#endif
        ).
/*
  The FL_BEATER predicate for binary exclusions (_opposes)
  This is like exclusion(?H,?_BeatenH)[FL_BEATER(?Mod)->?H]
  In other words, ?BeatenH is part of the exclusion Id and can't be eliminated
*/
FL_BEATER(?H,?BeatenH,?Mod) :-
	FL_COMPETES(?H,?BeatenH,?Mod),
	(naf FL_REBUTS(?BeatenH,?H,?Mod)
         or
#ifdef ATCK3
         neg ?BeatenH
#else   // ATCK2
         FL_STOMPED(?BeatenH,?Mod)
#endif
        ).

/******************** FL_DISQUALIFIED **************************************/
FL_DISQUALIFIED(?T,?H,?Mod) :- beaten_by_strict_rule(?T,?H,?Mod).
FL_DISQUALIFIED(?T,?H,?Mod) :- FL_CANCEL_AUX(?Mod,?T,?H).

/* FL_OVERRIDEN_CANCELLATION is defined in genincludes/flrdefeasible.fli
   roughly by axioms of the form:
   FL_DISQUALIFIED((?Id1,_cancel(?Id2,?Head2))) :-
                       _overrides(?Id2,?Head2,?Id1,_cancel(?Id2,?Head2)).
   FL_DISQUALIFIED((?Id1,_cancel(?Id2))) :-
                       _overrides(?Id2,?,?Id1,_cancel(?Id2)).
   That is: Cancellation rule is disqualified if the rule being canceled
            has higher priority than the cancellation rule itself
*/

FL_DISQUALIFIED(?T,?H,?Mod) :- FL_OVERRIDEN_CANCELLATION(?T,?H,?Mod).


/********* FL_REBUTS, FL_REFUTES *****************************************/
FL_REFUTES(?H1,?T2,?H2,?Exclusion,?Mod) :-
	FL_COMPETES(?H1,?H2,?Exclusion,?Mod),
	synonymous_tag_with_head(?T2,?Mod,?T22,?H2)@_plg(flrdescriptor_support),
	FL_OVERRIDES_AUX(?Mod,?T1,?H1,?T22,?H2),
	FL_CANDIDATE(?T1,?H1,?Mod).
FL_REFUTES(?H1,?T2,?H2,?Mod) :-
	FL_COMPETES(?H1,?H2,?Mod),
	synonymous_tag_with_head(?T2,?Mod,?T22,?H2)@_plg(flrdescriptor_support),
	FL_OVERRIDES_AUX(?Mod,?T1,?H1,?T22,?H2),
	FL_CANDIDATE(?T1,?H1,?Mod).

// FL_REBUTS/4
FL_REBUTS(?H1,?H2,?Exclusion,?Mod)  :-
	FL_COMPETES(?H1,?H2,?Exclusion,?Mod),
	FL_CANDIDATE(?T1,?H1,?Mod),
	naf FL_REFUTES(?H2,?T1,?H1,?Exclusion,?Mod).
// FL_REBUTS/3
FL_REBUTS(?H1,?H2,?Mod)  :-
	FL_COMPETES(?H1,?H2,?Mod),
	FL_CANDIDATE(?T1,?H1,?Mod),
	naf FL_REFUTES(?H2,?T1,?H1,?Mod).


/************************ Competition **************************************/
FL_COMPETES(?H1,?H2,?Exclusion,?Mod) :-
	?Exclusion[opposers(?Mod)->{?H1,?H2}],
	?H1 != ?H2.
FL_COMPETES(?H1,?H2,?Mod) :-
	FL_OPPOSES_AUX(?Mod,?_T1,?H1,?_T2,?H2),
	?H1 != ?H2.

competitors(?H1,?H2,?Mod) :-
	FL_COMPETES(?H1,?H2,?_Exclusion,?Mod)
        or
        FL_COMPETES(?H1,?H2,?Mod).


/*********************** FL_DOMINATES ****************************************
** FL_DOMINATES(?Lit,?DomineeH) =def=
**    Forall ?DomineeTag ( candidate(?DomineeTag,?DomineeH) ~~>
**                 Exists ?Tag ( candidate(?Tag,?Lit) and
**                               _overrides((?Tag,?Lit),(?DomineeTag,?DomineeH))
**                             )
**                       )
  Question: should it be _overrides((?Tag,?Lit),(?DomineeTag,?DomineeH)) or
                         _overrides(?Tag,?DomineeTag)
****************************************************************************/
FL_DOMINATES(?Lit,?DomineeH,?Mod) :-
	get_ruleid_by_tag_or_head(?,?Lit,?Mod,?Id)@_prolog(flrdescriptor_support),
	is_defeasible_rule(?Id,?Mod)@_prolog(flrdescriptor_support),
	competitors(?Lit,?DomineeH,?Mod),
	naf existsRuleWithNoOverrider(?Lit,?DomineeH,?Mod).
existsRuleWithNoOverrider(?Lit,?DomineeH,?Mod) :-
	FL_CANDIDATE(?DomineeTag,?DomineeH,?Mod),
	naf exist(?Tag)^((
	     FL_CANDIDATE(?Tag,?Lit,?Mod),
	     synonymous_tag_with_head(?DomineeTag,?Mod,?DomineeTag1,?DomineeH)@_plg(flrdescriptor_support),
	     FL_OVERRIDES_AUX(?Mod,?Tag,?Lit,?DomineeTag1,?DomineeH)
	   )).


/************************ Stomping *****************************************
** FL_STOMPED(?Lit) =def=
**         tightExclusion(?Excl,?Lit) and
**         Forall ?Competitor ( FL_COMPETES(?Competitor,?Lit,?Excl) ~~>
**                                           FL_DOMINATES(?Competitor,?Lit)
**                            )
****************************************************************************/
FL_STOMPED(?Lit,?Mod) :-
	//tightExclusion(?Excl,?Lit,?Mod),   // -- BG old 5/15/2012
	FL_CANDIDATE(?_Tag,?Lit,?Mod),       // -- BG new 5/15/2012
	?Excl[opposers(?Mod)->?Lit],         // -- BG new 5/15/2012
	naf existsCompetitorWhoDoesNotDominate(?Lit,?Excl,?Mod).
existsCompetitorWhoDoesNotDominate(?Lit,?Excl,?Mod) :-
	FL_COMPETES(?Lit,?Competitor,?Excl,?Mod),
	naf FL_DOMINATES(?Competitor,?Lit,?Mod).
// binary version of stomping
FL_STOMPED(?Lit,?Mod) :-
	get_ruleid_by_tag_or_head(?,?Lit,?Mod,?Id)@_prolog(flrdescriptor_support),
	is_defeasible_rule(?Id,?Mod)@_prolog(flrdescriptor_support),
	tightBinaryExclusion(?Competitor,?Lit,?Mod),
	if FL_COMPETES(?Competitor,?Lit,?Mod)
	then FL_DOMINATES(?Competitor,?Lit,?Mod).


/*********************** Tight Exclusion ***********************************
**  tightExclusion(?Excl,?Lit) =def=
**       candidate(?Tag,?Lit) and
**           Forall ?Competitor (
**                     FL_COMPETES(?Competitor,?Lit,?Excl) ~~>
**                       Exists ?CompetitorTag (
**                                  candidate(?CompetitorTag,?Competitor) and
**                                  naf FL_STOMPED(?Competitor)  --- for ATCK2
**                                             )
**                               )
****************************************************************************/
tightExclusion(?Excl,?Lit,?Mod) :-
	?Excl:_Exclusion@?Mod,
	FL_CANDIDATE(?,?Lit,?Mod),
	naf existsCompetitorNonCadidateOrStomped(?Excl,?Lit,?Mod).
existsCompetitorNonCadidateOrStomped(?Excl,?Lit,?Mod) :-
	FL_COMPETES(?Lit,?Competitor,?Excl,?Mod),
	naf((FL_CANDIDATE(?,?Competitor,?Mod),
	     // naf FL_STOMPED in some exclusion
	     naf FL_STOMPED(?Competitor,?Mod))).

// for binary exclusions (_opposes)
tightBinaryExclusion(?Competitor,?Lit,?Mod) :-
	FL_CANDIDATE(?,?Lit,?Mod),
	if FL_COMPETES(?Competitor,?Lit,?Mod)
        then (
	    FL_CANDIDATE(?,?Competitor,?Mod),
	    naf FL_STOMPED(?Competitor,?Mod)
	).


/********************* Conflictful Exclusion *******************************
**  ConflictfulExclusion(?Excl,?Mod) =def=
**       Forall ?Opposer ( opposerOf(?Excl,?Opposer) ~~>
**                              Exists ?Tag candidate(?Tag,?Opposer)
**                       )
****************************************************************************/
// **** NOT USED *****
ConflictfulExclusion(?Excl,?Mod) :-
	?Excl:_Exclusion@?Mod,
	naf existsOpposerWithNoCandidates(?Excl,?Mod).
existsOpposerWithNoCandidates(?Excl,?Opposer,?Mod) :-
	?Excl[opposers(?Mod)->?Opposer]@?Mod,
	naf exist(?Tag)^((
	       //is_defeasible_tag(?Tag,?Mod)@_prolog(flrdescriptor_support),
	       FL_CANDIDATE(?Tag,?Opposer,?Mod)
	   )).


/************************ Debugging ***************************************/

/*
   FL_STATUS(T,Head)[howDefeated->Reason] can be used to find out what is
   defeated and why. No need to reify the ?H argument or attach a module to it.
   This method finds out the caller module and replaces the module of Head
   with the caller module.
*/
FL_STATUS(?T,?H)[howDefeated -> notBeaterFor(?Exclusion)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
        ?Exclusion[opposers(?RealMod)->{?HM,?OtherH}],
	?HM@?RealMod != ?OtherH@?RealMod,
	FL_CANDIDATE(?T,?HM,?RealMod), // MK added 2/22/2012
	naf ?Exclusion[FL_BEATER(?RealMod)->?HM].
FL_STATUS(?T,?H)[howDefeated -> notBeaterFor(binaryExclusion(?HM,?BeatenH))] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_OPPOSES_AUX(?RealMod,?T,?HM,?,?BeatenH),
	FL_CANDIDATE(?T,?HM,?RealMod),     // MK added 2/22/2012
	naf FL_BEATER(?HM,?BeatenH,?RealMod).
FL_STATUS(?T,?H)[howDefeated -> canceled] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_CANCEL_AUX(?RealMod,?T,?HM).
FL_STATUS(?T,?H)[howDefeated->beatenByStrictRule(?SH)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	beaten_by_strict_rule(?T,?HM,?,?SH,?RealMod).

FL_STATUS(?_T,?H)[info -> stomped] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_STOMPED(?HM,?RealMod).

FL_STATUS(?_T,?H)[info -> dominates(?DomineeH)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_DOMINATES(?HM,?DomineeH,?RealMod).

FL_STATUS(?_T,?H)[info -> refutes(?RefutedT,?RefutedH)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_REFUTES(?HM,?RefutedT,?RefutedH,?RealMod).
FL_STATUS(?_T,?H)[info -> refutes(?RefutedT,?RefutedH)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_REFUTES(?HM,?RefutedT,?RefutedH,?_Exclusion,?RealMod).

FL_STATUS(?_T,?H)[info -> rebuts(?Rebutted)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_REBUTS(?HM,?Rebutted,?RealMod).
FL_STATUS(?_T,?H)[info -> rebuts(?Rebutted)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_REBUTS(?HM,?Rebutted,?_Exclusion,?RealMod).

FL_STATUS(?_T,?H)[info->beats(?Exclusion,?BeatenH)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	beater_aux(?HM,?BeatenH,?Exclusion,?RealMod).
FL_STATUS(?_T,?H)[info->beats(?BeatenH)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_BEATER(?HM,?BeatenH,?RealMod).

FL_STATUS(?_T,?H)[info->competes(?Exclusion,?Competitor)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_COMPETES(?HM,?Competitor,?Exclusion,?RealMod),
	FL_CANDIDATE(?,?Competitor,?RealMod).
FL_STATUS(?_T,?H)[info->competes(?Competitor)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_COMPETES(?HM,?Competitor,?RealMod),
	FL_CANDIDATE(?,?Competitor,?RealMod).

FL_STATUS(?T,?H)[info->candidate] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_CANDIDATE(?T,?HM,?RealMod).


/***************************** Auxiliary Predicates ***********************/
// Given a rule Tag and possibly Head, find body and test if it is satisfied.
// This predicate's tables are abolished after each query by an
// after-query hook because sometimes it is called with Tag/Head as a var.
// It may succeed for one query and will be tabled.
// If it is, then when called for another query, wrong result may be returned.
FL_CANDIDATE(?T,?Head,?Mod) :-
	/* Must reset term-depth limit, since get_ruleid_by_tag_or_head/4 can
	   retrieve rules with very large bodies. As terms they will be very
	   deep (>100). */
	current_prolog_flag(max_table_subgoal_depth,?TermDepth)@_prolog,
	set_prolog_flag(max_table_subgoal_depth, 0)@_prolog,
	?ModHead = ?Head@?Mod,
	get_ruleid_by_tag_or_head(?T,?ModHead,?Mod,?Id)@_prolog(flrdescriptor_support),
	is_defeasible_rule(?Id,?Mod)@_prolog(flrdescriptor_support),
	show_rule_by_id(?Id, ?Mod, ?ModHead, ?Body)@_plg(flrcanon),
	?Body,
	set_prolog_flag(max_table_subgoal_depth, ?TermDepth)@_prolog.

// opposer without the rule tag
?Exclusion[opposers(?Mod)->?HH] :-
	(?Exclusion:_Exclusion[_opposers->?H])@?Mod,
	?HH = ?H@?Mod.

// FL_OPPOSES_AUX/5, FL_OVERRIDES_AUX/5, FL_CANCEL_AUX/3 are defined in
// genincludes/flrdefeasible.fli



beaten_by_strict_rule(?T,?H,?Mod) :- beaten_by_strict_rule(?T,?H,?,?,?Mod).
beaten_by_strict_rule(?T,?H,?StrictT,?StrictH,?Mod) :-
	FL_CANDIDATE(?T,?H,?Mod),  // MK added 2/22/2012
	FL_OPPOSES_AUX(?Mod,?T,?H,?StrictT,?StrictH),
	FL_STRICT_CANDIDATE(?StrictT,?StrictH,?Mod).

FL_STRICT_CANDIDATE(?T,?Head,?Mod) :-
	/* Must reset term-depth limit, since show_rule_by_id/4 can
	   retrieve rules with very large bodies. As terms they will be very
	   deep (>100). */
	current_prolog_flag(max_table_subgoal_depth,?TermDepth)@_prolog,
	set_prolog_flag(max_table_subgoal_depth, 0)@_prolog,
	?ModHead = ?Head@?Mod,
	get_ruleid_by_tag_or_head(?T,?ModHead,?Mod,?Id)@_prolog(flrdescriptor_support),
	is_strict_rule(?Id,?Mod)@_prolog(flrdescriptor_support),
	show_rule_by_id(?Id, ?Mod, ?ModHead, ?Body)@_plg(flrcanon),
	?Body,
	set_prolog_flag(max_table_subgoal_depth, ?TermDepth)@_prolog.


// Hook for abolishing FL_CANDIDATE/3, FL_STRICT_CANDIDATE/3 after each query
FL_DEFEASIBLE_CLEANUP(?,?) :-
	flora_abolish_table_call(${FL_CANDIDATE(?,?,?)})@_prolog(flrtables),
	flora_abolish_table_call(${FL_STRICT_CANDIDATE(?,?,?)})@_prolog(flrtables).

//?- flora_add_hook(_@,QUERYHOOK,after,0,FL_DEFEASIBLE_CLEANUP(?,?))@_prolog(flrhooks).

// must have this in order for FL_STATUS to have right argument translation
?- flora_set_argdef(FL_STATUS,2,[FL_OID,FL_BODYFORMULA],_@)@_prolog(flrarguments).
