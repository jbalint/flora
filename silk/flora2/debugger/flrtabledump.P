/* File:      flrtabledump.P
**
** Author(s): Michael Kifer
**
** Contact:   kifer@cs.stonybrook.edu
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 2011;
**      and Vulcan, Inc., 2011.
**
** All rights reserved.
**
** For information about licensing terms, please see
** http://silk.projects.semwebcentral.org/flora2-license.html
**
**
*/

:- compiler_options([xpp_on]).

#include "flora_terms.flh"
#include "flora_exceptions.flh"

:- ensure_loaded('flrtruthvalue.P').

:- import table_dump/2 from dump_table.
:- import
	get_scc_dumpfile/1,
	print_incomplete_tables/0
   from tables.
:- import memberchk/2 from basics.
:- import flora_unwrap_truthvalued_call/2 from usermod.

:- import flora_unwrap_negation/2 from flrnegation.
:- import
	%%convert_to_body_literal/2,
	convert_to_head_literal/2
   from flrcanon.
:- import
	flora_generalize_last/2
   from flrtrim.
:- import
	flora_abort/2,
	flora_file_op/2 
   from flrporting.

:- import
	%%flora_escape_atom/2,
	flora_display_symbol/2,
	%%flora_display_mode/1,
	flora_decode_oid_as_atom_substitute_vars/2
   from flrdecode.

/*
:- import
	flora_hide_this_show/1,
	flora_hide_this_hide/1
   from usermod.
*/

:- export
	flora_dump_incomplete_tables/1,
	flora_dump_incomplete_tables_after_exception/1,
	flora_dump_tables/2,
	flora_dump_tables/3.


flora_dump_tables(File,AtomicGoal) :-
	flora_dump_tables(File,AtomicGoal,summary).
%% Option: details/summary. Details trumps summary
flora_dump_tables(File,AtomicGoal,Option) :-
	atom(File),
	!,
	(memberchk(Option,[subgoals,subgoal,goal]) ->
	    Options1 = [output(false),details(subgoals)]
	; memberchk(Option,[summary,sum]) ->
	    Options1 = [output(false),summary(true)]
	; memberchk(Option,[answers,answer]) ->
	    Options1 = [output(false),details(answers)]
	;
	    flora_decode_oid_as_atom_substitute_vars(Option,OptionDecoded),
	    flora_abort(['_tabledump: invalid option in argument 3, ',OptionDecoded],FLORA_ABORT_NOTRACE)
	),
	convert_to_head_literal(AtomicGoal,AtomicGoalH),
	flora_generalize_last(AtomicGoalH,FinalGoal),
	tell(File),
	convert_tabledump_to_flora(FinalGoal,Options1),
	told.
flora_dump_tables(_File,_AtomicGoal,_Option) :-
	flora_abort('_tabledump: argument 1 must be a file name or `userout'' (for standard output)', FLORA_ABORT_NOTRACE).

convert_tabledump_to_flora(AtomicGoal,Options) :-
	repeat,
	( table_dump(AtomicGoal,[results(TblDescriptor)|Options]),
	    nonvar(TblDescriptor),
	    write_one_table_record(TblDescriptor),
	    /*
	    (TblDescriptor = [Term1] -> write_one_table_record(Term1)
	    ; TblDescriptor = [Term1,Term2]
	    -> write_one_table_record(Term1),
		write_one_table_record(Term2)
	    ),
	    */
	    file_io:flush_output,
	    fail
	; true
	).
convert_tabledump_to_flora(_,_).


write_answers_for_subgoals([]) :- !.
write_answers_for_subgoals([First|Rest]) :-
	(First = Subgoal - times_called(Calls) - answers(Answers) - AnsList - Status
	;
	    First = Subgoal - times_called(Calls) - answers(Answers) - Status
	),
	%%flora_write_oid(Subgoal),
	write_according_to_display_mode(Subgoal),
	write('[total_answers->'), write(Answers),
	write(', total_calls->'), write(Calls),
	write(', status->'), write(Status),
	(nonvar(AnsList) ->
	    write(', answer_list->['),
	    \+(\+ write_plain_list_of_answers(AnsList)),
	    write(']')
	; true
	),
	write(']'),
	(Rest == [] -> true
	;
	    write(', '),
	    write_answers_for_subgoals(Rest)
	).

write_plain_list_of_answers([]) :- !.
write_plain_list_of_answers([H|Tail]) :-
	write_according_to_display_mode(H),
	(Tail==[], ! ; write(',')),
	write_plain_list_of_answers(Tail).

%% dump incomplete tables then read them and write to File
flora_dump_incomplete_tables(File) :-
	flora_file_op(tmpfilename,TmpFile),
	tell(TmpFile),
	print_incomplete_tables,
	told,
	flora_dump_incomplete_tables(TmpFile,File),
	flora_file_op(rm,TmpFile).

%% Assume InFile has a dump of incomplete tables.
%% Read it, convert to flora format and put the result in OutFile
flora_dump_incomplete_tables(InFile,OutFile) :-
	see(InFile),
	tell(OutFile),
	convert_incomplete_tables_to_flora,
	told,
	seen.

convert_incomplete_tables_to_flora :-
	repeat,
	read(SCCrecord),
	(SCCrecord == end_of_file, !
	;
	    nonvar(SCCrecord),
	    SCCrecord = Goal - scc(SN),
	    \+ irrelevant_goal(Goal),
	    write_according_to_display_mode(Goal),
	    write('[scc->'),
	    write(SN),
	    flora_display_symbol(terminator,Terminator),
	    write(']'), writeln(Terminator),
	    fail
	),
	!.

write_one_table_record(TblDescriptor) :-
	(
	  TblDescriptor = (summary = Goal - subgoals(NSG)
		 - total_times_called(NC) - total_answers(R))
	;
	  TblDescriptor = (details = Goal - subgoals(NSG) - details(AnsList))
	),
	!,
	NSG =\= 0,

	\+ irrelevant_goal(Goal),

	/*
	%% This hides too much. Better do it on a case-by-case basis
	%% hide whatever the debugger hides
	convert_to_body_literal(Goal,GoalB),
	functor(GoalB,FunctorB,_Arity),
	\+ hide_debug_goal(FunctorB,_Arity),
	*/
	
	write_according_to_display_mode(Goal),
	write('[total_subgoals->'),
	write(NSG),
	write(', '),
	(nonvar(R)
	-> write('total_subgoal_answers->'), write(R),
	    write(', total_times_called->'), write(NC)
	;
	    write('subgoal_details->{'),
	    \+ (\+ write_answers_for_subgoals(AnsList)),
	    write('}')
	),
	flora_display_symbol(terminator,Terminator),
	write(']'), writeln(Terminator).

%% get incomplete tables from the file that was used to dump the SCCs on abort
%% then convert to flora and dump into the DumpFile.
%% Requires that the user calls
%% ?- set_prolog_flag(exception_pre_action,print_incomplete_tables)
%% before the abort
flora_dump_incomplete_tables_after_exception(DumpFile) :-
	get_scc_dumpfile(InFile),
	flora_dump_incomplete_tables(InFile,DumpFile),
	flora_file_op(rm,InFile).

/*
%% Hiding rules taken from the debugger
hide_debug_goal(X,Y) :-
	flora_hide_this_hide(pref(X1/Y)), atom(X),atom(X1), str_sub(X1,X,0), !
	;
	flora_hide_this_hide(match(X1/Y)), atom(X),atom(X1), str_sub(X1,X), !.

hide_debug_goal(X,Y) :-
	flora_hide_this_show(pref(X1/Y)), atom(X),atom(X1), str_sub(X1,X,0), !
	;
	flora_hide_this_show(match(X1/Y)), atom(X),atom(X1), str_sub(X1,X), !
	;
	flora_hide_this_show(propermatch(X1/Y)), atom(X),atom(X1), str_sub(X1,X), X1 \= X, !.
*/

irrelevant_goal(Goal) :-
	    %% Hide FLLIBMODOBJ/5
	    Goal = FLLIBMODOBJ(_,_,_,_,_),
	    !.
irrelevant_goal(Goal) :-
	    functor(Goal,Functor,_Arity),
	    (
	      %% not a flora predicate
	      \+ str_sub(FLORA_MODULE_PREFIX,Functor), !
	    ;
	      %% a truth-checking call
	      flora_unwrap_truthvalued_call(Goal,_), !
	    ;
	      %% a negation FL_TABLED_UNNUMBER_CALL.
	      %% These calls are duplicated by positive calls.
	      %% We ignore FL_TABLED_UNNUMBER_CALL because it is
	      %% too confusing to show that to the user.
	      flora_unwrap_negation(Goal,Unwrapped), Goal \== Unwrapped, !
	    ).


write_according_to_display_mode(Goal) :-
	flora_decode_oid_as_atom_substitute_vars(Goal,FloraGoal),
	write(FloraGoal).
	/*
	(flora_display_mode(silk) ->
	    flora_escape_atom(FloraGoal,Escaped),
	    write(Escaped)
	;   write(FloraGoal)
	).
	*/
