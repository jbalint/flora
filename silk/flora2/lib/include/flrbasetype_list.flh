/* File:      include/flrbasetype_list.flh
**
** Author(s): Michael Kifer
**
** Contact:   kifer@cs.stonybrook.edu
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2013.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**      http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
**
*/


:- export
	?[_startsWith(?)],
	?[_endsWith(?)],
    	?[_contains(?)],
    	?[_member(?)],
	?[_append(?)->?],
	?[_length->?],
	?[_reverse->?],
	?[_sort->?],
	?[_subset(?)].


// startsWith
?X^^_list[_startsWith(?Y^^_list)] :-
    !,
    flora_startsWith_list(?X._rawValue,?Y._rawValue)@_prolog(flrdatatype_utils).
?X[_startsWith(?Y)] :-
    is_list(?X)@_prolog,
    flora_startsWith_list(?X,?Y)@_prolog(flrdatatype_utils).

// endsWith
?X^^_list[_endsWith(?Y^^_list)] :-
    !,
    reverse(?X._rawValue,?RX)@_prolog(basics),
    reverse(?Y._rawValue,?RY)@_prolog(basics),
    flora_startsWith_list(?RX,?RY)@_prolog(flrdatatype_utils).
?X[_endsWith(?Y)] :-
    is_list(?X)@_prolog,
    reverse(?X,?RX)@_prolog(basics),
    reverse(?Y,?RY)@_prolog(basics),
    flora_startsWith_list(?RX,?RY)@_prolog(flrdatatype_utils).

// contains
?X^^_list[_contains(?Y^^_list)] :-
    !,
    subseq(?X._rawValue,?Y._rawValue,?)@_prolog(basics).
?X[_contains(?Y)] :-
    is_list(?X)@_prolog,
    is_list(?Y)@_prolog,
    subseq(?X,?Y,?)@_prolog(basics).

// member
?X^^_list[_member(?Y)] :-
    !,
    member(?Y._rawValue,?X._rawValue)@_prolog(basics).
?X[_member(?Y)] :-
    is_list(?X)@_prolog,
    member(?Y,?X)@_prolog(basics).

// append
?X^^_list[_append(?Y^^_list) -> ?R] :-
    !,
    append(?X._rawValue,?Y._rawValue,?R)@_prolog(basics).
?X[_append(?Y) -> ?R] :-
    is_list(?X)@_prolog,
    is_list(?Y)@_prolog,
    append(?X,?Y,?R)@_prolog(basics).

// length
?X^^_list[_length -> ?R] :-
    (_isvar(?R), ! ; integer(?R)@_plg),
    !,
    length(?X._rawValue,?R)@_prolog(basics).
?X[_length -> ?R] :-
    (_isvar(?R), ! ; integer(?R)@_plg),
    is_list(?X)@_prolog,
    length(?X,?R)@_prolog(basics).

// reverse
?X^^_list[_reverse -> ?R] :-
    !,
    reverse(?X._rawValue,?R)@_prolog(basics).
?X[_reverse -> ?R] :-
    is_list(?X)@_prolog,
    reverse(?X,?R)@_prolog(basics).

// sort
?X^^_list[_sort -> ?R] :-
    !,
    sort(?X._rawValue,?R)@_prolog.
?X[_sort -> ?R] :-
    is_list(?X)@_prolog,
    sort(?X,?R)@_prolog.

// subset
?X^^_list[_subset(?Y^^_list)] :-
    !,
    subset(?Y._rawValue,?X._rawValue)@_prolog(basics).
?X[_subset(?Y)] :-
    is_list(?X)@_prolog,
    is_list(?Y)@_prolog,
    subset(?Y,?X)@_prolog(basics).


