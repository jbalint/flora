/* File:      flrgclp.flr
**
** Author(s): Michael Kifer
**
** Contact:   kifer@cs.stonybrook.edu
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 2008, 2009;
**      and Vulcan, Inc., 2008, 2009.
**
** All rights reserved.
**
** For information about licensing terms, please see
** http://silk.projects.semwebcentral.org/flora2-license.html
**
**
*/


/*** The default argumentation theory: GCL, Generalized Courteous Logic.
     Obtained from theoriginal Grosof's GCLP by modifying defeasibility
     and rebuttal.
     The only difference is that this argumentation theory also
     supports cancellation.
*/

#include "flora_terms.flh"

// All the FL_* names are defined in flora_terms.flh to make it easier to change
:- export FL_UNDEFEATED(?,?,?), %refresh.
:- export ?[howDefeated -> ?],
	  ?[info->?],
	  ?[howDisqualified->?].
:- export opposes(?,?),
	  overrides(?,?).
:- ignore_depchk %abort(?)@_system.

/*
  Note 1: FL_UNDEFEATED/3 must be called with the third argument bound to
          the user module name in which defeasible theory is invoked.
          This is done by the compiler.
  Note 2: We should make sure that ?R and ?Mod are ground.
          If ?Mod is not ground, it is an error (should catch).
          If ?R is non-ground, the result is incorrect: false{defeated} ==
          not Exists defeated, while we need Exists not defeated.
*/
FL_UNDEFEATED(?I,?H,?_Mod) :-
	//flora_trim_last(?H,?Htrimmed)@_prolog(flrtrim),
	//\+ ground(?Htrimmed)@_prolog(),
	\+ flora_ground(?H)@_prolog(flrtrim),
	!,
	flora_decode_oid_as_atom(?I,?Iatom)@_prolog(flrdecode),
	flora_decode_goal_as_atom(?H,?Hatom)@_prolog(flrdecode),
	%abort(['Invocation of nonground defeasible rule.\n\tLabel: ',
		 ?Iatom, '\n\tRule head: ',
		 ?Hatom])@_system.
FL_UNDEFEATED(?I,?H,?Mod) :-
	not FL_DEFEATED((?I,?H),?Mod).
        // cannot use 't not': ?H might not be ground
	//'t not'(FL_DEFEATED((?I,?H),?Mod)@ _@)@_prolog(tables).

// These are for debugging only
opposes(?L1,?L2) :-
	caller{?Mod},
	FL_OPPOSES_AUX(?Mod,?L1,?L2).
overrides(?R1,?R2) :-
	caller{?Mod},
	FL_OVERRIDES_AUX(?Mod,?R1,?R2).

// Axioms for Courteous LP

FL_DEFEATED(?R,?Mod) :- FL_DEFEATS(?S,?R,?Mod), not FL_COMPROMISED(?S,?Mod).
FL_DEFEATED(?R,?Mod) :- FL_DISQUALIFIED(?R,?Mod).

FL_DEFEATS(?R1,?R2,?Mod) :- FL_REFUTES(?R1,?R2,?Mod).
FL_DEFEATS(?R1,?R2,?Mod) :- FL_REBUTS(?R1,?R2,?Mod).

FL_REFUTED(?R,?Mod)   :- FL_REFUTES(?,?R,?Mod).
// rebutted/2 is unused in this version of the argumentation theory
FL_REBUTTED(?R,?Mod)  :- FL_REBUTS(?,?R,?Mod).

// Modifiers of the original GCL
FL_COMPROMISED(?R,?Mod)  :- FL_REFUTED(?R,?Mod), FL_DEFEATED(?R,?Mod).
FL_DISQUALIFIED(?R,?Mod) :- FL_TRANS_DEFEATS(?R,?R,?Mod).
FL_DISQUALIFIED(?R,?Mod) :- FL_CANCEL_AUX(?Mod,?R).
FL_DISQUALIFIED(?R,?Mod) :- FL_DISQUALIFIED_AUX(?R,?Mod).

/*
// other possibilities
FL_COMPROMISED(?R,?Mod)  :- FL_REFUTED(?R,?Mod).
FL_COMPROMISED(?R,?Mod)  :- FL_DEFEATED(?R,?Mod).
*/

// The original GCL essentially amounts to defining
// FL_COMPROMISED/2 and FL_DISQUALIFIED/2 defined as below.
/*
FL_COMPROMISED(?,?)  :- false.
FL_DISQUALIFIED(?R,?Mod) :- FL_CANCEL_AUX(?Mod,?R).
*/


FL_REFUTES(?R1,?R2,?Mod) :-
	// This order is potentially better, since normally
	// there are fewer overrides than conflicts.
	FL_OVERRIDES_AUX(?Mod,?R1,?R2),
	FL_CONFLICTS(?R1,?R2,?Mod).
FL_REBUTS(?R1,?R2,?Mod)  :-
	FL_CONFLICTS(?R1,?R2,?Mod),
	// but if compromised=defeated then XSB dumps core
	not FL_COMPROMISED(?R1,?Mod).
	//not FL_REFUTED(?R1,?Mod).
	//not FL_REFUTED(?R2,?Mod).   // this seems wrong
	//not FL_DEFEATED(?R1,?Mod).  // this dumps core


/***** refresh the tables used by the defeasible theory ********************/

%refresh :-
	refresh{?(?,?,?), ?(?,?)},
	flora_abolish_table_call(FL_OPPOSES_AUX(?,?,?))@_prolog(flrtables),
	flora_abolish_table_call(FL_OVERRIDES_AUX(?,?,?))@_prolog(flrtables),
	flora_abolish_table_call(FL_CANCEL_AUX(?,?))@_prolog(flrtables),
	caller{?Mod},
	refresh{FL_OPPOSES(?,?)@?Mod, FL_OPPOSES(?,?,?,?)@?Mod},
	refresh{FL_OVERRIDES(?,?)@?Mod, FL_OVERRIDES(?,?,?,?)@?Mod},
	refresh{FL_CANCEL(?)@?Mod, FL_CANCEL(?,?)@?Mod}.

/************************ Debugging ***************************************/

/*
   FL_STATUS(Id,Head)[howDefeated->Reason] can be used to find out what is defeated
   and why. No need to reify the ?H argument or attach the module to it.
   This method finds out the caller module and replaces the module of Head
   with the caller module.
*/

FL_STATUS(?I,?H)[howDefeated -> refutedBy(?DI,?DH)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	?R = (?I,?HM),
	FL_REFUTES((?DI,?DH),?R,?Mod), not FL_COMPROMISED((?DI,?DH),?Mod).
FL_STATUS(?I,?H)[howDefeated -> rebuttedBy(?DI,?DH)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	?R = (?I,?HM),
	FL_REBUTS((?DI,?DH),?R,?Mod), not FL_COMPROMISED((?DI,?DH),?Mod).
FL_STATUS(?I,?H)[howDefeated -> disqualified] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	?R = (?I,?HM),
	FL_DISQUALIFIED(?R,?Mod).

FL_STATUS(?I,?H)[info -> refutes(?Refuted)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_REFUTES((?I,?HM),?Refuted,?Mod).
FL_STATUS(?I,?H)[info -> rebuts(?Rebutted)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_REBUTS((?I,?HM),?Rebutted,?Mod).

FL_STATUS(?I,?H)[info->conflictsWith(?Conflict)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_CONFLICTS((?I,?HM),?Conflict,?Mod).

FL_STATUS(?I,?H)[info->candidate] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_CANDIDATE((?I,?HM),?Mod).

FL_STATUS(?I,?H)[howDisqualified->defeatCycle(?Defeater,?Defeated)] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_TRANS_DEFEATS((?I,?HM),(?I,?HM),?Mod),
	// FL_TRANS_DEFEATS is constructed so that it will work when Arg2
	// is bound; it might loop if Arg2 is unbound. This is why ?Defeater
	// and ?Defeated are in Arg1.
	FL_TRANS_DEFEATS(?Defeater,(?I,?HM),?Mod),
	FL_TRANS_DEFEATS(?Defeated,(?I,?HM),?Mod),
	?Defeater != ?Defeated,
	FL_DEFEATS(?Defeater,?Defeated,?Mod).

FL_STATUS(?I,?H)[howDisqualified->canceled] :-
	caller{?Mod},
	change_module(?H,?Mod,?HM),
	FL_CANCEL_AUX(?Mod,(?I,?HM)).


change_module(?InA,?Mod,?OutA) :-
	flora_change_module(?InA,?OutA,?Mod,['In ',FL_STATUS,'(Id,Head)[...]@',_@,': Head must be bound'])@_prolog(flrwrapper).

/***************************** Auxiliary Predicates ***********************/
// this works only if Arg2 is bound
FL_TRANS_DEFEATS(?R1,?R2,?Mod) :- FL_DEFEATS(?R1,?R2,?Mod).
FL_TRANS_DEFEATS(?R1,?R3,?Mod) :-
	// This order seems to be faster than others
	FL_TRANS_DEFEATS(?R2,?R3,?Mod),
	FL_DEFEATS(?R1,?R2,?Mod).

// Given a rule Id and possibly Head, find body and test if it is satisfied.
// This predicate's tables are abolished after each query by an
// after-query hook because sometimes it is called with RId/Head as a var.
// It may succeed for one query and will be tabled.
// If it is, then when called for another query, wrong result may be returned.
FL_CANDIDATE((?RId,?Head),?Mod) :-
	tag{?RId,?Head},
	clause{@{?RId} ?Head@?Mod, ?Body},
	call(?Body).
// Find out if two tags (Id,Head) are in conflict.
// One of the tags might be a variable
FL_CONFLICTS(?L1,?L2,?Mod) :-
	// FL_OPPOSES_AUX(?Mod,?L1,?L2) should be at the beginning, since
	// this is a cheap predicate compared to checking candidacy.
	// FL_OPPOSES_AUX is made symmetric in L1, L2 by an axiom
	// in genincludes/flrdefeasible.fli
	FL_OPPOSES_AUX(?Mod,?L1,?L2),
	FL_CANDIDATE(?L1,?Mod),
	FL_CANDIDATE(?L2,?Mod).


// FL_OPPOSES_AUX/3, FL_OVERRIDES_AUX/3, FL_CANCEL_AUX/2 are defined in
// genincludes/flrdefeasible.fli


// Hook for abolishing FL_CANDIDATE/1 after each query
FL_DEFEASIBLE_CLEANUP(?,?) :- flora_abolish_table_call(${FL_CANDIDATE(?,?)})@_prolog(flrtables).

?- flora_add_hook(_@,QUERYHOOK,after,0,FL_DEFEASIBLE_CLEANUP(?,?))@_prolog(flrhooks).

