/* File:      flrgclp.flr
**
** Author(s): Michael Kifer
**
** Contact:   kifer@cs.stonybrook.edu
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 2008 - 2010;
**      and Vulcan, Inc., 2008 - 2011.
**
** All rights reserved.
**
** For information about licensing terms, please see
** http://silk.projects.semwebcentral.org/flora2-license.html
**
**
*/


/*** The default argumentation theory: GCL, Generalized Courteous Logic.
     Obtained from theoriginal Grosof's GCLP by modifying defeasibility
     and rebuttal.
     The only difference is that this argumentation theory also
     supports cancellation.
*/

#include "flora_terms.flh"
#include "flora_porting.flh"

:- table FL_CANDIDATE/2, FL_STRICT_CANDIDATE/2.
:- table FL_TRANS_DEFEATS/3.
:- prolog FL_REFUTES/3, FL_REBUTS/3.
:- prolog FL_DEFEATS/3.
:- prolog FL_REFUTED/2, FL_REBUTTED/2.
:- prolog FL_CONFLICTS/3.
:- prolog FL_DISQUALIFIED/2.
:- prolog FL_DEFEATED/2.
:- prolog FL_COMPROMISED/2.
//:- table FL_UNDEFEATED/3.  // DO NOT TABLE - useless
:- prolog FL_UNDEFEATED/3.
:- prolog beaten_by_strict_rule/2, beaten_by_strict_rule/3,
	  change_module/4, change_module_nocheck/4,
	  check_module_to_AT_association/1.

:- symbol_context FL_DEFEATED(?,?)@?, beaten_by_strict_rule(?,?,?)@?.

// All the FL_* names are defined in flora_terms.flh to make it easier to change
//:- export FL_UNDEFEATED(?,?,?).
:- export %refresh.
:- export ?[howDefeated -> ?],
	  ?[info->?],
	  ?[howDisqualified->?].
:- export opposes(?,?),
	  overrides(?,?),
	  defeated(?).

:- ignore_depchk %abort(?)@_system.

/*
  Note 1: FL_UNDEFEATED/3 must be called with the third argument bound to
          the user module name in which defeasible theory is invoked.
          This is done by the compiler.
  Note 2: We should make sure that ?R and ?Mod are ground.
          If ?Mod is not ground, it is an error (should catch).
          If ?R is non-ground, the result is incorrect: false{defeated} ==
          not Exists defeated, while we need Exists not defeated.
*/
FL_UNDEFEATED(?I,?H,?Mod) :-
	naf FL_DEFEATED((?I,?H),?Mod).

// These are mostly for debugging
// Note: when ?H,?H1,?H2 are bound by the user, they should be reified
// For instance: defeated((?I,${neg a}))@_gcl.
defeated((?T,?H)) :-
	caller{?Mod},
	change_module_nocheck(?H,?Mod,?RealMod,?MH),
	FL_DEFEATED((?T,?MH),?RealMod).

opposes((?T1,?H1),(?T2,?H2)) :-
	caller{?Mod},
	change_module_nocheck(?H1,?Mod,?RealMod,?MH1),
	change_module_nocheck(?H2,?Mod,?RealMod,?MH2),
	FL_OPPOSES_AUX(?RealMod,(?T1,?MH1),(?T2,?MH2)).

overrides((?T1,?H1),(?T2,?H2)) :-
	caller{?Mod},
	change_module_nocheck(?H1,?Mod,?RealMod,?MH1),
	change_module_nocheck(?H2,?Mod,?RealMod,?MH2),
	FL_OVERRIDES_AUX(?RealMod,(?T1,?MH1),(?T2,?MH2)).

check_module_to_AT_association(?Mod) :-
	\+flora_defeasible_module_registry(?Mod,_@)@_prolog(flrregistry),
	?Mod \== _@,
	!,
	%abort(['User module ', ?Mod,
	        ' is not associated with the argumentation theory residing in module ',
		 _@])@_system.
check_module_to_AT_association(?) :- true.


// Axioms for Courteous LP

FL_DEFEATED(?R,?Mod) :- FL_DEFEATS(?S,?R,?Mod), not FL_COMPROMISED(?S,?Mod).
FL_DEFEATED(?R,?Mod) :- FL_DISQUALIFIED(?R,?Mod).

FL_DEFEATS(?R1,?R2,?Mod) :- FL_REFUTES(?R1,?R2,?Mod).
FL_DEFEATS(?R1,?R2,?Mod) :- FL_REBUTS(?R1,?R2,?Mod).

FL_REFUTED(?R,?Mod)   :- FL_REFUTES(?,?R,?Mod).
// rebutted/2 is unused in this version of the argumentation theory
FL_REBUTTED(?R,?Mod)  :- FL_REBUTS(?,?R,?Mod).

// Modifiers of the original GCL: FL_COMPROMISED and FL_DISQUALIFIED
FL_COMPROMISED(?R,?Mod)  :- FL_REFUTED(?R,?Mod), FL_DEFEATED(?R,?Mod).
FL_DISQUALIFIED(?R,?Mod) :- FL_TRANS_DEFEATS(?R,?R,?Mod).
FL_DISQUALIFIED(?R,?Mod) :- beaten_by_strict_rule(?R,?Mod).
FL_DISQUALIFIED(?R,?Mod) :- FL_CANCEL_AUX(?Mod,?R).
// FL_DISQUALIFIED_AUX expresses interaction  of defeat and cancellation:
// Cancellation rule is disqualified if the rule being canceled has higher
// priority than the cancellation rule itself
FL_DISQUALIFIED(?R,?Mod) :- FL_DISQUALIFIED_AUX(?R,?Mod).

/*
// other possibilities
FL_COMPROMISED(?R,?Mod)  :- FL_REFUTED(?R,?Mod).
FL_COMPROMISED(?R,?Mod)  :- FL_DEFEATED(?R,?Mod).
*/

// The original GCL essentially amounts to defining
// FL_COMPROMISED/2 and FL_DISQUALIFIED/2 defined as below.
/*
FL_COMPROMISED(?,?)  :- false.
FL_DISQUALIFIED(?R,?Mod) :- FL_CANCEL_AUX(?Mod,?R).
*/


FL_REFUTES(?R1,?R2,?Mod) :-
	// This order is potentially better, since normally
	// there are fewer overrides than conflicts.
	FL_OVERRIDES_AUX(?Mod,?R1,?R2),
	FL_CONFLICTS(?R1,?R2,?Mod).
FL_REBUTS(?R1,?R2,?Mod)  :-
	FL_CONFLICTS(?R1,?R2,?Mod),
	// but if compromised=defeated then XSB dumps core
	not FL_COMPROMISED(?R1,?Mod).
	//not FL_REFUTED(?R1,?Mod).
	//not FL_REFUTED(?R2,?Mod).   // this seems wrong
	//not FL_DEFEATED(?R1,?Mod).  // this dumps core


/***** refresh the tables used by the defeasible theory ********************/

%refresh :-
	refresh{?(?,?,?), ?(?,?)},
	caller{?Mod},
	refresh{FL_OPPOSES(?,?)@?Mod, FL_OPPOSES(?,?,?,?)@?Mod},
	refresh{FL_OVERRIDES(?,?)@?Mod, FL_OVERRIDES(?,?,?,?)@?Mod},
	refresh{FL_CANCEL(?)@?Mod, FL_CANCEL(?,?)@?Mod}.

/************************ Debugging ***************************************/

/*
   FL_STATUS(Id,Head)[howDefeated->Reason] can be used to find out what is
   defeated and why. No need to reify the ?H argument or attach a module to it.
   This method finds out the caller module and replaces the module of Head
   with the caller module.
*/
FL_STATUS(?I,?H)[howDefeated -> refutedBy(?DI,?DH)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	?R = (?I,?HM),
	FL_REFUTES((?DI,?DH),?R,?RealMod),
	not FL_COMPROMISED((?DI,?DH),?RealMod).
FL_STATUS(?I,?H)[howDefeated -> rebuttedBy(?DI,?DH)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	?R = (?I,?HM),
	FL_REBUTS((?DI,?DH),?R,?RealMod),
	not FL_COMPROMISED((?DI,?DH),?RealMod).
FL_STATUS(?I,?H)[howDefeated -> disqualified] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	?R = (?I,?HM),
	FL_DISQUALIFIED(?R,?RealMod).

FL_STATUS(?I,?H)[info -> refutes(?Refuted)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_REFUTES((?I,?HM),?Refuted,?RealMod).
FL_STATUS(?I,?H)[info -> rebuts(?Rebutted)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_REBUTS((?I,?HM),?Rebutted,?RealMod).

FL_STATUS(?I,?H)[info->conflictsWith(?Conflict)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_CONFLICTS((?I,?HM),?Conflict,?RealMod).

FL_STATUS(?I,?H)[info->candidate] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_CANDIDATE((?I,?HM),?RealMod).

FL_STATUS(?I,?H)[howDisqualified->defeatCycle(?Defeater,?Defeated)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_TRANS_DEFEATS((?I,?HM),(?I,?HM),?RealMod),
	// FL_TRANS_DEFEATS is constructed so that it will work when Arg2
	// is bound; it might loop if Arg2 is unbound. This is why ?Defeater
	// and ?Defeated are in Arg1.
	FL_TRANS_DEFEATS(?Defeater,(?I,?HM),?RealMod),
	FL_TRANS_DEFEATS(?Defeated,(?I,?HM),?RealMod),
	?Defeater != ?Defeated,
	FL_DEFEATS(?Defeater,?Defeated,?RealMod).

FL_STATUS(?I,?H)[howDisqualified->canceled] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	FL_CANCEL_AUX(?RealMod,(?I,?HM)).

FL_STATUS(?I,?H)[howDisqualified->beatenByStrictRule(?SH)] :-
	caller{?Mod},
	change_module(?H,?Mod,?RealMod,?HM),
	beaten_by_strict_rule((?I,?HM),(?,?SH),?RealMod).


// if ?InA has module _@, change it to ?Mod
// ?RealNewMod is the module of the final OutA
// (the module is not changed if it is not _@).
change_module(?InA,?Mod,?RealNewMod,?OutA) :-
	flora_change_module(?InA,?OutA,(_@,?Mod),?RealNewMod,['In ',FL_STATUS,'(Id,Head)[...]@',_@,': Head must be bound'])@_prolog(flrwrapper),
	check_module_to_AT_association(?RealNewMod).


change_module_nocheck(?InA,?,?,?OutA) :-
	var(?InA),
	!,
	?OutA = ?InA.
// if ?InA has module _@, change it to ?Mod
change_module_nocheck(?InA,?Mod,?RealNewMod,?OutA) :-
	flora_change_module(?InA,?OutA,(_@,?Mod),?RealNewMod,'In defeated/overrides/opposes: something wrong')@_prolog(flrwrapper),
	check_module_to_AT_association(?RealNewMod).


/***************************** Auxiliary Predicates ***********************/
// this works only if Arg2 is bound
FL_TRANS_DEFEATS(?R1,?R2,?Mod) :- FL_DEFEATS(?R1,?R2,?Mod).
FL_TRANS_DEFEATS(?R1,?R3,?Mod) :-
	// This order seems to be faster than others
	FL_TRANS_DEFEATS(?R2,?R3,?Mod),
	FL_DEFEATS(?R1,?R2,?Mod).

// Given a rule Id and possibly Head, find body and test if it is satisfied.
// This predicate's tables are abolished after each query by an
// after-query hook because sometimes it is called with RId/Head as a var.
// It may succeed for one query and will be tabled.
// If it is, then when called for another query, wrong result may be returned.
FL_CANDIDATE((?RId,?Head),?Mod) :-
	/* Must reset term-depth limit, since both tag{...} and clause{...} can
	   retrieve rules with very large bodies. As terms they will be very
	   deep (>100). */
        not FL_CANCEL_AUX(?Mod,(?RId,?Head)),
	current_prolog_flag(max_table_subgoal_depth,?TermDepth)@_prolog,
	set_prolog_flag(max_table_subgoal_depth, 0)@_prolog,
	tag{?RId,?Head},
	clause{@{?RId} ?Head@?Mod, ?Body},
	call(?Body),
	set_prolog_flag(max_table_subgoal_depth, ?TermDepth)@_prolog.

// Find out if two tags (Id,Head) are in conflict.
// One of the tags might be a variable
FL_CONFLICTS(?L1,?L2,?Mod) :-
	// FL_OPPOSES_AUX(?Mod,?L1,?L2) should be at the beginning, since
	// this is a cheap predicate compared to checking candidacy.
	// FL_OPPOSES_AUX is made symmetric in L1, L2 by an axiom
	// in genincludes/flrdefeasible.fli
	FL_OPPOSES_AUX(?Mod,?L1,?L2),
	FL_CANDIDATE(?L1,?Mod),
	FL_CANDIDATE(?L2,?Mod).

// FL_OPPOSES_AUX/3, FL_OVERRIDES_AUX/3, FL_CANCEL_AUX/2 are defined in
// genincludes/flrdefeasible.fli


beaten_by_strict_rule(?R,?Mod) :- beaten_by_strict_rule(?R,?,?Mod).
beaten_by_strict_rule(?R,?Rstrict,?Mod) :-
	FL_OPPOSES_AUX(?Mod,?R,?Rstrict),
	FL_STRICT_CANDIDATE(?Rstrict,?Mod).

FL_STRICT_CANDIDATE((?RId,?Head),?Mod) :-
	/* Must reset term-depth limit, since both tag{...} and clause{...} can
	   retrieve rules with very large bodies. As terms they will be very
	   deep (>100). */
	current_prolog_flag(max_table_subgoal_depth,?TermDepth)@_prolog,
	set_prolog_flag(max_table_subgoal_depth, 0)@_prolog,
	\+tag{?RId,?Head}, // strict
	clause{@{?RId} ?Head@?Mod, ?Body},
	call(?Body),
	set_prolog_flag(max_table_subgoal_depth, ?TermDepth)@_prolog.

/***** refresh the tables used by the defeasible theory ********************/

// Hook for abolishing FL_CANDIDATE/1 after each query
FL_DEFEASIBLE_CLEANUP(?,?) :- flora_abolish_table_call(${FL_CANDIDATE(?,?)})@_prolog(flrtables).

?- flora_add_hook(_@,QUERYHOOK,after,0,FL_DEFEASIBLE_CLEANUP(?,?))@_prolog(flrhooks).

// must have this in order for FL_STATUS to have right argument translation
?- flora_set_argdef(FL_STATUS,2,[FL_OID,FL_BODYFORMULA],_@)@_prolog(flrarguments).
