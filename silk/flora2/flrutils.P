/* File:      flrutils.P
**
** Author(s): Guizhen Yang
**            Michael Kifer
**
** Contact:   kifer@cs.stonybrook.edu
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2010.
**
** All rights reserved.
**
** For information about licensing terms, please see
** http://silk.projects.semwebcentral.org/flora2-license.html
**
**
*/


:- compiler_options([xpp_on]).

#include "standard.h"

#include "flora_characters.flh"
#include "flora_terms.flh"
#include "flora_errors.flh"
#include "flora_porting.flh"
#include "flora_extensions.flh"
#include "flora_exceptions.flh"
#include "flora_status_codes.flh"



?- bootstrap_flora.


/*************************************************************************
  flora_compile_internal(+File)
  Compiles user modules
*************************************************************************/
flora_compile_internal(File) :-
	flora_compile_internal(File,FLORA_DEFAULT_WORKSPACE).


/******************************************************************************
  flora_compile_internal(+File,+Workspace)
  Compiles user modules
  The OBJ file is renamed using the module name
******************************************************************************/
flora_compile_internal(OrigFile,Workspace) :-
	flora_check_filename(OrigFile,File),
	valid_flora_module_name(Workspace),
	( flora_locate_file(File,FLORA_FILE_EXT,FlrFile) ->
	    flora_compile_then_prolog_compile(FlrFile,Workspace)
	;
	  flora_flrfilename_error(File),
	  !,
	  fail
	),
	!.


/*************************************************************************
  flora_compile_add(+File)
  Compiles flora files for adding into "main" module
*************************************************************************/
flora_compile_add(File) :-
	flora_compile_add(File,FLORA_DEFAULT_WORKSPACE).


/******************************************************************************
  flora_compile_add(+File,+Workspace)
  Compiles flora files for adding into module
  The OBJ file is renamed using the module name
******************************************************************************/
flora_compile_add(OrigFile,Workspace) :-
	flora_check_filename(OrigFile,File),
	valid_flora_module_name(Workspace),
	( flora_locate_file(File,FLORA_FILE_EXT,FlrFile) ->
	    flora_compile_then_prolog_compile_add(FlrFile,Workspace)
	;
	  flora_flrfilename_error(File),
	  !,
	  fail
	),
	!.

/**********************************************************************
  flora_add_module_dyn(+File,+Workspace)
  File must be a FLORA file.
**********************************************************************/
flora_add_module_dyn(OrigInFile,Workspace) :-
	flora_check_filename(OrigInFile,InFile),
	valid_flora_module_name(Workspace),
	(\+ '_isloaded'(Workspace)
	-> flora_error_line('Cannot add clauses to an unloaded module, ~w~n',
			    Workspace),
	    fail
	; true
	),
	flora_get_user_program_maybe(InFile,File),
	( flora_locate_file(File,FLORA_FILE_EXT,FlrFile) ->
	    flora_fladd(FlrFile,Workspace)
	;
	  flora_flrfilename_error(InFile),
	  !,
	  fail
	),
	!.


/**********************************************************************
  flora_add_module_dyn(+File)
  File must be a FLORA file.
**********************************************************************/
flora_add_module_dyn(InFile) :-
	flora_add_module_dyn(InFile,FLORA_DEFAULT_WORKSPACE).
	

/**********************************************************************
  flora_load_module_internal(+File,+Workspace)
  File must be a FLORA file.
**********************************************************************/
flora_load_module_internal(OrigInFile,Workspace) :-
	flora_check_filename(OrigInFile,InFile),
	valid_flora_module_name(Workspace),
	flora_get_user_program_maybe(InFile,File),
	( flora_locate_file(File,FLORA_FILE_EXT,FlrFile) ->
	    flora_flload(FlrFile,Workspace)
	;
	  flora_flrfilename_error(InFile),
	  !,
	  fail
	),
	!.


/**********************************************************************
  flora_load_module_internal(+File)
  File may be a FLORA file, Prolog file, or OBJ file.
**********************************************************************/
flora_load_module_internal(OrigInFile) :-
	flora_check_filename(OrigInFile,InFile),
	flora_get_user_program_maybe(InFile,File),
	( flora_locate_file(File,FLORA_FILE_EXT,FlrFile) ->
	    flora_flload(FlrFile,FLORA_DEFAULT_WORKSPACE)

	; flora_locate_file(File,PROLOG_PFILE_EXT,PFile) ->
	    flora_stdmsg_nl,
	    flora_loader_message('Consulting ~w',[PFile]),
	    %% Note: when the loaded file has prolog extension, we don't know
	    %% if this is a Prolog module or a FLORA compiled output.
	    %% So, just in case we arrange the GPP options, but don't rename
	    %% the .xwam file. Maybe we should use a different extension for
	    %% the target of FLORA compilation?
	    flora_set_xpp_options_for_prolog_compile(FLORA_DEFAULT_WORKSPACE),
	    flora_add_xpp_options('-warninglevel 1 '),
	    (subsumptive_tabling_in_effect(FLORA_DEFAULT_WORKSPACE)
	    -> flora_add_xpp_options('-D FLORA_SUBSUMPTIVE_TABLING ')
	    ; true
	    ),
	    (incremental_tabling_in_effect(FLORA_DEFAULT_WORKSPACE)
	    -> flora_add_xpp_options('-D FLORA_INCREMENTAL_TABLING ')
	    ; true
	    ),
	    consult(PFile),
	    flora_clear_xpp_options

	; flora_locate_file(File,PROLOG_OFILE_EXT,OFile) ->
	    flora_stdmsg_nl,
	    flora_loader_message('Consulting ~w',[OFile]),
	    consult(OFile)

	; parse_filename(File,_,_,Ext), 
          Ext \== '', Ext \== PROLOG_OFILE_EXT, Ext \== PROLOG_PFILE_EXT, Ext \== FLORA_FILE_EXT,
	  flora_file_op(exists,File)
	->
	    flora_stderr_nl,
	    flora_error_line('~w: Filename extension must be ~w, ~w or ~w',
	                     [File,FLORA_FILE_EXT,PROLOG_PFILE_EXT,PROLOG_OFILE_EXT]),
	    fail
	;
	  flora_stderr_nl,
	  flora_error_line('File ~w[.{~w|~w|~w}] does not exist',
			   [File,FLORA_FILE_EXT,PROLOG_PFILE_EXT,PROLOG_OFILE_EXT]),
          fail
        ),
	!.



/**********************************************************************
  flloadtrailer(+TrailerOptions,+Workspace)
  TrailerOptions is a list
  [FL_EQUALITY(...),FL_INHERITANCE(...),FL_TABLING(...),FL_CUSTOM(...)]
  The FLOBJEQLDEF option is also possible.
  Maintains trailer registry.
  Won't load trailer if the workspace has a trailer with identical semantics.
**********************************************************************/
flloadtrailer(TrailerOptions,Workspace) :-
	valid_flora_module_name(Workspace),
	%% Check trailer options
	get_trailer_options(Workspace,CurrentTrailerOptions),
	(CurrentTrailerOptions == []
	-> DefaultTrailerOptions = FLORA_DEFAULT_SEMANTICS
	;
	    DefaultTrailerOptions = CurrentTrailerOptions
	),
	sort(DefaultTrailerOptions,SortedDefaultTrailerOptions),
	fixup_trailer_options(TrailerOptions,SortedDefaultTrailerOptions,NewTrailerOptions),
	sort(NewTrailerOptions,SortedNewTrailerOptions),
	( % requested opts = current default
	    SortedDefaultTrailerOptions = SortedNewTrailerOptions,
	    CurrentTrailerOptions \= [],  % not a new module
	    !
	; % Requested trailer options are different from current options
	    flora_slash(S),
	    flora_make_trailer_filename(SortedNewTrailerOptions,TrailerFileName),
	    %% Get file names in user dir.
	    flora_user_flora_dir(UserFloraDir),
	    flora_concat_atoms([UserFloraDir,S,TrailerFileName],UserTrailerPFile),
	    flora_mainO_filename(UserTrailerPFile,UserTrailerOFile),
	    flora_WSO_filename(UserTrailerPFile,Workspace,UserTrailerWSOFile),
	    %% Copy the main file to user directory.
	    (
	      %% Would be good to do something more sophisticated here.
	      %% E.g., comparing with files in ./closure/ and the custom file
	      flora_file_op(exists,UserTrailerPFile) -> true
	    ;
	      telling(PreOutFile),
	      tell(UserTrailerPFile),
	      include_xpp_control_variables(['LOADABLETRAILER'|SortedNewTrailerOptions]),
	      flora_include_file([FLTRAILER],_FileStatus),
	      /*
	          Must include FLHEADER2, which has static tabling definitions
		      :- table ...
                  Otherwise, dynamic tabling directives
		      ?- table ... as variant/subsumptive
	          do not seem to cause predicates to be tabled.
	      */
	      flora_include_file([FLHEADER2,FLDYNDECLARE],_FileStatus),
	      told,
	      tell(PreOutFile)
	    ),
	    check_custom_trailer_file(SortedNewTrailerOptions),
	    ( flora_file_newerthan(UserTrailerWSOFile,UserTrailerPFile)
	    ->
		true
	    ; 
		flora_set_xpp_options_for_prolog_compile(Workspace),
		(subsumptive_tabling_requested(SortedNewTrailerOptions)
		-> flora_add_xpp_options('-D FLORA_SUBSUMPTIVE_TABLING ')
		;  true
		),
		(incremental_tabling_requested(SortedNewTrailerOptions)
		-> flora_add_xpp_options('-D FLORA_INCREMENTAL_TABLING ')
		;  true
		),
		%%compile(UserTrailerPFile,[optimize,spec_repr,ti_all]),
		compile(UserTrailerPFile,[optimize,ti_all]),
		flora_rename_file(UserTrailerOFile,UserTrailerWSOFile),
		flora_clear_xpp_options
	    ),
	    %% abolish tables after loading the trailer
	    catch(abolish_all_tables,_,flora_warning_line(WARN_TABLED_FLLOAD,[setsemantics])),
	    consult(UserTrailerWSOFile)
	),
	!,
	%% Check if the patch needs to be loaded.
	%% Patch (.xsb/flora/patch.P) is loaded only once per workspace
	%% and only into the flora shell. The flora_module_registry/1 guard
	%% ensures this and that patch rules are never loaded into the same
	%% module as compiled programs.
	(flora_module_registry(Workspace) -> true
	; 
	    flloadpatch(Workspace)
	),
	!.


%% Unify TrailerOptions with the module semantics
fltrailersemantics(TrailerOptions,Workspace) :-
	valid_flora_module_name(Workspace),
	%% Check trailer options
	get_trailer_options(Workspace,CurrentTrailerOptions),
	fixup_trailer_options([],CurrentTrailerOptions,FixedTrailerOptions),
	unify_trailer_options(TrailerOptions,FixedTrailerOptions).

unify_trailer_options([],_FixedTrailerOptions).
unify_trailer_options([Opt|TrailerOptions],FixedTrailerOptions) :-
	member(Opt,FixedTrailerOptions),
	unify_trailer_options(TrailerOptions,FixedTrailerOptions).


/**********************************************************************
  flloadpatch(+Workspace)
  This is loaded only in the shell and only once per module.
  Compiled programs have their patch rules included by flora_generate_Pfile/8,
  and they don't need flloadpatch/1. (In fact, compiled rules and patch
  rules clash and should never be loaded into the same workspace.
**********************************************************************/
flloadpatch(Workspace) :-
	flora_slash(S),
	%% Get file names in user dir.
	flora_user_flora_dir(UserFloraDir),
	flora_concat_atoms([UserFloraDir,S,'patch.P'],UserPatchPFile),
	flora_mainO_filename(UserPatchPFile,UserPatchOFile),
	flora_WSO_filename(UserPatchPFile,Workspace,UserPatchWSOFile),
	%% Copy the main file to user directory.
	( flora_file_op(exists,UserPatchPFile) -> true
	;
	    telling(PreOutFile),
	    tell(UserPatchPFile),
	    %% Creating .xsb/flora/patch.P
	    flora_include_file([FLHEADER,FLDEFINITION,FLHEADER2,FLPATCH,
				FLDYNDECLARE, FLDYNALIB, FLDYNZLIB,
				FLOPPOSESBASELIB,
				FLPREDDEF,FLREFRESHTABLE],_FileStatus),
	    told,
	    tell(PreOutFile)
	),
	( flora_file_newerthan(UserPatchWSOFile,UserPatchPFile)
	->
	    true
	;
	    flora_set_xpp_options_for_prolog_compile(Workspace),
	    (subsumptive_tabling_in_effect(Workspace)
	    -> flora_add_xpp_options('-D FLORA_SUBSUMPTIVE_TABLING ')
	    ;  true
	    ),
	    (incremental_tabling_in_effect(Workspace)
	    -> flora_add_xpp_options('-D FLORA_INCREMENTAL_TABLING ')
	    ;  true
	    ),
	    compile(UserPatchPFile,[optimize,ti_all]),
	    flora_rename_file(UserPatchOFile,UserPatchWSOFile),
	    flora_clear_xpp_options
        ),
	consult(UserPatchWSOFile),
	!.


/*************************************************************************
  flora_user_flora_dir(-Dir)
*************************************************************************/
flora_user_flora_dir(Dir) :-
	( flora_configuration(userdir,Dir) ->
	    true
	;
	    flora_user_home(UserHome),
	    flora_slash(S),
	    %% something like $HOME/.xsb/flora
	    flora_concat_atoms([UserHome,S,PROLOG_CUSTOM_DIR,S,flora],Dir),
	    ( flora_file_op(exists,Dir) -> true
	    ;
		( flora_file_op(mkdir,Dir) -> true
		;
		    flora_abort(['Cannot create directory: ',Dir])
		)
	    ),
	    assert(flora_configuration(userdir,Dir))
	),
	!.

flora_user_tmpfile(Filename) :-
	flora_user_flora_dir(Dir),
	flora_slash(S),
	flora_concat_atoms([Dir,S,'tmp$user'],Filename).


/*************************************************************************
   flora_rename_file(+F1,+F2)
   This is like flora_file_op(rename,F1,F2), but it issues an error when fails.
   The reason is that on Windows files sometimes fail to be renamed for 
   strange reasons, so we first delete F2, try to rename, and if failed,
   issue an error, which explains what happened.
   There is no point to continue after a failure, because Flora 
   will be in a broken state.
*************************************************************************/
flora_rename_file(F1,F2) :-
	( (flora_file_op(unlink,F2), !; true),
	    flora_file_op(rename,F1,F2), !
	;
	    flora_abort(['Something wrong -- cannot rename ',F1,' to ',F2])
	).



/*************************************************************************
  flora_compile_then_prolog_compile_add(+FlrFile,+ModuleName)

  This procedure is called to compile either a Flora user module or a
  Flora system module. In the former case, the module name is an atom
  whereas in the latter case the module name looks like _name.
  It first calls the FLORA-2 compiler and then Prolog compiler.
*************************************************************************/
flora_compile_then_prolog_compile_add(FlrFile,ModuleName) :-
	flora_addP_filename(FlrFile,APFile),
	flora_addFDB_filename(FlrFile,FDBFile),
	flora_addFLD_filename(FlrFile,FLDFile),
	flora_set_xpp_options_for_compile(ModuleName),
	flora_compile_file_add(FlrFile,APFile,FDBFile,FLDFile,Status),
	( Status == FLORA_FAILURE ->
	    flora_clear_xpp_options,
	    !,
	    fail
	;
 	  flora_addO_filename(FlrFile,AOFile),
	  flora_loader_message('Invoking XSB compiler'),
	  (
	    %% Issue only important preprocessor warnings
	    %% to avoid warnings when atoms or strings have \n in them
	    flora_set_xpp_options_for_prolog_compile(ModuleName),
	    flora_add_xpp_options('-warninglevel 1 '),
	    (subsumptive_tabling_in_effect(ModuleName)
	    -> flora_add_xpp_options('-D FLORA_SUBSUMPTIVE_TABLING ')
	    ;  true
	    ),
	    (incremental_tabling_in_effect(ModuleName)
	    -> flora_add_xpp_options('-D FLORA_INCREMENTAL_TABLING ')
	    ;  true
	    ),
	    compile(APFile,[optimize,ti_all]) ->
	      true
	  ;
	    flora_clear_xpp_options,
	    fail
	  ),
	  !,
	  flora_clear_xpp_options,
	  flora_check_module_name(ModuleName),
	  flora_addWSO_filename(FlrFile,ModuleName,WSOFile),
	  flora_rename_file(AOFile,WSOFile)
        ),
	!.


/*************************************************************************
  flora_compile_then_prolog_compile(+FlrFile,+ModuleName)

  This procedure is called to compile either a Flora user module or a
  Flora system module. In the former case, the module name is an atom
  whereas in the latter case the module name looks like _name.
  It first calls the FLORA-2 compiler and then Prolog compiler.
*************************************************************************/
flora_compile_then_prolog_compile(FlrFile,ModuleName) :-
	flora_mainP_filename(FlrFile,MPFile),
	flora_FDB_filename(FlrFile,FDBFile),
	flora_FLD_filename(FlrFile,FLDFile),
	flora_set_xpp_options_for_compile(ModuleName),
	flora_compile_file(FlrFile,MPFile,FDBFile,FLDFile,Status),
	( Status == FLORA_FAILURE ->
	    flora_clear_xpp_options,
	    !,
	    fail
	;
	  flora_mainO_filename(FlrFile,MOFile),
	  flora_loader_message('Invoking XSB compiler'),
	  (
	    %% Issue only important preprocessor warnings
	    %% to avoid warnings when atoms or strings have \n in them
	    flora_set_xpp_options_for_prolog_compile(ModuleName),
	    flora_add_xpp_options('-warninglevel 1 '),
	    (subsumptive_tabling_in_effect(ModuleName)
	    -> flora_add_xpp_options('-D FLORA_SUBSUMPTIVE_TABLING ')
	    ;  true
	    ),
	    (incremental_tabling_in_effect(ModuleName)
	    -> flora_add_xpp_options('-D FLORA_INCREMENTAL_TABLING ')
	    ;  true
	    ),
	    compile(MPFile,[optimize,ti_all]) ->
	      true
	  ;
	    flora_clear_xpp_options,
	    fail
	  ),
	  !,
	  flora_clear_xpp_options,
	  flora_check_module_name(ModuleName),
	  flora_WSO_filename(FlrFile,ModuleName,WSOFile),
	  flora_rename_file(MOFile,WSOFile)
        ),
	!.


/******************************************************************************
  flora_compile_system_module(+File)

  Compile a Flora system module in the lib/ directory. 

  This predicate is used *ONLY* in the make file for simplicity.
******************************************************************************/
flora_compile_system_module(File) :-
	%% Get the system module ID from the base file name.
	flora_file_op(basename,File,BaseName),
	flora_sysmod_file(ModuleName,BaseName,_SubDir),
	( flora_locate_file(BaseName,FLORA_FILE_EXT,FlrFile) ->
	    flora_check_module_name(ModuleName),
	    flora_compile_then_prolog_compile(FlrFile,ModuleName)
	;
	  flora_stderr_nl,
	  flora_error_line('File ~w[.~w] does not exist',
			   [BaseName,FLORA_FILE_EXT]),
	  !,
          fail
	),
	!.


/*************************************************************************
  flora_load_system_module_internal(+ModuleName)

  This predicate is called to load a Flora system module. The input is
  its ID.
*************************************************************************/
flora_load_system_module_internal(ModuleName) :-
	( atom(ModuleName), flora_sysmod_file(ModuleName,BaseName,SubDir)
	->
	    flora_check_module_name(ModuleName),
	    %% Compute the Flora file name.
	    flora_configuration(installdir,FloraDir),
	    flora_slash(S),
	    flora_concat_atoms([FloraDir,S,SubDir,S,BaseName,'.flr'],FlrFile),
	    flora_mainP_filename(FlrFile,PFile),
	    flora_WSO_filename(FlrFile,ModuleName,WSOFile),
	    !,
	    ( flora_file_newerthan(PFile,FlrFile)
	    ->
		true

	    ; flora_file_op(exists,FlrFile) ->
		flora_compile_then_prolog_compile(FlrFile,ModuleName)
	    ;
	      flora_stderr_nl,
	      flora_error_line('System module file `~w'' does not exist',
			       [FlrFile]),
	      !,
	      fail
	    ),
	    !,
	    %% Seems system modules are always prolog-compiled.
	    %% Probably not necessary, but need to look into this.
	    flora_loader_message('loading FLORA system module `~w''',[ModuleName]),
	    %% Issue only important preprocessor warnings
	    %% to avoid warnings when atoms or strings have \n in them
	    flora_set_xpp_options_for_prolog_compile(ModuleName, '-warninglevel 0 '),
	    (subsumptive_tabling_in_effect(ModuleName)
	    -> flora_add_xpp_options('-D FLORA_SUBSUMPTIVE_TABLING ')
	    ;  true
	    ),
	    (incremental_tabling_in_effect(ModuleName)
	    -> flora_add_xpp_options('-D FLORA_INCREMENTAL_TABLING ')
	    ;  true
	    ),
	    consult(WSOFile),
	    flora_clear_xpp_options
	;
	  flora_stderr_nl,
	  flora_error_line('Invalid system module ID ~w -- Loading failed',
			   [ModuleName]),
          !,
	  fail
	),
	!.


/*************************************************************************
  flora_fladd(+FlrFile,+Workspace)

  Need to make sure the GPP options are cleared when this procedure is
  finished.
*************************************************************************/
flora_fladd(FlrFile,Workspace) :-
	flora_addP_filename(FlrFile,APFile),
	flora_addO_filename(FlrFile,AOFile),
	flora_addFDB_filename(FlrFile,FDBFile),
	%% support for undefinedness
	flora_addFLD_filename(FlrFile,FLDFile),

	flora_addWSO_filename(FlrFile,Workspace,WSOFile),
	!,
	flora_set_xpp_options_for_compile(Workspace),
        ( flora_file_newerthan(APFile,FlrFile) ->
	    flora_stdmsg_nl,
	    true
	;
	  flora_compile_file_add(FlrFile,APFile,FDBFile,FLDFile,Status),
	  ( Status == FLORA_FAILURE ->
	      flora_clear_xpp_options,
	      !,
	      fail
	  ;
	    true
	  )
	),
	!,
	flora_loader_message('Adding ~w into module ~w',[FlrFile,Workspace]),
	( flora_file_newerthan(WSOFile,APFile)
	->
	    true
	;
	  (
	    flora_set_xpp_options_for_prolog_compile(Workspace),
	    flora_add_xpp_options('-warninglevel 0 '),
	    (subsumptive_tabling_in_effect(Workspace)
	    -> flora_add_xpp_options('-D FLORA_SUBSUMPTIVE_TABLING ')
	    ;  true
	    ),
	    (incremental_tabling_in_effect(Workspace)
	    -> flora_add_xpp_options('-D FLORA_INCREMENTAL_TABLING ')
	    ;  true
	    ),
	    compile(APFile,[optimize,ti_all])
	  ->
	    true
	  ;
	    flora_clear_xpp_options,
	    fail
	  ),
	  flora_rename_file(AOFile,WSOFile)
        ),
        consult(WSOFile),
	flora_clear_xpp_options,
	!.


/*************************************************************************
  flora_flload(+FlrFile,+Workspace)

  Need to make sure the GPP options are cleared when this procedure is
  finished.
*************************************************************************/
flora_flload(FlrFile,Workspace) :-
	flora_mainP_filename(FlrFile,MPFile),
	flora_mainO_filename(FlrFile,MOFile),
	flora_FDB_filename(FlrFile,FDBFile),
	%% support for undefinedness
	flora_FLD_filename(FlrFile,FLDFile),

	flora_WSO_filename(FlrFile,Workspace,WSOFile),
	!,
	flora_set_xpp_options_for_compile(Workspace),
        ( flora_file_newerthan(MPFile,FlrFile) ->
	    flora_stdmsg_nl,
	    true
	;
	  flora_compile_file(FlrFile,MPFile,FDBFile,FLDFile,Status),
	  ( Status == FLORA_FAILURE ->
	      flora_clear_xpp_options,
	      !,
	      fail
	  ;
	    true
	  )
	),
	!,
	flora_loader_message('Loading ~w into module ~w',[FlrFile,Workspace]),
	( flora_file_newerthan(WSOFile,MPFile)
	->
	    true
	;
	  (
	    flora_set_xpp_options_for_prolog_compile(Workspace),
	    flora_add_xpp_options('-warninglevel 0 '),
	    (subsumptive_tabling_in_effect(Workspace)
	    -> flora_add_xpp_options('-D FLORA_SUBSUMPTIVE_TABLING ')
	    ;  true
	    ),
	    (incremental_tabling_in_effect(Workspace)
	    -> flora_add_xpp_options('-D FLORA_INCREMENTAL_TABLING ')
	    ;  true
	    ),
	    compile(MPFile,[optimize,ti_all])
	  ->
	    true
	  ;
	    flora_clear_xpp_options,
	    fail
	  ),
	  flora_rename_file(MOFile,WSOFile)
        ),
	flora_call_hooks(Workspace,LOADTOMODULE,FlrFile,before,AroundHookLink),
	consult(WSOFile),
	flora_call_hooks(Workspace,LOADTOMODULE,FlrFile,after,AroundHookLink),
	flora_clear_xpp_options,
	!.

	
/*****************************************************************************
  flora_save_user_clauses(+FlrFile)
  Read user input and save it in the given file
*****************************************************************************/
flora_save_user_clauses(FlrFile) :-
	(flora_running_under(windows) -> CtlChar = 'Z' ; CtlChar = 'D'),
	flora_message_line('Type in FLORA program statements; Ctl-~w when done',
			   [CtlChar]),
	flora_copy_input(_,FlrFile),
	flora_message_line('Program saved in file ~w', [FlrFile]).


/*************************************************************************
  flora_get_user_program_maybe(+InFile,-File)
  If InFile = _user assume the user wants to input the program from the shell.
  Return the name of the tempfile that has the program.
*************************************************************************/
flora_get_user_program_maybe(InFile,File) :-
	( InFile == FL_INLINEMODULE ->
	    flora_user_tmpfile(File),
	    flora_concat_atoms([File,'.',FLORA_FILE_EXT],FlrFile),
	    flora_save_user_clauses(FlrFile)
	;
	  File=InFile
	).


/*************************************************************************
  flora_locate_file(+InFile,+ExtType,-ExtFile)

  InFile must have ExtType as extension or no extension (in this case,
  ExtType is appended).
  In case of a URL, copy the Web module into the Web cache directory
  $HOME/.xsb/flora/www_cache/
*************************************************************************/
flora_locate_file(FL_URL(InFile),ExtType,ExtFile) :-
	!,
	%% for URLs we don't check for existence until the curl
	%% package stabilizes
	check_attach_extension(InFile,ExtType,ExtFileName),
	%% FixMe: In principle, we could first check the modtime of the URL
	%% and download it only if it is newer than ExtFile
	curl:load_page(FL_URL(ExtFileName),Document,
		       [redirect(true)],  %% decide which options make sense
		       [DirEnc,FileBase,Suffix,_Size,WebTime],Warn),
	curl:www_cache_filename([redirect(true)],FileBase,Suffix,WWW_cache_Filename),
	(Warn==[] -> true
	;
	    flora_warning_line('while loading ~w: ~w', [InFile,Warn])
	),
	flora_user_flora_dir(UserDir),
	flora_slash(S),
	%% $HOME/.xsb/flora/www_cache/
	flora_concat_atoms([UserDir,S,www_cache],UserWebCache),
	( flora_file_op(exists,UserWebCache) -> true
	;
	    ( flora_file_op(mkdir,UserWebCache) -> true
	    ;
		flora_abort(['Cannot create directory: ',UserWebCache])
	    )
	),
	flora_concat_atoms([UserWebCache,S,DirEnc],InFileCacheDirectory),
	( flora_file_op(exists,InFileCacheDirectory) -> true
	;
	    ( flora_file_op(mkdir,InFileCacheDirectory) -> true
	    ;
		flora_abort(['Cannot create directory: ',InFileCacheDirectory])
	    )
	),
	%% $HOME/.xsb/flora/www_cache/encoded_web_directory/web_file
	flora_concat_atoms([InFileCacheDirectory,S,WWW_cache_Filename],ExtFile),
	(flora_file_op(exists,ExtFile)
	-> flora_file_op(modtime,ExtFile,ExtFileTime)
	;  ExtFileTime = 0
	),
	(Document == ''
	->
	    flora_error_line('Web document ~w[.{~w|~w|~w}] does not exist or is not readable',
			   [InFile,FLORA_FILE_EXT,PROLOG_PFILE_EXT,PROLOG_OFILE_EXT]),
	    fail
	;   ExtFileTime =< WebTime 
	->
	    %% test: [url('http://www.cs.sunysb.edu/~kifer/test/test.flr')].
	    open(ExtFile,write,Stream),
	    write(Stream,Document),
	    close(Stream)
	;   true
	).


flora_locate_file(InFile,ExtType,ExtFile) :-
	check_attach_extension(InFile,ExtType,ExtFileName),
	flora_locate_file(ExtFileName,ExtFile),
	!.
check_attach_extension(InFile,ExtType,ExtFileName) :-
	parse_filename(InFile,_,_,Ext),
	( Ext == ExtType -> ExtFileName=InFile
	;
	    flora_concat_atoms([InFile,'.',ExtType],ExtFileName)
	).


/*************************************************************************
  flora_locate_file(+InFile,-LocatedFile)

  When it succeeds, it returns the absolute file name.
*************************************************************************/
flora_locate_file(In,In) :-
	flora_file_op(isabsolute,In),
	!,
	flora_file_op(exists,In).

flora_locate_file(In,Loc) :-
	flora_module_path_get(LibDir),
	flora_slash(S),
	flora_concat_atoms([LibDir,S,In],File),
	flora_file_op(expand,File,Loc),
	flora_file_op(exists,Loc),
	!.

flora_locate_file(In,Loc) :-
	flora_file_op(expand,In,Loc),
	!,
	flora_file_op(exists,Loc).



/*************************************************************************
  flora_file_newerthan(+File1,+File2)
  returns true if File1 exists and is newer than File2. File2 already exists.
*************************************************************************/
flora_file_newerthan(File1,File2) :-
	flora_file_op(exists,File1),
	flora_file_op(newerthan,File1,File2).



/*************************************************************************
  flora_addP_filename(+File,-APFile)
  flora_addO_filename(+File,-AOFile)
  flora_addFDB_filename(+File,-FDBFile)
  flora_addFLD_filename(+File,-FLDFile)
  flora_addWSO_filename(+File,+WS,-WSOFile)
*************************************************************************/
flora_addP_filename(File,APFile) :-
	parse_filename(File,Dir,Base,_),
	flora_concat_atoms([Dir,Base,'#for_add.',PROLOG_PFILE_EXT],APFile).

flora_addO_filename(File,AOFile) :-
	parse_filename(File,Dir,Base,_),
	flora_concat_atoms([Dir,Base,'#for_add.',PROLOG_OFILE_EXT],AOFile).

flora_addFDB_filename(File,FDBFile) :-
	parse_filename(File,Dir,Base,_),
	flora_concat_atoms([Dir,Base,'#for_add.',FLORA_FDB_EXT],FDBFile).

flora_addFLD_filename(File,FLDFile) :-
	parse_filename(File,Dir,Base,_),
	flora_concat_atoms([Dir,Base,'#for_add.',FLORA_FLD_EXT],FLDFile).

%% File name for the object file with module name attached
flora_addWSO_filename(File,WS,WSOFile) :-
	parse_filename(File,Dir,Base,_),
	flora_concat_atoms([Dir,Base,'_',WS,'#for_add.',PROLOG_OFILE_EXT],WSOFile).


/*************************************************************************
  flora_mainP_filename(+File,-MPFile)
  flora_mainO_filename(+File,-MOFile)
  flora_FDB_filename(+File,-FDBFile)
  flora_FLD_filename(+File,-FLDFile)
  flora_FLH_filename(+File,-FLHFile)
  flora_WSO_filename(+File,+WS,-WSOFile)
  flora_dump_filename(+File,-DFile)
*************************************************************************/
flora_mainP_filename(File,MPFile) :-
	parse_filename(File,Dir,Base,_),
	flora_concat_atoms([Dir,Base,'.',PROLOG_PFILE_EXT],MPFile).

flora_mainO_filename(File,MOFile) :-
	parse_filename(File,Dir,Base,_),
	flora_concat_atoms([Dir,Base,'.',PROLOG_OFILE_EXT],MOFile).

flora_FDB_filename(File,FDBFile) :-
	parse_filename(File,Dir,Base,_),
	flora_concat_atoms([Dir,Base,'.',FLORA_FDB_EXT],FDBFile).

flora_FLD_filename(File,FLDFile) :-
	parse_filename(File,Dir,Base,_),
	flora_concat_atoms([Dir,Base,'.',FLORA_FLD_EXT],FLDFile).

flora_FLH_filename(File,FLHFile) :-
	parse_filename(File,Dir,Base,_),
	flora_concat_atoms([Dir,Base,'.',FLORA_HEADER_EXT],FLHFile).

%% File name for the object file with module name attached
flora_WSO_filename(File,WS,WSOFile) :-
	parse_filename(File,Dir,Base,_),
	flora_concat_atoms([Dir,Base,'_',WS,'.',PROLOG_OFILE_EXT],WSOFile).

flora_dump_filename(File,DFile) :-
	parse_filename(File,Dir,Base,Ext),
	flora_concat_atoms([Dir,Base,'_dump.',Ext],DFile).

flora_FLR_filename(File,FlrFile) :-
	parse_filename(File,Dir,Base,_),
	flora_concat_atoms([Dir,Base,'.',FLORA_FILE_EXT],FlrFile).	
	
/*************************************************************************
  utilities
*************************************************************************/
flora_check_filename(OrigFile,File) :-
	P2H_CONVERSION(File,OrigFile),
	(atom(File), !
	; File = FL_URL(Atom), atom(Atom), !
	; 
	    flora_error_line('invalid file name: ~w', [OrigFile]),
	    fail
	).



/*************************************************************************
  gpp control utilities
*************************************************************************/
%% standard gpp options used by Flora.
flora_xpp_standard_options_for_compile('-F -m -nostdinc -curdirinclast -includemarker "'FLORA_GPP_MARKUP'.@'FLORA_GPP_MARKUP'(?,''?'',''?'')."').
flora_xpp_standard_options_for_prolog_compile('-P -m -nostdinc -curdirinclast -includemarker "'FLORA_GPP_MARKUP'.@'FLORA_GPP_MARKUP'(?,''?'',''?'')."').
flora_xpp_standard_options_for_dump('-F -m -nostdinc -curdirinclast').
flora_xpp_standard_options_for_read('-P -m -nostdinc -curdirinclast').


flora_set_xpp_options_for_compile :- flora_set_xpp_options(compile).
flora_set_xpp_options_for_compile(Module) :-
	flora_set_xpp_options(compile,Module).
flora_set_xpp_options_for_compile(Module,ExtraOpts) :-
	flora_set_xpp_options(compile,Module,ExtraOpts).
flora_set_xpp_options_for_prolog_compile(Module) :-
	flora_set_xpp_options(prolog_compile,Module).
flora_set_xpp_options_for_prolog_compile(Module,ExtraOpts) :-
	flora_set_xpp_options(prolog_compile,Module,ExtraOpts).

flora_set_xpp_options_for_dump(Module,ExtraOpts) :-
	flora_set_xpp_options(dump,Module,ExtraOpts).


flora_set_xpp_options_for_read :- flora_set_xpp_options(read).
flora_set_xpp_options_for_read(Module) :- flora_set_xpp_options(read,Module).
flora_set_xpp_options_for_read(Module,ExtraOpts) :-
	flora_set_xpp_options(read,Module,ExtraOpts).


flora_set_xpp_options(Purpose) :-
	flora_clear_xpp_options,
	(Purpose==read
	-> flora_xpp_standard_options_for_read(StandardOpt)
	; Purpose==dump
	-> flora_xpp_standard_options_for_dump(StandardOpt)
	; Purpose==prolog_compile
	-> flora_xpp_standard_options_for_prolog_compile(StandardOpt)
	; flora_xpp_standard_options_for_compile(StandardOpt)
	),
	(Purpose==prolog_compile, !
	; %% don't increment counter when loading trailers and things like that
	    flora_increment_counter(flora_compile_id,1,_,Id)
	),
	flora_concat_items([StandardOpt,' -D FLORA_COMPILATION_ID=',Id,' '],Opt),
	flora_assert_xpp_options(Opt).


%% This is always called before invoking GPP.
%% If ModuleName looks like a system module name (_module) then adds
%% extra options for compiling system modules.
%% Note: This predicate should not be called before a previous call of
%% flora_set_xpp_options finishes.
%% Purpose is either read or compile.
flora_set_xpp_options(Purpose,ModuleName) :-
	flora_clear_xpp_options,
	flora_check_module_name(ModuleName),
	(flora_is_system_module_name(ModuleName)
	-> ExtraOpt='-D FLORA_COMPILE_SYSTEM_MODULE'
	; flora_check_module_name(ModuleName)
	-> ExtraOpt=''
	; flora_module_name_error(ModuleName)
	),
	(Purpose==read -> flora_xpp_standard_options_for_read(StandardOpt)
	; Purpose==dump -> flora_xpp_standard_options_for_dump(StandardOpt)
	; Purpose==prolog_compile
	-> flora_xpp_standard_options_for_prolog_compile(StandardOpt)
	; flora_xpp_standard_options_for_compile(StandardOpt)
	),
	(Purpose==prolog_compile, !
	; %% don't increment counter when loading trailers and things like that
	    flora_increment_counter(flora_compile_id,1,_,Id)
	),
	flora_concat_items([StandardOpt,' -D FLORA_VAR_WORKSPACE="',ModuleName,
			    '" ',ExtraOpt,' -D FLORA_COMPILATION_ID=',Id,' '],
			   Opt),
	flora_assert_xpp_options(Opt),
	!.


%% Purpose is either read or compile
flora_set_xpp_options(Purpose,ModuleName,ExtraOpt) :-
	flora_set_xpp_options(Purpose,ModuleName),
	flora_add_xpp_options(ExtraOpt).

%% Adds NewOpt to the existing XPP options
flora_add_xpp_options(NewOpt) :-
	xpp_options(XOpt),
	flora_clear_xpp_options,
	flora_concat_atoms([XOpt,' ',NewOpt],Opt),
	flora_assert_xpp_options(Opt).

flora_clear_xpp_options :-
	retractall(xpp_options(_)).

flora_assert_xpp_options(Options) :- assert(xpp_options(Options)).

flora_replace_xpp_options(Options) :-
	flora_clear_xpp_options,
	flora_assert_xpp_options(Options).


/*************************************************************************
  flora_insert_code_for_loaddyn_data(+FileName)

  Add static code to the compiled .P file for loading FDB and FLD files.
*************************************************************************/
flora_insert_code_for_loaddyn_data(FileName) :-
	%% Output the base file name only. The full path will be taken
	%% care of by flora_loaddyn_data and consult.
	parse_filename(FileName,_Dir,Base,Ext),
	( Ext == FLORA_FDB_EXT, DataCat='FDB'
	; Ext == FLORA_FLD_EXT, DataCat='FLD'
	),
	%% The if-then-else play of FLORA_FDB_FILENAME and FLORA_FLD_FILENAME,
	%% controls whether flora_loaddyn_data/3 is used to load dynamic data
	%% or directly flora_read_canonical_and_insert/2
	%% Normally FLORA_FDB_FILENAME/FLORA_FLD_FILENAME are not defined,
	%% so data is loaded using flora_loaddyn_data/3.
	%% However, when we are trying to produce a dump of the program (where all
	%% the preprocessor stuff is stripped), then we don't need 
	%% flora_loaddyn_data/3 (whose primary purpose is to invoke the preprocessor
	%% before invoking flora_read_canonical_and_insert/2).
	%% In this case, we put the .P file through the preprocessor with
	%% FLORA_FDB_FILENAME set to ''. The result is that in the dumped
	%% program only the call to flora_read_canonical_and_insert/2 will stay.
	flora_current_out_line("#if !defined(FLORA_~w_FILENAME)",[DataCat]),
	flora_current_out_line('#if !defined(FLORA_LOADDYN_DATA)'),
	flora_current_out_line('#define FLORA_LOADDYN_DATA'),
	flora_current_out_line('#endif'),
	flora_current_out_line("#define FLORA_~w_FILENAME  '~w.~w'", [DataCat,Base,Ext]),
	flora_current_out_line("?- flrutils:flora_loaddyn_data(FLORA_~w_FILENAME,FLORA_THIS_MODULE_NAME,'~w').",[DataCat,Ext]),
	flora_current_out_line('#else'),
	flora_current_out_line('#if !defined(FLORA_READ_CANONICAL_AND_INSERT)'),
	flora_current_out_line('#define FLORA_READ_CANONICAL_AND_INSERT'),
	flora_current_out_line('#endif'),
	flora_current_out_line("?- flrutils:flora_read_canonical_and_insert(FLORA_~w_FILENAME,FLORA_THIS_~w_STORAGE).",[DataCat,DataCat]),
	flora_current_out_line('#endif'),
	flora_current_out_nl.


/*************************************************************************
  flora_include_file(+OptionList,-Status)
*************************************************************************/
flora_include_file([],FLORA_SUCCESS) :- !.

flora_include_file([Opt|OptList],Status) :-
	flora_include(Opt,File),
	!,
	flora_configuration(installdir,FloraDir),
	flora_slash(S),
	flora_concat_atoms([FloraDir,S,File],FullName),
	( flora_file_op(exists,FullName) ->
	    flora_copy_input(FullName,_),
	    flora_include_file(OptList,Status)
	;
	  flora_error_line('The FLORA system file ~w cannot be found',
			   [FullName]),
          Status=FLORA_FAILURE
	).

flora_include_file(_OptList,FLORA_FAILURE) :-
	  flora_error_line('System file corrupted').


/*************************************************************************
  flora_end_of_input(+Status)
  flora_not_end_of_input(+Status)
*************************************************************************/
flora_end_of_input(Status) :- member(FLORA_EOF,Status).
flora_not_end_of_input(Status) :- member(FLORA_NOT_EOF,Status).


/*************************************************************************
  flora_reset_modules_for_file(+FullFileName)
*************************************************************************/
flora_reset_modules_for_file(FullFileName) :-
	flora_reset_composer,
	flora_reset_lexer(FullFileName),
	flora_reset_operator,
	flora_reset_prolog,
	flora_reset_compiler,
	flora_set_counter(flora_shell_mode,0),
	retractall(flora_compiler_environment(_,_)),
	assert(flora_compiler_environment(file,FullFileName)),
	!.


/*************************************************************************
  flora_reset_modules_for_shell/0
*************************************************************************/
flora_reset_modules_for_shell :-
	flora_reset_composer,
	flora_reset_lexer,
	flora_reset_compiler,
	flora_set_counter(flora_shell_mode,1),
	retractall(flora_compiler_environment(_,_)),
	assert(flora_compiler_environment(file,userin)).


/*************************************************************************
  flora_compile_file_add(+InputFile,+OutputPFile,+OutputDBFile,+OutputFLDFile,-FileStatus)

  Note: FileStatus returns either FLORA_FAILURE or FLORA_SUCCESS.

        The appropriate GPP options must be set before this procedure is called.
*************************************************************************/
flora_compile_file_add(InputFile,PFile,DBFile,FLDFile,FileStatus) :-
	flora_maxerr(MaxErrNum),
	flora_stdmsg_nl,
	flora_loader_message('Compiling ~w for adding into module',[InputFile]),
	flora_cputime(T0),
	seeing(PreInFile),
	%% Disable the compilation for FLORA template include file.
	flora_set_counter(flora_compile_include_file,0),
	flora_reset_modules_for_file(InputFile),
	xpp_process_file(InputFile,XPP_process,IOportFromProc),
	see(IOportFromProc),
	flora_measure_time(
			   flora_rpc_file_add(MaxErrNum,0,CompiledRuleList,
					      FileOptionList,
					      RuleStatus,CompileStatus),
			   'Compile time '
			   ),
	%% Wait, to not leave zombies.
	process_control(XPP_process,wait(ExitStatus)),
	(ExitStatus==0, !
	; flora_error_line('Error while preprocessing ~w', [InputFile])
	),
	%% Release the file descriptor used to read from cpp.
	%%close(IOportFromProc),
	seen,
	see(PreInFile),
	( CompileStatus == FLORA_FAILURE ->
	    FileStatus=FLORA_FAILURE
	;
	    extract_trailer_options(InputFile,FileOptionList,
				    %% Default options
				    FLORA_DEFAULT_SEMANTICS,
				    StrippedFileOptions,TrailerOptions),
	    (\+flora_warnings_level(nodependency)
	    -> flora_measure_time(
				  check_for_dependencies(CompiledRuleList,DepErrList),
				  'Dependency checking time: '
				  )
	    ;
		flora_loader_message('Dependency checking skipped')
	    ),
	    count_errors(DepErrList,DepErrNum),
	    ( DepErrNum>0 ->
		FileStatus=FLORA_FAILURE
	    ;
		(check_custom_trailer_file(TrailerOptions)
		->
		    flora_generate_code_add(CompiledRuleList,
					    StrippedFileOptions,TrailerOptions,
					    PFile,DBFile,FLDFile,FileStatus)
		; 
		    FileStatus=FLORA_FAILURE
		)
	    )
        ),
	flora_cputime(T1),
	( FileStatus == FLORA_FAILURE ->
	    true
	;
	    T is T1-T0,
	    flora_loader_message('Done! CPU time used: ~w seconds',[T])
	),
	flora_print_warnings([depend(DepErrList)|RuleStatus]),
	flora_print_errors([depend(DepErrList)|RuleStatus]),
	!.

%% Catch a failure
flora_compile_file_add(_InputFile,_PFile,_DBFile,_FLDFile,FLORA_FAILURE).

/*************************************************************************
  flora_generate_code_add(+CompiledRuleList,+FileOptionList,+TrailerOptions,+PFile,+DBFile,+FLDFile,-FileStatus)

  Note: FileStatus returns either FLORA_FAILURE or FLORA_SUCCESS.
*************************************************************************/
flora_generate_code_add(CompiledRuleList,FileOptionList,TrailerOptions,PFile,DBFile,FLDFile,FileStatus) :-
	%% Generate FLD file for undefinedness checking
	flora_debug_code(CompiledRuleList, FLDFile),
	flora_divide_program(CompiledRuleList,RuleList,FactList),
	sort(FileOptionList,FileOptions),
	flora_measure_time(
			   flora_generate_Pfile_add(PFile,
						FileOptions,TrailerOptions,
						RuleList,FactList,
						DBFile,FLDFile,PFileStatus),
			   '[Coder] Generating P file'
			   ),
	( PFileStatus == FLORA_FAILURE ->
	    FileStatus=FLORA_FAILURE
	;
	  ( FactList == [] ->
	      FileStatus=FLORA_SUCCESS
	  ;
	      flora_measure_time(
				 flora_generate_DBfile(DBFile,FactList,FileStatus),
				 '[Coder] Generating DB file'
				 )
	  )
        ),
	!.


/*************************************************************************
  flora_generate_Pfile_add(+PFileName,+FileOptionList,+TrailerOptions,
                       +RuleList,+FactList,
                       +DBFile,+FLDFile,-FileStatus)

  Things to do:
  (1) include .flh file directive.
  (2) output header file.
  (3) syslib and sysmod loading instrucitons.
  (4) DB file loading instruction.
  (5) program.
  (6) trailer.
*************************************************************************/
flora_generate_Pfile_add(PFileName,FileOptionList,TrailerOptions,RuleList,FactList,DBFile,FLDFile,FileStatus) :-
	telling(PreOutFile),
	tell(PFileName),
	findall(LibOption,member(FLSYSLIB(LibOption),FileOptionList),SysLibOptionList),
	findall(ModOption,member(FLSYSMOD(ModOption),FileOptionList),SysModOptionList),
	append(SysLibOptionList,SysModOptionList,OptList),
	( member(XSB_SPECREPR,FileOptionList) -> true
	; flora_current_out_line(':- compiler_options([spec_off]).')
	),
	flora_include_file([FLHEADER],FLHeaderStatus),
	%% we must abolish tables when adding rules, since old tables
	%% may no longer be valid
	flora_concat_atoms(['?- catch(abolish_all_tables,_,flora_warning_line(''',
			    WARN_TABLED_FLLOAD,
			    ''',[''_add''])).'],
			   AbolishCommand),
	flora_current_out_line(AbolishCommand),
	%%
	( FLHeaderStatus == FLORA_FAILURE -> FileStatus=FLORA_FAILURE
	;
	    findall((Arity,Pos),member(FLINDEX(Arity,Pos),FileOptionList),IndexList),
	    write_index_directives(IndexList),
	    include_xpp_control_variables(TrailerOptions),
            flora_include_file(OptList,HeaderStatus),
	    ( HeaderStatus == FLORA_FAILURE -> FileStatus=FLORA_FAILURE
	    ;
		(FactList == [] -> true; 
		    flora_insert_code_for_loaddyn_data(DBFile)
		),
		flora_insert_code_for_loaddyn_data(FLDFile),
		flora_extern_code(RuleList,CoderStatus),
		( CoderStatus == [] ->
		    %% flora_include_file([FLTRAILER,FLDYNZLIB,FLPREDDEF],
		    %%                    FileStatus)
		    true
		;
		    flora_print_errors([coder(CoderStatus)]),
		    FileStatus=FLORA_FAILURE
		)
	    )
	),
	told,
	tell(PreOutFile),
	!.


/*************************************************************************
  flora_compile_file(+InputFile,+OutputPFile,+OutputDBFile,+OutputFLDFile,-FileStatus)

  Note: FileStatus returns either FLORA_FAILURE or FLORA_SUCCESS.

        The appropriate GPP options must be set before this procedure is called.
*************************************************************************/
flora_compile_file(InputFile,PFile,DBFile,FLDFile,FileStatus) :-
	flora_maxerr(MaxErrNum),
	flora_stdmsg_nl,
	flora_loader_message('Compiling ~w',[InputFile]),
	flora_cputime(T0),
	seeing(PreInFile),
	%% Disable the compilation for FLORA template include file.
	flora_set_counter(flora_compile_include_file,0),
	flora_reset_modules_for_file(InputFile),
	xpp_process_file(InputFile,XPP_process,IOportFromProc),
	see(IOportFromProc),
	flora_measure_time(
			   flora_rpc_file(MaxErrNum,0,CompiledRuleList,
					  FileOptionList,
					  RuleStatus,CompileStatus),
			   'Compile time: '
			   ),
	%% Wait, to not leave zombies.
	process_control(XPP_process,wait(ExitStatus)),
	(ExitStatus==0, !
	; flora_error_line('Error while preprocessing ~w', [InputFile])
	),
	%% Release the file descriptor used to read from cpp.
	%%close(IOportFromProc),
	seen,
	see(PreInFile),
	( CompileStatus == FLORA_FAILURE ->
	    FileStatus=FLORA_FAILURE
	;
	    extract_trailer_options(InputFile,FileOptionList,
				    %% Default options
				    FLORA_DEFAULT_SEMANTICS,
				    StrippedFileOptions,TrailerOptions),
	    (\+flora_warnings_level(nodependency)
	    -> flora_measure_time(
				  check_for_dependencies(CompiledRuleList,DepErrList),
				  'Dependency checking time: '
				  )
	    ;
		flora_loader_message('Dependency checking skipped')
	    ),
	    count_errors(DepErrList,DepErrNum),
	    ( DepErrNum>0 ->
		FileStatus=FLORA_FAILURE
	    ;
		(check_custom_trailer_file(TrailerOptions)
		->
		    flora_generate_code(CompiledRuleList,
					StrippedFileOptions,TrailerOptions,
					PFile,DBFile,FLDFile,FileStatus)
		; 
		    FileStatus=FLORA_FAILURE
		)
	    )
        ),
	flora_cputime(T1),
	( FileStatus == FLORA_FAILURE ->
	    true
	;
	    T is T1-T0,
	    flora_loader_message('Done! CPU time used: ~w seconds',[T])
	),
	flora_print_warnings([depend(DepErrList)|RuleStatus]),
	flora_print_errors([depend(DepErrList)|RuleStatus]),
	!.

%% Catch a failure situation.
flora_compile_file(_InputFile,_PFile,_DBFile,_FLDFile,FLORA_FAILURE).


/*************************************************************************
  flora_generate_code(+CompiledRuleList,+FileOptionList,+TrailerOptions,+PFile,+DBFile,+FLDFile,-FileStatus)

  Note: FileStatus returns either FLORA_FAILURE or FLORA_SUCCESS.
*************************************************************************/
flora_generate_code(CompiledRuleList,FileOptionList,TrailerOptions,PFile,DBFile,FLDFile,FileStatus) :-
	%% Generate FLD file for undefinedness checking
	flora_debug_code(CompiledRuleList, FLDFile),
	flora_divide_program(CompiledRuleList,RuleList,FactList),
	sort(FileOptionList,FileOptions),
	flora_measure_time(
			   flora_generate_Pfile(PFile,
						FileOptions,TrailerOptions,
						RuleList,FactList,
						DBFile,FLDFile,PFileStatus),
			   '[Coder] Generating P file'
			   ),
	( PFileStatus == FLORA_FAILURE ->
	    FileStatus=FLORA_FAILURE
	;
	  ( FactList == [] ->
	      FileStatus=FLORA_SUCCESS
	  ;
	      flora_measure_time(
				 flora_generate_DBfile(DBFile,FactList,FileStatus),
				 '[Coder] Generating DB file'
				 )
	  )
        ),
	!.


/*************************************************************************
  flora_generate_Pfile(+PFileName,+FileOptionList,+TrailerOptions,
                       +RuleList,+FactList,
                       +DBFile,+FLDFile,-FileStatus)

  Things to do:
  (1) include .flh file directive.
  (2) output header file.
  (3) syslib and sysmod loading instrucitons.
  (4) DB file loading instruction.
  (5) program.
  (6) trailer.
*************************************************************************/
flora_generate_Pfile(PFileName,FileOptionList,TrailerOptions,RuleList,FactList,DBFile,FLDFile,FileStatus) :-
	telling(PreOutFile),
	tell(PFileName),
	findall(LibOption,member(FLSYSLIB(LibOption),FileOptionList),SysLibOptionList),
	findall(ModOption,member(FLSYSMOD(ModOption),FileOptionList),SysModOptionList),
	append(SysLibOptionList,SysModOptionList,OptList),
	( member(XSB_SPECREPR,FileOptionList) -> true
	; flora_current_out_line(':- compiler_options([spec_off]).')
	),
	/*
	  include_xpp_control_variables/1 should be before FLHEADER2
	  so that the definitions of
	  FLORA_SUBSUMPTIVE_TABLING, FLORA_INCREMENTAL_TABLING
	  will affect the tabling definitions included from FLHEADER2
	*/
	include_xpp_control_variables(TrailerOptions),
	flora_include_file([FLHEADER,FLHEADER2,FLDYNDECLARE],FLHeaderStatus),
	( FLHeaderStatus == FLORA_FAILURE -> FileStatus=FLORA_FAILURE
	;
	    findall((Arity,Pos),member(FLINDEX(Arity,Pos),FileOptionList),IndexList),
	    write_index_directives(IndexList),
	    flora_include_file([FLDEFINITION,FLTRAILERREGISTRY,
				FLREFRESHTABLE,FLLIBIMPORTEDCALLS,
				FLINDEX_P,FLPATCH,
				FLOPPOSESBASELIB,
				FLDYNDECLARE,
				FLDYNALIB|OptList],
			       HeaderStatus),
	    ( HeaderStatus == FLORA_FAILURE -> FileStatus=FLORA_FAILURE
	    ;
		(FactList == [] -> true; flora_insert_code_for_loaddyn_data(DBFile)),
		flora_insert_code_for_loaddyn_data(FLDFile),
		flora_extern_code(RuleList,CoderStatus),
		( CoderStatus == [] ->
		    flora_include_file([FLTRAILER,FLDYNZLIB,FLPREDDEF],
				       FileStatus)
		;
		    flora_print_errors([coder(CoderStatus)]),
		    FileStatus=FLORA_FAILURE
		)
	    )
        ),
	told,
	tell(PreOutFile),
	!.

/*************************************************************************
  write_index_directives(+IndexList)
  For every pair (A,P) in the list, generate code (assuming A+1=A1,P+1=P1)
  :- index WRAP_NONTABLED_HILOG/A1-P1.
  ?- index(FLDYNAPREFIX(WRAP_NONTABLED_HILOG)/A1,P1).
  ?- index(FLDYNZPREFIX(WRAP_NONTABLED_HILOG)/A1,P1).
or
  :- index WRAP_TABLED_HILOG/A1-P1.
  ?- index(FLDYNAPREFIX(WRAP_TABLED_HILOG)/A1,P1).
  ?- index(FLDYNZPREFIX(WRAP_TABLED_HILOG)/A1,P1).
*************************************************************************/
write_index_directives([]) :- !.
write_index_directives([(A,P)|L]) :-
        ( A=FLTRANSACTIONALNUMBER(NA,_I) ->
            A1 is NA+1,
            Type=nontabled
        ;
            A1 is A+1,
            Type=tabled
        ),
	P1 is P+1,
	flora_write_atom(':- index FLORA_THIS_WORKSPACE('),
        ( Type==nontabled ->
	    flora_write_atom(WRAP_NONTABLED_HILOG)
        ;
	    flora_write_atom(WRAP_TABLED_HILOG)
        ),
        flora_write_atom(')/'),
	flora_current_out_string('~w',A1),
	flora_current_out_string('-'),
	flora_current_out_string('~w',P1),
	flora_current_out_string('.'),
	flora_current_out_nl,
	flora_write_atom('?- index(FLORA_THIS_WORKSPACE('),
        ( Type==nontabled ->
	    flora_write_atom(FLDYNAPREFIX(WRAP_NONTABLED_HILOG))
        ;
	    flora_write_atom(FLDYNAPREFIX(WRAP_TABLED_HILOG))
        ),
        flora_write_atom(')/'),
	flora_current_out_string('~w',A1), flora_current_out_string(','),
	flora_current_out_string('~w',P1), flora_current_out_string(')'),
	flora_current_out_string('.'), flora_current_out_nl,
	flora_write_atom('?- index(FLORA_THIS_WORKSPACE('),
        ( Type==nontabled ->
	    flora_write_atom(FLDYNZPREFIX(WRAP_NONTABLED_HILOG))
        ;
	    flora_write_atom(FLDYNZPREFIX(WRAP_TABLED_HILOG))
        ),
        flora_write_atom(')/'),
	flora_current_out_string('~w',A1), flora_current_out_string(','),
	flora_current_out_string('~w',P1), flora_current_out_string(')'),
	flora_current_out_string('.'), flora_current_out_nl,
	write_index_directives(L).

/*************************************************************************
  flora_generate_DBfile(+DBFileName,+FactList,-FileStatus)

  Things it does:
  (1) include .flh file directive.
  (2) output header file.
  (3) factList from flora_divide_program/3 written directly to .fdb file
      using flora_extern_code/2
  
*************************************************************************/

flora_generate_DBfile(DBFileName,FactList,FileStatus) :-
	telling(PreOutFile),
	tell(DBFileName),
	%% Include Macro definitions.
	flora_current_out_line('#include "flrheader.flh"'),
	flora_current_out_nl,
	flora_extern_code(FactList,CoderStatus),
	( CoderStatus == [] ->
	    FileStatus=FLORA_SUCCESS
	;
	    flora_print_errors([coder(CoderStatus)]),
	    FileStatus=FLORA_FAILURE
	),
	told,
	tell(PreOutFile),
	!.


/*************************************************************************
  flora_loaddyn_data(+InFile,+ModuleName,+Ext)

  This procedure reads a Flora DB/FLD file that contains facts in canonical
  form and inserts them into the storage trie for the module. The module
  could be either a Flora user module, or a Flora system module. In the
  latter case, it is structured term.
*************************************************************************/
flora_loaddyn_data(OrigInFile,ModuleName,Ext) :-
	flora_check_filename(OrigInFile,InFile),
	( flora_file_op(isabsolute,InFile) ->
	    InFileAbs=InFile

	; current_loaded_file(LoadedFile) ->
	    flora_file_op(dirname,LoadedFile,FileDir),
	    flora_concat_atoms([FileDir,InFile],InFileAbs)
	;
	  InFileAbs=InFile
	),
	!,
	( flora_locate_file(InFileAbs,File) ->
	    flora_loader_message('Dynamically loading ~w into module ~w',
				 [File,ModuleName]),
	    flora_cputime(T0),
	    seeing(PreInFile),
	    flora_set_xpp_options_for_read(ModuleName),
	    %% Don't issue irrelevant warnings
	    flora_add_xpp_options('-warninglevel 1 '),
	    xpp_process_file(File,XPP_process,IOportFromProc),
	    see(IOportFromProc),
	    ( Ext==FLORA_FDB_EXT,
		flora_fdb_storage_name(ModuleName,StorageName)
	    ; Ext==FLORA_FLD_EXT,
		flora_fld_storage_name(ModuleName,StorageName)
	    ),
	    flora_read_canonical_and_insert(StorageName),
	    %% Wait, not to leave zombies.
	    process_control(XPP_process,wait(ExitStatus)),
	    (ExitStatus==0, !
	    ; flora_error_line('Error while preprocessing ~w', [File])
	    ),
	    %% Release the file descriptor used to read from xpp.
	    %%close(IOportFromProc),
	    seen,
	    flora_clear_xpp_options,
	    see(PreInFile),
	    flora_cputime(T1),
	    T is T1-T0,
	    flora_loader_message('Done! CPU time used: ~w seconds',[T])
	;
	  flora_error_line('File ~w does not exist', [InFileAbs]),
	  fail
	),
	!.

	
/*************************************************************************
  flora_read_canonical_and_insert(+StorageName)

  Read the current input in canonical form and insert all facts
  into the storage trie.
*************************************************************************/
flora_read_canonical_and_insert(StorageName) :-
	repeat,
	read_canonical(Term),
	( Term == end_of_file, !
	;
            flora_put_attr_and_insert_fact(StorageName,Term),
	    fail
	).

flora_put_attr_and_insert_fact(StorageName,','(var_val(Var,Val),Term)) :-
        %% the only possible case is the PutAttr is put_attr
        %% and there is FLSYSRULEUPDATE in Term
        !,
        put_attr(Var,usermod,Val),
        flora_put_attr_and_insert_fact(StorageName,Term).

flora_put_attr_and_insert_fact(StorageName,Term) :-
        flora_db_insert_base(StorageName,Term).
	
	
/*************************************************************************
  
  flora_save_module_internal(+Module,+File)
  flora_save_module_internal(+File)
  Purpose: -save Module into File
           -if Module is omitted, main by defaut
	   -high level, mainly locating the File[.flr]
  Comments: -if File[.flr] already exists it will be replaced
            -   or a new File will be created
	   
*************************************************************************/

flora_save_module_internal(Module,OrigFile) :-
	flora_check_filename(OrigFile,File),
	valid_flora_module_name(Module),
	
	( flora_locate_file(File,FLORA_FILE_EXT,FlrFile) ->
	    flora_loader_message('replacing the old ~w', [FlrFile]),
	    flora_save_module_to_file(Module,FlrFile)
	; 
	    flora_FLR_filename(File,FlrFile),
	    flora_loader_message('~w is created',[FlrFile]),
	    flora_save_module_to_file(Module,FlrFile)
	),	
	!.	

flora_save_module_internal(File) :-
        flora_save_module_internal(FLORA_DEFAULT_WORKSPACE,File).
		
	
/*************************************************************************
  
  flora_save_module_to_file(+Module,+FlrFile)
  Purpose: -save Module into FlrFile
           -I/O operation and time computation
	   -output comments in target FirFile
  Comments: none
	   
*************************************************************************/

flora_save_module_to_file(ModuleName,FlrFile) :-
	flora_loader_message('Saving module ~w into file ~w',
			     [ModuleName, FlrFile]),
	(   flora_cputime(T0),
	    telling(PreInFile),
	    tell(FlrFile),
	    flora_current_out_line("/* Saved contents of module ~w */", [ModuleName]),
            flora_fdb_storage_name(ModuleName,StorageName),
	    flora_current_out_nl,
	    flora_current_out_line("/* Facts of module ~w */",[ModuleName]),
	    flora_current_out_nl,
	    flora_get_facts_write(StorageName), flora_current_out_nl,
            flora_current_out_line("/* Rules of module ~w */",[ModuleName]),
	    flora_current_out_nl,
	    flora_get_rules_write(ModuleName),		     
            told,
	    tell(PreInFile),
            flora_cputime(T1),
	    T is T1-T0,
	    flora_loader_message('Done! CPU time used: ~w seconds',[T])
	),
	!.

	
/*************************************************************************
  
  flora_get_facts_write(+Storage)
  Purpose: -retrieve all the facts in Storage and write it to the file
           -use backtrack to retrieve all facts in the trie
  Comments: none
	   
*************************************************************************/

flora_get_facts_write(StorageName) :-
	flora_storage_find_fact(StorageName,Term),
        flora_write_fact(Term),
	flora_current_out_line('.'),
	fail.
	
flora_get_facts_write(_StorageName).	

	
/*************************************************************************
  
  flora_get_rules_write(+ModuleName)
  Purpose: -retrieve all the rules in the registry and write them to the file
           -use backtrack to retrieve all rules in the registry
  Comments: none
	   
*************************************************************************/

flora_get_rules_write(ModuleName) :-
	
	matching_rule_signature(Id,_Prefix,Module,Head,Body,Meta,_RuleList,_BridgeRule),
	(Module==ModuleName ->  
	    %% may need to convert Head to head form, since signatures
	    %% contain head in the body form
	    flora_write_rule_label(Id,Meta),
	    flora_write_rule_head(Head),
	    flora_current_out_line(' :- '), flora_current_out_string('        '),
	    flora_write_rule_body(Body), flora_current_out_line('.'),
	    flora_current_out_nl	
	),

	fail.
	
flora_get_rules_write(_ModuleName).	

flora_write_rule_label(Id,Meta) :-
	Id = NULL,
	Meta = NULL,
	!.
flora_write_rule_label(Id,Meta) :-
	flora_current_out_string(FL_LABELINGOP),
	put(CH_LBRACE),
	(Id \= NULL -> flora_write_oid(Id) ; true),
	(Meta \= NULL -> put(CH_COMMA), flora_write_rule_head(Meta) ; true),
	put(CH_RBRACE),
	put(CH_SPACE).


					
/*************************************************************************
  flora_read_canonical_and_insert(+File,+StorageName)
  Same as flora_read_canonical_and_insert/1, but reads a file
*************************************************************************/
flora_read_canonical_and_insert(File,StorageName) :-
	flora_loader_message('Dynamically loading ~w into storage ~w',
			     [File,StorageName]),
	seeing(OldF),
	see(File),
	flora_read_canonical_and_insert(StorageName),
	seen,
	see(OldF).

/*************************************************************************
 Commit all backtrackable updates to Flora storage
**************************************************************************/

flora_commit_storage :-
	(flora_storage_registry(StorageName),
	    flora_db_commit(StorageName),
	    fail
	; true).

/*************************************************************************
 Collect garbage in Flora storage tries
 Should be called only after it is certain that backtracking 
 over deleted facts cannot occur.
**************************************************************************/
flora_reclaim_storage_space :-
	(flora_storage_registry(StorageName),
	    flora_db_reclaim_space(StorageName),
	    fail
	; true
	).


/*************************************************************************
flora_rpc_file_add(+MaxErr,+ErrNum,-CompiledRuleList,-FileOptionList,-RuleStatus,-FileStatus),

  flora_rpc_file_add/6 calls the lexer/composer/parser/compiler rule-by-rule.
      Each time checks if there have been any errors. 
*************************************************************************/
flora_rpc_file_add(MaxErr,ErrNum,CompiledRuleList,FileOptionList,RuleStatus,FileStatus) :-
	flora_read_parse_compile_add(FLORA_FILE,Tokens,
				     CompiledRuleList-NewCompiledRuleList,
				     RuleOptions,RuleStatus1),
	member(error(EN),RuleStatus1),
	NewErrNum is ErrNum+EN,
	( EN > 0 -> %% errors found in the latest compiled rule
	    ( MaxErr \== FLORA_ALL, NewErrNum >= MaxErr ->
		FileStatus=FLORA_FAILURE,
		RuleStatus = RuleStatus1

	    ; flora_rule_delimeter_struct(_,_,_,_,_,RuleDelimeterToken),
		flora_not_end_of_input(RuleStatus1),
		member(RuleDelimeterToken,Tokens)
	    ->
	        flora_rpc_file_add(MaxErr,NewErrNum,
				   _CompiledRuleList,_FileOptionList,
				   RuleStatus2,FileStatus),
		merge_status_lists(RuleStatus1,RuleStatus2,RuleStatus)

	    ; flora_not_end_of_input(RuleStatus1), flora_discard_tokens
	    ->
	        flora_rpc_file_add(MaxErr,NewErrNum,
				   _CompiledRuleList,_FileOptionList,
				   RuleStatus2,FileStatus),
		merge_status_lists(RuleStatus1,RuleStatus2,RuleStatus)
	    ;
		FileStatus=FLORA_FAILURE,
		RuleStatus = RuleStatus1
	    )
	;
	  ( NewErrNum == 0 -> %% no errors so far
	      flora_tailappend(FileOptionList,RuleOptions,NewFileOptionList)
	  ;
	    true
	  ),
	  ( flora_not_end_of_input(RuleStatus1)
	  ->
	      flora_rpc_file_add(MaxErr,NewErrNum,
				 NewCompiledRuleList,NewFileOptionList,
				 RuleStatus2,FileStatus),
	      merge_status_lists(RuleStatus1,RuleStatus2,RuleStatus)
	  ; %% end of file reached
	      ( NewErrNum == 0 ->
		  NewCompiledRuleList=[],
		  NewFileOptionList=[],
		  FileStatus=FLORA_SUCCESS
	      ;
		  FileStatus=FLORA_FAILURE
	      ),
	      RuleStatus = RuleStatus1
	  )
	),
	!.


/*************************************************************************
  flora_read_parse_compile_add(+Option,-Tokens,-RulesCode,-OptionList,-Status)

  Note: This procedure can be used to read both file and command line.
        For reading file, Option is FLORA_FILE. For reading command line,
        Option is FLORA_COMMANDLINE.

        RulesCode is a difference list in the form of List-Tail,
        where Tail is the tail of List. Tail is unbound when this procedure
        returns and so it should be set to [] later accordingly to close
        the end of the list.
*************************************************************************/
flora_read_parse_compile_add(Option,Tokens,RulesCode,OptionList,Status) :-
	%% get InputTokens
	flora_tokens(InputTokens,LexerStatus), 
	count_errors(LexerStatus,LexErrNum),
	( LexErrNum > 0 ->
	    Tokens=InputTokens,
	    RulesCode=T-T,
	    OptionList=[],
	    ErrNum=LexErrNum

	; flora_blank_line(InputTokens) ->
	    Tokens=InputTokens,
	    RulesCode=T-T,
	    OptionList=[],
	    ErrNum=0
	;
	    ( Option == FLORA_COMMANDLINE ->
		flora_construct_query_term(InputTokens,Tokens)
	    ;
		Tokens=InputTokens
	    ),
	    flora_compose(Tokens,ComposerTerm,ComposerStatus),
	    count_errors(ComposerStatus,CompoErrNum),
	    ( CompoErrNum > 0 ->
		RulesCode=T-T,
		OptionList=[],
		ErrNum=CompoErrNum
	    ;
		flora_parse(ComposerTerm,ParserTerm,ParserStatus),
		count_errors(ParserStatus,ParErrNum),
		( ParErrNum > 0 ->
		    RulesCode=T-T,
		    OptionList=[],
		    ErrNum=ParErrNum
		;
		    %% compile, and get RulesCode,OptionList
		    flora_compile_add(ParserTerm,RulesCode,OptionList,CompileStat),
		    count_errors(CompileStat,CompiErrN),
		    ErrNum=CompiErrN
		)
	    )
        ),

	(var(ComposerStatus) -> ComposerStatus = [] ; true),
	(var(ParserStatus) -> ParserStatus = [] ; true),
	(var(CompileStat) -> CompileStat = [] ; true),
	EWS=[error(ErrNum),
	     lexer([(InputTokens,LexerStatus)]),
	     composer(ComposerStatus),
	     parser(ParserStatus),
	     compiler(CompileStat)],
	( flora_end_of_input(LexerStatus) ->
	    Status=[FLORA_EOF|EWS]
	;
	    Status=[FLORA_NOT_EOF|EWS]
	).



/*************************************************************************
  flora_rpc_file(+MaxErr,+ErrNum,-CompiledRuleList,-FileOptionList,-RuleStatus,-FileStatus)
  flora_tailappend(+L1,+L2,-Result)

  flora_rpc_file/6 calls the lexer/composer/compiler rule-by-rule.
      Each time checks if there have been any errors. Collects options passed
      in by the compiler into a list. These options tell which libraries
      to load, how to compose the trailer, etc.
  flora_tailappend/3: used to concatenate the options passed in by the
      compiler efficiently, using difference lists.
*************************************************************************/
%% Third argument is bound to the tail of the list represented by first arg.
%% flora_tailappend(X,[a,b],T) gives X=[a,b|T].
%% Then T is passed to another flora_tailappend(T,[c,d],T1), etc.
flora_tailappend(V,[],V) :- !.
flora_tailappend([H|V],[H|L],T) :- flora_tailappend(V,L,T).


flora_rpc_file(MaxErr,ErrNum,CompiledRuleList,FileOptionList,RuleStatus,FileStatus) :-
	flora_read_parse_compile(FLORA_FILE,Tokens,
                                 CompiledRuleList-NewCompiledRuleList,
                                 RuleOptions,RuleStatus1),
	member(error(EN),RuleStatus1),
	NewErrNum is ErrNum+EN,
	( EN > 0 -> %% errors found in the latest compiled rule
	    ( MaxErr \== FLORA_ALL, NewErrNum >= MaxErr ->
		FileStatus=FLORA_FAILURE,
		RuleStatus = RuleStatus1

	    ; flora_rule_delimeter_struct(_,_,_,_,_,RuleDelimeterToken),
		flora_not_end_of_input(RuleStatus1),
		member(RuleDelimeterToken,Tokens)
	    ->
	        flora_rpc_file(MaxErr,NewErrNum,
                               _CompiledRuleList,_FileOptionList,
			       RuleStatus2,FileStatus),
		merge_status_lists(RuleStatus1,RuleStatus2,RuleStatus)

	    ; flora_not_end_of_input(RuleStatus1), flora_discard_tokens
	    ->
	        flora_rpc_file(MaxErr,NewErrNum,
                               _CompiledRuleList,_FileOptionList,
			       RuleStatus2,FileStatus),
		merge_status_lists(RuleStatus1,RuleStatus2,RuleStatus)
	    ;
		FileStatus=FLORA_FAILURE,
		RuleStatus = RuleStatus1
	    )
	;
	    ( NewErrNum == 0 -> %% no errors so far
		flora_tailappend(FileOptionList,RuleOptions,NewFileOptionList)
	    ;
		true
	    ),
	    ( flora_not_end_of_input(RuleStatus1)
	    ->
		flora_rpc_file(MaxErr,NewErrNum,
			       NewCompiledRuleList,NewFileOptionList,
			       RuleStatus2,FileStatus),
		merge_status_lists(RuleStatus1,RuleStatus2,RuleStatus)
	    ; %% end of file reached
		( NewErrNum == 0 ->
		    NewCompiledRuleList=[],
		    NewFileOptionList=[],
		    FileStatus=FLORA_SUCCESS
		;
		    FileStatus=FLORA_FAILURE
		),
		RuleStatus = RuleStatus1
	    )
	),
	flora_clear_compilation_permaoptions,
	!.


/*************************************************************************
  flora_discard_tokens/0
  Scan the input until a rule delimeter is found. Fails if eof.
*************************************************************************/
flora_discard_tokens :-
	flora_stdwarn_nl,
	flora_warning_line('discarding tokens (rule delimeter `.'' or EOF expected)'),
	flora_stdwarn_nl,
	repeat,
	flora_tokens(Tokens,Status),
	flora_rule_delimeter_struct(_Txt,_LN1,_CN1,_LN2,_CN2,RuleDelimeterToken),
	( flora_end_of_input(Status) ->
	    !,
	    fail
	
	; member(RuleDelimeterToken,Tokens) ->
	    !
	;
	  fail
        ).


/*************************************************************************
  flora_read_parse_compile(+Option,-Tokens,-RulesCode,-OptionList,-Status)

        Read file or command line, then parse and compile.

        This procedure can be used to read both file and command line.
        For reading file, Option is FLORA_FILE. For reading command line,
        Option is FLORA_COMMANDLINE.

        RulesCode is a difference list in the form of List-Tail,
        where Tail is the tail of List. Tail is unbound when this procedure
        returns and so it should be set to [] later accordingly to close
        the end of the list.
*************************************************************************/
flora_read_parse_compile(Option,Tokens,RulesCode,OptionList,Status) :-
	flora_tokens(InputTokens,LexerStatus), 
	%% get InputTokens
	count_errors(LexerStatus,LexErrNum),
	( LexErrNum > 0 ->
	    Tokens=InputTokens,
	    RulesCode=T-T,
	    OptionList=[],
	    ErrNum=LexErrNum

	; flora_blank_line(InputTokens) ->
	    Tokens=InputTokens,
	    RulesCode=T-T,
	    OptionList=[],
	    ErrNum=0
	;
	    ( Option == FLORA_COMMANDLINE ->
		flora_construct_query_term(InputTokens,Tokens)
	    ;
		%% set Tokens from InputTokens
		Tokens=InputTokens
	    ),
	    %% compose
	    flora_compose(Tokens,ComposerTerm,ComposerStatus),
	    count_errors(ComposerStatus,CompoErrNum),
	    ( CompoErrNum > 0 ->
		RulesCode=T-T,
		OptionList=[],
		ErrNum=CompoErrNum
	    ;
		%% parse
		flora_parse(ComposerTerm,ParserTerm,ParserStatus),
		count_errors(ParserStatus,ParErrNum),
		( ParErrNum > 0 ->
		    RulesCode=T-T,
		    OptionList=[],
		    ErrNum=ParErrNum
		;
		    %% compile, and get RulesCode,OptionList
		    flora_compile(ParserTerm,RulesCode,OptionList,CompileStat),
		    count_errors(CompileStat,CompiErrN),
		    ErrNum=CompiErrN
		)
	    )
        ),
	(var(ComposerStatus) -> ComposerStatus = [] ; true),
	(var(ParserStatus) -> ParserStatus = [] ; true),
	(var(CompileStat) -> CompileStat = [] ; true),
	EWS=[error(ErrNum),
	     lexer([(InputTokens,LexerStatus)]),
	     composer(ComposerStatus),
	     parser(ParserStatus),
	     compiler(CompileStat)],
	( flora_end_of_input(LexerStatus) ->
	    Status=[FLORA_EOF|EWS]
	;
	    Status=[FLORA_NOT_EOF|EWS]
	).


/*************************************************************************
  flora_read_then_parse(-ParserTerm,-Status)
  flora_read_then_parse(-InputTokens,-ParserTerm,-Status)

        Read standard input (one line) then parse (don't compile)
	This can be used to dump parsed FLORA-2 code to XML and other formats.

        For reading file, Option is FLORA_FILE. For reading command line,
        Option is FLORA_COMMANDLINE.

        The parser output is ParserTerm.
        InputTokens is the list of tokens after tokenization.
        Provided because it is sometimes useful.

        flora_read_then_parse/2 is like flora_read_then_parse/3,
	but discards InputTokens.

*************************************************************************/
flora_read_then_parse(ParserTerm,Status) :-
	flora_read_then_parse(_InputTokens,ParserTerm,Status).
flora_read_then_parse(InputTokens,ParserTerm,Status) :-
	%% get InputTokens
	flora_tokens(InputTokens,LexerStatus), 
	count_errors(LexerStatus,LexErrNum),
	( LexErrNum > 0 ->
	    ErrNum=LexErrNum

	; flora_blank_line(InputTokens) ->
	    ErrNum=0
	;
	    %% compose
	    flora_compose(InputTokens,ComposerTerm,ComposerStatus),
	    count_errors(ComposerStatus,CompoErrNum),
	    ( CompoErrNum > 0 ->
		ErrNum=CompoErrNum
	    ;
		%% parse
		flora_parse(ComposerTerm,ParserTerm,ParserStatus),
		count_errors(ParserStatus,ParErrNum),
		( ParErrNum > 0 ->
		    ErrNum=ParErrNum
		;
		    ErrNum=0
		)
	    )
        ),
	(var(ComposerStatus) -> ComposerStatus = [] ; true),
	(var(ParserStatus) -> ParserStatus = [] ; true),
	EWS=[error(ErrNum),
	     lexer([(InputTokens,LexerStatus)]),
	     composer(ComposerStatus),
	     parser(ParserStatus) ],

	flora_print_warnings(EWS),
	flora_print_errors(EWS),

	( flora_end_of_input(LexerStatus) ->
	    Status=[FLORA_EOF|EWS]
	;
	    Status=[FLORA_NOT_EOF|EWS]
	).


/*************************************************************************
  flora_read_then_parse_string(+String,-ParserTerm,-Status)

      Uses flora_read_then_parse/3 to read and parse from string.
      This predicate is mostly for debugging.

*************************************************************************/
flora_read_then_parse_string(String,ParserTerm,Status) :-
	see_source(atom(String),IOPort,OldStdin),
	!,
	flora_read_then_parse(ParserTerm,Status),
	seen_source(IOPort,OldStdin).



/*************************************************************************
  flora_construct_query_term(+InputTokens,-Tokens)

  Construct a query term from the shell command line input. Two extra
  pair of parentheses are added to enclose the input. This is to prevent
  the query term from being intepreted as having arity other than one.
*************************************************************************/
flora_construct_query_term(InputTokens,Tokens) :-
	flora_symbol_token_struct("?-",1,0,1,0,QueryOpToken),
	flora_symbol_token_struct("(",1,0,1,0,LPToken),
	Tokens=[QueryOpToken,LPToken,LPToken|L],
	flora_construct_rest_query_term(InputTokens,L).


flora_construct_rest_query_term([T],[RPToken,RPToken,T]) :-
	!,
	%% This last one from the input tokens is the rule delimeter.
	flora_symbol_token_struct(")",1,0,1,0,RPToken).

flora_construct_rest_query_term([T|Ts],[T|L]) :-
	flora_construct_rest_query_term(Ts,L).


/*************************************************************************
  flora_shell_command_line(-Code,-Options,-Status)
*************************************************************************/
flora_shell_command_line(Code,Options,Status) :-
	flora_reset_modules_for_shell,
	flora_read_parse_compile(FLORA_COMMANDLINE,Tokens,Rules-[],
                                 RuleOptions,RuleStatus),
	%% Trailer options will always be empty list in the shell
	strip_indices_from_options_and_split(RuleOptions,StrippedOptions,_TrailerOptions),
	sort(StrippedOptions,Options),
	member(error(ErrNum),RuleStatus),
	( ErrNum > 0 ->
	    ( flora_end_of_input(RuleStatus) ->
		InputStatus=FLORA_EOF

	    ; flora_rule_delimeter_struct(_,_,_,_,_,RuleDelimeterToken),
	      member(RuleDelimeterToken,Tokens) ->
		InputStatus=FLORA_NOT_EOF

	    ; flora_discard_tokens ->
	        InputStatus=FLORA_NOT_EOF
	    ;
	      InputStatus=FLORA_EOF
	    ),
	    Status=[InputStatus,FLORA_FAILURE]
	; %% ErrNum > 0  end
	    ( Rules == [] ->
		CommandStatus=FLORA_NOOP
	    ;
		%% The below is ErrNum = 0 and Rules \= []
		flora_intern_code(Rules,FLORA_DEFAULT_WORKSPACE,Code,CoderStatus),
		%% get Code from Rules
		( CoderStatus == [] ->
		    CommandStatus=FLORA_SUCCESS
		;
		    flora_print_errors([coder(CoderStatus)]),
		    CommandStatus=FLORA_FAILURE
		)
	    ),
	    ( flora_end_of_input(RuleStatus) ->
		Status=[FLORA_EOF,CommandStatus]
	    ;
		Status=[FLORA_NOT_EOF,CommandStatus]
	    )
	),
	flora_print_errors(RuleStatus),
	!.


/*************************************************************************
  flora_flrfilename_error(+FileName)

  This procedure is called when search for a Flora file is failed. The
  failure may be due to incorrect file name extension or non-existence.
*************************************************************************/
flora_flrfilename_error(File) :-
	( parse_filename(File,_,_,Ext), Ext \== '', Ext \== FLORA_FILE_EXT,
	  flora_file_op(exists,File) ->
	    flora_stderr_nl,
	    flora_error_line('~w: Filename extension must be ~w',
			     [File,FLORA_FILE_EXT])
	;
	  flora_stderr_nl,
	  flora_error_line('File ~w[.~w] does not exist',[File,FLORA_FILE_EXT])
        ),
	!.


/*************************************************************************
  utilities
*************************************************************************/
print_error_count(ErrNum) :-
	( ErrNum == 1 ->
	    flora_stderr_nl,
	    flora_stderr_string('++1 error'),
	    flora_stderr_nl, flora_stderr_nl,
	    flora_stderr_string('++compilation aborted'),
	    flora_stderr_nl

	; ErrNum > 1 ->
	    flora_stderr_nl,
	    flora_stderr_string('++~w errors',[ErrNum]),
	    flora_stderr_nl, flora_stderr_nl,
	    flora_stderr_string('++compilation aborted'),
	    flora_stderr_nl
	;
	    true
        ).

print_warn_count(WarnNum) :-
	( WarnNum == 1 ->
	    flora_stdwarn_nl,
	    flora_stdwarn_string('++1 warning'),
	    flora_stderr_nl, flora_stderr_nl

	; WarnNum > 1 ->
	    flora_stdwarn_nl,
	    flora_stdwarn_string('++~w warnings',[WarnNum]),
	    flora_stdwarn_nl, flora_stdwarn_nl
	;
	    true
        ).


%% StatusList is a list of error/warnings from lexer,composer,compiler,coder
flora_print_warnings(_StatusList) :-
	flora_warnings_level(nocompiler),
	!.
flora_print_warnings(StatusList) :-
	(member(composer(ComposerList),StatusList)
	->
	    (count_warnings(ComposerList,0), ! ; flora_stdwarn_nl),
	    flora_composer_warn(ComposerList,ComposerNum)
	; ComposerNum = 0
	),
	(member(compiler(CompilerList),StatusList)
	-> 
	    ((count_warnings(CompilerList,0) ; ComposerNum>0), !
	    ; flora_stdwarn_nl),
	    flora_compiler_warn(CompilerList,CompilerNum)
	; CompilerNum = 0
	),
	(member(depend(DependList),StatusList)
	->
	    ((count_warnings(DependList,0) ; ComposerNum>0 ; CompilerNum>0), !
	     ; flora_stdwarn_nl),
	    check_for_dependencies_warn(DependList,DependNum)
	; DependNum = 0
	),
	NewNum is ComposerNum+CompilerNum+DependNum,
	print_warn_count(NewNum).

%% StatusList is a list of error/warnings from lexer,composer,compiler,coder
flora_print_errors(StatusList) :-
	(member(error(0),StatusList), ! ; flora_stderr_nl),
	(member(lexer(LexerList),StatusList)
	-> flora_lexer_error(LexerList,LexerNum)
	; LexerNum = 0
	),
	(member(composer(ComposerList),StatusList)
	-> flora_composer_error(ComposerList,ComposerNum)
	; ComposerNum = 0
	),
	(member(parser(ParserList),StatusList)
	-> flora_parser_error(ParserList,ParserNum)
	; ParserNum = 0
	),
	(member(compiler(CompilerList),StatusList)
	-> flora_compiler_error(CompilerList,CompilerNum)
	; CompilerNum = 0
	),
	(member(coder(CoderList),StatusList)
	-> flora_coder_error(CoderList),
	    length(CoderList,CoderNum)
	; CoderNum = 0
	),
	(member(depend(DependList),StatusList)
	-> check_for_dependencies_error(DependList,DependNum)
	; DependNum = 0
	),
	NewNum is LexerNum+ComposerNum+ParserNum+CompilerNum+CoderNum+DependNum,
	print_error_count(NewNum).


count_in_list(_TestList,[],0) :- !.
count_in_list(TestList,[H|T],Num) :-
	term_psc(H,PSC),
	term_new(PSC,HH),
	member(HH,TestList), % use a copy of H to avoid binding
	!,
	count_in_list(TestList,T,Num1),
	Num is Num1+1.
count_in_list(TestList,[_|T],Num) :- count_in_list(TestList,T,Num).

count_warnings([],0) :- !.  % to guard against variables
count_warnings(List,Num) :-
	count_in_list([warning(_),warning(_,_),warning(_,_,_)], List, Num).
count_errors([],0) :- !.  % to guard against variables
count_errors(List,Num) :-
	count_in_list([error(_),error(_,_),error(_,_,_)], List, Num).

%% A status list has the form [EOF/NOT_EOF,Type1(List1), Type2(List2), ...]
%% Lists must have same length, and Type1, Type2, etc., are in same order.
merge_status_lists([],[],[]) :- !.
merge_status_lists([FLORA_NOT_EOF|T1],[FLORA_NOT_EOF|T2],[FLORA_NOT_EOF|T3]) :-
	!,
	merge_status_lists(T1,T2,T3).
merge_status_lists([FLORA_EOF|T1],[_|T2],[FLORA_EOF|T3]) :-
	!,
	merge_status_lists(T1,T2,T3).
merge_status_lists([_|T1],[FLORA_EOF|T2],[FLORA_EOF|T3]) :-
	!,
	merge_status_lists(T1,T2,T3).
merge_status_lists([error(N1)|T1],[error(N2)|T2],[error(N3)|T3]) :-
	!,
	N3 is N1 + N2,
	merge_status_lists(T1,T2,T3).
merge_status_lists([H1|T1], [H2|T2], [H3|T3]) :-
	H1 =.. [F|[A1]],
	H2 =.. [F|[A2]],
	!,
	append(A1,A2,A3),
	H3 =.. [F|[A3]],
	merge_status_lists(T1,T2,T3).
merge_status_lists(_,_,_) :-
	flora_abort(['Internal error: ',
		     'merge_status_lists with invalid status lists']).


/*************************************************************************
  flora_lexer_error(+Tokens,+LexerStatus,-ErrNum)
*************************************************************************/
flora_lexer_error([],0) :- !.

flora_lexer_error([(Tokens,LexerStatus)|Rest],ErrNum) :-
	( member(error(Msg),LexerStatus) ->
	    flora_last_element(Tokens,Tk),
	    flora_token_text(Tk,TextStr,_BLN,_BCN,ELN,ECN),
	    ( flora_current_compile_filename(FileName) ->
		flora_error_line('[~w] [Lexer] near line(~w)/char(~w) `~s''',
	                         [FileName,ELN,ECN,TextStr])
	    ;
	      flora_error_line('[Lexer] near line(~w)/char(~w) `~s''',
	                       [ELN,ECN,TextStr])
	    ),
	    flora_error_indentline,
	    flora_stderr_string('~w',[Msg]),
	    flora_stderr_nl,
	    ErrNum1 = 1
	;
	  ErrNum1 = 0
        ),
	flora_lexer_error(Rest,ErrNum2),
	ErrNum is ErrNum1 + ErrNum2.


flora_last_element([T],T) :- !.
flora_last_element([_|L],T) :- flora_last_element(L,T).


/*************************************************************************
  flora_composer_error(+ComposerStatus,-ErrNum)
  flora_composer_warn(+ComposerStatus,-WarnNum)
*************************************************************************/
flora_composer_error([],0) :- !.

flora_composer_error([error(Indx,Msg)|L],ErrNum) :-
	!,
	flora_nth_token(Indx,Tk),
	atom_codes(A,[CH_UNDERSCORE]),
	( (Tk = variable(A,_)) ->
	    %% in error reporting, output ? for anonymous variable
	    %% (vars are stored as variable(_,...))
	    TextStr=[CH_QUESTION],
	    flora_token_text(Tk,_TextStr,BLN,BCN,_ELN,_ECN)
	 ;
	  flora_token_text(Tk,TextStr,BLN,BCN,_ELN,_ECN)
	),
	( flora_current_compile_filename(FileName) ->
	    flora_error_line('[~w] [Composer] near line(~w)/char(~w) `~s''',
                             [FileName,BLN,BCN,TextStr])
	;
	  flora_error_line('[Composer] near line(~w)/char(~w) `~s''',
                           [BLN,BCN,TextStr])
	),
	flora_error_indentline,
	flora_stderr_string('~w',[Msg]),
	flora_stderr_nl,
	flora_composer_error(L,EN),
	ErrNum is EN+1.

flora_composer_error([error(I1,I2,Msg)|L],ErrNum) :-
	!,
	flora_nth_token(I1,Tk1),
	flora_nth_token(I2,Tk2),
	atom_codes(A,[CH_UNDERSCORE]),
	( (Tk1 = variable(A,_)) ->
	    %% in error reporting, prepend ? to anonymous variable _
	    TextStr1=[CH_QUESTION],
	    flora_token_text(Tk1,_TextStr1,BLN1,BCN1,_ELN1,_ECN1)
	 ;
	  flora_token_text(Tk1,TextStr1,BLN1,BCN1,_ELN1,_ECN1)
	),
	( (Tk2 = variable(A,_)) ->
	    %% prepend ? to anonymous variable _
	    TextStr2=[CH_QUESTION],
	    flora_token_text(Tk2,_TextStr2,BLN2,BCN2,_ELN2,_ECN2)
	 ;
	  flora_token_text(Tk2,TextStr2,BLN2,BCN2,_ELN2,_ECN2)
	),
	( flora_current_compile_filename(FileName) ->
	    flora_error_line('[~w] [Composer] near line(~w)/char(~w) `~s'' and near line(~w)/char(~w) `~s''',
	                     [FileName,BLN1,BCN1,TextStr1,BLN2,BCN2,TextStr2])
	;
	  flora_error_line('[Composer] near line(~w)/char(~w) `~s'' and near line(~w)/char(~w) `~s''',
	                   [BLN1,BCN1,TextStr1,BLN2,BCN2,TextStr2])
	),
	flora_error_indentline,
	flora_stderr_string('~w',[Msg]),
	flora_stderr_nl,
	flora_composer_error(L,EN),
	ErrNum is EN+1.


flora_composer_error([error(Msg)|L],ErrNum) :-
	!,
	( flora_current_compile_filename(FileName) ->
	    flora_error_line('[~w] [Composer] ~w',[FileName,Msg])
	;
	  flora_error_line('[Composer] ~w',[Msg])
	),
	flora_composer_error(L,EN),
	ErrNum is EN+1.

%% Skip warnings
flora_composer_error([_|L],ErrNum) :- flora_composer_error(L,ErrNum).


flora_composer_warn([],0) :- !.
flora_composer_warn([warning(I1,I2,Msg)|L],WarnNum) :-
	!,
	flora_nth_token(I1,Tk1),
	flora_nth_token(I2,Tk2),
	atom_codes(A,[CH_UNDERSCORE]),
	( (Tk1 = variable(A,_)) ->
	    %% in reporting, prepend ? to anonymous var _
	    %% (it is represented as variable(_,...))
	    TextStr1=[CH_QUESTION],
	    flora_token_text(Tk1,_TextStr1,BLN1,BCN1,_ELN1,_ECN1)
	 ;
	  flora_token_text(Tk1,TextStr1,BLN1,BCN1,_ELN1,_ECN1)
	),
	( (Tk2 = variable(A,_)) ->
	    %% prepend ? to anonymous var _
	    TextStr2=[CH_QUESTION],
	    flora_token_text(Tk2,_TextStr2,BLN2,BCN2,_ELN2,_ECN2)
	 ;
	    flora_token_text(Tk2,TextStr2,BLN2,BCN2,_ELN2,_ECN2)
	),
	( flora_current_compile_filename(FileName) ->
	    flora_warning_line('[~w] [Composer] near line(~w)/char(~w) `~s'' and near line(~w)/char(~w) `~s''',
	                       [FileName,BLN1,BCN1,TextStr1,BLN2,BCN2,TextStr2])
	;
	  flora_warning_line('[Composer] near line(~w)/char(~w) `~s'' and near line(~w)/char(~w) `~s''',
	                     [BLN1,BCN1,TextStr1,BLN2,BCN2,TextStr2])
	),
	flora_warning_indentline,
	flora_stdwarn_string("~w~n",[Msg]),
	flora_composer_warn(L,WN),
	WarnNum is WN+1.

%% Skip errors
flora_composer_warn([_|L],WarnNum) :- flora_composer_error(L,WarnNum).


/*************************************************************************
  flora_parser_error(+ParserStatus,-ErrNum)
*************************************************************************/
flora_parser_error([],0) :- !.

flora_parser_error([error(Indx,Msg)|L],ErrNum) :-
	!,
	flora_nth_token(Indx,Tk),
	atom_codes(A,[CH_UNDERSCORE]),
	( (Tk = variable(A,_)) ->
	    TextStr=[CH_QUESTION], 
	    %% in error reporting, prefix ? to anonymous variable
	    flora_token_text(Tk,_TextStr,BLN,BCN,_ELN,_ECN)
	 ;
	    flora_token_text(Tk,TextStr,BLN,BCN,_ELN,_ECN)
	),
	( flora_current_compile_filename(FileName) ->
	    flora_error_line('[~w] [Parser] near line(~w)/char(~w) `~s''',
                             [FileName,BLN,BCN,TextStr])
	;
	  flora_error_line('[Parser] near line(~w)/char(~w) `~s''',
                           [BLN,BCN,TextStr])
	),
	flora_error_indentline,
	flora_stderr_string('~w',[Msg]),
	flora_stderr_nl,
	flora_parser_error(L,EN),
	ErrNum is EN+1.

flora_parser_error([error(Msg)|L],ErrNum) :-
	!,
	( flora_current_compile_filename(FileName) ->
	    flora_error_line('[~w] [Parser] ~w',[FileName,Msg])
	;
	  flora_error_line('[Parser] ~w',[Msg])
	),
	flora_parser_error(L,EN),
	ErrNum is EN+1.

/*************************************************************************
  check_for_dependencies_warn(+ParserStatus,-WarnNum)
  check_for_dependencies_error(+ParserStatus,-ErrNum)
*************************************************************************/

check_for_dependencies_warn([],0) :- !.

check_for_dependencies_warn([warning(HTK,BTK,(MH,MB))|L],WarnNum) :-
	!,
	(
	  flora_compile_filename_by_token(HTK,HFileName),
	  flora_compile_filename_by_token(BTK,BFileName) ->
	  %%flora_warning_line('[Dependency check] ~w in [~w]~w in [~w]', [MH,HFileName,MB,BFileName])
	  flora_warning_line('[~w] [Dependency check]', [HFileName]),
	  flora_warning_indentline,
	  flora_stdwarn_string('~w ~w in [~w]~n', [MH,MB,BFileName])
        ;
	  flora_compile_filename_by_token(HTK,HFileName),
	  %%flora_warning_line('[Dependency check] ~w in [~w] depends on ~w', [MH,HFileName,MB])
	  flora_warning_line('[~w] [Dependency check]', [HFileName]),
	  flora_warning_indentline,
	  flora_stdwarn_string('~w depends on ~w~n', [MH,MB])
        ;
	  flora_compile_filename_by_token(BTK,BFileName),
	  %%flora_warning_line('[Dependency check] ~w depends on ~w in [~w]', [MH,MB,BFileName])
	  flora_warning_line('[Dependency check]'),
	  flora_stdwarn_string('~w depends on ~w in [~w]~n', [MH,MB,BFileName])
        ;
	  %%flora_warning_line('[Dependency check] ~w depends on ~w', [MH,MB])
	  flora_warning_line('[Dependency check]'),
	  flora_warning_indentline,
	  flora_warning_line('~w depends on ~w~n', [MH,MB])
	),
	check_for_dependencies_warn(L,WN),
	WarnNum is WN+1.

%% Skip errors
check_for_dependencies_warn([_|L],WarnNum) :-
	check_for_dependencies_warn(L,WarnNum).


check_for_dependencies_error([],0) :- !.

check_for_dependencies_error([error(Msg)|L],ErrNum) :-
	!,
	( flora_current_compile_filename(FileName) ->
	    flora_error_line('[~w] [Dependency check] ~w', [FileName,Msg])
	;
	    flora_error_line('[Dependency check] ~w', [Msg])
	),
	check_for_dependencies_error(L,EN),
	ErrNum is EN+1.

%% Skip warnings
check_for_dependencies_error([_|L],ErrNum) :-
	check_for_dependencies_error(L,ErrNum).

/*************************************************************************
  flora_compiler_error(+CompileStat,-ErrNum)
  flora_compiler_warn(+CompileStat,-WarnNum)
*************************************************************************/
flora_compiler_error([],0) :- !.

flora_compiler_error([error(Indx,Msg)|L],ErrNum) :-
	!,
	flora_nth_token(Indx,Tk),
	atom_codes(A,[CH_UNDERSCORE]),	
	( (Tk = variable(A,_)) ->
	    %% prepend ? to anonymous var _
	    TextStr=[CH_QUESTION],
	    flora_token_text(Tk,_TextStr,BLN,BCN,_ELN,_ECN)
	 ;
	  flora_token_text(Tk,TextStr,BLN,BCN,_ELN,_ECN)
	),
	( flora_current_compile_filename(FileName) ->
	    flora_error_line('[~w] [Compiler] near line(~w)/char(~w) `~s''',
                             [FileName,BLN,BCN,TextStr])
	;
	  flora_error_line('[Compiler] near line(~w)/char(~w) `~s''',
                           [BLN,BCN,TextStr])
	),
	flora_error_indentline,
	flora_stderr_string('~w~n',[Msg]),
	flora_compiler_error(L,EN),
	ErrNum is EN+1.

flora_compiler_error([error(Msg)|L],ErrNum) :-
	!,
	( flora_current_compile_filename(FileName) ->
	    flora_error_line('[~w] [Compiler] ~w',[FileName,Msg])
	;
	  flora_error_line('[Compiler] ~w',[Msg])
	),
	flora_compiler_error(L,EN),
	ErrNum is EN+1.

%% Skip warnings
flora_compiler_error([_|L],ErrNum) :- flora_compiler_error(L,ErrNum).


flora_compiler_warn([],0) :- !.

flora_compiler_warn([warning(Indx,Msg)|L],WarnNum) :-
	!,
	flora_nth_token(Indx,Tk),
	atom_codes(A,[CH_UNDERSCORE]),
	( (Tk = variable(A,_)) ->
	    %% prepend ? to anonymous var _
	    TextStr=[CH_QUESTION],
	    flora_token_text(Tk,_TextStr,BLN,BCN,_ELN,_ECN)
	 ;
	  flora_token_text(Tk,TextStr,BLN,BCN,_ELN,_ECN)
	),
	( flora_current_compile_filename(FileName) ->
	    flora_warning_line('[~w] [Compiler] near line(~w)/char(~w) `~s''',
                               [FileName,BLN,BCN,TextStr])
	;
	  flora_warning_line('[Compiler] near line(~w)/char(~w) `~s''',
                             [BLN,BCN,TextStr])
	),
	flora_warning_indentline,
	flora_stdwarn_string("~w~n",[Msg]),
	flora_compiler_warn(L,WN),
	WarnNum is WN+1.

%% Skip errors
flora_compiler_warn([_|L],WarmNum) :- flora_compiler_warn(L,WarmNum).


/*************************************************************************
  flora_coder_error(+CoderStatus)
*************************************************************************/
flora_coder_error([]) :- !.

flora_coder_error([error(Msg)|L]) :-
	!,
	( flora_current_compile_filename(FileName) ->
	    flora_error_line('[~w] [Coder] ~w',[FileName,Msg])
	;
	  flora_error_line('[Coder] ~w',[Msg])
	),
	flora_coder_error(L).

flora_coder_error([error(Indx,Msg)|L]) :-
	!,
	flora_nth_token(Indx,Tk),
	atom_codes(A,[CH_UNDERSCORE]),
	( (Tk = variable(A,_)) ->
	    %% prepend ? to anonymous var _
	    TextStr=[CH_QUESTION],
		flora_token_text(Tk,_TextStr,BLN,BCN,_ELN,_ECN)
	 ;
	  flora_token_text(Tk,TextStr,BLN,BCN,_ELN,_ECN)
	),
	( flora_current_compile_filename(FileName) ->
	    flora_error_line('[~w] [Coder] near line(~w)/char(~w) `~s''',
                             [FileName,BLN,BCN,TextStr])
	;
	  flora_error_line('[Coder] near line(~w)/char(~w) `~s''',
                           [BLN,BCN,TextStr])
	),
	flora_error_indentline,
	flora_stderr_string('~w~n',[Msg]),
	flora_coder_error(L).


/*****************************************************************************
  flora_list2conjunct(+List,-Goal)
*****************************************************************************/
flora_list2conjunct([G],G) :- !.

flora_list2conjunct([G|L],(G,LG)) :-
	!,
	flora_list2conjunct(L,LG).


/*************************************************************************
  flMaxerr(+Num)
  Controls how many compile errors to show.
  No longer advertized to the user (not important)
*************************************************************************/
:- flora_set_maxerrors(8).

flora_set_maxerrors(X) :-
	( var(X) ->
	    flora_maxerr(X)

	; X \== FLORA_ALL, (not integer(X); X < 1) ->
	    flora_error_line('Invalid argument to maxerr'),
	    fail
	;
	  retractall(flora_maxerr(_)),
	  assert(flora_maxerr(X))
	).


/*************************************************************************
  _dump/1
*************************************************************************/
FL_DUMP(InFile>>Workspace) :-
	%% Include workspace in the dumped file
	flora_dump_file(InFile,Workspace,dontsquash).

FL_DUMP(InFile) :-
	%% Ignore workspace in the dumped file
	flora_dump_file(InFile,FLORA_DEFAULT_WORKSPACE,squash).


/*************************************************************************
  flora_dump_file(+File,+Workspace,+SquashingOption)

  Expects a Flora file as input and dumps the .P file in a more readable
  format. If SquashingOption == squash, ignore Workspace in the final round 
  of gpp pre-processing.
*************************************************************************/
flora_dump_file(OrigInFile,Workspace,SquashingOption) :-
	flora_check_filename(OrigInFile,InFile),
	valid_flora_module_name(Workspace),
	( flora_locate_file(InFile,FLORA_FILE_EXT,FlrFile), !
	; flora_flrfilename_error(InFile),
	    !,
	    fail
	),
	%% Find the files that need to be dumped.
	flora_mainP_filename(FlrFile,PFile),
	flora_FDB_filename(FlrFile,FDBFile),
	flora_FLD_filename(FlrFile,FLDFile),
	flora_dump_filename(PFile,DumpPFile),
	flora_dump_filename(FDBFile,DumpFDBFile),
	flora_dump_filename(FLDFile,DumpFLDFile),

	flora_set_xpp_options_for_compile,
	flora_compile_file(FlrFile,PFile,FDBFile,FLDFile,Status),
	( Status == FLORA_FAILURE -> flora_clear_xpp_options, !, fail
	; true
	),
	flora_clear_xpp_options,
	!,
	%% Compilation has succeeded. Need to dump file contents.
	( SquashingOption == squash -> NewWorkspace=''
	;
	  %% Add '_' to the workspace to simplify reading.
	  atom_concat(Workspace,'_',NewWorkspace)
	),
	!,
	( flora_file_op(exists,PFile) ->
	    %% Dump the main .P file.
	    flora_gpp_dumpfile(PFile,DumpPFile,NewWorkspace)
	;
	  flora_error_line('Failed to create the main dumpfile ~w', [PFile])
	),
	( flora_file_op(exists,FDBFile) ->
	    %% Dump the .fdb file if it exists.
	    flora_gpp_dumpfile(FDBFile,DumpFDBFile,NewWorkspace)
	;
	    true
	),
	( flora_file_op(exists,FLDFile) ->
	    %% Dump the .fld file if it exists.
	    flora_gpp_dumpfile(FLDFile,DumpFLDFile,NewWorkspace)
	;
	    true
	),
	!.


/*************************************************************************
  flora_gpp_dumpfile(+FileName,+DumpFileName,+Workspace)

  When this procedure is called, the input file is already checked
  for existence.
*************************************************************************/
flora_gpp_dumpfile(FileName,DumpFileName,Workspace) :-
	flora_loader_message('Making dump file ~w from ~w',
			     [DumpFileName,FileName]),
	parse_filename(DumpFileName,_,Base,_),
	flora_concat_atoms(['-D FLORA_DUMP -D FLORA_FDB_FILENAME="''',
			    Base,'.',FLORA_FDB_EXT,
			    '''" -D FLORA_FLD_FILENAME="''',
			    Base,'.',FLORA_FLD_EXT,'''"'],
			   ExtraOptions),
	flora_set_xpp_options_for_dump(Workspace,ExtraOptions),
	xpp_process_file(FileName,XPP_process,IOportFromGPP),
	%% Save standard input and output ports
	seeing(StdIn),
	telling(StdOut),
	%% Pipe gpp output to standard input
	see(IOportFromGPP),
	%% Pipe standard output to the dump file
	open(DumpFileName,write,DumpPort),
	tell(DumpPort),
	%% do prettyprinting; gpp output is now piped through
	%% this predicate to the dumpfile
	prettyprint_stdin,
	process_control(XPP_process,wait(ExitStatus)),
	(ExitStatus==0, !
	; flora_error_line('Error while preprocessing ~w', [FileName])
	),
	flora_clear_xpp_options,
	%%close(IOportFromGPP),
	%%close(DumpPort),
	seen,
	told,
	%% Restore the old stdin and stdout
	see(StdIn),
	tell(StdOut),
	!.

flora_gpp_dumpfile(FileName,_DumpFileName,_Workspace) :-
	flora_error_line('Failed to make a dump file for ~w',[FileName]),
	!,
	fail.


/*****************************************************************************
   flora_copy_and_preprocess(?Input, ?Output, +GPP_OptionsList)

   Input and Output are either bound to file names or are unbound variables.
   GPP_OptionsList is a list of options to pass to the preprocessor.
               Each option is an atom. The atoms in the list are concatenated
	       and passed to gpp.
*****************************************************************************/
flora_copy_and_preprocess(Input,Output,GPP_OptionsList) :-
	flora_concat_atoms(GPP_OptionsList, XPP_Options),
	flora_replace_xpp_options(XPP_Options),
	xpp_process_file(Input,XPP_process,IOportFromGPP),
	%% Save standard input and output ports
	seeing(StdIn),
	telling(StdOut),
	flora_copy_input(IOportFromGPP,Output),
	process_control(XPP_process,wait(ExitStatus)),
	(ExitStatus==0, !
	; flora_error_line('Error while preprocessing ~w', [Input])
	),
	flora_clear_xpp_options,
	seen,
	%% Restore the old stdin and stdout
	see(StdIn),
	tell(StdOut).
	

/*****************************************************************************
   flora_measure_time(+Call,+Message)
   Tells now much time the call has been executing.
   Message is printed to identify the call.
*****************************************************************************/
flora_measure_time(Call,Message) :-
	flora_cputime(T1),
	call(Call),
	flora_cputime(T2),
	Delta is T2 - T1,
	flora_loader_message('~w ~w seconds',[Message,Delta]).


flora_abort :-
	xsb_backtrace(Bt),
	close_open_tables,
	throw(FLORA_ABORT(Bt)).
flora_abort(Msg) :-
	flora_abort(Msg,FLORA_ABORT).

flora_abort(Msg,AbortType) :-
	is_list(Msg),
	!,
	flora_concat_items(Msg,AtomMsg),
	xsb_backtrace(Bt),
	close_open_tables,
	ThrowMsg =.. [AbortType,AtomMsg,Bt],
	throw(ThrowMsg).
flora_abort(Msg,AbortType) :-
	xsb_backtrace(Bt),
	close_open_tables,
	ThrowMsg =.. [AbortType,Msg,Bt],
	throw(ThrowMsg).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Generation of the trailer filename
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/*
    Create a proper trailer filename for the given options: equality,
    inheritance, custom file
*/
flora_make_trailer_filename(TrailerOptions,TrailerFilerFN) :-
	member(FL_EQUALITY(Equality),TrailerOptions),
	member(FL_INHERITANCE(Inheritance),TrailerOptions),
	member(FL_TABLING(Tabling1),TrailerOptions),
	member(FL_TABLING(Tabling2),TrailerOptions), Tabling1 \== Tabling2,
	member(FL_CUSTOM(Custom),TrailerOptions),
	encode_path_as_filename(Custom,CustomFN),
	flora_concat_atoms(['trailer$eq=',Equality,'+inh=',Inheritance,'+tbl=',Tabling1,'+',Tabling2,'+cus=',CustomFN,'.',PROLOG_PFILE_EXT], TrailerFilerFN).

/*
   Converts full path to a single filename that is acceptable to both Unix 
   and Windows. The file name has no directory part. This ensures that
   trailer names are uniquely identified by the custom part of the trailer
   and the inheritance/equality parameters.
   Maps: / -> _, \ -> =, : -> %, . -> $
   Each occurrence of _, =, %, $ that is part of the input path is doubled 
   in the output filename.
*/
encode_path_as_filename(InPath, OutFilename) :-
	atom_codes(InPath,InPathList),
	encode_pathList_as_filenameList(InPathList,OutFilenameList),
	atom_codes(OutFilename,OutFilenameList).

encode_pathList_as_filenameList([],[]) :- !.
encode_pathList_as_filenameList([CH_SLASH|Rest],[CH_UNDERSCORE|Rest1]) :-
	!,
	encode_pathList_as_filenameList(Rest,Rest1).
encode_pathList_as_filenameList([CH_BACKSLASH|Rest],[CH_EQUAL|Rest1]) :-
	!,
	encode_pathList_as_filenameList(Rest,Rest1).
encode_pathList_as_filenameList([CH_DOT|Rest],[CH_DOLLAR|Rest1]) :-
	!,
	encode_pathList_as_filenameList(Rest,Rest1).
encode_pathList_as_filenameList([CH_COLON|Rest],[CH_PERCENT|Rest1]) :-
	!,
	encode_pathList_as_filenameList(Rest,Rest1).
encode_pathList_as_filenameList([CH_UNDERSCORE|Rest],[CH_UNDERSCORE,CH_UNDERSCORE|Rest1]) :-
	!,
	encode_pathList_as_filenameList(Rest,Rest1).
encode_pathList_as_filenameList([CH_EQUAL|Rest],[CH_EQUAL,CH_EQUAL|Rest1]) :-
	!,
	encode_pathList_as_filenameList(Rest,Rest1).
encode_pathList_as_filenameList([CH_PERCENT|Rest],[CH_PERCENT,CH_PERCENT|Rest1]) :-
	!,
	encode_pathList_as_filenameList(Rest,Rest1).
encode_pathList_as_filenameList([CH_DOLLAR|Rest],[CH_DOLLAR,CH_DOLLAR|Rest1]) :-
	!,
	encode_pathList_as_filenameList(Rest,Rest1).
encode_pathList_as_filenameList([Char|Rest],[Char|Rest1]) :-
	!,
	encode_pathList_as_filenameList(Rest,Rest1).


%% Include #define statements according to TrailerOptions
include_xpp_control_variables(TrailerOptions) :-
	flora_current_out_nl,
	flora_current_out_line(':- compiler_options([xpp_on]).~n'),
	flora_current_out_line('/********** Tabling and Trailer Control Variables ************/'),
	flora_current_out_nl,
	(member('LOADABLETRAILER',TrailerOptions)
	-> flora_current_out_line('#define LOADABLETRAILER')
	; true
	),
	member(FL_EQUALITY(EqType),TrailerOptions),
	flora_current_out_string('#define EQUALITY~w~n', [EqType]),
	member(FL_INHERITANCE(InhType),TrailerOptions),
	flora_current_out_string('#define INHERITANCE~w~n', [InhType]),
	member(FL_TABLING(TabType1),TrailerOptions),
	flora_current_out_string('#define TABLING~w~n', [TabType1]),
	member(FL_TABLING(TabType2),TrailerOptions), TabType1 \== TabType2,
	flora_current_out_string('#define TABLING~w~n', [TabType2]),
	member(FL_CUSTOM(CusFile),TrailerOptions),
	(CusFile == NONE
	-> flora_current_out_line('#define CUSTOMnone')
	; 
	    %% file without quotes; quotes are added
	    %% in assert(flora_trailer_registry(...)) calls
	    flora_current_out_string('#define CUSTOMTRAILER ~w~n', [CusFile])
	),
	flora_current_out_nl,
	(subsumptive_tabling_requested(TrailerOptions)
	-> flora_current_out_line('#define FLORA_SUBSUMPTIVE_TABLING ')
	;  true
	),
	(incremental_tabling_requested(TrailerOptions)
	-> flora_current_out_line('#define FLORA_INCREMENTAL_TABLING ')
	;  true
	),
	flora_current_out_nl,
	!.
include_xpp_control_variables(TrailerOptions) :- 
	flora_error_line('Bug in include_xpp_control_variables/1. Options: ~w', [TrailerOptions]),
	fail.



%% collect all trailer options for module
get_trailer_options(Module,Options) :-
	findall(O,flora_trailer_registry(Module,O),Options).

subsumptive_tabling_requested(TrailerOptions) :-
	member(FL_TABLING(FL_SUBSUMPTIVE),TrailerOptions).
subsumptive_tabling_in_effect(Module) :-
	flrregistry:flora_trailer_registry(Module,FL_TABLING(FL_SUBSUMPTIVE)).
	
incremental_tabling_requested(TrailerOptions) :-
	member(FL_TABLING(FL_INCREMENTAL),TrailerOptions).
incremental_tabling_in_effect(Module) :-
	flrregistry:flora_trailer_registry(Module,FL_TABLING(FL_INCREMENTAL)).
	

/*
   extract_trailer_options(+OldOptions,-NewOptions,-TrailerOptions)

   Check for conflicting options in the trailer.
   If no conflicts, split off trailer options, resolve defaults.
   Strip indices from all options.
*/

extract_trailer_options(InputFile,OldOptions,Defaults,NewOptions,NewTrailerOptions) :-
	%% this succeeds, if errors
	\+ found_option_conflicts(InputFile,OldOptions),
	strip_indices_from_options_and_split(OldOptions,NewOptions,TrailerOptions),
	fixup_trailer_options(TrailerOptions,Defaults,NewTrailerOptions).

%% This should be replaced by a recursive procedure that takes a list like
%% [FL_EQUALITY,FL_INHERITANCE,FL_TABLING,FL_CUSTOM]
%% and checks every element for conflicts
found_option_conflicts(InputFile,OptList) :-
	member((FL_EQUALITY(X),IdxX), OptList),
	member((FL_EQUALITY(Y),IdxY), OptList),
	conflicting_semantics_options(FL_EQUALITY(X),FL_EQUALITY(Y)),
	!,
	print_option_conflict_error(InputFile,FL_EQUALITY,IdxX,IdxY).
found_option_conflicts(InputFile,OptList) :-
	member((FL_INHERITANCE(X),IdxX), OptList),
	member((FL_INHERITANCE(Y),IdxY), OptList),
	conflicting_semantics_options(FL_INHERITANCE(X),FL_INHERITANCE(Y)),
	!,
	print_option_conflict_error(InputFile,FL_INHERITANCE,IdxX,IdxY).
found_option_conflicts(InputFile,OptList) :-
	member((FL_TABLING(X),IdxX), OptList),
	member((FL_TABLING(Y),IdxY), OptList),
	conflicting_semantics_options(FL_TABLING(X),FL_TABLING(Y)),
	!,
	print_option_conflict_error(InputFile,FL_INHERITANCE,IdxX,IdxY).
found_option_conflicts(InputFile,OptList) :-
	member((FL_CUSTOM(X),IdxX), OptList),
	member((FL_CUSTOM(Y),IdxY), OptList),
	conflicting_semantics_options(FL_CUSTOM(X),FL_CUSTOM(Y)),
	!,
	print_option_conflict_error(InputFile,FL_CUSTOM,IdxX,IdxY).

conflicting_semantics_options(FL_EQUALITY(X),FL_EQUALITY(Y)) :-
	nonvar(X), nonvar(Y), X \= Y.
conflicting_semantics_options(FL_INHERITANCE(X),FL_INHERITANCE(Y)) :-
	nonvar(X), nonvar(Y),  X \= Y.
conflicting_semantics_options(FL_CUSTOM(X),FL_CUSTOM(Y)) :-
	nonvar(X), nonvar(Y),  X \= Y.
conflicting_semantics_options(FL_TABLING(X),FL_TABLING(Y)) :-
	nonvar(X), nonvar(Y),
	( X == FL_SUBSUMPTIVE, Y == FL_VARIANT, !
	; Y == FL_SUBSUMPTIVE, X == FL_VARIANT
	),
	!.
conflicting_semantics_options(FL_TABLING(X),FL_TABLING(Y)) :-
	nonvar(X), nonvar(Y),
	( X == FL_INCREMENTAL, Y == FL_NONINCREMENTAL, !
	; Y == FL_INCREMENTAL, X == FL_NONINCREMENTAL
	),
	!.

print_option_conflict_error(InputFile,OptionName,Idx1,Idx2) :-
	(flora_nth_token(Idx1,Tk1),
	    flora_token_text(Tk1,_TextStr1,BLN1,_BCN1,_ELN1,_ECN1),
	    flora_nth_token(Idx2,Tk2),
	    flora_token_text(Tk2,_TextStr2,BLN2,_BCN2,_ELN2,_ECN2)
	->
	    flora_error_line('~w: Conflicting occurrences of option `~w'' in the directive `~w'' on lines ~w and ~w',
	                     [InputFile,OptionName,FL_SEMANTICS,BLN1,BLN2])
	;
	    flora_error_line('~w: Conflicting occurrences of option `~w'' in the directive `~w''',
	                     [InputFile,OptionName,FL_SEMANTICS])
	).


/*
   Takes an option list (for the trailers) of the form [(Option,Index),...]
   and deletes indices from options. Options FLOBJEQLDEF, FL_EQUALITY,
   FL_CUSTOM, FL_INHERITANCE are ignored completely.
*/
strip_indices_from_options_and_split([],[],[]).
strip_indices_from_options_and_split([(Option,_I)|Rest],
				     StrippedOptions,
				     [Option|RestTrailer]) :-
	(Option = FLOBJEQLDEF; Option = FL_EQUALITY(_);
	    Option = FL_INHERITANCE(_); Option = FL_CUSTOM(_);
	    Option = FL_TABLING(_)
	),
	!,
	strip_indices_from_options_and_split(Rest,StrippedOptions,RestTrailer).
strip_indices_from_options_and_split([(Option,_I)|Rest], [Option|StrippedRest], TrailerOptions) :-
	strip_indices_from_options_and_split(Rest,StrippedRest,TrailerOptions).

/*
   Fix option defaults:
       FLOBJEQLDEF overrides equality(none),
       equality(none), inheritance(flogic), custom(none) are defaults.
   Always succeeds.
*/
fixup_trailer_options(TrailerOptions,Defaults,NewTrailerOptions) :-
	fixup_trailer_options1(TrailerOptions,Defaults,NewTrailerOptions1),
	sort(NewTrailerOptions1,NewTrailerOptions).
fixup_trailer_options1(TrailerOptions,Defaults,NewTrailerOptions) :-
	var(TrailerOptions),
	!,
	fixup_trailer_options1([],Defaults,NewTrailerOptions),
	TrailerOptions = NewTrailerOptions.

fixup_trailer_options1(TrailerOptions,Defaults,NewTrailerOptions) :-
	(member(FLOBJEQLDEF,TrailerOptions)
	->
	    flrporting:flora_delete_from_list(FLOBJEQLDEF,TrailerOptions,TrailerOptions1),
	    /*
	    %% This makes :=: in the head override the explicit
	    %% equality(none) option. But our stated policy is that
	    %% the explicit directive overrides the implicit ones
	    */
	    ( member(FL_EQUALITY(_),TrailerOptions1)
	    -> 
		NewTrailerOptions1 = TrailerOptions1
	    ; 
		NewTrailerOptions1 = [FL_EQUALITY(BASIC)|TrailerOptions1]
	    )
	;
	    NewTrailerOptions1 = TrailerOptions
	),
	(member(FL_CUSTOM(File),NewTrailerOptions1)
	->
	    %% custom files must be expanded
	    ( (var(File) ; File == NONE)
	    -> NewTrailerOptions2 = NewTrailerOptions1
	    ;
		flora_file_op(expand,File,ExpandedFile),
		flrporting:flora_delete_from_list(FL_CUSTOM(File),NewTrailerOptions1,NewTrailerOptions1Tmp),
		NewTrailerOptions2 = [FL_CUSTOM(ExpandedFile)|NewTrailerOptions1Tmp]
	    )
	; NewTrailerOptions2 = NewTrailerOptions1
	),
	add_default_options(Defaults,NewTrailerOptions2,NewTrailerOptions).


add_default_options([],Options,Options) :- !.
add_default_options([Opt|Defaults],CurrentOptions,NewOptions) :-
	add_one_option(Opt,CurrentOptions,NewOptions1),
	add_default_options(Defaults,NewOptions1,NewOptions).

add_one_option(Option,[],[Option]) :- !.
add_one_option(Option,[HeadOpt|Options],[HeadOpt|NewOptions]) :-
	(
	  (conflicting_semantics_options(Option,HeadOpt)
	  ; Option = HeadOpt
	  )
	->
	  NewOptions = Options
	;
	  add_one_option(Option,Options,NewOptions)
	).



check_custom_trailer_file(TrailerOptions) :-
	( member(FL_CUSTOM(File),TrailerOptions)
	->
	    (File == NONE, !
	    ;
		flora_file_op(expand,File,ExpandedFile),
		(flora_file_op(exists, ExpandedFile), !
		; flora_error_line('Custom trailer file not found: ~w', [ExpandedFile]),
		    fail
		)
	    )
	;
	    true
	).



%% If CallerInfo is a var, abort - used in closure/ for debugging to
%% make sure that Caller is always bound
%% For now, the second elt in caller info list is just the callee module name
%% Later it might be a term with arguments, such as module(arg1,arg2,...)

%% This checks for bugs in the caller info.
%% In FLORA-2 releases, the first 2 clauses should be commented out, for speed.
/*
checkCallerInfo(_Call,_CalleeModule,[Caller,_ModArgs|_]) :-
	var(Caller),
	!,
	flora_abort(['internal bug: ', _Call, '- unbound Caller argument']).
checkCallerInfo(Call,CalleeModule,[_Caller,ModArgs|_]) :-
	(CalleeModule = ModArgs -> fail
	; flora_abort(['internal bug: ', Call, '- the callee component ',
		       ModArgs, ' does not match its presumed module ',
		       CalleeModule])
	).
*/
checkCallerInfo(_,_,_).




/*
    flora_read_parse_compile_build_term(-Code,?Module,-Status)

    Reads a term from std input, parses, compiles, and builds it.
    Term can also be a reification.
    Molecules or rules not allowed unless represented as reified terms.
    Always succeeds (unless there is a bug).

    Code: the code of the term read. 
          If the thing read is not a term then Code is left unbound
    Module: If unbound then FLORA_DEFAULT_WORKSPACE is assumed.
            If bound and if the term is a reification then the reified formula
	    is built for this module.
    Status: [OutcomeFlag, EOF_flag|ErrorList]
            OutcomeFlag = null/ok/error
	       null  - a blank line was read, no code generated (Code = null)
	       ok    - good code was generated, no errors
	       error - parsing/compilation errors
	    EOF_flag = eof/not_eof
               not_eof -  end-of-file has not been reached
	       eof     -  if it has been reached. 
            ErrorList - if OutcomeFlag=null/ok, then this list would be empty.
                        if OutcomeFlag=error, then this would be a list of the
			form [error(N1,N2,Message), ...]
			N1, N2 encode the line and character number, which is
			largely irrelevant in this context. Message is an error
			message that explains the problem. Error messages are 
			also printed to stderr.
*/
flora_read_parse_compile_build_term(Code,Module,Status) :-
	(var(Module) -> Module=FLORA_DEFAULT_WORKSPACE; true),
	flora_tokens(InputTokens,LexerStatus), 
	%% get Tokens
	count_errors(LexerStatus,LexErrNum),
	( LexErrNum > 0 ->
	    ErrNum=LexErrNum,
	    Status1 = LexerStatus
	; flora_blank_line(InputTokens) ->
	    ErrNum=0,
	    Outcome = FLORA_NULL_CODE,
	    Code = NULL
	;   %% compose
	    flora_compose(InputTokens,ComposerTerm,ComposerStatus),
	    count_errors(ComposerStatus,CompoErrNum),
	    ( CompoErrNum > 0 ->
		ErrNum=CompoErrNum,
		Status1=ComposerStatus
	    ;   %% parse
		flora_parse_term_external(ComposerTerm,ParseTerm,ParserStatus),
		count_errors(ParserStatus,ParErrNum),
		( ParErrNum > 0 ->
		    ErrNum=ParErrNum,
		    Status1 = ParserStatus
		;   %% compile
		    flora_compile_pathexp(ParseTerm,CompileCode,CompileStat),
		    count_errors(CompileStat,CompiErrN),
		    ( CompiErrN > 0 ->
			ErrNum=CompiErrN,
			Status1=CompileStat 
		    ;
			flora_build_struct(CompileCode, Module,
					   '', %% does not matter which context
					   _Varlist, Code,
					   _, CoderStatus),
			count_errors(CoderStatus,ErrNum),
			Status1 = CoderStatus
		    )
		)
	    )
        ),

	(var(ComposerStatus) -> ComposerStatus = [] ; true),
	(var(ParserStatus) -> ParserStatus = [] ; true),
	(var(CompileStat) -> CompileStat = [] ; true),
	(var(CoderStatus) -> CoderStatus = [] ; true),
	EWS=[error(ErrNum),
	     lexer([(InputTokens,LexerStatus)]),
	     composer(ComposerStatus),
	     parser(ParserStatus),
	     compiler(CompileStat),
	     coder(CoderStatus)],

	flora_print_warnings(EWS),
	flora_print_errors(EWS),

	(ErrNum == 0 -> Status2=[]; Status2 = Status1),
	(Outcome == FLORA_NULL_CODE -> true
	; Status2 = [] -> Outcome = FLORA_GOOD_CODE
	; Outcome = FLORA_BAD_CODE
	),
	( flora_end_of_input(LexerStatus)
	-> Status = [Outcome,FLORA_EOF|Status2]
	;  Status = [Outcome,FLORA_NOT_EOF|Status2]
	).

/*
    flora_read_parse_compile_build_term(-String,-Code,?Module,-Status)
    Like flora_read_parse_compile_build_term/3 but reads from a source
    such as a string (atom(String)) or a file (file(FileName)).
*/
flora_read_parse_compile_build_term(Source,Code,Module,Status) :-
	see_source(Source,IOPort,OldStdin),
	!,
	(flora_read_parse_compile_build_term(Code,Module,Status),
	    seen_source(IOPort,OldStdin)
	-> true
	; %% failure is impossible unless a bug
	    seen_source(IOPort,OldStdin),
	    fail
	).

/*
   flora_read_parse_compile_build_term_list(+Source,-CodeList,?Module)

   This is like flora_read_parse_compile_build_term/4, but
   it collects all terms from the source (atom(Str) or file(FileName),
   which looks like Term. Term. ... Term.
   and returns them in a list, CodeList, of the form code(TermCode,Status).
   TermCode is the compiled code of a term in String, and Status is the status
   of the compilation for this term, as in flora_read_parse_compile_build_term/3
*/
flora_read_parse_compile_build_term_list(Source,CodeList,Module) :-
	see_source(Source,IOPort,OldStdin),
	!,
	/*
	%% using flora_read_parse_compile_build_loop/3 is more parsimonious
	read_parse_compile_build_terms(CodeList,Module),
	*/
	findall(code(Code,Status),
		flora_read_parse_compile_build_loop(Code,Module,Status),
		CodeList),
	seen_source(IOPort,OldStdin).

/*
   flora_read_parse_compile_build_loop(-Code,?Module,-Status) :-

   This one is useful for reading terms one-by-one and returning answers
   interactively. 
   Under 1-at-a-time solution (_one), will wait for input, return parsed code,
   then wait for input again, if the user types ";". If the user types
   RET then succeeds and exits.
   Under the all-solutions semantics (_all), will wait for inputs and process
   them, but will not return answers unless the file is closed (e.g., Ctl-D at
   standard input).
*/
flora_read_parse_compile_build_loop(Code,Module,Status) :-
	flora_read_parse_compile_build_term(Code1,Module,Status1),
	(Status1 \== [null,eof], Code=Code1, Status=Status1
	; Status1 == [null,eof] -> fail
	; flora_read_parse_compile_build_loop(Code,Module,Status)
	).



see_source(Source,IOPort,OldStdin) :-
	seeing(OldStdin),
	open(Source, read, IOPort),
	see(IOPort).

seen_source(IOPort,OldStdin) :-
	seen,
	see(OldStdin),
	close(IOPort).
