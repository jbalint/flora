/* File:      flrcompiler.P  -- The Flora Compiler
**
** Author(s): Guizhen Yang, Michael Kifer
**
** Contact:   kifer@cs.stonybrook.edu
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2011;
**      and Vulcan, Inc., 2008-2011.
**
** All rights reserved.
**
** For information about licensing terms, please see
** http://silk.projects.semwebcentral.org/flora2-license.html
**
**
*/


:- compiler_options([xpp_on]).

#include "flora_errors.flh"
#include "flora_terms.flh"
#include "flora_porting.flh"
#include "flora_exceptions.flh"
#include "flora_characters.flh"

#define NEWVAR	        	 newvar
#define NEWDONTCAREVAR	       	 newdontcarevar
#define NEWCALLERVAR	       	 newcallervar
#define NEWPREDICATE        	 newpredicate
#define NEWOID                   FL_NEWOID_SYM
#define RULE_NUM                 rule_num
#define DEFAULT_RULE_TAG         default_rule_tag
#define NEWOID_COUNT        	 FL_NEWOID_PREFIX
#define TMPDIRECT        	 tmpdirect
#define TMPOPTION	         tmpoption
#define PERMAOPTION	         permaoption
#define COMPILATION_CONTEXT	 compcontext
#define DYNRULE_VARLIST          dynrule_varlist

#define  BODYLITERAL     1
#define  HEADLITERAL     2

%% ruleoid is used for numbered anonymous oid generation
:- dynamic ruleoid(_,_,_).
%%:- dynamic TMPDIRECT(_).
:- dynamic TMPOPTION(_,_).
:- dynamic PERMAOPTION(_).
:- dynamic COMPILATION_CONTEXT(_).
:- dynamic DYNRULE_VARLIST(_,_).
:- dynamic user_defined_function_var_substitute(_,_,_,_,_).
:- index(user_defined_function_var_substitute/5,2+1).
:- dynamic symbol(_,_,_,_,_,_,_).
:- dynamic nowarn_symbol(_,_,_,_,_).


/****************************************************************************
  utilities
****************************************************************************/
is_flrule(FLRULE(Head,Body),Head,Body).
is_flfact(FLFACT(Head),Head).
is_flquery(FLQUERY(Body),Body).
is_fldirective(FLDIRECTIVE(DirectList,I),DirectList,I).
is_fllabeled_construct(FLTAGGEDCONSTRUCT(Label,Contents),Label,Contents).
is_fludfunction(FLUDF(Function,Body,ReturnValue),Function,Body,ReturnValue).
is_fludfunctionfact(FLUDFFACT(Function,Value),Function,Value).

is_fludfsymbol(FLUDFSYM(ParserTerm),ParserTerm).
is_flsensorsymbol(FLSENSORSYM(ParserTerm),ParserTerm).
is_flprlgsymbol(FLPRLGSYM(ParserTerm),ParserTerm).

is_fllabel(FLTAG(Id,Meta,Index),Id,Meta,Index).

is_flexport_list(FLEXPORT_LIST(Term),Term).
is_flexport(FLEXPORT(Term,Modules,IsUpdatable),Term,Modules,IsUpdatable).
is_flexport(FLEXPORT(DynamicModule,Term,Modules,IsUpdatable),DynamicModule,Term,Modules,IsUpdatable).

is_fldynrule(FLDYNRULE(Head,Body,Label),Head,Body,Label).

is_flopdef(FLOPDEF(P,A,O),P,A,O).
is_flprolog_directive(FLPROLOG(List,Idx),List,Idx).
is_flindex(FLINDEX(A,P),A,P).
is_fltabledirect(FLTABLE(List,Idx),List,Idx).
is_flsensordirect(FLSENSOR(SensCall,DelayCond),SensCall,DelayCond).
is_flusesensordirect(FLUSESENSOR(List,Idx),List,Idx).
is_flusefunctiondirect(FLUSEFUNCTION(List,Idx),List,Idx).
is_flsemantics(FLSEMANTICS(A),A).
is_flsetsemantics(FLSETSEMANTICS(A),A).
is_flcmpopt(FLCMPOPT(OptList),OptList).

is_fldefeasible(FLDEFEASIBLE(Module),Module).

is_fldefeasible_rule_default(FLDEFEASIBLE_RULE_DEFAULT).
is_flstrict_rule_default(FLSTRICT_RULE_DEFAULT).

is_verbatim(FLVERBATIM(Instruction),Instruction).

is_flprefixdef(FLPREFIXDEF(PrefixName,PrefixStr),PrefixName,PrefixStr).

is_importmodule(FLIMPORTMOD(Module),Module).

is_flignoredep(FLIGNOREDEP(PredList),PredList).

is_flsymbolcontext(FLSYMBOLCONTEXT(PredList),PredList).

is_flconjunct(FLCONJUNCT(L,R),L,R).
is_fldisjunct(FLDISJUNCT(L,R),L,R).

is_flnaf(FLNAF(Goal),Goal).
is_flnot(FLNOT(Goal),Goal).
is_flneg(FLNEG(Goal,Idx),Goal,Idx).
is_default_negation(Term,Goal,not) :- is_flnot(Term,Goal).
is_default_negation(Term,Goal,naf) :- is_flnaf(Term,Goal).

is_fllogicquantifier(FLQUANTIFIER(Quant,VarNames,FormulaCode,Idx),
		     Quant,VarNames,FormulaCode,Idx).
is_fldelayquant(FLDELAYQUANTIFIER(Quant,Condition,Goal,Index),
		Quant,Condition,Goal,Index).


is_flhypothetical(FLHYPOTHETICAL(Op,Goal,Index),Op,Goal,Index).

is_flload(FLLOAD(LoadList),LoadList).

is_flconstraint(FLCONSTRAINT(ConstrBody),ConstrBody).

is_flemptyterm(FLEMPTYTERM(_Index)).

%% @module
is_flworkspace(FLWORKSPACE(P,WS),P,WS).
%% (dynrule)@module
is_flruleworkspace(FLRULEWORKSPACE(R,WS),R,WS).
%% P@_M
is_flfloralib(FLFLORALIB(P,M),P,M).
%% _M - the workspace itself
is_flfloralib(FLFLORALIB(Mod), Mod).

%% @_prolog(M) and @_prolog
is_flplib(FLPLIB(P,M),P,M).
is_flplib(FLPLIB(P),P).
%% @_prologall and @_prologall(module)
%% Make sure the coder translates P2H_PREDICATE/4 as prolog
is_flpliball(FLPLIBALL(P),P) :-
	flora_define_prolog(P2H_PREDICATE,4).
is_flpliball(FLPLIBALL(P,M),P,M) :-
	flora_define_prolog(P2H_PREDICATE,4).

is_flifthenelse(FLIFTHENELSE(Cond,Then,Else),Cond,Then,Else).
is_flifthen(FLIFTHEN(Cond,Then),Cond,Then).

%% Meta ~
is_fluniveqform(FLUNIVEQFORM(Left,Right),Left,Right).
%% Meta =..
is_flmetauniv(FLMETAUNIV(Left,Right),Left,Right).

is_reifyop(FLREIFYOP(Formula),Formula).

%% Control constructs while-do, while-loop, loop-until, do-until,unless-do
is_flcontrolconstruct(FLWHILEDO(Cond,Action),FLLIBWHILEDO,Cond,Action).
is_flcontrolconstruct(FLWHILELOOP(Cond,Action),FLLIBWHILELOOP,Cond,Action).
is_flcontrolconstruct(FLDOUNTIL(Cond,Action),FLLIBDOUNTIL,Cond,Action).
is_flcontrolconstruct(FLLOOPUNTIL(Cond,Action),FLLIBLOOPUNTIL,Cond,Action).
is_flcontrolconstruct(FLUNLESSDO(Cond,Action),FLLIBUNLESSDO,Cond,Action).

is_flterm(FLTERM(Funct,Arity,Args),Funct,Arity,Args) :-
	\+is_fltransactionalatom(Funct,_),
	\+is_fltransactionalterm(Funct,_,_,_),
	\+is_fltransactionalpredspec(Funct,_).
is_fltransactionalterm(FLTRANSACTIONALTERM(Func,N,Args),Func,N,Args) :- !.
is_fltransactionalterm(FLTERM(Term,Arity,Args),Funct,Arity,Args) :-
	is_fltransactionalpredspec(Term,Funct),
	!.
is_fltransactionalterm(FLTERM(Term,Arity,Args),Term,Arity,Args) :-
	is_fltransactionalterm(Term,_,_,_),
	!.
is_fltransactionalterm(FLTERM(F,Arity,Args),F,Arity,Args) :-
	is_fltransactionalatom(F,_).

is_flterm_or_flatom(Term,Funct,Arity,Args) :-
	is_flterm(Term,Funct,Arity,Args),
	!.
is_flterm_or_flatom(Atom,Atom,0,[]) :-
	is_flatom(Atom,_),
	!.

is_flarith(FLARITH(Expr),Expr).

is_flinsert(FLINSERT(Op,List,Cond),Op,List,Cond).
is_flinsert(FLINSERT(Op,List),Op,List).
is_fldelete(FLDELETE(Op,List,Cond),Op,List,Cond).
is_fldelete(FLDELETE(Op,List),Op,List).

is_fltablerefresh(FLREFRESH(List),List).

is_fltruthvalue(FLTRUTHVALUE(Formula,Op),Formula,Op).

is_fllabelprimitive(FLTAGPRIMITIVE(Label,HeadList),Label,HeadList).
is_flprefixprimitive(FLPREFIXPRIMITIVE(Prefix,Expansion,Module),Prefix,Expansion,Module).

is_flclause(FLCLAUSE(Head,Body),Head,Body).
is_flclause(FLCLAUSE(Mode,Head,Body),Mode,Head,Body).
is_fllabeledclause(FLTAGGEDCLAUSE(Label,Head,Body),Label,Head,Body).
is_fllabeledclause(FLTAGGEDCLAUSE(Label,Mode,Head,Body),Label,Mode,Head,Body).

is_flcatch(FLCATCH(Goal,Error,Handler),Goal,Error,Handler).
is_flthrow(FLTHROW(Error),Error).
is_flp2h(FLP2H(Prolog,Hilog),Prolog,Hilog).

is_flnewoidop(FLNEWOIDOP(Var),Var).

%% Op is needed for newmodule only because of its position information 
is_flcallermodule(FLCALLERMODULE(Op,Var),Op,Var).
%% Op needed for newmodule/erasemodule only because of its position information 
is_flnewmodule(FLNEWMODULE(Op,Module),Op,Module).
is_flerasemodule(FLERASEMODULE(Op,Module),Op,Module).
is_flupdaterule(FLUPDATERULE(Op,RuleList),Op,RuleList).

is_flaggregate(FLAGGREGATE(Op,V,GV,Sort,Goal),Op,V,GV,Sort,Goal).

%% Binary relationship, like : or ::
is_flbirelate(FLBIRELATE(Obj1,RelType,Obj2),Obj1,RelType,Obj2).
is_flobjspec(FLOBJSPEC(Obj,Spec),Obj,Spec).
%% Represents object reference: O.M, O!M. RefType is ->, *->, ...
is_flobjref(FLOBJREF(Obj,RefType,Att),Obj,RefType,Att).

%% RefType represents the arrow type: ->, *->, ->, =>>, ...
is_flmvdattspec(FLMVDATTSPEC(Att,RefType,Val),Att,RefType,Val).
is_flsigattspec(FLSIGATTSPEC(Att,RefType,Val),Att,RefType,Val).
is_flsigattconspec(FLSIGATTCONSPEC(Att,Constr,RefType,Val),Att,Constr,RefType,Val).
is_flsigconstr(FLSIGCONSTR(Lower,Upper),Lower,Upper).
is_flincattspec(FLINCATTSPEC(Att,RefType,Val),Att,RefType,Val).
is_fltolistattspec(FLTOLISTATTSPEC(Att,RefType,Val),Att,RefType,Val).
is_flboolsig(FLBOOLSIG(Att,RefType),Att,RefType).
is_fliboolsig(FLIBOOLSIG(Att,RefType),Att,RefType).
is_fltransig(FLTRANSIG(Att,RefType),Att,RefType).
is_flitransig(FLITRANSIG(Att,RefType),Att,RefType).

is_fltranspec(FLTRANSPEC(QN),Tran) :- 
	is_fltransactionalpredspec(QN,Tran),
	!.
is_fltranspec(FLTRANSPEC(Tran),Tran).

is_fltranspec(FLMETHSPEC(Meth),Tran) :-
	is_fltransactionalpredspec(Meth,Tran),
	!.
is_fltranspec(FLMETHSPEC(QN),QN) :- 
	is_fltransactionalatom(QN,_),
	!.
is_fltranspec(FLMETHSPEC(QN),QN) :- 
	is_fltransactionalterm(QN,_,_,_),
	!.

is_flmethspec(FLMETHSPEC(Meth),Meth) :-
	\+is_fltransactionalterm(Meth,_,_,_),
	\+is_fltransactionalpredspec(Meth,_),
	\+is_fltransactionalatom(Meth,_).
is_flimethspec(FLIMETHSPEC(IMeth),IMeth).

is_fltransactionalpredspec(FLTRANSACTIONALPREDSPEC(QN),QN).

is_flobjeql(FLOBJEQL(O1,O2),O1,O2).
is_flcut(FLCUT(I),I).

%% constructs like O[X=Y], O[X>Y], O[!], O[true], O[false], are compiled as
%% X=Y, !, true, etc.
is_flpassthru(FLPASSTRU(O),O).

%% basic building blocks
is_flatom(FLATOM(Atom,_I),Atom) :- 
	\+ is_fltransactionalatom(Atom,_),
	!.
is_flatom(FLATOM(Atom,Index),Atom,Index) :- 
	\+ is_fltransactionalatom(Atom,_),
	!.
get_flatom_name(Atom,Name) :- is_flatom(Atom,Name), !.
get_flatom_name(Atom,Name) :- is_flbuiltin_identifier(Atom,Name), !.
get_flatom_name(Atom,Atom) :- atom(Atom).

is_fltransactionalatom(FLTRANSACTIONALATOM(Atom,_I),Atom).
is_flnumber(FLNUMBER(Number,_I),Number).
%% transactional numbers are used only in :- index %arity-argument
is_fltransactionalnumber(FLTRANSACTIONALNUMBER(Number,_I),Number).
is_flstring(FLSTRING(String,_I),String).
is_fltransactionalstring(FLTRANSACTIONALSTRING(String,_I),String).
is_fltoken(FLTOKEN(Token,I),Token,I).
is_fltoken(FLTOKEN(Token,Num,I),Token,Num,I).

is_fldatatype(FLDATATYPE(Sort,Literal,Index),Sort,Literal,Index).
is_fltransactionaldatatype(FLTRANSACTIONALPREDSPEC(FLDATATYPE(Sort,Literal,Index)),Sort,Literal,Index).
is_fldatatypelist(DTListVal,List) :-
        nonvar(DTListVal),
        DTListVal = FLDATATYPELIST(List).


is_flbuiltin_identifier(FLBUILTIN_IDENTIFIER(Builtin,_I),Builtin).
is_flbuiltin_identifier(FLBUILTIN_IDENTIFIER(Builtin,I),Builtin,I).

is_flvariable(FLVAR(Name,Index),Name,Index).
is_anonymous_flvariable(FLVAR(FL_UNDERSCORE,I),I).
is_fltransactionalvariable(FLTRANSACTIONALVAR(Name,Index),Name,Index).
is_fllist(FLLIST(L,T,I),L,T,I).

is_fldelayedliteral(FLDELAYEDLITERAL(Op,Args),Op,Args).
is_fldelayedliteral(FLDELAYEDLITERAL(Op,Args,Mod),Op,Args,Mod).

is_isaspecop(FL_ISA).
is_subspecop(FL_SUB).
is_mvdrefop(FL_MVD).
is_imvdrefop(FL_INHERIMVD).
is_mvdspecop(FL_MVDARROW).
is_imvdspecop(FL_INMVDARROW).
is_mvdsigspecop(FL_MVDSIGARROW).
is_mvdincspecop(FL_ALLINARROW).
is_imvdincspecop(FL_INALLINARROW).
is_mvdtolistspecop(FL_TOLISTARROW).
is_imvdtolistspecop(FL_INTOLISTARROW).
is_imvdsigspecop(FL_INMVDSIGARR).


%% For postprocessing dynrules that were stuch inside insert{...} or delete{...}
is_prdynrule(PRDYNRULE(Head,Body,HVars,BVars,DelayCheck,Label),
	     Head,Body,HVars,BVars,DelayCheck,Label).

/****************************************************************************
  approx_flindex(+ParserTerm,-Index)

  Ideally, this procedure should always succeed with a meaningful index,
  since the input is a structure from the parser and corresponds to a
  piece of text in the program file.
****************************************************************************/
approx_flindex(FLATOM(_Atom,I),I)              :- !.
approx_flindex(FLTRANSACTIONALATOM(_Atom,I),I) :- !.
approx_flindex(FLBUILTIN_IDENTIFIER(_Id,I),I)  :- !.
approx_flindex(FLDATATYPE(_Type,_Sort,I),I)    :- !.
approx_flindex(FLNUMBER(_Number,I),I)          :- !.
approx_flindex(FLTRANSACTIONALNUMBER(_N,I),I)  :- !.
approx_flindex(FLSTRING(_String,I),I)          :- !.
approx_flindex(FLTRANSACTIONALSTRING(_S,I),I)  :- !.
approx_flindex(FLTOKEN(_Token,I),I)            :- !.
approx_flindex(FLTOKEN(_Token,_Num,I),I)       :- !.
approx_flindex(FLVAR(_Name,I),I)               :- !.
approx_flindex(FLTRANSACTIONALVAR(_Var,I),I)   :- !.
approx_flindex(FLLIST(_List,_T,I),I)           :- !.
approx_flindex(FLTERM(F,_,_),I)                :- !, approx_flindex(F,I).
approx_flindex(FLTRANSACTIONALTERM(F,_,_),I)   :- !, approx_flindex(F,I).

approx_flindex(FLBIRELATE(Obj1,_Rel,_O),I)  :- !, approx_flindex(Obj1,I).
approx_flindex(FLOBJSPEC(Obj,_Spec),I)      :- !, approx_flindex(Obj,I).
approx_flindex(FLOBJREF(Obj,_Ref,_Att),I)   :- !, approx_flindex(Obj,I).
approx_flindex(FLMETHSPEC(Meth),I)          :- !, approx_flindex(Meth,I).
approx_flindex(FLIMETHSPEC(Meth),I)         :- !, approx_flindex(Meth,I).
approx_flindex(FLTRANSPEC(Meth),I)          :- !, approx_flindex(Meth,I).
approx_flindex(FLBOOLSIG(Att,_),I)          :- !, approx_flindex(Att,I).
approx_flindex(FLIBOOLSIG(Att,_),I)         :- !, approx_flindex(Att,I).
approx_flindex(FLTRANSIG(Att,_),I)          :- !, approx_flindex(Att,I).
approx_flindex(FLITRANSIG(Att,_),I)         :- !, approx_flindex(Att,I).
approx_flindex(FLMVDATTSPEC(Att,_,_),I)     :- !, approx_flindex(Att,I).
approx_flindex(FLSIGATTSPEC(Att,_,_),I)     :- !, approx_flindex(Att,I).
approx_flindex(FLSIGATTCONSPEC(A,_,_,_),I)  :- !, approx_flindex(A,I).
approx_flindex(FLINCATTSPEC(Att,_,_),I)     :- !, approx_flindex(Att,I).
approx_flindex(FLTOLISTATTSPEC(Att,_,_),I)  :- !, approx_flindex(Att,I).
approx_flindex(FLOBJEQL(Obj,_),I)           :- !, approx_flindex(Obj,I).

approx_flindex([Obj|_],I)                   :- !, approx_flindex(Obj,I).
approx_flindex(FLNEWOIDOP(Op),I)            :- !, approx_flindex(Op,I).

approx_flindex(FLIFTHEN(Cond,_Then),I)      :- !, approx_flindex(Cond,I).
approx_flindex(FLIFTHENELSE(Cond,_,_),I)    :- !, approx_flindex(Cond,I).
approx_flindex(FLWHILEDO(Cond,_),I)         :- !, approx_flindex(Cond,I).
approx_flindex(FLWHILELOOP(Cond,_),I)       :- !, approx_flindex(Cond,I).
approx_flindex(FLDOUNTIL(Cond,_),I)         :- !, approx_flindex(Cond,I).
approx_flindex(FLLOOPUNTIL(Cond,_),I)       :- !, approx_flindex(Cond,I).
approx_flindex(FLUNLESSDO(Cond,_),I)        :- !, approx_flindex(Cond,I).

approx_flindex(FLCONJUNCT(First,_),I)       :- !, approx_flindex(First,I).
approx_flindex(FLDISJUNCT(First,_),I)       :- !, approx_flindex(First,I).
approx_flindex(FLRULE(Head,_),I)            :- !, approx_flindex(Head,I).
approx_flindex(FLFACT(Head),I)              :- !, approx_flindex(Head,I).
approx_flindex(FLQUERY(Body),I)             :- !, approx_flindex(Body,I).
approx_flindex(FLDIRECTIVE(_Dir,I),I)       :- !.
approx_flindex(FLTAGPRIMITIVE(Labl,_),I)  :- !, approx_flindex(Labl,I).

approx_flindex(FLTAGGEDCLAUSE(_,_,H,_),I)  :- !, approx_flindex(H,I).
approx_flindex(FLTAGGEDCLAUSE(_,H,_),I)    :- !, approx_flindex(H,I).
approx_flindex(FLCLAUSE(_,Head,_),I)        :- !, approx_flindex(Head,I).
approx_flindex(FLCLAUSE(Head,_),I)          :- !, approx_flindex(Head,I).
approx_flindex(FLUNIVEQFORM(Left,_),I)      :- !, approx_flindex(Left,I).
approx_flindex(FLMETAUNIV(Left,_),I)        :- !, approx_flindex(Left,I).
approx_flindex(FLAGGREGATE(Op,_,_,_),I)     :- !, approx_flindex(Op,I).
approx_flindex(FLCONSTRAINT(C),I)           :- !, approx_flindex(C,I).

approx_flindex(FLREIFYOP(Form),I)             :- !, approx_flindex(Form,I).
approx_flindex(FLTRUTHVALUE(Form,_),I)        :- !, approx_flindex(Form,I).
approx_flindex(FLPLIB(P,_M),I)                :- !, approx_flindex(P,I).
approx_flindex(FLPLIB(P),I)                   :- !, approx_flindex(P,I).
approx_flindex(FLPLIBALL(P,_M),I)             :- !, approx_flindex(P,I).
approx_flindex(FLPLIBALL(P),I)                :- !, approx_flindex(P,I).
approx_flindex(FLFLORALIB(P,_M),I)            :- !, approx_flindex(P,I).
approx_flindex(FLWORKSPACE(P,_WS),I)          :- !, approx_flindex(P,I).

approx_flindex(FLINSERT(Op,_List,_Cond),I)    :- !, approx_flindex(Op,I).
approx_flindex(FLINSERT(Op,_List),I)          :- !, approx_flindex(Op,I).
approx_flindex(FLDELETE(Op,_List,_Cond),I)    :- !, approx_flindex(Op,I).
approx_flindex(FLDELETE(Op,_List),I)          :- !, approx_flindex(Op,I).

approx_flindex(FLDELAYEDLITERAL(Op,_),I)      :- !, approx_flindex(Op,I).
approx_flindex(FLDELAYEDLITERAL(Op,_,_),I)    :- !, approx_flindex(Op,I).
approx_flindex(FLNOT(G),I)                    :- !, approx_flindex(G,I).
approx_flindex(FLNAF(G),I)                    :- !, approx_flindex(G,I).
approx_flindex(FLNEG(_G,I),I)                 :- !.
approx_flindex(FLQUANTIFIER(_Quant,_,_,I),I)  :- !.


/****************************************************************************
  approx_prindex(+ParserTerm,-Index)

  Same as approx_flindex, but for compiled code

  Ideally, this procedure should always succeed with a meaningful index,
  since the input is a structure from the parser and corresponds to a
  piece of text in the program file.
****************************************************************************/
approx_prindex(PRATOM(_Atom,I),I)                  :- !.
approx_prindex(PRATOMLIT(_Atom,I),I)               :- !.
approx_prindex(PRTRANSACTIONALATOMLIT(_Atom,I),I)  :- !.
approx_prindex(PRBUILTIN_IDENTIFIER(_Id,I),I)      :- !.
approx_prindex(PRNUMBER(_Number,I),I)              :- !.
approx_prindex(PRTRANSACTIONALNUMBER(_N,I),I)      :- !.
approx_prindex(PRSTRING(_String,I),I)              :- !.
approx_prindex(PRVARIABLE(_Name,I),I)              :- !.
approx_prindex(PRTRANSACTIONALVARIABLE(_Var,I),I)  :- !.
approx_prindex(PRLIST(_List,_T,I),I)               :- !.
approx_prindex(PRNEWOID(_,I),I)                    :- !.
approx_prindex(PRCUT(I),I)                         :- !.
approx_prindex(PRMODULARIZEDATOM(_Form,I),I)       :- !.
approx_prindex(PRMODULARIZEDATOM(_Form,_,I),I)     :- !.

approx_prindex(PRDATATYPE(_Type,_Sort,I),I)        :- !.
approx_prindex(PRDATATYPELIST(Lit),I)              :- !, approx_prindex(Lit,I).

approx_prindex(PRTERM(F,_,_),I)                    :- !, approx_prindex(F,I).
approx_prindex(PRTERMLIT(F,_,_),I)                 :- !, approx_prindex(F,I).
approx_prindex(PRTRANSACTIONALTERMLIT(F,_,_),I)    :- !, approx_prindex(F,I).

approx_prindex(PRISA(Obj,_,_),I)              :- !, approx_prindex(Obj,I).
approx_prindex(PRSUB(Obj,_,_),I)              :- !, approx_prindex(Obj,I).
approx_prindex(PREXISTS(Obj,_),I)             :- !, approx_prindex(Obj,I).
approx_prindex(PRMVD(Obj,_,_,_),I)            :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVD(Obj,_,_,_),I)           :- !, approx_prindex(Obj,I).
approx_prindex(PRMVDDEF(Obj,_,_),I)           :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVDDEF(Obj,_,_),I)          :- !, approx_prindex(Obj,I).
approx_prindex(PRMVDSIG(Obj,_,_,_),I)         :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVDSIG(Obj,_,_,_),I)        :- !, approx_prindex(Obj,I).
approx_prindex(PRMVDSIGDEF(Obj,_,_),I)        :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVDSIGDEF(Obj,_,_),I)       :- !, approx_prindex(Obj,I).
approx_prindex(PRMVDCON(Obj,_,_,_,_),I)       :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVDCON(Obj,_,_,_,_),I)      :- !, approx_prindex(Obj,I).
approx_prindex(PRMVDCONDEF(Obj,_,_,_,_,_),I)  :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVDCONDEF(Obj,_,_,_,_,_),I) :- !, approx_prindex(Obj,I).
approx_prindex(PRMVDTOLIST(Obj,_,_,_),I)      :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVDTOLIST(Obj,_,_,_),I)     :- !, approx_prindex(Obj,I).
approx_prindex(PRMVDINC(Obj,_,_,_),I)         :- !, approx_prindex(Obj,I).
approx_prindex(PRIMVDINC(Obj,_,_,_),I)        :- !, approx_prindex(Obj,I).
approx_prindex(PRMETH(Meth,_,_),I)            :- !, approx_prindex(Meth,I).
approx_prindex(PRIMETH(Meth,_,_),I)           :- !, approx_prindex(Meth,I).
approx_prindex(PRTRAN(Meth,_,_),I)            :- !, approx_prindex(Meth,I).
approx_prindex(PRBOOLSIG(Att,_,_),I)          :- !, approx_prindex(Att,I).
approx_prindex(PRIBOOLSIG(Att,_,_),I)         :- !, approx_prindex(Att,I).
approx_prindex(PRTRANSIG(Att,_,_),I)          :- !, approx_prindex(Att,I).
approx_prindex(PRITRANSIG(Att,_,_),I)         :- !, approx_prindex(Att,I).
approx_prindex(PROBJEQL(Obj,_,_),I)           :- !, approx_prindex(Obj,I).

approx_prindex([Obj|_],I)                     :- !, approx_prindex(Obj,I).

approx_prindex(PRAND(First,Second),I)         :-
	(approx_prindex(First,I), I \= NO_INDEX, !
	; approx_prindex(Second,I)).
approx_prindex(PROR(First,Second),I)               :- 
	(approx_prindex(First,I), I \= NO_INDEX, !
	; approx_prindex(Second,I)).
approx_prindex(PRRULE(Head,_),I)              :- !, approx_prindex(Head,I).
approx_prindex(PRDYNRULE(Head,_,_,_,_,_),I)   :- !, approx_prindex(Head,I).
approx_prindex(PRFACT(Head),I)                :- !, approx_prindex(Head,I).
approx_prindex(PRREIFY(F),I)                  :- !, approx_prindex(F,I).
approx_prindex(PRQUERY(Body),I)               :- !, approx_prindex(Body,I).
approx_prindex(PRDIRECTIVE(Direct),I)         :- !, approx_prindex(Direct,I).
approx_flindex(PRCONSTRAINT(C),I)             :- !, approx_flindex(C,I).

approx_prindex(FLORASYSLIB(NO_INDEX,_,_,Args),I) :- !, approx_prindex(Args,I).
approx_prindex(FLORASYSLIB(Idx,_,_,_),Idx)    :- !.

approx_prindex(PROLOGTERM(F,_,_),I)           :- !, approx_prindex(F,I).
approx_prindex(PROLOGTERM(F,_,_,_),I)         :- !, approx_prindex(F,I).
approx_prindex(PROLOGLIBLIT(P),I)             :- !, approx_prindex(P,I).
approx_prindex(PRFLORALIB(P),I)               :- !, approx_prindex(P,I).
approx_prindex(PRFDBSTORAGE(P),I)             :- !, approx_prindex(P,I).
approx_prindex(PRWORKSPACE(P,_WS),I)          :- !, approx_prindex(P,I).
approx_prindex(PRWORKSPACETERM(WS),I)         :- !, approx_prindex(WS,I).

approx_prindex(PRNOT(G),I)                    :- !, approx_prindex(G,I).
approx_prindex(PRNAF(G),I)                    :- !, approx_prindex(G,I).
approx_prindex(PRNEG(G),I)                    :- !, approx_prindex(G,I).
approx_prindex(PRQUANTIFIER(Form,_,_),I)      :- !, approx_prindex(Form,I).


/****************************************************************************
  encoding utilities
****************************************************************************/
rule_struct(Head,Body,PRRULE(Head,Body)).
fact_struct(Head,PRFACT(Head)).
query_struct(Goal,PRQUERY(Goal)).
directive_struct(Direct,PRDIRECTIVE(Direct)).

%% Label is a tripple: (TagCode,MetaCode,DefeatConditionCode)
dynrule_struct(Head,Body,HVars,BVars,DelayChecker,Label,PRDYNRULE(Head,Body,HVars,BVars,DelayChecker,Label)) :-
	report_option(FLSYSLIB(FLLIBINSERTRULE_A),NO_INDEX).

reify_struct(Formula,PRREIFY(Formula)) :-
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX).

%% We use this import directive support mechanism for @_prolog(module)
%%import_struct(F,N,M,PRIMPORT(F,N,M)).
cmpopt_struct(OptList,PRCMPOPT(OptList)).
ignoredep_struct(SpecList,PRIGNOREDEP(SpecList)).

%%empty module list, all modules allowed
export_struct(TermList,Code) :-
	florasyslib_struct(_Index,FLLIBEXPORT,_N,[TermList],Code).

%% :- importmodule foo.
importmodule_struct(Module,PRIMPORTMOD(Module)).

defeasible_struct(Module,PRDEFEASIBLE(Module)).

verbatim_struct(Instruction,PRVERBATIM(Instruction)).
table_directive_struct(SpecList,PRTABLE(SpecList)).


/****************************************************************************
  conjunct_struct(+Goal1,+Goal2,-Code)
  disjunct_struct(+Goal1,+Goal2,-Code)
  prolog_naf_struct(+Goal,-Code)
  flora_naf_struct(+Goal,-Code)
  neg_struct(+Goal,+Idx,-Code,-Status)
  head_neg_struct(+Goal,+Idx,-Code,-Status)
****************************************************************************/
conjunct_struct(Goal1,Goal2,Goal2) :-
	%% NULL and FL_TRUE are both dummy code that is ignored
	(Goal1 == NULL ; Goal1 == FL_TRUE),
	!.
conjunct_struct(Goal1,Goal2,Goal1) :-
	(Goal2 == NULL ; Goal2 == FL_TRUE),
	!.
conjunct_struct(Goal1,Goal2,PRAND(Goal1,Goal2)).

disjunct_struct(Goal1,Goal2,PROR(Goal1,Goal2)).

quantifier_struct(QuantifierType,FormCode,FreVarObjs,
		  PRQUANTIFIER(QuantifierType,FormCode,FreVarObjs)).
is_prquantifier(PRQUANTIFIER(QuantifierType,FormCode,FreVarObjs),
		QuantifierType,FormCode,FreVarObjs).

%% \+
prolog_naf_struct(Goal,PRNAF(Goal)).
%% not,naf
pure_flora_naf_struct(Goal,PRNOT(WrappedGoal,Line,CurrFileName)) :-
	code_line_and_file_by_prterm(Goal,Line,CurrFileName),
	modularized_atom_struct(FL_TABLED_UNNUMBER_CALL,NO_INDEX,FunCode),
	prologterm_struct(FunCode,1,[Goal],WrappedGoal).
%% We can optimize this by passing free variables list. If the list is empty,
%% we won't delay
flora_naf_struct(Goal,Code) :-
	pure_flora_naf_struct(Goal,PureNotCode),
	%% delay default negation
	delay_struct(NO_INDEX,FL_DEFLTNEG,[PureNotCode],Code).

%% delay struct
delay_struct(Index,DelayOp,Args,Code) :-
	code_line_and_file_by_index(Index,Line,CurrFileName),
	list_struct(Args,[],CodeList),
	%% this never gives out errors, so no need for file/nline args
	prologterm_struct(FLLIBDELAYEDLITERAL,4,
			  [DelayOp,CurrFileName,Line,CodeList],
			  FLDELAYSUPPORTMOD,
			  Code).


%% unlike not/naf, neg can appear in the head
neg_struct(PRAND(Goal1,Goal2),Idx,PROR(Struct1,Struct2),Status) :-
	neg_struct(Goal1,Idx,Struct1,S),
	( no_errors_found(S) -> 
	   neg_struct(Goal2,Idx,Struct2,Status)
	;  Status = S
	).
neg_struct(PROR(Goal1,Goal2),Idx,PRAND(Struct1,Struct2),Status) :-
	neg_struct(Goal1,Idx,Struct1,S),
	( no_errors_found(S) -> 
	   neg_struct(Goal2,Idx,Struct2,Status)
	;  Status = S
	).
%% double negation
neg_struct(PRNEG(Goal),_Idx,Goal,[]) :- !.

/*
neg_struct(Goal,Idx,_,[Err]) :-
	is_unimplemented_neg_negatable_literal(Goal),
	!,
	compiling_error(Idx,UNIMPLEMENTED_NEG,Err).
*/
neg_struct(Goal,Idx,_,[Err]) :-
	\+is_body_neg_negatable_literal(Goal),
	!,
	compiling_error(Idx,ILLEGAL_NEGBODY,Err).

neg_struct(Goal,_Idx,Code,[]) :-
	(workspace_struct(PRNEG(L),WS,Goal)
	-> workspace_struct(L,WS,Code) % double negation
	;  workspace_struct(L,WS,Goal)
	-> workspace_struct(PRNEG(L),WS,Code)
	; is_florasyslib_struct(Goal,Idx,FLLIBMODLIT,N,Args)
	-> florasyslib_struct(Idx,FLNEGLIBMODLIT,N,Args,Code)
	; is_florasyslib_struct(Goal,Idx,FLLIBMODOBJ,N,Args)
	-> florasyslib_struct(Idx,FLNEGLIBMODOBJ,N,Args,Code)
	; is_florasyslib_struct(Goal,Idx,FLNEGLIBMODLIT,N,Args)
	-> florasyslib_struct(Idx,FLLIBMODLIT,N,Args,Code)
	; is_prvariable(Goal,_VarName,Idx),
	    has_context(goal_reification)
	-> % When variable is negated under ~, as in ?X ~ neg ?Y.
	    thismodule_struct(ThisModule),
	    callerargsterm_struct(ThisModule,CallerInfo),
	    atomobj_struct(FL_INVALIDMODULE,Mod),
	    florasyslib_struct(Idx,FLNEGLIBMODLIT,3,[Goal,Mod,CallerInfo],Code)
	; is_prologterm(Goal,Struct,Arity,Args),
	    is_modularized_atom(Struct,Atom,Idx),
	    %% to check if this is a negatable prolog, reduce arity by 1:
	    %% modularized prolog has one extra caller argument
	    Arity1 is Arity-1,
	    flora_negatable_prlgdef(Atom,Arity1,NegAtm),
	    modularized_atom_struct(NegAtm,Idx,FCode),
	    prologterm_struct(FCode,Arity,Args,Code)
	;   Code = PRNEG(Goal)
	).

%% double negation
head_neg_struct(PRNEG(Goal),_Idx,Goal,[]) :- !.

head_neg_struct(Goal,Idx,Code,Status) :-
	%% Normally Goal is a single literal. It can also be a conjunction
	%% where the second conjunct is a cardinality constraint in a signature.
	%% In the latter case, the constraint is ignored.
	%% Any other conjunction is an error.
	conjunct_struct(Goal1,Goal2,Goal),
	ignorable_negated_head_conjunct(Goal2),
	!,
	head_neg_struct(Goal1,Idx,Code,Status).
	
head_neg_struct(Goal,Idx,Code,Status) :-
	workspace_struct(L,WS,Goal),
	!,
	head_neg_struct(L,Idx,Code1,Status),
	( no_errors_found(Status) -> 
		workspace_struct(Code1,WS,Code)
	;
		true
	).

head_neg_struct(Goal,_Idx,NegGoal,[]) :-
	is_prologterm(Goal,Struct,Arity,Args),
	is_modularized_atom(Struct,Atom,Idx),
	%% to check if this is a negatable prolog, reduce arity by 1:
	%% modularized prolog has one extra caller argument
	Arity1 is Arity-1,
	flora_negatable_prlgdef(Atom,Arity1,NegAtm),
	modularized_atom_struct(NegAtm,Idx,FCode),
	prologterm_struct(FCode,Arity,Args,NegGoal),
	!.
head_neg_struct(Goal,_Idx,PRNEG(Goal),[]) :-
	is_head_neg_negatable_literal(Goal),
	!.

head_neg_struct(Goal,Idx,Code,[]) :-
	is_prvariable(Goal,_VarName,_Idx),
	!,
	%% When variable is neg-negated (inside an update op)
	thismodule_struct(ThisModule),
	callerargsterm_struct(ThisModule,CallerInfo),
	atomobj_struct(FL_INVALIDMODULE,Mod),
	florasyslib_struct(Idx,FLNEGLIBMODLIT,3,[Goal,Mod,CallerInfo],Code).

head_neg_struct(Goal,_Idx,Code,[]) :-
	is_florasyslib_struct(Goal,Idx,FLNEGLIBMODLIT,N,Args),
	!,
	florasyslib_struct(Idx,FLLIBMODLIT,N,Args,Code).

head_neg_struct(_Goal,Idx,_Code,[Err]) :-
	compiling_error(Idx,ILLEGAL_NEGHEAD,Err).


ignorable_negated_head_conjunct(Goal) :-
	(is_prmvdcondef(Goal) ; is_primvdcondef(Goal)),
	!.
ignorable_negated_head_conjunct(Goal) :-
	workspace_struct(L,_WS,Goal),
	ignorable_negated_head_conjunct(L).


/****************************************************************************
  conjunct_code(+GoalList,-Code)

  Takes a list of goals and constructs a conjunct:
        prand(G1, prand(G2, G3))
  Discards NULLs
  If all are NULLs, returns NULL.
****************************************************************************/
conjunct_code([Goal],Goal).

conjunct_code([NULL|GList],ConjGoal) :- !, conjunct_code(GList,ConjGoal).

conjunct_code([Goal|GList],ConjGoal) :-
	conjunct_code(GList,ConjGoalTail),
	!,
	( ConjGoalTail == NULL ->
	    ConjGoal=Goal
	;
	  conjunct_struct(Goal,ConjGoalTail,ConjGoal)
	).


/****************************************************************************
  encoding routines

  Note: Only primitive structures (atoms, variables, numbers, strings, lists,
        newoids, and cuts) encode the index to the corresponding textual
        information. The compiler directives do not encode any textual
        information. However, not all primitive structures have a meaningful
        index, for instance, new variables that are generated for an oid
        reference. In this case, an index is approximated. In some other
        cases, an atom is generated to encode an internal structure. So there
        is no meaningful index. Then the macro NO_INDEX is encoded as a
        place holder. No textual information should be inferred from the
        NO_INDEX value.
****************************************************************************/
%% atomobj_struct/2
atomobj_struct(FLATOM(Atm,I),PRATOM(Atm,I)) :- !.
atomobj_struct(Atm,PRATOM(Atm,NO_INDEX)) :- atomic(Atm).
%% atomobj_struct/3
atomobj_struct(Atm,Index,PRATOM(Atm,Index)).

%% A prolog atom that has FLORA-2 prefix and workspace in it.
%% Currently, only FLORA_THIS_WORKSPACE is used
modularized_atom_struct(Atom,Idx,PRMODULARIZEDATOM(Atom,Idx)).
modularized_atom_struct(Atom,Mod,Idx,PRMODULARIZEDATOM(Atom,Mod,Idx)).
is_modularized_atom(PRMODULARIZEDATOM(Atom,Idx),Atom,Idx) :- !.
is_modularized_atom(PRMODULARIZEDATOM(Atom,_Mod,Idx),Atom,Idx) :- !.

transactionalatomobj_struct(FLTRANSACTIONALATOM(Atom,I),PRATOM(Atom,I)) :- !.


atomlit_struct(_Context,FLATOM(Atom,I),Code) :-
	flora_prlgdef(Atom,0),
	!,
	atomobj_struct(FLATOM(Atom,I),AtomCode),
	prologterm_struct(AtomCode,0,[],Code).
atomlit_struct(_Context,FLATOM(Atom,I),Code) :-
	flora_prlgdef(Atom,0,Mod),
	!,
	atomobj_struct(FLATOM(Atom,I),AtomCode),
	prologterm_struct(AtomCode,0,[],Mod,Code).
atomlit_struct(_Context,FLATOM(Atom,I),Code) :-
	flora_prlgdef_repl(Atom,0,ReplacementAtm,Mod),
	!,
	atomobj_struct(FLATOM(ReplacementAtm,I),AtomCode),
	prologterm_struct(AtomCode,0,[],Mod,Code).
atomlit_struct(_Context,FLBUILTIN_IDENTIFIER(Atom,I),Code) :-
	flora_prlgdef(Atom,0),
	!,
	builtin_identifier_struct(FLBUILTIN_IDENTIFIER(Atom,I),AtomCode),
	prologterm_struct(AtomCode,0,[],Code).
atomlit_struct(_Context,FLBUILTIN_IDENTIFIER(Atom,I),Code) :-
	flora_prlgdef(Atom,0,Mod),
	!,
	builtin_identifier_struct(FLBUILTIN_IDENTIFIER(Atom,I),AtomCode),
	prologterm_struct(AtomCode,0,[],Mod,Code).
atomlit_struct(_Context,FLBUILTIN_IDENTIFIER(Atom,I),Code) :-
	flora_prlgdef_repl(Atom,0,ReplacementAtm,Mod),
	!,
	builtin_identifier_struct(FLBUILTIN_IDENTIFIER(ReplacementAtm,I),AtomCode),
	prologterm_struct(AtomCode,0,[],Mod,Code).
atomlit_struct(Context,FLATOM(Atom,I),PRATOMLIT([Atom,Caller],I)) :-
	!,
	determine_caller_info(Context,Caller).
atomlit_struct(Context,FLBUILTIN_IDENTIFIER(Atom,I),PRATOMLIT([Atom,Caller],I)) :-
	!,
	determine_caller_info(Context,Caller).
%% This is for the cases of an atomic literal like "abcd"^^foo
atomlit_struct(Context,Atomspec,PRATOMLIT([Atomspec,Caller],Idx)) :-
	is_prdatatype(Atomspec,_,_,Idx),
	determine_caller_info(Context,Caller).

transactionalatomlit_struct(Context,FLTRANSACTIONALATOM(Atom,I),PRTRANSACTIONALATOMLIT([Atom,Caller],I)) :-
	!,
	determine_caller_info(Context,Caller).
%% This is for the case of an atomic literal like %"abcd"^^foo
transactionalatomlit_struct(Context,Atomspec,PRTRANSACTIONALATOMLIT([Atomspec,Caller],Idx)) :-
	is_prdatatype(Atomspec,_,_,Idx),
	determine_caller_info(Context,Caller).

numobj_struct(FLNUMBER(Number,I),PRNUMBER(Number,I)) :- !.
numobj_struct(Number,PRNUMBER(Number,NO_INDEX)) :- number(Number).

%% transactional numbers are used only in :- index %arity-argument
transactionalnumobj_struct(FLTRANSACTIONALNUMBER(Number,I),PRTRANSACTIONALNUMBER(Number,I)).

prvar_to_flvar_struct(PRVARIABLE(Name,Index),FLVAR(Name,Index)).
flvar_struct_change_index(FLVAR(Name,_Index),FlIndex,FLVAR(Name,FlIndex)).

varobj_struct(FLVAR(Name,Index),PRVARIABLE(Name,Index)).
varobj_struct(Name,Index,PRVARIABLE(Name,Index)).
varobj_struct(Name,PRVARIABLE(Name,NO_INDEX)).

transactionalvar_struct(Name,Index,PRTRANSACTIONALVARIABLE(Name,Index)).

strobj_struct(FLSTRING(String,I),PRSTRING(String,I)).
transactionalstrobj_struct(FLTRANSACTIONALSTRING(String,I),PRSTRING(String,I)).

datatypeobj_struct(FLDATATYPE(Sort,Lit,Idx),
		   PRDATATYPE(SortCode,LitCode,OutIdx),
		   Status) :-
	!,
	compile_pathexp(Sort,SortCode,_,_,_),
	(is_flvariable(Lit,VarName,VarIdx)
	->  add_underscore(VarName,InDataTypeVarName),
	    varobj_struct(InDataTypeVarName,VarIdx,LitCode),
	    OutIdx = VarIdx, Status = []
	; is_fldatatypelist(Lit,ListOfLits)
	-> compile_datatype_list(ListOfLits,LitCode0,Status),
	    datatypelistobj_struct(LitCode0,LitCode),
	    OutIdx=Idx
	;
	    LitCode = Lit, OutIdx=Idx, Status = []
	).
datatypeobj_struct(FLTRANSACTIONALPREDSPEC(DTspec),Code,Status) :-
	!,
	datatypeobj_struct(DTspec,Code,Status).

datatypelistobj_struct(ListLit,PRDATATYPELIST(ListLit)).


builtin_identifier_struct(FLBUILTIN_IDENTIFIER(Builtin,I),
			  PRBUILTIN_IDENTIFIER(Builtin,I)).

newoid_struct(Oid,Index,PRNEWOID(Oid,Index)).
cut_struct(Index,PRCUT(Index)).

list_struct(List,Term,Index,PRLIST(List,Term,Index)).
list_struct(List,Term,PRLIST(List,Term,NO_INDEX)).

workspace_struct(P,WS,PRWORKSPACE(P,WS)).
newpredicate_struct(Name,N,Args,PRNEWPRED(Name,N,Args)).
thismodule_struct(PRTHISMODULE(PRTHISMODULE)).

callerargsterm_struct(Caller,CallerInfo) :-
	%% In the future we'll replace INFONULL with rule numbers or something
	(has_context(literal_workspace(_WS)) -> 
	    %%compile_workspace_term(_WS,ArgsCode)
	    ArgsCode = INFONULL
	; has_context(goal_reification) ->
	    %%thismodule_struct(ArgsCode)
	    ArgsCode = INFONULL
	; has_context(rule_reification)
	-> ArgsCode = PRDYNCALLERARGSVAR(PRDYNCALLERARGSVAR)
	; %% non-workspace literal in the body
	  %%thismodule_struct(ArgsCode)
	    ArgsCode = INFONULL
	),
	list_struct([Caller,PRCALLERARGSTERM(ArgsCode)],[],CallerInfo).


workspaceterm_struct(WS,PRWORKSPACETERM(WSTerm)) :-
	compile_workspace_term(WS,WSTerm).

%% Compiles both user and system workspace terms
compile_workspace_term(WS, CompiledWS) :-
	(is_flatom(WS,_Atom,_I) -> atomobj_struct(WS,CompiledWS)
	; is_flvariable(WS,_Var,_I) -> varobj_struct(WS,CompiledWS)
	; is_fltoken(WS,FL_THISMODULE,_) -> thismodule_struct(CompiledWS)
	; is_flfloralib(WS,Mod) -> 
	    compile_workspace_term(Mod,WS1),
	    floralib_struct(WS1, CompiledWS) 
	; %% WS may come already compiled as a system workspace or as a var
	    (floralib_struct(_, WS) ; is_prvariable(WS))
	-> WS = CompiledWS
	; flora_error_line('[Compiler] BUG: Invalid workspace term, ~w', [WS]),
	    throw(FLORA_TOP_LEVEL)
	).

%% For dynamic rules - workspace of the rule: (rule)@WS
%% Otherwise - current module.
context_module_struct(CallerInfo) :-
	has_context(dynruleworkspace(WSTerm)),
	!,
	callerargsterm_struct(WSTerm,CallerInfo).
context_module_struct(CallerInfo) :-
	has_context(goal_reification),
	\+ has_context(rule_reification),
	!,
	new_caller_prvariable(NO_INDEX,WSTerm),
	%% with this reification in the head doesn't unify with the body
	%%thismodule_struct(WSTerm), 
	callerargsterm_struct(WSTerm,CallerInfo).
context_module_struct(CallerInfo) :-
	thismodule_struct(WSTerm),
	!,
	callerargsterm_struct(WSTerm,CallerInfo).

%% Represents the special variable, which appears in the rule head, that is
%% bound to the caller name 
callermod_info_structure(Caller) :-
	%% In the head of dynamic rules
	has_context(compiling_dynrule),
	!,
	list_struct([PRDYNCALLERVAR(PRDYNCALLERVAR),
		     PRDYNCALLERARGSVAR(PRDYNCALLERARGSVAR)],
		    [], Caller).
%% In the head of static rules
callermod_info_structure(Caller) :-
	list_struct([PRCALLERVAR(PRCALLERVAR),
		     PRCALLERARGSVAR(PRCALLERARGSVAR)],
		    [], Caller).

callermod_var_structure(PRDYNCALLERVAR(PRDYNCALLERVAR)) :-
	%% In the head of dynamic rules
	has_context(compiling_dynrule),
	!.
%% In the head of static rules
callermod_var_structure(PRCALLERVAR(PRCALLERVAR)).

thisstorage_struct(fdb,PRTHISFDBSTORAGE(PRTHISFDBSTORAGE)).
%% support for checking undefinedness
thisstorage_struct(fld,PRTHISFLDSTORAGE(PRTHISFLDSTORAGE)).

floralib_struct(WS,PRFLORALIB(WS)).
storage_struct(WS,PRFDBSTORAGE(WS)).

determine_caller_info(Context,Caller) :-
	(Context==BODYLITERAL -> context_module_struct(Caller)
	; Context==HEADLITERAL -> callermod_info_structure(Caller)
	%% debug
	; flora_error_line('[Compiler] BUG: No caller type exists for this context, ~w', [Context]),
	    throw(FLORA_TOP_LEVEL)
	).
splice_in_caller_argument(Context,Args,NewArgs) :-
	determine_caller_info(Context,Caller),
	flatten([Args,Caller],NewArgs).

%% special treatment of _overrides/2/4, _opposes/2/4, _cancel/1/2,
%% and stuff declared as :- prolog or :- table
termlit_struct(Context,FObj,N,ObjList,Code) :-
	(is_pratom(FObj,AtomName,Idx)
	; is_prbuiltin_identifier(FObj,AtomName,Idx)
	),
	flora_modular_prlgdef(AtomName,N),
	!,
	splice_in_caller_argument(Context,ObjList,Args),
	N1 is N+1,
	modularized_atom_struct(AtomName,Idx,FunCode),
	prologterm_struct(FunCode,N1,Args,Code).

%% for things that have prolog name replacement
termlit_struct(_Context,FObj,N,ObjList,Code) :-
	(is_pratom(FObj,AtomName)
	; is_prbuiltin_identifier(FObj,AtomName)
	),
	(has_permaoption(prolog(AtomName,N)) ->
	    termlit_replacement(FObj,N,NewFObj),
	    prologterm_struct(NewFObj,N,ObjList,Code)
	; flora_prlgdef(AtomName,N) ->
	    %%termlit_replacement(FObj,N,NewFObj),
	    %%prologterm_struct(NewFObj,N,ObjList,Code)
	    prologterm_struct(FObj,N,ObjList,Code)
	; flora_prlgdef(AtomName,N,Mod)
	-> prologterm_struct(FObj,N,ObjList,Mod,Code)
	).
termlit_struct(_Context,FObj,N,ObjList,Code) :-
	is_pratom(FObj,AtomName,Idx),
	flora_prlgdef_repl(AtomName,N,ReplacementAtm,Mod),
	!,
	is_pratom(ReplFObj,ReplacementAtm,Idx),
	prologterm_struct(ReplFObj,N,ObjList,Mod,Code).

termlit_struct(_Context,FObj,N,ObjList,Code) :-
	is_prbuiltin_identifier(FObj,AtomName,Idx),
	flora_prlgdef_repl(AtomName,N,ReplacementAtm,Mod),
	!,
	is_prbuiltin_identifier(ReplFObj,ReplacementAtm,Idx),
	prologterm_struct(ReplFObj,N,ObjList,Mod,Code).

termlit_struct(Context,FObj,N,ObjList,PRTERMLIT(FObj,N1,Args)) :-
	splice_in_caller_argument(Context,ObjList,Args),
	length(Args,N1),
	!,
	%% integrity check - debug
	(N1 is N+1, !
	; flora_error_line('[Compiler] BUG: Assertion N=N1 failed in termlit structure: Obj=~w, Arity=~w, Args=~w, Context=~w',
			   [FObj,N,ObjList,Context]),
	    throw(FLORA_TOP_LEVEL)
	).

transactionaltermlit_struct(Context,FObj,N,ObjList,PRTRANSACTIONALTERMLIT(FObj,N1,Args)) :-
	splice_in_caller_argument(Context,ObjList,Args),
	length(Args,N1),
	!,
	%% integrity check - debug
	(N1 is N+1, !
	; flora_error_line('[Compiler] BUG: Assertion N=N1 failed in transactionaltermlit structure: Obj=~w, Arity=~w, Args=~w, Context=~w',
			   [FObj,N,ObjList,Context]),
	    throw(FLORA_TOP_LEVEL)
	).


%%udfunction_struct(Name,N,Args,Predicate,ReturnValue,PRUSERDEFINEDFUNCTION(Name,N,Args,Predicate,ReturnValue)).


caller_binding_code(Binding,Code) :-
	callermod_var_structure(CallerVar),
	atomobj_struct(FL_SILENT_EQUAL,EqCode),
	prologterm_struct(EqCode,2,[CallerVar,Binding],Code).

/*
is_prtermlit(PRTERMLIT(Obj,_,_),I) :- approx_prindex(Obj,I).
is_prtermlit(PRATOMLIT(_Obj,I),I).
*/

is_prtransactionallit(PRTRANSACTIONALTERMLIT(O,_,_),I) :- approx_prindex(O,I).
is_prtransactionallit(PRTRANSACTIONALATOMLIT(_,I),I).
is_prtransactionallit(PRTRAN(_,Obj,_),I) :- approx_prindex(Obj,I).

has_prtransactionallit([],_) :- !, fail.
has_prtransactionallit([H|_],Idx) :-
	is_prtransactionallit(H,Idx),
	!.
has_prtransactionallit([_|Rest],Idx) :-
	has_prtransactionallit(Rest,Idx).

has_prologlit([],_) :- !, fail.
has_prologlit([H|Rest],Idx) :-
	prologterm_atom_arity(H,Atm,_) -> approx_prindex(Atm,Idx)
	; has_prologlit(Rest,Idx).


/*
   attach_workspace(+WS,+Generator,-GeneratorCode,-WSCode)

   Attaches workspace code to the code produced by Generator
   Generator is a predicate, that produces code for a flora syntactic construct.
   GeneratorCode must be the variable where Generator deposits the code
   it produces.
   WSCode is a var where the final code is produced.
*/
attach_workspace(WS,Generator,GeneratorCode,WSCode) :- 
	set_context(literal_workspace(WS)),
	call(Generator),
	(is_prologterm(GeneratorCode)
	->
	    %% If prolog term occurs under the scope of a FLORA-2 module, 
	    %% ignore the module
	    WSCode = GeneratorCode
	;
	    workspacelit_struct(GeneratorCode,WS,WSCode),
	    clear_context(literal_workspace(WS))
	).

workspacelit_struct(P,WS,Code) :-
	thismodule_struct(ThisModuleName),
	(is_flvariable(WS,WSVarName,Index)
	->
	    varobj_struct(WSVarName,Index,WSVarCode),
	    callerargsterm_struct(ThisModuleName,CallerInfo),
	    %% a call to a Flora user module
	    florasyslib_struct(Index,FLLIBMODLIT,3,[P,WSVarCode,CallerInfo],Code)

	%% X@module or X@_module
        %% or %X@module or %X@_module
	; (is_prvariable(P,_,Index); is_prtransactionalvariable(P,_,Index))
	->
	    compile_workspace_term(WS,WSCode),
	    set_context(literal_workspace(WS)),
	    callerargsterm_struct(ThisModuleName,CallerInfo),
	    clear_context(literal_workspace(WS)),
	    %% a call to a module
	    florasyslib_struct(Index,FLLIBMODLIT,3,[P,WSCode,CallerInfo],Code)

	; is_flatom(WS,WSAtom,Index) ->
	    atomobj_struct(WSAtom,Index,WSCode),
	    workspace_struct(P,WSCode,Code)

	; is_fltoken(WS,FL_THISMODULE,_) ->
	    thismodule_struct(WSCode),
	    workspace_struct(P,WSCode,Code)
	;
	    %% a Flora system module
	    workspace_struct(P,WS,Code)
	).

%% This is used in situations where a workspace
%% term appears inside a predicate or a molecule,
%% e.g., p(foo@?Mod) or a[b->foo@?Mod] or ?X = abc#cde@?Mod
%% or ?Pred@ws or ?Pred@?Mod
workspaceobj_struct(P,WS,Object,Code) :-
	thismodule_struct(ThisModuleName),
	(is_flvariable(WS,WSVarName,Index) ->
	    varobj_struct(WSVarName,Index,WSVarCode),
	    new_prvariable(Index,Object),
	    callerargsterm_struct(ThisModuleName,CallerInfo),
	    %% code to construct the object for foo@X in arg position,
	    %% i.e., p(foo@X)
	    florasyslib_struct(Index,FLLIBMODOBJ,4,[P,WSVarCode,CallerInfo,Object],Code)

	; is_prvariable(P,_,Index)
	->
	    compile_workspace_term(WS,WSCode),
	    new_prvariable(Index,Object),
	    callerargsterm_struct(ThisModuleName,CallerInfo),
	    %% code to construct the object for X@... in arg position,
	    %% i.e., p(X@...)
	    florasyslib_struct(Index,FLLIBMODOBJ,4,[P,WSCode,CallerInfo,Object],Code)

	; is_flatom(WS,WSAtom,Index) ->
	    atomobj_struct(WSAtom,Index,WSCode),
	    workspace_struct(P,WSCode,Object),
	    Code=NULL

	; is_fltoken(WS,FL_THISMODULE,_) ->
	    thismodule_struct(WSCode),
	    workspace_struct(P,WSCode,Object),
	    Code=NULL
	;
	  %% a Flora system module
	  Code=NULL,
	  workspace_struct(P,WS,Object)
	).

prologterm_struct(F,N,Args,PROLOGTERM(F,N,Args)).
%% This is used for prolog terms like goo(...)@_prolog(module)
%% when we encode them as module:goo. This is in addition to 
%% :- import goo from module. When XSB allows the notation foo:bar
%% in assert/retract, the :- module feature will be deprecated.
prologterm_struct(F,N,Args,Module,PROLOGTERM(F,N,Args)) :-
	var(Module),
	!.
prologterm_struct(F,N,Args,Module,PROLOGTERM(F,N,Args,ModuleCode)) :-
	atomobj_struct(Module,ModuleCode).

prologliblit_struct(PrologTerm,PROLOGLIBLIT(PrologTerm)).

is_prologterm(Term)    :- is_prologterm(Term,_,_,_).
is_prologterm(Term)    :- is_prologterm(Term,_,_,_,_).

prologterm_atom_arity(Term,Atom,Arity) :-
	is_prologterm(Term,Struct,Arity,_),
	is_modularized_atom(Struct,Atom,_).
prologterm_atom_arity(Term,Atom,Arity) :- is_prologterm(Term,Atom,Arity,_).
prologterm_atom_arity(Term,Atom,Arity) :- is_prologterm(Term,Atom,Arity,_,_).

flprologlib_atom_arity(ParserTerm,Atm,Arity) :-
	is_flplib(ParserTerm,FLterm),
	is_flterm(FLterm,Funct,Arity,_),
	get_flatom_name(Funct,Atm).
flprologlib_atom_arity_mod(ParserTerm,Atm,Arity,Mod) :-
	is_flplib(ParserTerm,FLterm,Mod),
	is_flterm(FLterm,Funct,Arity,_),
	get_flatom_name(Funct,Atm).
%% returns functor object, not its name
flprologlib_functor(ParserTerm,Funct) :-
	(is_flplib(ParserTerm,FLterm) ; is_flplib(ParserTerm,FLterm,_)),
	is_flterm(FLterm,Funct,_,_).
flprologlib_call(ParserTerm,FLterm) :-
	(is_flplib(ParserTerm,FLterm) ; is_flplib(ParserTerm,FLterm,_)).

%% Not all Flora system libraries encode textual information. Only
%% the ones for aggregates and DB updates
florasyslib_struct(F,N,Args,FLORASYSLIB(NO_INDEX,F,N,Args)) :-
	report_option(FLSYSLIB(F),NO_INDEX).
florasyslib_struct(Index,F,N,Args,FLORASYSLIB(Index,F,N,Args)) :-
	report_option(FLSYSLIB(F),Index).

is_florasyslib_struct(FLORASYSLIB(I,F,N,Args), I,F,N,Args).

termobj_struct(FObj,N,ObjList,Code) :-
	(is_pratom(FObj,AtomName)
	; is_prbuiltin_identifier(FObj,AtomName)
	),
	(flora_prlgdef(AtomName,N)
	-> prologterm_struct(FObj,N,ObjList,Code)
	; flora_prlgdef(AtomName,N,Mod)
	-> prologterm_struct(FObj,N,ObjList,Mod,Code)
	).
termobj_struct(FObj,N,ObjList,Code) :-
	is_pratom(FObj,AtomName,Idx),
	flora_prlgdef_repl(AtomName,N,ReplacementAtm,Mod),
	!,
	is_pratom(ReplFObj,ReplacementAtm,Idx),
	prologterm_struct(ReplFObj,N,ObjList,Mod,Code).
termobj_struct(FObj,N,ObjList,Code) :-
	is_prbuiltin_identifier(FObj,AtomName,Idx),
	flora_prlgdef_repl(AtomName,N,ReplacementAtm,Mod),
	!,
	is_prbuiltin_identifier(ReplFObj,ReplacementAtm,Idx),
	prologterm_struct(ReplFObj,N,ObjList,Mod,Code).
termobj_struct(FObj,N,ObjList,PRTERM(FObj,N,ObjList)).

%% catch{...,...,...}
catch_struct(Goal,Error,Handler,Code) :-
	florasyslib_struct(FLLIBCATCH,3,[Goal,Error,Handler],Code).

%% throw{...}
throw_struct(Error,Code) :-
	florasyslib_struct(FLLIBTHROW,1,[Error],Code).

%% true{...}, false{...}, unknown{...}. Opname is FL_TRUE, FL_FALSE, FL_UNKNOWN
truthvalue_struct(Formula,Opname,Code) :-
	modularized_atom_struct(FL_TRUTHVALUE_TABLED_CALL,NO_INDEX,FunCode),
	prologterm_struct(FunCode,1,[Formula],WrappedFormula),
	florasyslib_struct(FLLIBTRUTHVALUE,2,[WrappedFormula,Opname],Code).

labelprimitive_struct(Label,Module,Code) :-
	approx_prindex(Label,Index),
	florasyslib_struct(Index,FLLIBTAGPRIMITIVE,2,[Label,Module],Code).

prefixprimitive_struct(Prefix,Expansion,Module,Code) :-
	florasyslib_struct(FLLIBPREFIXPRIMITIVE,3,[Prefix,Expansion,Module],Code).

%% p2h{...}
p2h_struct(Prolog,Hilog,Code) :-
	atomobj_struct(P2H_PREDICATE,P2HCode),
	prologterm_struct(P2HCode,4,[Prolog,Hilog,WRAP_HILOG,P2H_DONOT_UNIFY_VARS],Code).

%% newoid{...}
newoidop_struct(Var,Code) :-
	florasyslib_struct(FLLIBNEWOID,1,[Var],Code).

insert_struct(Op,List,Cond,Code) :-
	%% Index denotes the textual information for the insert
	%% operator and represents the textual information for the
	%% entire insert statement.
	is_flatom(Op,OpAtom,Index),
	insert_syslib(OpAtom,Lib),
	florasyslib_struct(Index,Lib,2,[List,Cond],Code).

insert_struct(Op,List,Code) :-
	%% Index denotes the textual information for the insert
	%% operator and represents the textual information for the
	%% entire insert statement.
	is_flatom(Op,OpAtom,Index),
	insert_syslib(OpAtom,Lib),
	florasyslib_struct(Index,Lib,1,[List],Code).

delete_struct(Op,List,Cond,Code) :-
	%% Index denotes the textual information for the delete
	%% operator and represents the textual information for the
	%% entire delete statement.
	is_flatom(Op,OpAtom,Index),
	delete_syslib(OpAtom,Lib),
	florasyslib_struct(Index,Lib,2,[List,Cond],Code).

delete_struct(Op,List,Code) :-
	%% Index denotes the textual information for the delete
	%% operator and represents the textual information for the
	%% entire delete statement.
	is_flatom(Op,OpAtom,Index),
	delete_syslib(OpAtom,Lib),
	florasyslib_struct(Index,Lib,1,[List],Code).

table_refresh_struct(List,Code) :-
	florasyslib_struct(FLLIBREFRESH,1,[List],Code).

clause_struct(Id,Meta,Mode,HeadList,Body,Code) :-
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
	florasyslib_struct(FLLIBCLAUSE,5,[Id,Meta,Mode,HeadList,Body],Code).

insert_rulesig_struct(HeadList,Body,(TagCode,MetaCode,DefeatCond),Newpred,Code) :-
	thismodule_struct(WS),
	florasyslib_struct(FLLIBINSRULESIG,7,[TagCode,WS,HeadList,Body,MetaCode,DefeatCond,Newpred],Code).

insert_syslib(FL_INSERT,FLLIBINSERT) :- !.
insert_syslib(FL_INSERTALL,FLLIBINSERTALL) :- !.

insert_syslib(FL_BTINSERT,FLLIBBTINSERT) :- !.
insert_syslib(FL_BTINSERTALL,FLLIBBTINSERTALL) :- !.

delete_syslib(FL_DELETE,FLLIBDELETE) :-
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
	!.
delete_syslib(FL_DELETEALL,FLLIBDELETEALL) :-
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
	!.
delete_syslib(FL_ERASE,FLLIBERASE) :-
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
	!.
delete_syslib(FL_ERASEALL,FLLIBERASEALL) :-
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
	!.

delete_syslib(FL_BTDELETE,FLLIBBTDELETE) :- !.
delete_syslib(FL_BTDELETEALL,FLLIBBTDELETEALL) :- !.
delete_syslib(FL_BTERASE,FLLIBBTERASE) :- !.
delete_syslib(FL_BTERASEALL,FLLIBBTERASEALL) :- !.

updaterule_syslib(FL_INSERTRULE,FLLIBINSERTRULE_Z) :- 
        !.
updaterule_syslib(FL_INSERTRULE_A,FLLIBINSERTRULE_A) :- 
        !.
updaterule_syslib(FL_INSERTRULE_Z,FLLIBINSERTRULE_Z) :- 
        !.
updaterule_syslib(FL_DELETERULE_A,FLLIBDELETERULE_A) :- 
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
        !.
updaterule_syslib(FL_DELETERULE_Z,FLLIBDELETERULE_Z) :- 
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
        !.
updaterule_syslib(FL_DELETERULE,FLLIBDELETERULE) :- 
	report_option(FLSYSLIB(FLLIBUNIVEQFORM),NO_INDEX),
        !.

is_fldeleteruleop(FL_DELETERULE_A) :- !.
is_fldeleteruleop(FL_DELETERULE_Z) :- !.
is_fldeleteruleop(FL_DELETERULE) :- !.

aggregate_struct(Op,V,GV,B,Object,Code) :-
	%% Index denotes the textual information for the aggregate
	%% operator and represents the textual information for the
	%% entire aggregate statement.
	is_flatom(Op,OpAtom,Index),
	aggregate_syslib(OpAtom,Lib),
	new_prvariable(Index,Object),
	( GV == [] ->
	    florasyslib_struct(Index,Lib,3,[V,B,Object],Code)
	;
	  florasyslib_struct(Index,Lib,4,[V,GV,B,Object],Code)
        ),
	!.
aggregate_struct(Op,V,GV,SortCode,B,Object,Code) :-
	%% Index denotes the textual information for the aggregate
	%% operator and represents the textual information for the
	%% entire aggregate statement.
	is_flatom(Op,OpAtom,Index),
	aggregate_syslib_sorted(OpAtom,Lib),
	new_prvariable(Index,Object),
	( GV == [] ->
	    florasyslib_struct(Index,Lib,4,[V,SortCode,B,Object],Code)
	;
	  florasyslib_struct(Index,Lib,5,[V,GV,SortCode,B,Object],Code)
        ),
	!.

aggregate_syslib(FL_MIN,FLLIBMIN) :- !.
aggregate_syslib(FL_MAX,FLLIBMAX) :- !.
aggregate_syslib(FL_SUM,FLLIBSUM) :- !.
aggregate_syslib(FL_AVG,FLLIBAVG) :- !.
aggregate_syslib(FL_COUNT,FLLIBCOUNT) :- !.
aggregate_syslib(FL_COLLECTSET,FLLIBCOLLECTSET) :- !.
aggregate_syslib(FL_COLLECTBAG,FLLIBCOLLECTBAG) :- !.
aggregate_syslib(FL_SET,FLLIBCOLLECTSET) :- !.
aggregate_syslib(FL_BAG,FLLIBCOLLECTBAG) :- !.

aggregate_syslib_sorted(FL_COLLECTSET,FLLIBSETSORTBY) :- !.
aggregate_syslib_sorted(FL_COLLECTBAG,FLLIBBAGSORTBY) :- !.
aggregate_syslib_sorted(FL_SET,FLLIBSETSORTBY) :- !.
aggregate_syslib_sorted(FL_BAG,FLLIBBAGSORTBY) :- !.

hypothetical_struct(Op,Goal,Index,Code) :-
	hypothetical_syslib(Op,Lib), %% Op is a plain atom, not flatom
	florasyslib_struct(Index,Lib,2,[Op,Goal],Code).

hypothetical_syslib(FL_POSSIBLE,FLLIBHYPOTHETICAL)      :- !.
hypothetical_syslib(FL_IMPOSSIBLE,FLLIBHYPOTHETICAL)    :- !.

objexists_struct(Context,Obj,PREXISTS(Obj,Caller)) :-
	determine_caller_info(Context,Caller).

birelate_struct(LiteralContext,Obj1,RelType,Obj2,Code) :-
	( is_isaspecop(RelType) ->
	    isaspec_struct(LiteralContext,Obj1,Obj2,Code)
	;
	  is_subspecop(RelType),
	  subspec_struct(LiteralContext,Obj1,Obj2,Code)
        ).

isaspec_struct(Context,Obj1,Obj2,PRISA(Obj1,Obj2,Caller)) :-
	determine_caller_info(Context,Caller).

subspec_struct(Context,Obj1,Obj2,PRSUB(Obj1,Obj2,Caller)) :-
	determine_caller_info(Context,Caller).


sigattspec_struct(LiteralContext,Object,AttObj,RefType,ValObj,Code) :-
	(
	  is_mvdsigspecop(RefType) ->
	    mvdsigspec_struct(LiteralContext,Object,AttObj,ValObj,Code)

	; is_imvdsigspecop(RefType) ->
	    imvdsigspec_struct(LiteralContext,Object,AttObj,ValObj,Code)

        ).


%% cardinality constraints in the body
sigattconstr_struct(LiteralContext,Object,AttObj,LowerObj,UpperObj,RefType,Code) :-
	(
	is_mvdsigspecop(RefType) ->
	    mvdcon_struct(LiteralContext,Object,AttObj,LowerObj,UpperObj,Code) 

	; is_imvdsigspecop(RefType) ->
	    imvdcon_struct(LiteralContext,Object,AttObj,LowerObj,UpperObj,Code) 
	).


%% cardinality constraints in the head
sigattcondef_struct(LiteralContext,Object,AttObj,LowerObj,UpperObj,RefType,ValObj,Code) :-
	( is_mvdsigspecop(RefType) ->
	    mvdcondef_struct(LiteralContext,Object,AttObj,LowerObj,UpperObj,ValObj,Code) 

	; is_imvdsigspecop(RefType) ->
	    imvdcondef_struct(LiteralContext,Object,AttObj,LowerObj,UpperObj,ValObj,Code) 
	).

mvdsigspec_struct(Context,Object,AttObj,ValObj,PRMVDSIG(Object,AttObj,ValObj,Caller)) :-
	determine_caller_info(Context,Caller).
imvdsigspec_struct(Context,Object,AttObj,ValObj,PRIMVDSIG(Object,AttObj,ValObj,Caller)) :-
	determine_caller_info(Context,Caller).

%% This is for cardinality constraints in the body
mvdcon_struct(Context,Object,AttObj,LowerObj,UpperObj,PRMVDCON(Object,AttObj,LowerObj,UpperObj,Caller)) :-
	determine_caller_info(Context,Caller).
imvdcon_struct(Context,Object,AttObj,LowerObj,UpperObj,PRIMVDCON(Object,AttObj,LowerObj,UpperObj,Caller)) :-
	determine_caller_info(Context,Caller).

%% This is for cardinality constraints in the head
mvdcondef_struct(Context,Object,AttObj,LowerObj,UpperObj,ValObj,PRMVDCONDEF(Object,AttObj,LowerObj,UpperObj,ValObj,Caller)) :-
	determine_caller_info(Context,Caller).
imvdcondef_struct(Context,Object,AttObj,LowerObj,UpperObj,ValObj,PRIMVDCONDEF(Object,AttObj,LowerObj,UpperObj,ValObj,Caller)) :-
	determine_caller_info(Context,Caller).

is_prmvdcondef(PRMVDCONDEF(_Object,_AttObj,_LowerObj,_UpperObj,_Type,_Caller)).
is_primvdcondef(PRIMVDCONDEF(_Object,_AttObj,_LowerObj,_UpperObj,_Type,_Caller)).

boolsig_struct(Context,Object,AttObj,PRBOOLSIG(Object,AttObj,Caller)):-
	determine_caller_info(Context,Caller).
iboolsig_struct(Context,Object,AttObj,PRIBOOLSIG(Object,AttObj,Caller)):-
	determine_caller_info(Context,Caller).

transig_struct(Context,Object,AttObj,PRTRANSIG(Object,AttObj,Caller)):-
	determine_caller_info(Context,Caller).
itransig_struct(Context,Object,AttObj,PRITRANSIG(Object,AttObj,Caller)):-
	determine_caller_info(Context,Caller).


%% This is for ->, *-> when the attribute is defined,
%% but its value is empty set
mvdattdef_struct(LiteralContext,Object,AttObj,RefType,Code) :-
	( is_mvdspecop(RefType) ->
	    mvddef_struct(LiteralContext,Object,AttObj,Code)
	;
	  is_imvdspecop(RefType),
	    imvddef_struct(LiteralContext,Object,AttObj,Code)
        ).

%% This is for =>, *=>, when the attribute is defined,
%% but its value is empty set
sigattdef_struct(LiteralContext,Object,AttObj,RefType,Code) :-
	( 
	  is_mvdsigspecop(RefType) ->
	    mvdsigdef_struct(LiteralContext,Object,AttObj,Code)

	; is_imvdsigspecop(RefType) ->
	    imvdsigdef_struct(LiteralContext,Object,AttObj,Code)

        ).


mvddef_struct(Context,Object,AttObj,PRMVDDEF(Object,AttObj,Caller)) :-
		determine_caller_info(Context,Caller).
imvddef_struct(Context,Object,AttObj,PRIMVDDEF(Object,AttObj,Caller)) :-
		determine_caller_info(Context,Caller).
mvdsigdef_struct(Context,Object,AttObj,PRMVDSIGDEF(Object,AttObj,Caller)) :-
		determine_caller_info(Context,Caller).
imvdsigdef_struct(Context,Object,AttObj,PRIMVDSIGDEF(Object,AttObj,Caller)) :-
		determine_caller_info(Context,Caller).

mvdattspec_struct(LiteralContext,Object,AttObj,RefType,ValObj,Code) :-
	(
	  is_mvdspecop(RefType) ->
	    mvdspec_struct(LiteralContext,Object,AttObj,ValObj,Code)

	; is_imvdspecop(RefType) ->
	    imvdspec_struct(LiteralContext,Object,AttObj,ValObj,Code)
        ).

mvdspec_struct(Context,Object,AttObj,ValObj,PRMVD(Object,AttObj,ValObj,Caller)) :-
		determine_caller_info(Context,Caller).
imvdspec_struct(Context,Object,AttObj,ValObj,PRIMVD(Object,AttObj,ValObj,Caller)) :-
		determine_caller_info(Context,Caller).

%% for +>> and *+>>
%% appears only in the rule body
incattspec_struct(Object,AttObj,RefType,ValObj,Code) :-
	( is_mvdincspecop(RefType) ->
	    mvdincspec_struct(Object,AttObj,ValObj,Code)
	;
	  is_imvdincspecop(RefType),
	  imvdincspec_struct(Object,AttObj,ValObj,Code)
        ).

%% +>>
%% appears only in the rule body
mvdincspec_struct(Object,AttObj,ValObj,PRMVDINC(Object,AttObj,ValObj,CallerInfo)) :-
	thismodule_struct(ThisModule),
	callerargsterm_struct(ThisModule,CallerInfo).
%% *+>>
%% appears only in the rule body
imvdincspec_struct(Object,AttObj,ValObj,PRIMVDINC(Object,AttObj,ValObj,CallerInfo)) :-
	thismodule_struct(ThisModule),
	callerargsterm_struct(ThisModule,CallerInfo).

%% ->->, *->->
%% appears only in the rule body
tolistattspec_struct(Object,AttObj,RefType,ValObj,Code) :-
	( is_mvdtolistspecop(RefType) ->
	    mvdtolistspec_struct(Object,AttObj,ValObj,Code)
	;
	  is_imvdtolistspecop(RefType),
	  imvdtolistspec_struct(Object,AttObj,ValObj,Code)
        ).

mvdtolistspec_struct(Object,AttObj,ValObj,PRMVDTOLIST(Object,AttObj,ValObj,CallerInfo)) :-
	thismodule_struct(ThisModule),
	callerargsterm_struct(ThisModule,CallerInfo).
imvdtolistspec_struct(Object,AttObj,ValObj,PRIMVDTOLIST(Object,AttObj,ValObj,CallerInfo)) :-
	thismodule_struct(ThisModule),
	callerargsterm_struct(ThisModule,CallerInfo).

%% This is called when someting like a.b[] is compiled.
body_objref_struct(Obj,RefType,Att,Index,Val,Code) :-
	%% Index is the approximate textual information
	%% for the new variable that represents an oid.
	new_prvariable(Index,Val),
	( is_mvdrefop(RefType) ->
	    mvdspec_struct(BODYLITERAL,Obj,Att,Val,Code)
	;
	  is_imvdrefop(RefType),
	  imvdspec_struct(BODYLITERAL,Obj,Att,Val,Code)
        ).

%% if it is the same with body_objref_struct, combine them later
head_objref_struct(Obj,RefType,Att,Index,Val,Code) :-
	new_prvariable(Index,Val), 
        ( is_mvdrefop(RefType) -> 	 
            mvdspec_struct(HEADLITERAL,Obj,Att,Val,Code) 	 
        ; 	 
          is_imvdrefop(RefType), 	 
          imvdspec_struct(HEADLITERAL,Obj,Att,Val,Code) 	 
        ). 	 
 	 

methspec_struct(Context,Obj,Meth,PRMETH(Obj,Meth,Caller)) :-
	determine_caller_info(Context,Caller).
imethspec_struct(Context,Obj,IMeth,PRIMETH(Obj,IMeth,Caller)) :-
	determine_caller_info(Context,Caller).
transpec_struct(Context,Obj,Tran,PRTRAN(Obj,Tran,Caller)) :-
	determine_caller_info(Context,Caller).

objeql_struct(Context,O1,O2,PROBJEQL(O1,O2,Caller)) :-
	determine_caller_info(Context,Caller).


ifthenelse_struct(Cond,Then,Else,Code) :-
	code_line_and_file_by_prterm(Cond,Line,CurrFileName),
	thismodule_struct(ThisMod),
	florasyslib_struct(FLLIBIFTHENELSE,6,[ThisMod,Cond,Then,Else,Line,CurrFileName],Code).

ifthen_struct(Cond,Then,Code) :-
	code_line_and_file_by_prterm(Cond,Line,CurrFileName),
	thismodule_struct(ThisMod),
	florasyslib_struct(FLLIBIFTHEN,5,[ThisMod,Cond,Then,Line,CurrFileName],Code).

%% encoding of control constructs
controlconstruct_struct(CondCode,ActionCode,Wrapper,Code) :-
	code_line_and_file_by_prterm(CondCode,Line,CurrFileName),
	thismodule_struct(ThisMod),
	florasyslib_struct(Wrapper,5,[ThisMod,CondCode,ActionCode,Line,CurrFileName],Code).

univeqform_struct(Left,Right,Code) :-
	florasyslib_struct(FLLIBUNIVEQFORM,2,[Left,Right],Code).

%% This handles both ~.. and =..
%% These predicates are defined identically. The only difference is that
%% the LHS arg of ~.. is compiled as meta, while in =.. it is compiled as oid
metauniv_struct(Left,Right,Code) :-
	florasyslib_struct(FLLIBMETAUNIV,2,[Left,Right],Code).

constraint_struct(ConstrCode,PRCONSTRAINT(ConstrCode)).


/****************************************************************************
  reset_newpredicate/0
  new_predicate(-Name)
****************************************************************************/
reset_newpredicate :- flora_set_counter(NEWPREDICATE,1).

new_predicate(Name) :-
	flora_increment_counter(NEWPREDICATE,1,OldVal,_NewVal),
	%%number_codes(OldVal,OldValLst),
	%%atom_codes(OldValAtm,OldValLst),
	%%flora_concat_atoms([NEWPREDICATE,OldValAtm],Name).
	flora_concat_items([NEWPREDICATE,OldVal],Name).

/****************************************************************************
  reset_defaultlabel/0
  new_defaultlabel(-Name)
****************************************************************************/
reset_defaultlabel :- flora_set_counter(DEFAULT_RULE_TAG,1).

new_defaultlabel(Name) :-
	flora_increment_counter(DEFAULT_RULE_TAG,1,OldVal,_NewVal),
	%%number_codes(OldVal,OldValLst),
	%%atom_codes(OldValAtm,OldValLst),
	%%flora_concat_atoms([DEFAULT_RULE_TAG,OldValAtm],Name).
	flora_concat_items([DEFAULT_RULE_TAG,OldVal],Name).

is_defaultlabel(LabObj) :-
	is_pratom(LabObj,LabName),
	str_sub(DEFAULT_RULE_TAG,LabName).


/****************************************************************************
  flora_reset_newvar/0
  flora_new_varobj(+VarPrefix,+Index,-CompiledVarObj)
  new_prvariable(+Index,-CompiledVarObj)
****************************************************************************/
flora_reset_newvar :- flora_set_counter(NEWVAR,1).

%% This 3-argument version is provided for other parts of the compiler,
%% such as flrundefined.P, which need to generate vars.
%% VarPrefix makes sure that names don't clash.
flora_new_varobj(VarPrefix,Index,VarObj) :-
	flora_increment_counter(NEWVAR,1,OldVal,_NewVal),
	%%number_codes(OldVal,OldValLst),
	%%atom_codes(OldValAtm,OldValLst),
	%%flora_concat_atoms([VarPrefix,OldValAtm],Name),
	flora_concat_items([VarPrefix,OldVal],Name),
	varobj_struct(Name,Index,VarObj).

flora_new_transactionalvarobj(VarPrefix,Index,VarObj) :-
	flora_increment_counter(NEWVAR,1,OldVal,_NewVal),
	%%number_codes(OldVal,OldValLst),
	%%atom_codes(OldValAtm,OldValLst),
	%%flora_concat_atoms([VarPrefix,OldValAtm],Name),
	flora_concat_items([VarPrefix,OldVal],Name),
	transactionalvar_struct(Name,Index,VarObj).

new_prvariable(Index,VarObj) :-
	flora_new_varobj(NEWVAR,Index,VarObj).
new_dontcare_prvariable(Index,VarObj) :-
	flora_new_varobj(NEWDONTCAREVAR,Index,VarObj).
new_caller_prvariable(Index,VarObj) :-
	flora_new_varobj(NEWCALLERVAR,Index,VarObj).

%% creates new transactional variable
%%new_prtransactionalvar(Index,VarObj) :-
%%	flora_new_transactionalvarobj(NEWVAR,Index,VarObj).
new_dontcare_prtransactionalvar(Index,VarObj) :-
	flora_new_transactionalvarobj(NEWDONTCAREVAR,Index,VarObj).


new_prvarlist(0,[]) :- !.

new_prvarlist(N,[VarObj|L]) :-
	new_prvariable(NO_INDEX,VarObj),
	M is N-1,
	new_prvarlist(M,L).


/****************************************************************************
  reset_newoid/0
  new_oidobj(+Index,-OidObject)
****************************************************************************/
reset_newoid :- flora_set_counter(NEWOID_COUNT,1).

new_oidobj(Index,OidObject) :-
	flora_increment_counter(NEWOID_COUNT,1,OldVal,_NewVal),
	flora_term_to_atom(OldVal,OldValAtm),
	flora_concat_atoms([NEWOID,OldValAtm],Name),
	newoid_struct(Name,Index,OidObject).

/*************************************************************************
  new_oidobj(+RuleNum,+OidNumStr,+Index,-OidObject) :-
*************************************************************************/
new_oidobj(RuleNum,OidNumStr,Index,OidObject) :-
	( ruleoid(OidNumStr,_,Count)
	-> Count_new is Count+1,
	  retract(ruleoid(OidNumStr,_,Count)),
	  asserta(ruleoid(OidNumStr,Index,Count_new))
	;  asserta(ruleoid(OidNumStr,Index,1))
	), 
	flora_term_to_atom(RuleNum,RuleNumAtm),
        flora_concat_atoms([NEWOID,RuleNumAtm,'|',OidNumStr],Name),
	newoid_struct(Name,Index,OidObject).


clear_ruleoid :- flora_retractall_substitute(ruleoid(_,_,_)).

/****************************************************************************
  reset_rulenum

****************************************************************************/
reset_rulenum :- flora_set_counter(RULE_NUM,1).

/****************************************************************************
  collect_prvars(+CompilerTerm,-Vars)
  collect_prvars(+CompilerTerm,-Vars,-TailVars)
  collects all variables in a *compiled* term (or a list of terms).
  Returns a list Vars.

****************************************************************************/
collect_prvars(Term,Vars) :-
	collect_prvars(Term,Vs,[]),
	sort(Vs,Vars).

collect_prvars([],Vars,Vars) :- !.
collect_prvars(Term,Vars,Vars) :-
	(var(Term); atomic(Term)),
	!.
collect_prvars([H|L],Vars,TVars) :-
	!,
	collect_prvars(H,Vars,LVars),
	collect_prvars(L,LVars,TVars).
collect_prvars(Term,[Term|Vars],Vars) :-
	is_prvariable(Term),
	!.
collect_prvars(Term,[Head|Vars],Vars) :-
	is_prtransactionalvariable(Term,Name,Index),
	!,
        is_prvariable(Head,Name,Index).

collect_prvars(Term,Vars,Vars) :-
	( is_pratom(Term,_);
	  is_prnumber(Term);
	  is_prstring(Term);
	  is_prbuiltin_identifier(Term,_);
	  is_prtransactionalnumber(Term,_,_)
        ),
	!.
collect_prvars(Term,NewVars,Vars) :-
	is_prdatatype(Term,_Sort,Lit,_),
	!,
	(is_prvariable(Lit,_Name,_Indx)
	-> NewVars = [Lit|Vars]
	; is_list(Lit)
	-> collect_prvars(Lit,AddlVars),
	    append(AddlVars,Vars,NewVars)
	; is_prdatatypelist(Lit,LitList)
	-> collect_prvars(LitList,AddlVars),
	    append(AddlVars,Vars,NewVars)
	; NewVars=Vars
	).
collect_prvars(Term,Vars,TVars) :-
	Term =.. [_F|L],
	collect_prvars(L,Vars,TVars).


/****************************************************************************
  error and warning messages
****************************************************************************/
compiling_error(Index,Msg,error(Index,Msg)).

compiling_warning(Index,Msg,warning(Index,Msg)).


/****************************************************************************
  collect_flvars(+ParserTermOrList,-Vars)
  collects all occurrences of variables in a *parser* term (or a list of parser
  terms) into the list Vars.

  collect_flvars(+ParserTerm,-Vars,-TailVars)
****************************************************************************/
collect_flvars(ParserTermOrList,Vars) :-
	collect_flvars(ParserTermOrList,Vars,[]).

collect_flvars([],Vars,Vars) :- !.
collect_flvars(ParserTerm,Vars,Vars) :-
	var(ParserTerm),
	!.
collect_flvars(ParserTerm,Vars,Vars) :-
	atomic(ParserTerm),
	!.
collect_flvars([H|L],Vars,TVars) :-
	!,
	collect_flvars(H,Vars,LVars),
	collect_flvars(L,LVars,TVars).

collect_flvars(ParserTerm,[ParserTerm|Vars],Vars) :-
	is_flvariable(ParserTerm,_Name,_Index),
	!.

collect_flvars(ParserTerm,[NewParserTerm|Vars],Vars) :-
	is_fltransactionalvariable(ParserTerm,Name,Index),
	!,
        is_flvariable(NewParserTerm,Name,Index).

collect_flvars(ParserTerm,Vars,Vars) :-
	( is_flatom(ParserTerm,_Atom);
	  is_flnumber(ParserTerm,_Number);
	  is_flstring(ParserTerm,_String);
	  is_flbuiltin_identifier(ParserTerm,_Ident);
	  is_fltransactionalnumber(ParserTerm,_Number);
          is_fltransactionalatom(ParserTerm,_Atom);
	  is_fltransactionalstring(ParserTerm,_String);
	  is_fltoken(ParserTerm,_Token,_I);
	  is_fltoken(ParserTerm,_Token,_Num,_I) 
        ),
	!.

collect_flvars(ParserTerm,NewVars,Vars) :-
	is_fldatatype(ParserTerm,_Sort,Lit,_Index),
	!,
        (is_flvariable(Lit,_Name,_Indx)
	-> NewVars = [Lit|Vars]
	; is_list(Lit)
	-> collect_flvars(Lit,NewVars,Vars)
	; is_fldatatypelist(Lit,ListLit)
	-> collect_flvars(ListLit,NewVars,Vars)
	;  NewVars=Vars
	).

collect_flvars(ParserTerm,Vars,TVars) :-
	ParserTerm =.. [_F|L],
	collect_flvars(L,Vars,TVars).


/****************************************************************************
  collect_prdatatypevars(+ParserTermOrList,-DTVarsCode)

  Collects all occurrences of datatype variable terms in a parser term 
  (or a list of parser terms) into the list Vars.
****************************************************************************/
collect_prdatatypevars(CompilerTermOrList,Vars) :-
	collect_prdatatypevars(CompilerTermOrList,VarsUnsorted,[]),
	sort(VarsUnsorted,Vars).

collect_prdatatypevars([],Vars,Vars) :- !.

collect_prdatatypevars([H|L],Vars,TVars) :-
	!,
	collect_prdatatypevars(H,Vars,LVars),
	collect_prdatatypevars(L,LVars,TVars).

%% If there is a variable in data type  ... ?Y^^type ... 
%% then create ?Y = FL_DATATYPE(Sort,?_Y) and collect all these
collect_prdatatypevars(CompilerTermOrList,NewVars,Vars) :-
	is_prdatatype(CompilerTermOrList,SortCode,VarCode,_Index),
	!,
        (is_prvariable(VarCode,VarName,VarIdx)
	-> strip_underscore(VarName,UsrGivenVarName),
	    %% create ?_Y =?__Y^^type
	    varobj_struct(UsrGivenVarName,VarIdx,UsrGivenVarCode),
	    is_prdatatype(DataTypeVarStruct,SortCode,VarCode,NO_INDEX),
	    atomobj_struct(FL_UNIVEQ,UnivEQCode),
	    prologterm_struct(UnivEQCode,2,[UsrGivenVarCode,DataTypeVarStruct],
			      DatatypeVarCode),
	    NewVars = [DatatypeVarCode|Vars]
	; is_list(VarCode)
	-> collect_prdatatypevars(VarCode,AddlVars),
	    append(AddlVars,Vars,NewVars)
	; is_prdatatypelist(VarCode,ListOfLits)
	-> collect_prdatatypevars(ListOfLits,AddlVars),
	    append(AddlVars,Vars,NewVars)
	;  NewVars=Vars
	).


collect_prdatatypevars(CompilerTermOrList,Vars,TVars) :-
	CompilerTermOrList =.. [_F|L],
	collect_prdatatypevars(L,Vars,TVars).


strip_underscore(Atom,NewAtom) :-
	%%atom_codes(Atom,[_|NewAtomChars]),
	%%atom_codes(NewAtom,NewAtomChars).
	substring(Atom,1,_,NewAtom).

add_underscore(Atom,NewAtom) :-
	%%atom_codes(Atom,AtomChars),
	%%atom_codes(NewAtom,[CH_UNDERSCORE|AtomChars]).
	flora_concat_atoms(['_',Atom],NewAtom).


/****************************************************************************
  subtract_vars(+VarsList1,+VarsList2,-VarsList)

  subtracts the VarsList2 from VarsList1.
  Both VarsList1 and VarsList2 must be of the same type: parser vars
  or compiler vars. Alternatively, VarsList2 can be a list of names of vars.
  The result is a list of variables whose names do not appear in VarsList2.
  Anonymous variables are considered as distinct names.
****************************************************************************/
subtract_vars([],_,[]) :- !.
subtract_vars(L,[],L) :- !.

subtract_vars([H|T1],L,[H|T2]) :-
	( is_flvariable(H,FL_UNDERSCORE,_I)
	; is_fltransactionalvariable(H,FL_UNDERSCORE,_I)
	; is_prvariable(H,FL_UNDERSCORE,_I)
	; is_prtransactionalvariable(H,FL_UNDERSCORE,_I)
	),
	!,
	subtract_vars(T1,L,T2).

subtract_vars([H|T],L,V) :-
	( is_flvariable(H,N,_I)
	-> (is_flvariable(X,N,_J) ; is_prvariable(X,N,_J))
	; is_fltransactionalvariable(H,N,_I)
	-> (is_fltransactionalvariable(X,N,_J) ; is_prtransactionalvariable(X,N,_J))
	; is_prvariable(H,N,_I)
	-> (is_flvariable(X,N,_J) ; is_prvariable(X,N,_J))
	; is_prtransactionalvariable(H,N,_I)
	-> (is_fltransactionalvariable(X,N,_J) ; is_prtransactionalvariable(X,N,_J))
	; X = N
	),
	%% X is the same as H, but with variable index
	/*
	( is_flvariable(X,N,_J)
	; is_fltransactionalvariable(X,N,_J)
	; is_prvariable(X,N,_J)
	; is_prtransactionalvariable(X,N,_J)
	; X = N
	),
	*/
	memberchk(X,L),
	!,
	subtract_vars(T,L,V).

subtract_vars([H|T1],L,[H|T2]) :-
	subtract_vars(T1,L,T2).

/*****************************************************************************
     vars_contains(+VarList1,+VarList2)
     Checks if VarList1 contains VarList2 up to indices.
     VarList1,VarList2 are assumed to be sorted and of the same kind
*****************************************************************************/
vars_contains(_,[]) :- !.
vars_contains([H1|T1],[H2|T2]) :-
	( is_flvariable(H1,N,_), is_flvariable(H2,N,_)
	; is_fltransactionalvariable(H1,N,_), is_fltransactionalvariable(H2,N,_)
	; is_prvariable(H1,N,_), is_prvariable(H2,N,_)
	; is_prtransactionalvariable(H1,N,_), is_prtransactionalvariable(H2,N,_)
	),
	!,
	N \= FL_UNDERSCORE,
	vars_contains(T1,T2).


/*****************************************************************************
             remove_prdontcare_vars(+InList,-OutList)
             remove_caller_vars(+InList,-OutList)
             remove_prvars(+InList,-OutList)
      Removes all the do not care variables from InList.
      InList can be a list of parser or compiler vars.
*****************************************************************************/
/*
remove_fldontcare_vars([],[]) :- !.
remove_fldontcare_vars([H|T1],T2) :-
	( is_flvariable(H,FL_UNDERSCORE,_I)
	; is_fltransactionalvariable(H,FL_UNDERSCORE,_I)
	),
	!,
	remove_fldontcare_vars(T1,T2).
remove_fldontcare_vars([H|T1],[H|T2]) :-
	remove_fldontcare_vars(T1,T2).
*/

remove_prvars(_,[],[]) :- !.
remove_prvars(Prefix,[H|T1],T2) :-
	%% new vars are all prvar structures
	( is_prvariable(H,Var,_I)
	; is_prtransactionalvariable(H,Var,_I)
	),
	str_sub(Prefix,Var,0), %% starts with Prefix
	!,
	remove_prvars(Prefix,T1,T2).
remove_prvars(Prefix,[H|T1],[H|T2]) :-
	remove_prvars(Prefix,T1,T2).

remove_prdontcare_vars(InVars,OutVars) :-
	remove_prvars(NEWDONTCAREVAR,InVars,OutVars).
remove_caller_vars(InVars,OutVars) :-
	remove_prvars(NEWCALLERVAR,InVars,OutVars).


/****************************************************************************
  collect_name_var_pairs(+ParserTerm,-QueryVars)
  collects all the queryable variables (those that do not start with an
  underscore) in a parser term (or a list of parser terms) into a list
  of Name=Var constructs.

  indexvars(+SortedNameVars,-IndexVars)
  namevars(+SortedIndexVars,-QueryVars)
****************************************************************************/
collect_name_var_pairs(ParserTerm,QueryVars) :-
	collect_flvars(ParserTerm,NameVs),
	sort(NameVs,SortedNameVs),
	indexvars(SortedNameVs,IndexVs),
	keysort(IndexVs,SortedIndexVs),
	namevars(SortedIndexVs,QueryVars).


indexvars([],[]) :- !.

indexvars([T|L],Vars) :-
	(is_flvariable(T,Name,I);is_fltransactionalvariable(T,Name,I)),
	(
	  (is_flvariable(T,Name,I), flora_match_substring(FL_UNDERSCORE,Name,0)
	  ; is_fltransactionalvariable(T,Name,I),
	      flora_match_substring(FL_UNDERSCORE,Name,0)
	  )
	-> indexvars(L,Vars)
	;
          Vars=[I-Name|Vs],
	  remove_dupflvars(L,Name,VL),
	  indexvars(VL,Vs)
        ).


namevars([],[]) :- !.

namevars([Index-Name|L],[NV|NVs]) :-
	varobj_struct(Name,Index,VCode),
	%% prepend '?' to var names in query answers
	flora_concat_atoms(['?',Name],NewName),
	atomobj_struct(NewName,Index,NCode),
	atomobj_struct(FL_UNIVEQ,FCode),
	prologterm_struct(FCode,2,[NCode,VCode],NV),
	namevars(L,NVs).


/****************************************************************************
  singleton_flvars(+SortedVarsList,-SingletonVars)
  collects all the singleton variables in SortedVarsList into SingletonVars.
  Singleton variables collected here exclude those
  beginning with a underscore and the anonymous.

  remove_dupflvars(+SortedVarsList,+VarName,-Vars)
  remove_dupflvars(+SortedVarsList,-Vars)
****************************************************************************/
singleton_flvars([],[]) :- !.

singleton_flvars([V|L],[V|Vs]) :-
	(is_flvariable(V,FL_UNDERSCORE,_I);is_fltransactionalvariable(V,FL_UNDERSCORE,_I)),
	!,
	singleton_flvars(L,Vs).

singleton_flvars([V],[V]) :- !.

singleton_flvars([V1,V2|L],Vars) :-
	( (is_flvariable(V1,Name,_I);is_fltransactionalvariable(V1,Name,_I)),
	  (is_flvariable(V2,Name,_J);is_fltransactionalvariable(V2,Name,_I))
	->
	    remove_dupflvars(L,Name,Vs),
	    singleton_flvars(Vs,Vars)
        ;
	  Vars=[V1|Vs],
	  singleton_flvars([V2|L],Vs)
        ).


%% removes variables named Name from a sorted list of vars,
%% if this var is at the top
remove_dupflvars([V|L],Name,Vars) :-
	(is_flvariable(V,Name,_I) ; is_fltransactionalvariable(V,Name,_I)),
	!,
	remove_dupflvars(L,Name,Vars).

remove_dupflvars(Vars,_Name,Vars).

%% real remove duplicate flvars
remove_dupflvars(Vars,VarsOut) :-
	sort(Vars,VarsS),
	remove_dupflvars_aux(VarsS,VarsOut).
remove_dupflvars_aux([],[]) :- !.
remove_dupflvars_aux([H|T],[H|TT]) :-
	(is_flvariable(H,Name,_I) ; is_fltransactionalvariable(H,Name,_I)),
	!,
	remove_dupflvars(T,Name,Vars),
	remove_dupflvars_aux(Vars,TT).


/****************************************************************************
  singleton_warning(+VarList,-WarnList,-WarnTail)
  Warnings are not generated for variables beginning with an underscore.
****************************************************************************/
singleton_warning([],WarnList,WarnList).

singleton_warning([V|L],WarnList,WarnTail) :-
	(is_flvariable(V,Name,I);is_fltransactionalvariable(V,Name,I)),
	( (is_flvariable(V,Name,I),flora_match_substring(FL_UNDERSCORE,Name,0);is_fltransactionalvariable(V,Name,I),flora_match_substring(FL_UNDERSCORE,Name,0)) ->
	    singleton_warning(L,WarnList,WarnTail)
	;
	  compiling_warning(I,SINGLETON_VAR,W),
	  WarnList=[W|T],
	  singleton_warning(L,T,WarnTail)
        ).


/****************************************************************************
  unbound_warning(+VarList,-WarnList,-WarnTail)
  Warnings are not generated for variables beginning with an underscore.
****************************************************************************/
unbound_warning(VarList,WarnList,WarnTail) :-
	unbound_warning(VarList,WarnList,WarnTail,UNBOUND_VAR).

unbound_warning([],WarnList,WarnList,_).

unbound_warning([V|L],WarnList,WarnTail,WarningMessage) :-
	(is_flvariable(V,Name,I) ; is_fltransactionalvariable(V,Name,I)),
	( (is_flvariable(V,Name,I), flora_match_substring(FL_UNDERSCORE,Name,0)
	  ;
	      is_fltransactionalvariable(V,Name,I),
	      flora_match_substring(FL_UNDERSCORE,Name,0))
	->
	    unbound_warning(L,WarnList,WarnTail,WarningMessage)
	;
	  compiling_warning(I,WarningMessage,W),
	  WarnList=[W|T],
	  unbound_warning(L,T,WarnTail,WarningMessage)
        ).


/****************************************************************************
  check_head_vars_for_safety(+HeadTermList,+BodyTerm,-Status)
****************************************************************************/
check_head_vars_for_safety(HeadTermList,BodyTerm,Status) :-
	collect_flvars(HeadTermList,HeadVars),
	collect_flvars(BodyTerm,BodyVars),
	append(HeadVars,BodyVars,Vars),
	sort(Vars,SortedVars),
	singleton_flvars(SortedVars,SingletonVars),
	singleton_warning(SingletonVars,Status,WarnTail),
	subtract_vars(HeadVars,BodyVars,UnboundVars),
	%% Don't issue the unboundedness var warning for facts
	(BodyTerm \= [] ->
	    unbound_warning(UnboundVars,WarnTail,[])
	;
	    (var(Status) -> Status=[] ; true )
	).


/****************************************************************************
  check_udf_vars_for_safety(+Function,+Predicate,+ReturnValue,-Status)
****************************************************************************/
check_udf_vars_for_safety(Function,Predicate,ReturnValue,Status) :-
        collect_flvars([Function,ReturnValue],FuncVars),
        collect_flvars(Predicate,PredVars),
        append(FuncVars,PredVars,Vars),
        sort(Vars,SortedVars),
        singleton_flvars(SortedVars,SingletonVars),
        singleton_warning(SingletonVars,Status,WarnTail),
        subtract_vars(FuncVars,PredVars,UnboundVars),
        %% Don't issue the unboundedness var warning for facts (facts can be defined using function definition)
        (Predicate = NULL ->
            ( var(Status) -> Status=[] ; true )
        ;
            unbound_warning(UnboundVars,WarnTail,[],UNBOUND_UDF_VAR)
        ).



/****************************************************************************
    vars_to_var_names(+VarList,-NameList)

 Takes a list of vars from either the parser or compiler
 and returns a list of their names.
 Assumes that the list is indeed a list of vars.

****************************************************************************/
vars_to_var_names([],[]) :- !.
vars_to_var_names([V|VarList],[Name|NameList]) :-
	(is_flvariable(V,Name,_)
	; is_fltransactionalvariable(V,Name,_)
	; is_prvariable(V,Name,_)
	; is_prtransactionalvariable(V,Name,_)
	),
	!,
	vars_to_var_names(VarList,NameList).


/****************************************************************************
  clear_directive
  get_directive(-L)  
  report_directive(+Direct)
  clear_options
  get_options(-L)
  report_option(+Option,+Index)
  clear_dynrule_varlist
  report_dynrule_varlist(+Var,+Val)
  get_dynrule_varlist(-L)
  get_dynrule_varlist(+CompileVarList,-L)
****************************************************************************/
%% Not used any more. Instead of import we use the module:pred notation
%%clear_directive :- flora_retractall_substitute(TMPDIRECT(_)).
%%get_directive(L) :- findall(D,TMPDIRECT(D),L).
%%report_directive(Direct) :- asserta(TMPDIRECT(Direct)).


clear_options :- flora_retractall_substitute(TMPOPTION(_,_)).
get_options(L) :- findall((O,Idx),TMPOPTION(O,Idx),L).
report_option(Option,Idx) :- asserta(TMPOPTION(Option,Idx)).

%% Do not(!) check for \+ PERMAOPTION(X) here!
%% We rely on duplicates if multiple declarations of argumentation theories
set_permaoption(X) :- asserta(PERMAOPTION(X)).
set_permaoptions([]) :- !.
set_permaoptions([X|Rest]) :-
	set_permaoption(X),
	set_permaoptions(Rest).
has_permaoption(X) :- PERMAOPTION(X).
flora_clear_compilation_permaoptions :- retractall(PERMAOPTION(_)).
clear_one_permaoption(X) :- (retract(PERMAOPTION(X)), ! ; true).
%% this is exported for others to use
%%flora_compiler_permaoption(X) :- has_permaoption(X).

/*
clear_context(X) :- (retract(COMPILATION_CONTEXT(X)), ! ; true).
clear_contextall(X) :- flora_retractall_substitute(COMPILATION_CONTEXT(X)).
set_context(X) :-
	(\+has_context(X)
	-> asserta(COMPILATION_CONTEXT(X))
	; true
	).
has_context(X) :- COMPILATION_CONTEXT(X).
*/

set_context(X) :-
	atom(X),
	!,
	flora_set_counter(X,1).
set_context(X) :-
	compound(X),
	\+COMPILATION_CONTEXT(X),
	!,
	asserta(COMPILATION_CONTEXT(X)).
set_context(X) :-
	compound(X),
	!.
set_context(X) :-
	abort([X, ': FLORA-2 compiler BUG!! Invalid compiler context']).

has_context(X) :-
	compound(X),
	!,
	COMPILATION_CONTEXT(X).
has_context(X) :-
	flora_get_counter(X,1).

clear_context(X) :-
	atom(X),
	!,
	flora_set_counter(X,0).
clear_context(X) :-
	retract(COMPILATION_CONTEXT(X)),
	!.
clear_context(_).
clear_contextall(X) :- flora_retractall_substitute(COMPILATION_CONTEXT(X)).

%% this one is exported
flora_compilation_context(X) :- has_context(X).

clear_dynrule_varlist :- flora_retractall_substitute(DYNRULE_VARLIST(_,_)).
report_dynrule_varlist(AttrVar,Val) :-
	asserta(DYNRULE_VARLIST(AttrVar,Val)).
get_dynrule_varlist(L) :- findall((Var,Val),DYNRULE_VARLIST(Var,Val),L).
get_dynrule_varlist(VarList,L) :- findall((Var,Val),(DYNRULE_VARLIST(Var,Val),memberchk(Var,VarList)),L).

%% Report options specified in the :- setsemantics{...} directive
%% Since the argument is a parser list (sans the FLLIST wrapper), we need 
%% to extract the actual values of terms in the list in order to pass
%% to report_options/2.
report_semantic_options([]).
report_semantic_options([H|T]) :-
	is_flplib(H,FlTerm),
	is_flterm(FlTerm,Funct,_N,[Arg|_]),
	is_flatom(Funct,FunctVal,Index),
	is_flatom(Arg,ArgVal),
	Option =.. [FunctVal,ArgVal],
	report_option(Option,Index),
	report_semantic_options(T).


/****************************************************************************
  initialize_work
****************************************************************************/
initialize_work :-
	flora_reset_newvar,
	%%clear_directive,
	clear_options,
	clear_contextall(_),
        clear_dynrule_varlist.

/****************************************************************************
  flora_reset_compiler/0
****************************************************************************/
flora_reset_compiler :-
	reset_newpredicate,
	reset_rulenum,
	reset_defaultlabel,
	flora_clear_compiletime_uriprefixes,
	reset_newoid.


/****************************************************************************
  flora_compile_add(+ParserTerm,-RuleDiffList,-FactDiffList,-UDFPredsDiffList,-OptionList,-Status)

  This is the top level predicate that is called to compile code for
  adding code to module.

  RuleDiffList is a difference list in the form of [...|R]-R. Diff lists
  are used for optimization of append.
  FactDiffList is the same for facts
  UDFPredsDiffList is the same for the list of tabled predicates
****************************************************************************/
flora_compile_add(NULL,R-R,F-F,U-U,[],[]) :- !.
	
flora_compile_add(ParserTerm,RuleDiffList,FactDiffList,UDFPredsDiffList,OptionList,Status) :-
	compile_add_internal(ParserTerm,(NULL,NULL),
			     RuleDiffList,FactDiffList,UDFPredsDiffList,
			     OptionList,Status),
/*
	writeln(2,'------------result of add_compilation-------------'),
	writeln(2,rules=RuleDiffList),
	writeln(2,facts=FactDiffList),
	%%writeln(2,udfs =UDFPredsDiffList),
	writeln(2,status=Status),
	writeln(2,'--------------------------------------------------'),
*/
	!.
	
%% This rule is for debugging.
flora_compile_add(_ParserTerm,[],[],[],[],[error(UNKNOWN_ERROR)]).

compile_add_internal(ParserTerm,LabelCode,RuleDiffList,FactDiffList,UDFPreds-UDFPredsTail,OptionList,Status) :-
	%% extract the rule number
	flora_increment_counter(RULE_NUM,1,_,_),
	initialize_work,
	!,
	set_context(compiling_for_addition),
	( is_flrule(ParserTerm,Head,Body) ->
	    UDFPreds=UDFPredsTail,
	    compile_rule_add(Head,Body,LabelCode,RuleDiffList,FactDiffList,Status)

	; is_flfact(ParserTerm,Head) ->
	    UDFPreds=UDFPredsTail,
	    compile_fact(Head,RuleDiffList,FactDiffList,Status)

	; is_flquery(ParserTerm,Body) ->
	    UDFPreds=UDFPredsTail,
	    compile_query(Body,RuleDiffList,FactDiffList,Status)

	; is_fldirective(ParserTerm,DirectList,DirctIdx) ->
	    UDFPreds=UDFPredsTail,
	    compile_directive_add(DirectList,DirctIdx,RuleDiffList,FactDiffList,Status)

	; is_fllabeled_construct(ParserTerm,Label,Contents) ->
	    UDFPreds=UDFPredsTail,
	    compile_annotated_construct_add(Label,Contents,RuleDiffList,FactDiffList,Status)

	; is_fludfunction(ParserTerm,Function,Body,ReturnValue) ->
	    compile_user_defined_function(Function,Body,ReturnValue,RuleDiffList,FactDiffList,UDFPreds-UDFPredsTail,Status)

	; is_fludfunctionfact(ParserTerm,Function,Value) ->
	    compile_user_defined_function(Function,NULL,Value,RuleDiffList,FactDiffList,UDFPreds-UDFPredsTail,Status)
        ),
	!,
	clear_context(compiling_for_addition),
	get_options(OptionList),
	clear_ruleoid.

/****************************************************************************
  compile_rule_add(+Head,+Body,+LabelCode,-RuleDiffList,-FactDiffList,-Status)

  LabelCode has the form (TagCode, MetaCode). TagCode is NULL or an atom-object.
  MetaCode is a NULL or a list of codes.

  RuleDiffList is a difference list in the form of [...|R]-R.
  FactDiffList is Facts-Facts == empty diff list
  It is for the optimization of append.
****************************************************************************/
compile_rule_add(Head,Body,Label,RuleList-RuleTail,Facts-Facts,Status):-
	%% Note: Label here is already compiled code of the form
	%% (TagCode,MetaCode). A special case in compile_label takes care
	%% of that. If FLDYNRULE(H,B,L) comes from the parser, then the
	%% label has the form FLTAG(Id,Meta,Index).
	compile_flupdaterule(FLATOM(FL_INSERTRULE_Z,NO_INDEX),[FLDYNRULE(Head,Body,Label)],RCode,Status),
	get_dynrule_varlist(L),
	add_dynrule_attr_code(L,RCode,RuleCode),
	query_struct(RuleCode,Code),
	RuleList = [Code|RuleTail].

compile_directive_add([],_,R-R,F-F,[]) :- !.

%% Facts-Facts = empty diff list
compile_directive_add([D|L],DirIdx,RuleList-RuleTail,Facts-Facts,Status) :-
	compile_direct_add(D,DirIdx,DCodeList,S),
	( no_errors_found(S) -> 
	    append(DCodeList,T,RuleList),
	    compile_directive_add(L,DirIdx,T-RuleTail,Facts-Facts,S2),
	    append(S2,S,Status)
	;
	  Status=S
        ).

compile_direct_add(DirectTerm,_DirIdx,[Code],S) :-
	is_flsetsemantics(DirectTerm,_OptionsList),
	!,
	compile_exec_directive([DirectTerm],NULL,Code1,S),
	query_struct(Code1,Code).

compile_direct_add(DirectTerm,DirIdx,DCodeList,S) :-
	compile_direct(DirectTerm,DirIdx,DCodeList,S).

%% Facts-Facts = empty diff list
compile_annotated_construct_add(Label,Contents,RuleList-RuleTail,Facts,Status) :-
	compile_label(Label,TagCode,MetaCode,Status1),
	( no_errors_found(Status1) -> 
	    compile_add_internal(Contents,(TagCode,MetaCode),
				 RuleList1-[],Facts,_UDFPreds,_OptionList,Status),
	    append(RuleList1,RuleTail,RuleList)
	;  Status = Status1
	).


/****************************************************************************
  flora_compile(+ParserTerm,-RuleDiffList,-FactDiffList,-UDFPredsDiffList,-OptionList,-Status)

  This is the top level procedure that is called to compile code.

  RuleDiffList is a rule difference list in the form of [...|R]-R.
      It is used in order to optimize append.
  FactDiffList is the same for facts
  UDFPredsDiffList is the same for the list of tabled predicates
****************************************************************************/
flora_compile(NULL,R-R,F-F,U-U,[],[]) :- !.

flora_compile(ParserTerm,RuleDiffList,FactDiffList,UDFPredsDiffList,OptionList,Status) :-
/*
	writeln(2,'------------result of parsing-----------------'),
	writeln(2,ParserTerm),
	writeln(2,'----------------------------------------------'),
*/
	compile_internal(ParserTerm,(NULL,NULL),
			 RuleDiffList,FactDiffList,UDFPredsDiffList,
			 OptionList,Status),
/*
	writeln(2,'------------result of compilation-----------------'),
	writeln(2,rules=RuleDiffList),
	writeln(2,facts=FactDiffList),
	%%writeln(2,udfs =UDFPredsDiffList),
	writeln(2,status=Status),
	writeln(2,'--------------------------------------------------'),
*/
	!.
	
%% This rule is for debugging.
flora_compile(_ParserTerm,[],[],[],[],[error(UNKNOWN_ERROR)]).


%% This does the main work
%% LabelCode has the form (TagCode, MetaCode). TagCode is NULL or atom-object.
%% MetaCode is a NULL or a list of codes.
compile_internal(ParserTerm,LabelCode,RuleDiffList,FactDiffList,UDFPreds-UDFPredsTail,OptionList,Status) :-
	%% extract the rule number
	flora_increment_counter(RULE_NUM,1,_,_),
	initialize_work,
	!,
	( is_flrule(ParserTerm,Head,Body) ->
	    UDFPreds=UDFPredsTail,
	    compile_rule(Head,Body,LabelCode,RuleDiffList,FactDiffList,S),
	    %% check whether singleton numbered anon oid exists
	    (ruleoid(_,_,1) -> referenced_once(S,Status) ;  Status=S)

	; is_flfact(ParserTerm,Head) ->
	    UDFPreds=UDFPredsTail,
	    compile_fact(Head,RuleDiffList,FactDiffList,S),
	    (ruleoid(_,_,1) -> referenced_once(S,Status) ;  Status=S)

	; is_flquery(ParserTerm,Body) ->
	    UDFPreds=UDFPredsTail,
	    compile_query(Body,RuleDiffList,FactDiffList,Status)

	; is_fldirective(ParserTerm,DirectList,DirctIdx) ->
	    UDFPreds=UDFPredsTail,
	    compile_directive(DirectList,DirctIdx,RuleDiffList,FactDiffList,Status)

	; is_fllabeled_construct(ParserTerm,Label,Contents) ->
	    UDFPreds=UDFPredsTail,
	    compile_annotated_construct(Label,Contents,RuleDiffList,FactDiffList,Status)

	; is_fludfunction(ParserTerm,Function,Body,ReturnValue) ->
	    compile_user_defined_function(Function,Body,ReturnValue,RuleDiffList,FactDiffList,UDFPreds-UDFPredsTail,Status)

	; is_fludfunctionfact(ParserTerm,Function,Value) ->
	    compile_user_defined_function(Function,NULL,Value,RuleDiffList,FactDiffList,UDFPreds-UDFPredsTail,Status)
        ),
	!,
	get_options(OptionList),
	clear_ruleoid.

/***************************************************************************
  referenced_once(+Status_rf,-Status)
  finds singleton numbered anon oid and puts warning message in Status
***************************************************************************/
referenced_once(Status_rf,Status) :-
	findall(Index,ruleoid(_,Index,1),IndexList),
	singleton_oid_warning(IndexList,WarnList,[]),
	append(Status_rf,WarnList,Status).


/*************************************************************************
singleton_oid_warning(+SingleOidList,-WarnList,-WarnTail)
***********************************************************************/
singleton_oid_warning([],WarnList,WarnList).

singleton_oid_warning([Index|L],WarnList,WarnTail) :-
	compiling_warning(Index,SINGLETON_OID,W),
	WarnList=[W|T],
	singleton_oid_warning(L,T,WarnTail).


/****************************************************************************
  compile_directive(+DirectList,+DirctIdx,-RuleDiffList,-FactDiffList,-Status)
  compile_direct(+DirectTerm,+DirctIdx,-RuleList,-Status)
****************************************************************************/
compile_directive([],_,R-R,F-F,[]) :- !.

%% Facts-Facts = empty diff list
compile_directive([D|L],DirIdx,RuleList-RuleTail,Facts-Facts,Status) :-
	compile_direct(D,DirIdx,DCodeList,S),
	( no_errors_found(S) -> 
	    append(DCodeList,T,RuleList),
	    compile_directive(L,DirIdx,T-RuleTail,Facts-Facts,S2),
	    append(S,S2,Status)
	;
	  Status=S
        ).

compile_direct(DirectTerm,_DirIdx,[Code],Status) :-
	is_flexport_list(DirectTerm,Term),
	compile_export(Term,Direct,Status),
	!,
	directive_struct(Direct,Code).

compile_direct(DirectTerm,DirIdx,[],[]) :-
	is_flindex(DirectTerm,A,P),
	!,
	report_option(FLINDEX(A,P),DirIdx).

compile_direct(DirectTerm,_DirIdx,[Code],[]) :-
	is_verbatim(DirectTerm,Instruction),
	!,
	atomobj_struct(Instruction,InstrCode),
	verbatim_struct(InstrCode,Direct),
	directive_struct(Direct,Code).

compile_direct(DirectTerm,DirIdx,[Code],[]) :-
	is_fldefeasible(DirectTerm,Module),
	!,
	is_flatom(Module,Name),
	set_permaoption(FLDEFEASIBLE(Name)),
	%% the next option is reported so that GCLP library would be included,
	%% if the default GCLP theory is used.
	(Name == FL_DEFAULT_DEFEASIBLE_THEORY
	->
	    report_option(FLSYSMOD(FL_DEFAULT_DEFEASIBLE_THEORY),DirIdx)
	; true
	),
	defeasible_struct(Name,Direct),
	directive_struct(Direct,Code).


compile_direct(DirectTerm,_DirIdx,[],[]) :-
	is_fldefeasible_rule_default(DirectTerm),
	!,
	set_permaoption(FLDEFEASIBLE_RULE_DEFAULT).
	
compile_direct(DirectTerm,_DirIdx,[],[]) :-
	is_flstrict_rule_default(DirectTerm),
	!,
	clear_one_permaoption(FLDEFEASIBLE_RULE_DEFAULT).
	

%% Operator definition. Must also induce executable op definition,
%% to execute in the shell (restricted to "main" module)
compile_direct(DirectTerm,_DirIdx,[Code],Status) :-
	is_flopdef(DirectTerm,P,A,O),
	flora_define_operator(P,A,O),
	compile_exec_directive([FLOPDEF(P,A,O)],NULL,Code1,Status),
	query_struct(Code1,Code),
	!.

compile_direct(DirectTerm,_,[Code],Status) :-
	is_flprolog_directive(DirectTerm,PairList,Idx),
	!,
	check_symbol_pairlist_for_clashes(PairList,Idx, PROLOG_SYMBOL,
					  NONTRANSACTIONAL_SYMBOL,Status),
	maplist(prolog_option(_,_),PairList,PermaOptions),
	make_runtime_modular_prolog_declarations(PermaOptions,Code),
	set_permaoptions(PermaOptions).
prolog_option((P,N),prolog(P,N)) :- 
	!,
	flora_define_modular_prolog(P,N),
	set_permaoption(atomreplacement(P,N,PRMODULARIZEDATOM(P))).
prolog_option(P/N,prolog(P,N)) :- 
	flora_define_modular_prolog(P,N),
	set_permaoption(atomreplacement(P,N,PRMODULARIZEDATOM(P))).

compile_direct(DirectTerm,_,[CodeTbl,CodePrlg],Status) :-
	is_fltabledirect(DirectTerm,PredSpecList,Idx),
	!,
	check_symbol_pairlist_for_clashes(PredSpecList,Idx, PROLOG_SYMBOL,
					  NONTRANSACTIONAL_SYMBOL,Status),
	maplist(prolog_option(_,_),PredSpecList,PermaOptions),
	make_runtime_modular_prolog_declarations(PermaOptions,CodePrlg),
	set_permaoptions(PermaOptions),
	maplist(table_option(_,_),PredSpecList,TableSpecList),
	list2commalist(TableSpecList,TableSpec),
	table_directive_struct(TableSpec,Direct),
	directive_struct(Direct,CodeTbl).
table_option(P/N,PMod/N1) :-
	N1 is N+1, %% because of the caller argument
	modularized_atom_struct(P,NO_INDEX,PMod).

compile_direct(DirectTerm,_,[Code],Status) :-
	is_flusesensordirect(DirectTerm,PairList,Idx),
	!,
	maplist(make_sensor_permaoption(_,_),PairList,PermaOptions),
	set_permaoptions(PermaOptions),
	check_symbol_pairlist_for_clashes(PairList,Idx, USE_SENSOR_SYMBOL,
					  NONTRANSACTIONAL_SYMBOL,Status),
	verbatim_struct(PairList,PairListCode),
	thismodule_struct(ThisMod),
	florasyslib_struct(FLLIBRECORDSENSORS,2,[ThisMod,PairListCode],Code1),
	report_option(FLSYSLIB(FLLIBRECORDSENSORS),NO_INDEX),
	query_struct(Code1,Code).
%% used in converting usesensor pred list
make_sensor_permaoption(P/N,sensor(P,N)).
%% not used
%%sensor_name_replacement(P/N,SP/N) :- flora_scramble_atom(P,SP).


compile_direct(DirectTerm,_,[],Status) :-
	is_flusefunctiondirect(DirectTerm,PairList,Idx),
	!,
	check_symbol_pairlist_for_clashes(PairList,Idx, USE_UDF_SYMBOL,
					  NONTRANSACTIONAL_SYMBOL,Status),
	maplist(usefunction_option(_,_),PairList,PermaOptions),
	set_permaoptions(PermaOptions).

usefunction_option(FunName/Arity,PermaOption) :-
	new_udf_predicate(FunName,Arity,[],NewArgs,NewPredicate,_NewPredicateOrigArgs,_NewPredName,_NewPredArity,NewReturnValue),
	PermaOption = user_defined_function(FunName,Arity,NewArgs,NewPredicate,NewReturnValue).
	


%% need to also construct a query so that sensor will be registered
%% during the compilation
compile_direct(DirectTerm,_,[Code],Status) :-
	is_flsensordirect(DirectTerm,SensCall,DelayCond),
	!,
	compile_sensor_direct(SensCall,DelayCond,Direct,S1),
	query_struct(Direct,QueryCode),
	( no_errors_found(S1) -> 
	    flora_intern_code([QueryCode],NULL,PrologCode,S2),
	    ( no_errors_found(S2) -> 
		call(PrologCode)
	    ; true
	    ),
	    directive_struct(Direct,Code),
	    append(S1,S2,Status)
	; Status = S1
	).

compile_direct(DirectTerm,_Idx,CodeList,[]) :-
	is_flsetsemantics(DirectTerm,OptionsList),
	!,
	is_fllist(OptionsList,L,_T,_I),
	report_semantic_options(L),
	CodeList = [],
	!.

%% prefix definition
compile_direct(DirectTerm,_Idx,[Code],[]) :-
	is_flprefixdef(DirectTerm,PrefixName,PrefixBody),
	!,
	FLLIBPREFIXDEF(PrefixName,PrefixBody),
	thismodule_struct(ThisModule),
	florasyslib_struct(FLLIBPREFIXDEF,3,[ThisModule,PrefixName,PrefixBody],Code1),
	query_struct(Code1,Code).

%% :- compiler_options
compile_direct(DirectTerm,Idx,[Code],[]) :-
	is_flcmpopt(DirectTerm,OptList),
	( memberchk(XSB_SPECREPR,OptList) ->
	    report_option(XSB_SPECREPR,Idx)
	;
	    true
	),
	cmpopt_struct(OptList,OCode),
	directive_struct(OCode,Code),	
	!.
	
%% :- ignore_depchk
compile_direct(DirectTerm,_Idx,[Code],Status) :-
	is_flignoredep(DirectTerm,SpecList),
        set_context(compile_with_var_module),
	compile_ignoredep_list(SpecList,SCode,Status),
        clear_context(compile_with_var_module),
        !,
	( no_errors_found(Status) -> 
	    ignoredep_struct(SCode,ICode),
	    directive_struct(ICode,Code)
        ;   true
        ).

compile_direct(DirectTerm,_Idx,[Code],Status) :-
	is_importmodule(DirectTerm,Modspec) ->
	compile_pathexp(Modspec,Obj,_Oid,_Cd,Status),
	importmodule_struct(Obj,Code1),
	directive_struct(Code1,Code),
	!,
	(is_flbuiltin_identifier(Modspec,MName,Index),
	    flrlibman:flora_system_module(MName)
	-> report_option(FLSYSMOD(MName),Index)
	; true
	).

compile_direct(DirectTerm,_Idx,[],Status) :-
	is_flsymbolcontext(DirectTerm,SymbolList),
	compile_symbol_context_list(SymbolList,Status).

/****************************************************************************
  compile_ignoredep_list(+SpecList,-CodeList,-Status)
  compile a list of ignoredep sepcifications
****************************************************************************/
compile_ignoredep_list([],[],[]) :- !.
compile_ignoredep_list([H|L],[HCode|LCode],Status) :-
        compile_body(H,HCode,S),
	( no_errors_found(S) -> 
            compile_ignoredep_list(L,LCode,Status)
        ;
            Status = S
        ).

/****************************************************************************
  compile_symbol_context_list(+SymbolsList,-Status)
  compile a list of symbols for which compiler does NOT check context usage
****************************************************************************/
compile_symbol_context_list([],[]) :- !.
compile_symbol_context_list([H|L],Status) :-
        compile_symbol_literal(H,S),
	( no_errors_found(S) -> 
            compile_symbol_context_list(L,Status)
        ;
            Status = S
        ).

/****************************************************************************
  compile_symbol_literal(+ParserTerm,-Status)
  compile_symbol_literal(+ParserTerm,+Context,-Status)
  compile a symbol for which compiler does NOT check context usage
****************************************************************************/
compile_symbol_literal(ParserTerm,Status) :-
	( is_fltransactionalterm(ParserTerm,Funct,N,_Args) ->
	    compile_symbol_term(Funct,N,NULL,FUNCTION_SYMBOL,TRANSACTIONAL_SYMBOL),
	    Status = []
	; is_flterm(ParserTerm,Funct,N,_Args) ->
	    compile_symbol_term(Funct,N,NULL,FUNCTION_SYMBOL,NONTRANSACTIONAL_SYMBOL),
	    Status = []
	; is_flatom(ParserTerm,_Atom) ->
	    compile_symbol_term(ParserTerm,0,NULL,FUNCTION_SYMBOL,NONTRANSACTIONAL_SYMBOL),
	    Status = []
	; is_fltransactionalatom(ParserTerm,_Atom) ->
	    compile_symbol_term(ParserTerm,0,NULL,FUNCTION_SYMBOL,TRANSACTIONAL_SYMBOL),
	    Status = []
	; is_fludfsymbol(ParserTerm,Term) ->
	    compile_symbol_literal(Term,NULL,UDF_SYMBOL,Status)
	; is_flsensorsymbol(ParserTerm,Term) ->
	    compile_symbol_literal(Term,NULL,SENSOR_SYMBOL,Status)
	; is_flprlgsymbol(ParserTerm,Term) ->
	    compile_symbol_literal(Term,NULL,PROLOG_SYMBOL,Status)
	; is_flworkspace(ParserTerm,Term,WS) ->
	    compile_symbol_literal(Term,WS,PREDICATE_SYMBOL,Status)
	; is_flfloralib(ParserTerm,Term,WS) ->
	    compile_symbol_literal(Term,WS,PREDICATE_SYMBOL,Status)
	;
	    approx_flindex(Funct,Index),
	    compiling_error(Index,ERROR_SYMBOL,Err),
	    Status = [Err]
	).

compile_symbol_literal(ParserTerm,WS,Context,Status) :-
	( is_fltransactionalterm(ParserTerm,Funct,N,_Args) ->
	    compile_symbol_term(Funct,N,WS,Context,TRANSACTIONAL_SYMBOL),
	    Status = []
	; is_flterm(ParserTerm,Funct,N,_Args) ->
	    compile_symbol_term(Funct,N,WS,Context,NONTRANSACTIONAL_SYMBOL),
	    Status = []
	; is_flatom(ParserTerm,_Atom) ->
	    compile_symbol_term(ParserTerm,0,WS,FUNCTION_SYMBOL,NONTRANSACTIONAL_SYMBOL),
	    Status = []
	; is_fltransactionalatom(ParserTerm,_Atom) ->
	    compile_symbol_term(ParserTerm,0,WS,FUNCTION_SYMBOL,TRANSACTIONAL_SYMBOL),
	    Status = []
	;
	    approx_flindex(Funct,Index),
	    compiling_error(Index,ERROR_SYMBOL,Err),
	    Status = [Err]
	).

/****************************************************************************
  compile_symbol_term(+Funct,+N,+WS,+Context,+Transactional)
****************************************************************************/
compile_symbol_term(Funct,N,WS,Context,Transactional) :-
	flora_get_flatomvar_name(Funct,Name),
	add_nowarn_symbol(Name,N,WS,Context,Transactional).

/****************************************************************************
  compile_flatomvar(+T,-Code)

  T is a variable structure, or an atom structure, or a plain atomic.
****************************************************************************/
compile_flatomvar(T,Code) :-
	    ( is_flvariable(T,TName,I) ->
		varobj_struct(TName,I,Code)
	    ; 
	      atomobj_struct(T,Code)
	    ).

/****************************************************************************
        compile_sensor_direct(+SensCall,+DelayCond,-Direct,-Status)

   Compile a sensor directive.
****************************************************************************/
compile_sensor_direct(SensCall,DelayCond,Code,Status) :-
	(flprologlib_atom_arity(SensCall,SensName,SensArity)
	%% sensor defined in a .flr file: declare it as prolog
	->
	    flora_scramble_atom(SensName,SensNameWithFloraPrefix),
	    set_permaoption(atomreplacement(SensName,SensArity,SensNameWithFloraPrefix)),
	    %%flora_define_prolog(SensNameWithFloraPrefix,SensArity)
	    %% trmporarily record as prolog
	    set_permaoption(prolog(SensName,SensArity))
	; flprologlib_atom_arity_mod(SensCall,SensName,SensArity,ModName),
	    %% sensor defined in a prolog module
	    flora_define_prolog(SensName,SensArity,ModName)
	),
	set_context(compiling_sensor_directive(SensName,SensArity)),
	%% flprologlib_call converts flplib into flterm.
	%% This is needed because atomreplacement takes place in
	%% termlit_struct, which takes flterm's.
	flprologlib_call(SensCall,SensFLtermCall),
	compile_body_literal(SensFLtermCall,SensCode,S1),
	(no_errors_found(S1) -> compile_body_literal(DelayCond,DelayCode,S2)
	; S2 = S1
	),
	(no_errors_found(S2) ->
	    %% record symbol as sensor symbol, for error checking
	    SensArity2 is SensArity-2,
	    flprologlib_functor(SensCall,SensFunct),
	    check_symbol_name_for_clashes(SensFunct,SensArity2,
					  SENSOR_SYMBOL,NONTRANSACTIONAL_SYMBOL,
					  Status)
	; Status = S2
	),
	report_option(FLSYSLIB(FLLIBSENSOR),NO_INDEX),
	prologterm_struct(flora_register_sensor,2,
			 [SensCode,DelayCode],FLDELAYSUPPORTMOD,Code),
	clear_context(compiling_sensor_directive(SensName,SensArity)).
	


/****************************************************************************
  compile_fact(+Head,-RuleDiffList,-FactDiffList,-Status)

  RuleDiffList is a difference list in the form of [...|R]-R.
		It is used to optimize append
  FactDiffList is a difference list of facts

  Note: a fact containing a path expression might cause this
        fact to become a rule. However, we strip annotations from facts in
	the parser, so no need here to take rule tag/meta info into account.
****************************************************************************/
compile_fact(Head,RuleList-RuleTail,FactList-FactTail,Status) :-
	set_context(compiling_facts), 
	compile_head(Head,HeadCode,H2BCodeHead,H2BCodeTail,S),
	!,
	( no_errors_found(S) ->
	    ( H2BCodeHead == NULL, H2BCodeTail == NULL ->
		compile_factlist(HeadCode,RuleList-RuleTail,FactList-FactTail),
		%%RuleList = RuleTail, %% empty rule diff list
		(has_context(compiling_udf) -> S2 = []
		%% for UDFs variables are checked separately
		;
		    check_head_vars_for_safety(Head,[],S2)
		)
	    %%% fact became a rule due to code in arguments: compile as a rule
	    ; has_context(compiling_for_addition) ->
		%% if compiling for addition, just insert the rule: no need
		% to add signature, as signatures are added when such rules
		%% are inserted at copile time
		H2BflCode = FLATOM(FL_TRUE,NO_INDEX),
		compile_rule_add(Head,H2BflCode,(NULL,NULL),
				 RuleList-RuleTail,FactList-FactTail,S2)
	    /*
		compile_flinsert(FLATOM(FL_INSERT,NO_INDEX),Head,InsCode,S2),
		query_struct(InsCode,QInsCode),
		RuleList = [QInsCode|RuleTail],
		FactList = FactTail
	    */
	    ;
	        compile_conjunct2list(HeadCode,HeadCodeList),
		get_dynrule_varlist(L),
		conjunct_code([H2BCodeHead,H2BCodeTail],H2BCode),
		add_dynrule_attr_code(L,H2BCode,BodyCode),
		compile_label((NULL,NULL),TagCode,MetaCode,_),
		split_ruleheads_add_rulesig(HeadCodeList,
					    BodyCode,BodyCode,
					    (TagCode,MetaCode),
					    RuleList-RuleTail,[]),
		FactList = FactTail, %% empty fact diff list
		(has_context(compiling_udf) -> S2 = []
		%% for UDFs variables are checked separately
		;
		    check_head_vars_for_safety(Head,[],S2)
		)
	    ),
	    append(S,S2,Status)
        ;
	  Status=S
	),
	clear_context(compiling_facts).


/****************************************************************************
  compile_factlist(+Code,-RuleDifferenceList,-FactDifferenceList)

  This procedure takes a conjucntion of atoms and splits into a
  difference list.

  If a fact is declared as a prolog term, it is put into the rule list,
  so that it would be dumped as is rather than put into a trie.
****************************************************************************/
compile_factlist(NULL,RuleList-RuleList,FactList-FactList) :- !.

compile_factlist(ConjunctCode,RuleList-RuleListTail,FactList-FactListTail) :-
	conjunct_struct(F1,F2,ConjunctCode),
	!,
	compile_factlist(F1,RuleList-RT,FactList-FT),
	compile_factlist(F2,RT-RuleListTail,FT-FactListTail).

%% this is for fact-predicates that the compiler defines as prolog
%% using flora_define_prolog
compile_factlist(F,[FCode|ListTail]-ListTail,FL-FL) :-
	is_prologterm(F),
	!,
	(has_context(compiling_for_addition)
	->
	    generate_prolog_liblit(assert,1,[F],FCode1),
	    query_struct(FCode1,FCode)
	; fact_struct(F,FCode)
	).

compile_factlist(F,RL-RL,[FCode|ListTail]-ListTail) :-
	!,
        collect_prvars(F,FVars),
        get_dynrule_varlist(FVars,L),
        sort(L,NL),
        ( NL == [] ->
	    fact_struct(F,FCode)
        ;
            add_fact_attr_code(NL,F,AugmentedF),
            fact_struct(AugmentedF,FCode)
        ).

add_dynrule_attr_code([],Code,Code) :- !.
add_dynrule_attr_code([(Var,Val)|L],BCode,NewCode) :-
	attrvar_code(Var,Val,FLDYNRULEVARCHECK,Code),
        add_dynrule_attr_code(L,BCode,LCode),
        conjunct_struct(Code,LCode,NewCode).

%% This is used when a rule appears in a fact (as a reified subterm).
%% In this case, we prepend a var_val(Var,Val) pair to the code.
%% In flrutils.P, flora_put_attr_and_insert_fact will execute
%% put_attr(Var,FLDYNRULEVARCHECK,Val) before asserting the fact.
%% If this rule is then ever inserted, its variables will be chacked
%% for singletons and safety.
add_fact_attr_code([],Code,Code) :- !.
add_fact_attr_code([(Var,Val)|L],BCode,NewCode) :-
	attrvar_code_delayed(Var,Val,FLDYNRULEVARCHECK,Code),
        add_fact_attr_code(L,BCode,LCode),
        conjunct_struct(Code,LCode,NewCode).

attrvar_code(Var,Val,AttrName,Code) :-
	atomobj_struct(flora_put_attr,PutAttrFunct),
        atomobj_struct(AttrName,AttrCode),
        prologterm_struct(PutAttrFunct,3,[Var,AttrCode,Val],flrutils,VCode),
        prologliblit_struct(VCode,Code).

%% This version creates record that will enable flrutils.P
%% flora_put_attr_and_insert_fact to create attributed variables
%% at insertion time
attrvar_code_delayed(Var,Val,AttrName,Code) :-
	atomobj_struct(var_val,VarValFunct), %% this is utilized in flrutils.P
        prologterm_struct(VarValFunct,3,[Var,AttrName,Val],Code).

/****************************************************************************
  compile_query(+Body,-RuleDiffList,-FactDiffList,-Status)

  RuleDiffList is a difference list in the form of [...|R]-R.
	It is used to optimize append/3
  FactDiffList = Facts-Facts: the empty diff list
****************************************************************************/
compile_query(Body,RuleList-RuleTail,Facts-Facts,Status) :-
	compile_body(Body,BCode,Status),
	( no_errors_found(Status) -> 
	    collect_prdatatypevars(BCode,DTVarsCode),
	    append(DTVarsCode,[BCode],BCode1),
	    conjunct_code(BCode1,BCode2),
            get_dynrule_varlist(L),
	    %% sets attributed variables for the checker of
	    %% vars in dynamic rules
            add_dynrule_attr_code(L,BCode2,BodyCode),
	    thismodule_struct(ThisMod),
	    %% code to bind the Caller variable to the calling module
	    caller_binding_code(ThisMod,CallerBindingCode),
	    conjunct_struct(CallerBindingCode,BodyCode,AugmentedBodyCode),
	    collect_name_var_pairs(Body,NV),
	    list_struct(NV,[],NVCode),
	    %% Note: we do not add delay-checker code FLORA_DELAY_CHECKER
	    %% in queries, since it is explicit in FLLIBANSWER
	    florasyslib_struct(FLLIBANSWER,2,[AugmentedBodyCode,NVCode],Goal),
	    query_struct(Goal,QueryCode),
	    RuleList = [QueryCode|RuleTail]
	;
	  true
	).


/****************************************************************************
  compile_annotated_construct(+Label,Contents,-RuleDiffList,-FactDiffList,-Status)

  RuleDiffList is a difference list in the form of [...|R]-R.
		It is used for append/3 optimization
  FactDiffList = Facts-Facts: the empty diff list
****************************************************************************/
compile_annotated_construct(Label,Contents,RuleList-RuleTail,Facts,Status) :-
	compile_label(Label,TagCode,MetaCode,Status1),
	( no_errors_found(Status1) -> 
	    compile_internal(Contents,(TagCode,MetaCode),
			     RuleList1-[],Facts,_UDFPreds,_OptionList,Status),
	    append(RuleList1,RuleTail,RuleList)
	;  Status = Status1
	).


%% TagCode is NULL or an atom object
%% If permaoption is FLDEFEASIBLE_RULE_DEFAULT, then generate labels
%% even for untagged rules
%% MetaCode is NULL or a list of codes for meta frames
compile_label(NULL,TagCode,NULL,[]) :-
	!,
	construct_default_label(TagCode).
compile_label(Label,NULL,NULL,[]) :-
	var(Label),
	!.
%% already compiled
compile_label((Id,Meta),TagCode,Meta,[]) :-
	!,
	(Id == NULL
	-> construct_default_label(TagCode)
	;  TagCode = Id
	).
compile_label(Label,TagCode,MetaCode,Status) :-
	is_fllabel(Label,Id,Meta,Index),
	(is_flatom(Id,_A) ->
	    atomobj_struct(Id,TagCode),
	    IdStatus = []
	; is_fltoken(Id,FL_NEWOID,Index1) ->
	    new_oidobj(Index1,TagCode),
	    IdStatus = []
	; is_fltoken(Id,FL_NEWOID,Num,Index1) ->
	    flora_get_counter(RULE_NUM, Rule_num), 
	    new_oidobj(Rule_num,Num,Index1,TagCode),
	    %% Decrement RULE_NUM counter so that the tag and the rule will
	    %% have the same counter: compile_internal is called right
	    %% after compile_label, and this will increment the RULE_NUM
	    %% counter again
	    flora_increment_counter(RULE_NUM,-1,_,_),
	    IdStatus = []
	; is_flvariable(Id,VarName,VarIdx) ->
            compile_flvar(VarName,VarIdx,TagCode),
	    IdStatus = []
	; is_fldatatype(Id,_Sort,_Lit,_Index) ->
	    datatypeobj_struct(Id,TagCode,IdStatus)
	; is_flterm(Id,Funct,N,Args) ->
	    compile_fltermobj(Funct,N,Args,TagCode,_,_,IdStatus)
	; Id == FL_SKIP_TAG ->  %% requested that there should be no tag
	    TagCode = FL_SKIP_TAG,
	    IdStatus = []
	; construct_default_label(TagCode),
	    IdStatus = []
	),
	(Meta == NULL 
	-> Status = [],
	    MetaCode = NULL
	; compile_head(Meta,MetaCodeConjunct,NULL,NULL,Status1)
	-> 
	    ( no_errors_found(IdStatus), no_errors_found(Status1) -> 
	     	Status = [],
		%% convert to list
		compile_conjunct2list(MetaCodeConjunct,MetaCode)
	    ;  compiling_error(Index,INVALID_META_IN_LABEL,Err),
		Status = [Err]
	    )
	;  compiling_error(Index,INVALID_META_IN_LABEL,Err),
	    Status = [Err]
	).


%% default tag: either NULL or the DEFAULT_RULE_TAGNNNN atom
construct_default_label(TagCode) :-
	(has_permaoption(FLDEFEASIBLE_RULE_DEFAULT)
	->  new_defaultlabel(Rule_lab),
	    atomobj_struct(Rule_lab,TagCode)
	;
	    TagCode = FL_SKIP_TAG
	).


/***************************************************************************
  Compile the export directive
  The body can be a list of export terms, which are compiled individually.
***************************************************************************/
compile_export(BodyTerm,Code,Status) :-
	compile_export_predicate_list(BodyTerm,BodyTermCode,Status),
	list_struct(BodyTermCode,[],BodyTermCodeList),
	export_struct(BodyTermCodeList,Code).


/****************************************************************************
  compile_export_predicate_list(+List,-Code,-Status)
  To recursively compile a list of export predicates.
****************************************************************************/
compile_export_predicate_list([H|T],Code,Status) :-
	compile_export_predicate(H,HCode,S1),
	compile_export_predicate_list(T,TCode,S2),
	append(S1,S2,Status),
	Code = [HCode|TCode].
	
compile_export_predicate_list([],[],[]) :- !.


/****************************************************************************
  compile_export_predicate(+ExportTerm,-Code,-Status)
****************************************************************************/
compile_export_predicate(ExportTerm,Code,Status) :-
	(
	  is_flexport(ExportTerm,BodyTerm,ModuleList,IsUpdatable)
	;
	  is_flexport(ExportTerm,WS,BodyTerm,ModuleList,IsUpdatable)
	),
	is_flfact(BodyTerm,ParseBodyTerm),
	%% compile_fact expects the argument to be a list.
	%% Hence the ParseBodyTerm is enclosed in a list.
	%%if they are uninitialized, they will be taken care at run-time.
	compile_fact([ParseBodyTerm],_,ListBodyTermCode,StatusFact),
	compile_pathexp(ModuleList,ModuleListCode,_,_,_StatusModule),
	compile_pathexp(IsUpdatable,IsUpdatableCode,_,_,_StatusUpd),
	( var(WS) -> StatusWS = []
	;
	  compile_pathexp(WS,WSCode,_,_,StatusWS)
	),
	append(StatusFact,StatusWS,Status),
	%% It may be that the predicate itself is a comma separated list
	%% Convert ListBodyTermCode from a difference list to a normal list
	%% then wrap each element of the list in PREXPORT
	compile_export_list_convert(ListBodyTermCode,WSCode,ModuleListCode,IsUpdatableCode,Code).


/****************************************************************************
  compile_export_list_convert(+Args,-Code)
   Args is a difference list of the form : [H|_V] -_V.
   Ground _V to [] and convert the diff list to a list
   Then processes the list with compile_export_extract_facts
****************************************************************************/
compile_export_list_convert(ListBodyTermCode - T, WSCode, ModuleListCode,IsUpdatableCode,Code) :-
	T = [],
	%% ListBodyTermCode is a list of facts; process them
	compile_export_extract_facts(ListBodyTermCode,[],WSCode,ModuleListCode,IsUpdatableCode,Code).


/****************************************************************************
  compile_export_extract_facts(+Args,+InitialTerm,+WSCode,+ModuleListCode,+IsUpdatableCode,-Code)
  Encloses the individual predicates of the Args list in a PREXPORT struct. 
  Then the whole list is compiled as a list_struct.
****************************************************************************/
compile_export_extract_facts([H|T],InitTerm,WSCode,ModuleListCode,IsUpdatableCode,Code) :-
	is_prfact(H,HTermCode),
	construct_export_struct(HTermCode,WSCode,IsUpdatableCode,ModuleListCode,HCode),
	compile_export_extract_facts(T,[HCode|InitTerm],WSCode,ModuleListCode,IsUpdatableCode,Code).

compile_export_extract_facts([],InitTerm,_WSCode,_ModuleListCode,_IsUpdatableCode,Code) :-
	list_struct(InitTerm,[],Code).


/****************************************************************************
  construct_export_struct(+Term,+WSCode,+IsUpdatableCode,+ModuleListCode,-Code)
  Constructs an appropriate prexport struct.
****************************************************************************/
construct_export_struct(TermCode,WSCode,IsUpdatableCode,ModuleListCode,Code) :-
	thismodule_struct(ThisModule),
	atomobj_struct(FLEXPORT,FCode),
	( var(WSCode) ->
		prologterm_struct(FCode,4,[IsUpdatableCode,ThisModule,ModuleListCode,TermCode],Code)
	;
		prologterm_struct(FCode,5,[WSCode,IsUpdatableCode,ThisModule,ModuleListCode,TermCode],Code)
	).


/****************************************************************************
  compile_user_defined_function(+Function,+Body,+ReturnValue,-RuleDiffList,-FactDiffList,-UDFPredsDiffList,-Status)

  RuleDiffList is a difference list in the form of [...|T]-T. It is for
  the optimization of append.
  FactDiffList is the same for facts
  UDFPredsDiffList is the same for the list of tabled predicates
****************************************************************************/
compile_user_defined_function(Function,_Body,_ReturnValue,CodeList-CodeList,FactList-FactList,U-U,[Err]) :-
	is_flterm_or_flatom(Function,Funct,N,_),
	flora_get_flatomvar_name(Funct,Name),
	has_symbol(Name,N,_,_,_,FUNCTION_SYMBOL,_),
	\+ has_nowarn_symbol(Name,N,_WS,UDF_SYMBOL,_),
	!,
	approx_flindex(Function,Index),
	compiling_error(Index,ERROR_UDF_SYMBOL,Err).

compile_user_defined_function(Function,Body,ReturnValue,CodeList-ListTail,FactList-FactTail,UDFPreds-UDFPredsTail,Status) :-
	set_context(compiling_udf),
	( is_flterm_or_flatom(Function,Funct,N,Args),
	    flora_get_flatomvar_name(Funct,Name) ->
	    new_udf_predicate(Name,N,Args,NewArgs,NewPredicate,NewPredicateOrigArgs,NewPredName,NewPredArity,NewReturnValue),
	    ( \+ has_permaoption(user_defined_function(Name,N,_,_,_)) ->
		%% account for the caller argument
		NewPredArity1 is NewPredArity+1,
		UDFPreds = [(NewPredName,NewPredArity1),UDFPredsTail],
		set_permaoption(user_defined_function(Name,N,NewArgs,NewPredicate,NewReturnValue))
	    ;
		UDFPreds = UDFPredsTail
		%% ,HasUDF=1
	    ),
	    %% UDFs are always compiled as STATIC rules.
	    %% If a file is added to a module and has the same function,
	    %% the added UDFs use a different predicate, so no clash.
	    %% Perhaps we should warn in this case.
	    ( Body=NULL ->
		%% UDFs are always compiled as rules: add a dummy body
		RealBody = FLATOM(FL_TRUE,NO_INDEX),
		new_udfrule_body(RealBody,FunctIndex,
				 ReturnValue,NewReturnValue,NewBody),
		compile_rule([NewPredicateOrigArgs],NewBody,(NULL,NULL),
			     RuleList-ListTail,FactList-FactTail,S)
		/*
	        new_udffact(Name,N,Args,ReturnValue,Fact),
		compile_fact([Fact],RuleList-ListTail,FactList-FactTail,S)
		*/
	    ;
		approx_flindex(Funct,FunctIndex),
		new_udfrule_body(Body,FunctIndex,ReturnValue,NewReturnValue,NewBody),
		compile_rule([NewPredicateOrigArgs],NewBody,(NULL,NULL),RuleList-ListTail,FactList-FactTail,S)
	    ),
	    /*
	    %% neither the registry for UDF nor the associated :- prolog
	    %% declarations are used. Not clear how to utilize them
	    ( var(HasUDF) ->
		%% or has_permaoption(udf...) - i.e. already have function defn
		%% This puts function definition into the registry
		udfunction_struct(Name,N,NewArgs,NewPredicate,NewReturnValue,UDFCodeList),
		%% code for setting prolog declaration at run time.
		make_runtime_modular_prolog_declarations([prolog(NewPredName,NewPredArity)],PrologDeclarationCode),
		CodeList=[PrologDeclarationCode,UDFCodeList|RuleList]
	    ;
		CodeList=RuleList
	    ),
	    */
	    CodeList=RuleList,
	    ( no_errors_found(S) -> 
		is_flterm(Function,FuncSym,FuncSymArity,_),
		check_symbol_name_for_clashes(FuncSym,FuncSymArity,UDF_SYMBOL,
					      NONTRANSACTIONAL_SYMBOL,
					      SymbolStatus),
		check_udf_vars_for_safety(Function,Body,ReturnValue,VarStatus),
		append(SymbolStatus,VarStatus,Status)
	    ;
		/*
		clear_one_permaoption(user_defined_function(Name,N,Args,NewPredicate,NewReturnValue)),
		approx_flindex(Function,Index),
		compiling_error(Index,ERROR_UDF,Err),
		append([Err],S,Status)
		*/
			Status=S
	    )
	;
	    %%CodeList=ListTail,
	    approx_flindex(Function,Index),
	    compiling_error(Index,ERROR_UDF,Err),
	    Status = [Err]
	),
	clear_context(compiling_udf).

/*
new_udf_args([],[]):-!.
new_udf_args([_|Args],[Var|NewArgs]):-
	new_prvariable(NO_INDEX,VarObj),
	prvar_to_flvar_struct(VarObj,Var),
	new_udf_args(Args,NewArgs).
*/
new_udf_args(0,[]):-!.
new_udf_args(N,[Var|NewArgs]):-
	N>0,
	new_prvariable(NO_INDEX,VarObj),
	prvar_to_flvar_struct(VarObj,Var),
	N1 is N-1,
	new_udf_args(N1,NewArgs).

new_udf_predicate(Name,N,OrigArgs,Args,NewPredicateCode,NewPredicateOrigArgs,NPName,NPN,NewReturnValue):-
	new_udf_predicate_funct(Name,NPFunct,NPName),
	new_prvariable(NO_INDEX,NewReturnValueObj),
	prvar_to_flvar_struct(NewReturnValueObj,NewReturnValue),
	new_udf_args(N,Args),
	append(Args,[NewReturnValue],NPArgs),
	append(OrigArgs,[NewReturnValue],NPOrigArgs),
	NPN is N+1,
	flterm_struct(NPFunct,NPN,NPArgs,NewPredicateCode),
	flterm_struct(NPFunct,NPN,NPOrigArgs,NewPredicateOrigArgs),
	%%flora_define_prolog(NPName,NPN).
	flora_define_modular_prolog(NPName,NPN).

new_udfrule_body(Body,FunctIndex,ReturnValue,NewReturnValue,NewBody):-
	%% Form body for the new rule.
	%% To avoid singletin variable warning variable in the head
	%%    and variable in the body of new rule must have different indexes
	flvar_struct_change_index(NewReturnValue,FunctIndex,NewReturnValueInBody), 
	flatom_struct(FL_UNIVEQ,NO_INDEX,ExprFunct),
	flterm_struct(ExprFunct,2,[NewReturnValueInBody,ReturnValue],ExprCode),
	flconjunct_struct(Body,ExprCode,NewBody).

/*
new_udffact(FuncName,N,Args,ReturnValue,Fact):-
	new_udf_predicate_funct(FuncName,NPFunct,NPName),
	append(Args,[ReturnValue],NPArgs),
	NPN is N+1,
	flterm_struct(NPFunct,NPN,NPArgs,Fact),
	%%flora_define_prolog(NPName,NPN).
	flora_define_modular_prolog(NPName,NPN).
*/

new_udf_predicate_funct(Name,NewPredicateFunct,NewName):-
	/*
	flora_get_counter(FLORA_COMPILATION_COUNTER,Counter),
	flora_concat_atoms([NEWUDFPREDICATENAME,Name,Counter],NewName),
	*/
	flora_concat_atoms([NEWUDFPREDICATENAME,Name],NewName),
	flatom_struct(NewName,NO_INDEX,NewPredicateFunct).


/****************************************************************************
  compile_rule(+Head,+Body,+Annotation,-RuleDiffList,-FactDiffList,-Status)

  Annotation has the form (TagCode, MetaCode).
  TagCode is NULL or an atom-object.
  MetaCode is a NULL or a list of codes.

  RuleDiffList is a difference list in the form of [...|T]-T. It is for
  the optimization of append.
  FactDiffList = Facts-Facts: the empty diff list
****************************************************************************/
compile_rule(Head,Body,Annotation,RuleList-RuleTail,Facts-Facts,Status) :-
	compile_head(Head,HeadCode,H2BCodeHead,H2BCodeTail,HeadStatusPre),
	compile_conjunct2list(HeadCode,HeadCodeList),
	no_mixed_sensor_nonsensor_heads(HeadCodeList,Head,DelayStatus),
	merge_status([HeadStatusPre,DelayStatus],HeadStatus),
	( no_errors_found(HeadStatus) ->
	    compile_body(Body,BCode1,BodyStatus),
	    collect_prdatatypevars([HeadCodeList,BCode1],DTVarsCode),
	    /*
	    acyclicity_check_for_head(HeadCode,HeadAcyclicityCheckCode),
	    append(DTVarsCode, %% DTVarsCode - datatype code for variables
		   [HeadAcyclicityCheckCode,H2BCodeHead,BCode1,H2BCodeTail],
		   BCodeList),
	    */
	    append(DTVarsCode,[H2BCodeHead,BCode1,H2BCodeTail],BCodeList),
	    conjunct_code(BCodeList,BCode),
            get_dynrule_varlist(L),
            add_dynrule_attr_code(L,BCode,BodyCodeSansDelay),
	    %% should not add delay-checker to sensor rules
	    (all_defined_as_sensors(HeadCodeList) -> DelayCode = NULL
	    ; delay_literals_checking_code(Head,Body,DelayCode)
	    ),
	    (is_prvariable(DelayCode) -> BodyCode = BodyCodeSansDelay
	    ; conjunct_struct(BodyCodeSansDelay,DelayCode,BodyCode)
	    ),
	    ( no_errors_found(BodyStatus) ->
		%%get_directive(DirectCodeList),
		%%append(DirectCodeList,Tail,RuleList),
		compile_label(Annotation,TagCode,MetaCode,_),
		split_ruleheads_add_rulesig(HeadCodeList,
					    BodyCode,BodyCodeSansDelay,
					    (TagCode,MetaCode),
					    %%Tail-RuleTail, Status1),
					    RuleList-RuleTail, Status1),
		( no_errors_found(Status1), \+ has_context(compiling_udf)
		%% for UDFS checking variables is done separately
		->
		    check_head_vars_for_safety(Head,Body,VarStatus),
		    merge_status([HeadStatus,BodyStatus,Status1,VarStatus],Status)
		; Status = Status1
		)
	    ;
		Status=BodyStatus
	    )
	;
	    Status=HeadStatus
        ).

/****************************************************************************
  split_ruleheads_add_rulesig(+HeadCodeList,+BodyCode,+BodyCodeSansDelay,?LabelCode,-RuleDiffList,-Status)

  HeadCodeList is a list of atoms in the rule head. BodyCode is the formula
  in the rule body. This procedure splits the list of atoms in the rule
  head and generates a difference list.

  LabelCode has the form (TagCode, MetaCode). TagCode is NULL or an atom-object.
  MetaCode is a NULL or a list of codes.

  Note: delay checker is NOT added to the body in signatures
****************************************************************************/

split_ruleheads_add_rulesig([H],Body,BodySansDelay,(TagCodeIn,MetaCode),[InsSigCode,Code|T]-T,Status) :-
	!,
	%% Adjust TagCode for the case when compile_label created a
	%% default tag for rules due to FLDEFEASIBLE_RULE_DEFAULT being on.
	(is_prtransactionallit(H,Index), is_defaultlabel(TagCodeIn)
	-> TagCode = FL_SKIP_TAG
	;  TagCode = TagCodeIn
	),
	%% Only a single atom appears in the rule head.
	(is_prtransactionallit(H,Index), TagCode \= NULL, TagCode \= FL_SKIP_TAG
	-> compiling_error(Index,LABELED_TRANSACTION_NOT_ALLOWED,Err),
	    Status = [Err]
	; 
	    ( approx_prindex(H,HeadIdx) -> true ; HeadIdx=NO_INDEX),
	    construct_defeasible_condition(HeadIdx,TagCode,DefeatCond),
	    insert_rule_signature_onehead(H,BodySansDelay,(TagCode,MetaCode,DefeatCond),InsSigCode),
	    construct_defeasible_condition(HeadIdx,H,TagCode,DefeatCondWithHead),
	    add_defeasible_condition_to_body(DefeatCondWithHead,Body,NewBody),
	    rule_struct(H,NewBody,Code),
	    Status=[]
	).

split_ruleheads_add_rulesig(HeadList,Body,BodySansDelay,(TagCode,MetaCode),[InsSigCode,Code|CodeList]-ListTail,Status) :-
	%% Multiple atoms appear in the rule head.
	%% Generate a temp rule.
	collect_prvars(HeadList,HeadVars),
	length(HeadVars,N),
	new_predicate(Name),
	!,
	callermod_info_structure(CallerVarObj),
	append(HeadVars,[CallerVarObj],HeadVarsAndCaller),
	N1 is N+1,
	newpredicate_struct(Name,N1,HeadVarsAndCaller,Newpredicate),
        insert_rule_signature_multihead(HeadList,BodySansDelay,(TagCode,MetaCode),Newpredicate,InsSigCode),
	rule_struct(Newpredicate,Body,Code),
	%% Split the head over this temp rule.
	rule_difflist(HeadList,Newpredicate,TagCode,CodeList-ListTail,Status).


rule_difflist([],_B,_TagCode,CodeList-CodeList,[]) :- !.

rule_difflist([H|L],B,TagCodeIn,[HC|LC]-T,Status) :-
	%% Adjust TagCode for the case when compile_label created a
	%% default tag for rules due to FLDEFEASIBLE_RULE_DEFAULT being on.
	(is_prtransactionallit(H,Index), is_defaultlabel(TagCodeIn)
	-> TagCode = NULL
	;  TagCode = TagCodeIn
	),
	(is_prtransactionallit(H,Index), TagCode \= NULL, TagCode \= FL_SKIP_TAG
	-> compiling_error(Index,LABELED_TRANSACTION_NOT_ALLOWED,Err),
	    Status = [Err]
	; 
	    approx_prindex(H,HeadIdx),
	    construct_defeasible_condition(HeadIdx,H,TagCode,DefeatCond),
	    add_defeasible_condition_to_body(DefeatCond,B,NewB),
	    rule_struct(H,NewB,HC),
	    rule_difflist(L,B,TagCode,LC-T,Status)
	).

%% If TagCode is NULL, inserts a unique Id
insert_rule_signature_onehead(Head,Body,(TagCode,MetaCode,DefeatCond),Code) :-
	make_real_label_id(TagCode,RealTagCode),
        insert_rulesig_struct(Head,Body,(RealTagCode,MetaCode,DefeatCond),NULL,CCode),
        query_struct(CCode,Code).

%% If TagCode is NULL, inserts a unique Id
insert_rule_signature_multihead(HeadList,Body,(TagCode,MetaCode),Newpred,Code) :-
        list_struct(HeadList,[],HeadListCode),
	approx_prindex(HeadList,HeadIdx),
	construct_defeasible_condition(HeadIdx,TagCode,DefeatCond),
	make_real_label_id(TagCode,RealTagCode),
        insert_rulesig_struct(HeadListCode,Body,(RealTagCode,MetaCode,DefeatCond),Newpred,CCode),
        query_struct(CCode,Code).

%% If ProposedId == NULL, invent a new Id
make_real_label_id(ProposedId,RealId) :-
	(ProposedId == NULL -> new_oidobj(NO_INDEX,RealId)
	; ProposedId == FL_SKIP_TAG -> new_oidobj(NO_INDEX,RealId)
	; RealId = ProposedId
	).

%% add_defeasible_condition_to_body(+DefeatCondCode,+BodyCode,-NewBodyCode)
add_defeasible_condition_to_body(DefeatCondCode,BodyCode,NewBodyCode) :-
	(DefeatCondCode == NULL -> NewBodyCode = BodyCode
	; conjunct_struct(BodyCode,DefeatCondCode,NewBodyCode)
	).

%% DefeatCondCode = FL_UNDEFEATED@LibModule(TagCode,NewVar,ThisModule)
%% or NULL. This is encoded as
%% FL_UNDEFEATED(TagCode,NewVar,ThisModule)
%% NewVar is used because this type of defeasible condition is used in rule
%% signatures and dynamic rules; NewVar is bound to the head at run time.
construct_defeasible_condition(Index,TagCode,DelayedDefeatCondCode) :-
	(has_permaoption(FLDEFEASIBLE(LibModule)),
	    TagCode \= NULL, TagCode \= FL_SKIP_TAG
	->
	    %% DummyVarObj is unified with Head in flora_record_rule_signature
	    %% in flrcanon.P and flrdynrule.P
	    %% This is because the rule head can be a variable bound at runtime.
	    %% Eg, ?X=${p(?Y)}, insertrule{?X :- ...}.
	    %% So, we cannot determine the rule head statically here.
	    new_prvariable(NO_INDEX,DummyVarObj),
	    thismodule_struct(ThisModule),
	    %% create FL_UNDEFEATED(TagCode,NewVar,ThisModule)
	    %% this code makes FL_UNDEFEATED into Prolog predicate
	    %% It is faster, saves table space
	    modularized_atom_struct(FL_UNDEFEATED,LibModule,NO_INDEX,
				    UnDefeatFunCode),
	    callerargsterm_struct(ThisModule,CallerInfo),
	    prologterm_struct(UnDefeatFunCode,4,
			      [TagCode,DummyVarObj,ThisModule,CallerInfo],
			      DefeatCondCode),
	    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	    %% wrap up for delaying the defeasible condition
	    list_struct([],[],EmptyListObj),
	    delay_struct(Index,FL_UNDEFEATED,
			 [DefeatCondCode,EmptyListObj,EmptyListObj,DummyVarObj],
			 DelayedDefeatCondCode)
	;
	    DelayedDefeatCondCode = NULL
	).

%% DefeatCondCode = FL_UNDEFEATED@LibModule(TagCode,HeadCode,ThisModule)
%% or NULL. This is encoded as
%% TABLED_HILOG_WRAPPER(FL_UNDEFEATED,TagCode,HeadCode,ThisModule)
%% The difference is that instead of NewVar we insert head code at compile time.
construct_defeasible_condition(Index,HeadCode,TagCode,DelayedDefeatCondCode) :-
	(has_permaoption(FLDEFEASIBLE(LibModule)),
	    TagCode \= NULL, TagCode \= FL_SKIP_TAG
	->
	    %% create FL_UNDEFEATED(TagCode,NewVar,ThisModule)
	    thismodule_struct(ThisModule),
	    %% create FL_UNDEFEATED(TagCode,NewVar,ThisModule)
	    %% this code makes FL_UNDEFEATED into modularized Prolog predicate
	    %% It is faster, saves table space
	    modularized_atom_struct(FL_UNDEFEATED,LibModule,NO_INDEX,
				    UnDefeatFunCode),
	    callerargsterm_struct(ThisModule,CallerInfo),
	    prologterm_struct(UnDefeatFunCode,4,
			      [TagCode,HeadCode,ThisModule,CallerInfo],
			      DefeatCondCode),
	    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	    %% wrap up for delaying the defeasible condition
	    collect_prvars(HeadCode,HeadCodeVars1),
	    remove_caller_vars(HeadCodeVars1,HeadCodeVars),
	    vars_to_var_names(HeadCodeVars,HeadCodeVarNames),
	    list_struct(HeadCodeVars,[],HeadCodeVarsStruct),
	    list_struct(HeadCodeVarNames,[],HeadCodeVarNamesStruct),
	    delay_struct(Index,FL_UNDEFEATED,
			 [DefeatCondCode,HeadCodeVarsStruct,HeadCodeVarNamesStruct,NULL],
			 DelayedDefeatCondCode)
	;
	    DelayedDefeatCondCode = NULL
	).


/****************************************************************************
  compile_conjunct2list(+ConjunctCode,-CodeList)
  compile_conjunct2list(+ConjunctCode,-CodeList,-ListTail)

  ConjunctCode may contain NULL.
****************************************************************************/
compile_conjunct2list(ConjunctCode,CodeList) :-
	compile_conjunct2list(ConjunctCode,CodeList,[]).

compile_conjunct2list(NULL,CodeList,CodeList) :- !.

compile_conjunct2list(ConjunctCode,CodeList,ListTail) :-
	conjunct_struct(C1,C2,ConjunctCode),
	!,
	compile_conjunct2list(C1,CodeList,T1),
	compile_conjunct2list(C2,T1,ListTail).

compile_conjunct2list(Code,[Code|ListTail],ListTail) :- !.


/****************************************************************************
  compile_head(+ParserTermList,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
  H2BCodeHead - code passed from head to body, which is supposed to be
                prepended to the code of the body
  H2BCodeTail - code passed from head to body, which is supposed to be
                appended to the code of the body
****************************************************************************/
compile_head([],NULL,NULL,NULL,[]) :- !.

compile_head([ParserTerm|ParserTermList],Code,H2BCodeHead,H2BCodeTail,Status) :-
	compile_head_literal(ParserTerm,PCode,PH2BCodeHead,PH2BCodeTail,S),
	( no_errors_found(S) ->
	    compile_head(ParserTermList,PLCode,PLH2BCodeHead,PLH2BCodeTail,S2),
	    ( no_errors_found(S2) ->
		    conjunct_struct(PCode,PLCode,Code),
		    conjunct_code([PH2BCodeHead,PLH2BCodeHead],H2BCodeHead),
		    conjunct_code([PH2BCodeTail,PLH2BCodeTail],H2BCodeTail),
		    append(S,S2,Status)
	     ;
		Status=S2
	    )
	;
	  Status=S
        ).


/****************************************************************************
  compile_head_literal(+ParserTerm,-Code,-H2BCodeHead,-H2BCodeTail,-Status)

  Code is conjunction of atoms, which should be split into a list later.
  H2BCodeHead - code passed from head to body, which is supposed to be
                prepended to the code of the body
  H2BCodeTail - code passed from head to body, which is supposed to be
                appended to the code of the body
****************************************************************************/
compile_head_literal(ParserTerm,Code,H2BCodeHead,H2BCodeTail,Status) :- 
        set_context(compiling_headliteral),
	( is_flvariable(ParserTerm,VName,VIndex) ->
            compile_flvar(VName,VIndex,Code),
	    H2BCodeHead=NULL,
	    H2BCodeTail=NULL,
            Status=[]

        ; is_fltransactionalterm(ParserTerm,Funct,N,Args) ->
            compile_head_fltransactionaltermlit(Funct,N,Args,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_head_fltermlit(Funct,N,Args,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flbirelate(ParserTerm,OT1,RelType,OT2) ->
	    compile_head_flbirelate(OT1,RelType,OT2,_Obj,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flobjspec(ParserTerm,ObjTerm,Spec) ->
	    compile_head_flobjspec(ObjTerm,Spec,_Obj,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flobjeql(ParserTerm,Obj1,Obj2) ->
	    compile_head_flobjeql(Obj1,Obj2,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flneg(ParserTerm,PositiveLit,Idx) ->
	    compile_head_flneg(PositiveLit,Idx,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flworkspace(ParserTerm,P,WS) ->
	    compile_head_wsliteral(P,WS,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flfloralib(ParserTerm,P,Module) ->
	    compile_head_floraliblit(P,Module,Code,H2BCodeHead,H2BCodeTail,Status)
	; is_fldatatype(ParserTerm,_Sort,_Lit,_Index) ->
	    datatypeobj_struct(ParserTerm,Code1,Status),
	    atomlit_struct(HEADLITERAL,Code1,Code),
	    H2BCodeHead=NULL,
	    H2BCodeTail=NULL

	; is_fltransactionaldatatype(ParserTerm,_Sort,_Lit,_Index) ->
	    datatypeobj_struct(ParserTerm,Code1,Status),
	    transactionalatomlit_struct(HEADLITERAL,Code1,Code),
	    H2BCodeHead=NULL,
	    H2BCodeTail=NULL

	; is_flatom(ParserTerm,_) ->
	    %% atom (0-ary predicate)
	    check_symbol_name_for_clashes(ParserTerm,0,
					  FUNCTION_SYMBOL,
					  NONTRANSACTIONAL_SYMBOL,Status),
	    atomlit_struct(HEADLITERAL,ParserTerm,Code),
	    H2BCodeHead=NULL,
	    H2BCodeTail=NULL
	    %%Status=[]

	
	; is_flbuiltin_identifier(ParserTerm,_) ->
	    check_symbol_name_for_clashes(ParserTerm,0,
					  FUNCTION_SYMBOL,
					  NONTRANSACTIONAL_SYMBOL,Status),
	    atomlit_struct(HEADLITERAL,ParserTerm,Code) ->
	    H2BCodeHead=NULL,
	    H2BCodeTail=NULL
	    %%Status=[]

        ;
	    check_symbol_name_for_clashes(ParserTerm,0,
					  FUNCTION_SYMBOL,
					  TRANSACTIONAL_SYMBOL,Status),
	    transactionalatomlit_struct(HEADLITERAL,ParserTerm,Code),
	    H2BCodeHead=NULL,
	    H2BCodeTail=NULL
            %%Status=[]
	),
        clear_context(compiling_headliteral).


/****************************************************************************
  compile_body(+ParserTerm,-Code,-Status)
****************************************************************************/
compile_body(ParserTerm,Code,Status) :-
	is_flconjunct(ParserTerm,L,R),
	!,
	compile_body(L,LCode,S),
	( no_errors_found(S) ->
	    compile_body(R,RCode,S2),
	    ( no_errors_found(S2) ->
		conjunct_struct(LCode,RCode,Code),
		merge_status([S,S2],Status)
	    ; Status=S2)
	;
	  Status=S
        ).

compile_body(ParserTerm,Code,Status) :-
	is_fldisjunct(ParserTerm,L,R),
	!,
	compile_body(L,LCode,S),
	( no_errors_found(S) ->
	    compile_body(R,RCode,S2),
	    ( no_errors_found(S2) ->
		disjunct_struct(LCode,RCode,Code),
		merge_status([S,S2],Status)
	    ; Status=S2)
	;
	  Status=S
        ).


compile_body(ParserTerm,Code,Status) :-
	is_flneg(ParserTerm,G,Idx),
	!,
	compile_body(G,GCode,Status1),
	( no_errors_found(Status1) ->
	   neg_struct(GCode,Idx,Code,Status2),
	   merge_status([Status1,Status2],Status)
	; Status = Status1
	).

compile_body(ParserTerm,Code,Status) :-
	is_default_negation(ParserTerm,G,NAFType),
	!,
	set_context(compiling_default_negation),
	compile_body(G,GCode,Status),
	( no_errors_found(Status) ->
	    (is_prquantifier(GCode,_Quant,FormCode,_FreeVarObjs)
	    -> true
	    ;  FormCode = GCode
	    ),
	    (NAFType == (not) -> flora_naf_struct(FormCode,Code)
	    ; prolog_naf_struct(FormCode,Code)
	    )
	; true
	),
	clear_context(compiling_default_negation).

compile_body(ParserTerm,Code,Status) :-
	is_fllogicquantifier(ParserTerm,FL_EXISTS,QuantVarNames,Formula,Idx),
	has_context(compiling_default_negation),
	!,
	%% no quantified don't care vars (?,?_) 
	(memberchk(FL_UNDERSCORE,QuantVarNames) ->
	    compiling_error(Idx,NO_QUANTIFIED_ANONVARS,Err1),
	    S1 = [Err1]
	; S1 = []
	),

	compile_body(Formula,FormCode,S2),
	%% We use prvars so that newly introduced vars will be accounted for
	collect_prvars(FormCode,FormVarList),
	vars_to_var_names(FormVarList,FormVarNames),
	%% quantified vars must occur in Formula
	(subset(QuantVarNames,FormVarNames) -> S3 = []
	; compiling_error(Idx,QUANT_VARS_NOT_SUBSET,Err3),
	    S3 = [Err3]
	),
	subtract_vars(FormVarList,QuantVarNames,FreeVarObjs_aux),
	remove_prdontcare_vars(FreeVarObjs_aux,FreeVarObjs_aux2),
	remove_caller_vars(FreeVarObjs_aux2,FreeVarObjs),

	rename_prvariables(QuantVarNames,FormCode,
			   RenamedFormCode,_RenamedQuantVars),
	merge_status([S1,S2,S3],Status),
	( no_errors_found(Status) ->
	    %% Create the code for compiled quantification.
	    quantifier_struct(FL_EXISTS,RenamedFormCode,FreeVarObjs,Code)
	;
	    true
	).


compile_body(ParserTerm,Code,Status) :-
	is_flhypothetical(ParserTerm,Op,Goal,Index),
	!,
	compile_body(Goal,GCode,Status),
	( no_errors_found(Status) ->
		hypothetical_struct(Op,GCode,Index,Code)
	;
	    true
	).


compile_body(ParserTerm,Code,Status) :-
        compile_body_literal(ParserTerm,0,LitCode,BodyHeadList,Status),
	append(BodyHeadList,[LitCode],CodeList), 
	conjunct_code(CodeList,Code).


/****************************************************************************
  compile_body_literal(+ParserTerm,+Nesting,-Code,?BodyHeadList,-Status)

 +Nesting - needed for nested user defined functions
 ?BodyHeadList - code to add at the beginning of the body
                 (mostly for user defined fnctions),
		 it is output argument, but if it is initialized to empty ([])
		 ignores user defined functions
****************************************************************************/
compile_body_literal(ParserTerm,Code,Status) :-
	compile_body_literal(ParserTerm,0,Code,[],Status).

compile_body_literal(ParserTerm,Nesting,Code,BodyHeadList,Status) :-
	( is_flvariable(ParserTerm,VName,VIndex) ->
	    BodyHeadList = [],
            compile_flvar(VName,VIndex,V),
            ( (has_context(compile_with_var_module)
	      ; has_context(goal_reification)
	      ; has_context(compile_delete))
	    ->
                SpecCode = V
            ;
                %% Not for promoting term to predicate, but to bind caller info.
                %% Needed only for calls when a variable occurs by itself in
		%% the rule body:  ... :- ..., X, ,,,
                thismodule_struct(ThisModule),
                callerargsterm_struct(ThisModule,CallerInfo),  %% doesn't matter
                atomobj_struct(FL_INVALIDMODULE,Module),
                florasyslib_struct(VIndex,FLLIBMODLIT,3,[V,Module,CallerInfo],SpecCode)
            ),
            OidCode=NULL,
            Status=[]

	/*
	%% This is not used for now. Transactional variables by
	%% themselves are hard to translate into queries.
	; is_fltransactionalvariable(ParserTerm,VName,VIndex) ->
	    has_context(compile_with_var_module),
	    compile_fltransactionalvar(VName,VIndex,SpecCode),
	    OidCode=NULL,
	    Status=[]
	*/

        ; is_fldelayquant(ParserTerm,Quant,Condition,Goal,Idx) ->
		compile_fldelayquant(Quant,Condition,Goal,Idx,SpecCode,BodyHeadList,Status)

        ; is_fltransactionalterm(ParserTerm,Funct,N,Args) ->
	    compile_fltransactionaltermlit(Funct,N,Args,Nesting,OidCode,SpecCode,BodyHeadList,Status)

        ; is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_fltermlit(Funct,N,Args,Nesting,OidCode,SpecCode,BodyHeadList,Status)

	; is_flbirelate(ParserTerm,ObjTerm1,RelType,ObjTerm2) ->
	    BodyHeadList = [],
	    compile_flbirelate(ObjTerm1,RelType,ObjTerm2,_Obj,OidCode,SpecCode,Status)

	; is_flobjspec(ParserTerm,ObjTerm,Spec) ->
	    compile_flobjspec(ObjTerm,Spec,_Object,OidCode,SpecCode,BodyHeadList,Status)

	; is_flload(ParserTerm,LoadList) ->
	    BodyHeadList = [],
	    compile_flload(LoadList,SpecCode,Status),
	    OidCode=NULL

	; is_flconstraint(ParserTerm,ConstrBody) ->
	    BodyHeadList = [],
	    compile_body(ConstrBody,ConstrBodyCode,Status),
	    constraint_struct(ConstrBodyCode,SpecCode),
	    OidCode=NULL

	; is_flworkspace(ParserTerm,P,WS) ->
	    compile_wsliteral(P,WS,Nesting,OidCode,SpecCode,BodyHeadList,Status)

	%% prolog call withOUT prolog module
	; is_flplib(ParserTerm,P) ->
	    compile_prologliblit(P,Nesting,OidCode,SpecCode,BodyHeadList,Status)

	%% prolog call WITH prolog module
	; is_flplib(ParserTerm,P,Module) ->
	    compile_prologliblit(P,Module,Nesting,OidCode,SpecCode,BodyHeadList,Status)

	%% prologALL call withOUT prolog module
	; is_flpliball(ParserTerm,P) ->
	    compile_prologallliblit(P,Nesting,OidCode,SpecCode,BodyHeadList,Status)

	%% prologALL call WITH prolog module
	; is_flpliball(ParserTerm,P,Module) ->
	    compile_prologallliblit(P,Module,Nesting,OidCode,SpecCode,BodyHeadList,Status)

	; is_flfloralib(ParserTerm,P,Module) ->
	    compile_floraliblit(P,Module,Nesting,OidCode,SpecCode,BodyHeadList,Status)

	; is_flinsert(ParserTerm,Op,List,Cond) ->
	    BodyHeadList = [],
	    compile_flinsert(Op,List,Cond,SpecCode,Status),
	    OidCode=NULL

	; is_flinsert(ParserTerm,Op,List) ->
	    BodyHeadList = [],
	    compile_flinsert(Op,List,SpecCode,Status),
	    OidCode=NULL

	; is_fldelete(ParserTerm,Op,List,Cond) ->
	    BodyHeadList = [],
	    compile_fldelete(Op,List,Cond,SpecCode,Status),
	    OidCode=NULL

	; is_fldelete(ParserTerm,Op,List) ->
	    BodyHeadList = [],
	    compile_fldelete(Op,List,SpecCode,Status),
	    OidCode=NULL

	; is_flneg(ParserTerm,_,_) ->
	    BodyHeadList = [],
	    compile_body(ParserTerm,Code,Status),
	    OidCode=NULL

	; is_fldelayedliteral(ParserTerm,Op,Args) ->
	    compile_delayed_literal(Op,Args,Nesting,SpecCode,OidCode,BodyHeadList,Status)
	; is_fldelayedliteral(ParserTerm,Op,Args,Mod) ->
	    compile_delayed_literal(Op,Args,Mod,Nesting,SpecCode,OidCode,BodyHeadList,Status)

	%% Rule: can occur only inside reify_op as a top-level literal
	; ParserTerm = [ReifiedRule|_],
	    BodyHeadList = [],
	    is_fldynrule(ReifiedRule,_H,_B,_Lab) ->
	    compile_reifyop(ParserTerm,SpecCode,OidCode,Status)

	%% Rule: can occur inside reify_op
	; ParserTerm = [ReifiedRule|_],
	    BodyHeadList = [],
	    is_flruleworkspace(ReifiedRule,_RealRule,_WS) ->
	    compile_reifyop(ParserTerm,SpecCode,OidCode,Status)

	; is_fltablerefresh(ParserTerm,List) ->
	    BodyHeadList = [],
	    compile_flrefresh(List,SpecCode,Status),
	    OidCode=NULL

	; is_fltruthvalue(ParserTerm,Formula,Atom) ->
	    BodyHeadList = [],
	    compile_truthvalue(Formula,Atom,SpecCode,Status),
	    OidCode=NULL

	; is_fllabelprimitive(ParserTerm,Label,HeadList) ->
	    BodyHeadList = [],
	    compile_labelprimitive(Label,HeadList,SpecCode,Status),
	    OidCode=NULL

	; is_flprefixprimitive(ParserTerm,Prefix,Expansion,Module) ->
	    BodyHeadList = [],
	    compile_prefixprimitive(Prefix,Expansion,Module,SpecCode,Status),
	    OidCode=NULL

	; is_flcatch(ParserTerm,Goal,Error,Handler) ->
	    BodyHeadList = [],
	    compile_flcatch(Goal,Error,Handler,SpecCode,Status),
	    OidCode=NULL

	; is_flthrow(ParserTerm,Error) ->
	    BodyHeadList = [],
	    compile_flthrow(Error,SpecCode,Status),
	    OidCode=NULL

	; is_flp2h(ParserTerm,Prolog,Hilog) ->
	    BodyHeadList = [],
	    compile_flp2h(Prolog,Hilog,SpecCode,Status),
	    OidCode=NULL

	; is_flnewoidop(ParserTerm,VarTerm) ->
	    BodyHeadList = [],
	    is_flvariable(VarTerm,Name,Index),
	    compile_flvar(Name,Index,VarCode),
	    newoidop_struct(VarCode,SpecCode),
	    Status = [],
	    OidCode=NULL

	; is_flnewmodule(ParserTerm,Op,Module) ->
	    BodyHeadList = [],
	    is_flatom(Op,_OpAtom,Index),
	    compile_flatomvar(Module,ModCode),
	    thismodule_struct(ThisModuleName),
	    florasyslib_struct(Index,FLLIBNEWMODULE,2,[ThisModuleName,ModCode],SpecCode),
	    Status=[],
	    OidCode=NULL

	; is_flerasemodule(ParserTerm,Op,Module) ->
	    BodyHeadList = [],
	    is_flatom(Op,_OpAtom,Index),
	    compile_flatomvar(Module,ModCode),
	    thismodule_struct(ThisModuleName),
	    florasyslib_struct(Index,FLLIBERASEMODULE,2,[ThisModuleName,ModCode],SpecCode),
	    Status=[],
	    OidCode=NULL

	; is_flcallermodule(ParserTerm,Op,Module) ->
	    BodyHeadList = [],
	    is_flatom(Op,_OpAtom,Index),
	    compile_flatomvar(Module,ModCode),
	    caller_binding_code(ModCode,SpecCode),
	    Status=[],
	    OidCode=NULL

	; is_flupdaterule(ParserTerm,Op,List) ->
	    BodyHeadList = [],
	    compile_flupdaterule(Op,List,SpecCode,Status),
	    OidCode=NULL
		
        ; is_flclause(ParserTerm,Head,Body) ->
	    BodyHeadList = [],
            compile_flclause(NULL,NULL,Head,Body,SpecCode,Status),
            OidCode=NULL

        ; is_flclause(ParserTerm,Mode,Head,Body) ->
	    BodyHeadList = [],
            compile_flclause(NULL,Mode,Head,Body,SpecCode,Status),
            OidCode=NULL

        ; is_fllabeledclause(ParserTerm,Label,Mode,Head,Body) ->
	    BodyHeadList = [],
            compile_flclause(Label,Mode,Head,Body,SpecCode,Status),
            OidCode=NULL

	; is_fllabeledclause(ParserTerm,Label,Head,Body) ->
	    BodyHeadList = [],
            compile_flclause(Label,NULL,Head,Body,SpecCode,Status),
            OidCode=NULL

	; is_flifthenelse(ParserTerm,Cond,Then,Else) ->
	    BodyHeadList = [],
	    compile_flifthenelse(Cond,Then,Else,SpecCode,Status),
	    OidCode=NULL

	; is_flifthen(ParserTerm,Cond,Then) ->
	    BodyHeadList = [],
	    compile_flifthen(Cond,Then,SpecCode,Status),
	    OidCode=NULL

	; is_fluniveqform(ParserTerm,Left,Right) ->
	    BodyHeadList = [],
	    compile_fluniveqform(Left,Right,SpecCode,Status),
	    OidCode=NULL

	; is_flmetauniv(ParserTerm,Left,Right) ->
	    BodyHeadList = [],
	    compile_flmetauniv(Left,Right,OidCode,SpecCode,Status)

	; is_flcontrolconstruct(ParserTerm,Wrapper,Cond,Action) ->
	    BodyHeadList = [],
	    compile_flcontrolconstruct(Cond,Action,Wrapper,SpecCode,Status),
	    OidCode = NULL
	
	; is_flcut(ParserTerm,I) ->
	    BodyHeadList = [],
	    cut_struct(I,SpecCode),
	    OidCode=NULL,
	    Status=[]

	; is_flatom(ParserTerm,_A) ->
	    check_symbol_name_for_clashes(ParserTerm,0,FUNCTION_SYMBOL,
					  NONTRANSACTIONAL_SYMBOL,Status),
	    BodyHeadList = [],
	    atomlit_struct(BODYLITERAL,ParserTerm,SpecCode) ->
	    OidCode=NULL

	; is_flbuiltin_identifier(ParserTerm,_A) ->
	    check_symbol_name_for_clashes(ParserTerm,0,FUNCTION_SYMBOL,
					  NONTRANSACTIONAL_SYMBOL,Status),
	    BodyHeadList = [],
	    atomlit_struct(BODYLITERAL,ParserTerm,SpecCode) ->
	    OidCode=NULL

	; is_fltransactionalatom(ParserTerm,_A) ->
	    check_symbol_name_for_clashes(ParserTerm,0,FUNCTION_SYMBOL,
					  TRANSACTIONAL_SYMBOL,Status),
	    BodyHeadList = [],
	    transactionalatomlit_struct(BODYLITERAL,ParserTerm,SpecCode) ->
	    OidCode=NULL

	; is_fldatatype(ParserTerm,_Sort,_Lit,_Index) ->
	    BodyHeadList = [],
	    datatypeobj_struct(ParserTerm,Code1,Status),
	    atomlit_struct(BODYLITERAL,Code1,Code),
	    OidCode=NULL

	; is_fltransactionaldatatype(ParserTerm,_Sort,_Lit,_Index) ->
	    BodyHeadList = [],
	    datatypeobj_struct(ParserTerm,Code1,Status),
	    transactionalatomlit_struct(BODYLITERAL,Code1,Code),
	    OidCode=NULL

	; is_flobjeql(ParserTerm,O1,O2) ->
	    BodyHeadList = [],
	    compile_flobjeql(O1,O2,OidCode,SpecCode,Status)

	; is_fldirective(ParserTerm,DirectList,_Idx) ->
	    BodyHeadList = [],
	    compile_exec_directive(DirectList,NULL,SpecCode,Status),
	    OidCode=NULL
	),
	conjunct_code([OidCode,SpecCode],Code).


/****************************************************************************
  compile_flifthenelse(+Cond,+Then,+Else,-Code,-Status)
****************************************************************************/
compile_flifthenelse(Cond,Then,Else,Code,Status) :-
	compile_body(Cond,CondCode,S1),
	compile_body(Then,ThenCode,S2),
	merge_status([S1,S2],CondThenStatus),
	( no_errors_found(CondThenStatus) ->
	    compile_body(Else,ElseCode,Status),
	    ( no_errors_found(Status) ->
	       ifthenelse_struct(CondCode,ThenCode,ElseCode,Code)
	    ;
		true
	    )
	;
	    Status=CondThenStatus
	).


/****************************************************************************
  compile_flifthen(+Cond,+Then,-Code,-Status)
****************************************************************************/
compile_flifthen(Cond,Then,Code,Status) :-
	compile_body(Cond,CondCode,S1),
	( no_errors_found(S1) ->
	    compile_body(Then,ThenCode,Status),
	    ( no_errors_found(Status) ->
	       ifthen_struct(CondCode,ThenCode,Code)
	    ;
		true
	    )
	;
	  Status=S1
	).

/****************************************************************************
  compile_fluniveqform(+Left,+Right,-Code,-Status)

  Compiling ~
  This produces only spec code -- no oid code, because each argument
  is treated as Meta, so no oid is passed utside of this term
****************************************************************************/
compile_fluniveqform(Left,Right,Code,Status) :-
        set_context(goal_reification),
	compile_body(Left,LeftCode,S1),
	( no_errors_found(S1) ->
	    compile_body(Right,RightCode,Status),
	    ( no_errors_found(Status) ->
		univeqform_struct(LeftCode,RightCode,Code); true)
	;
	  Status=S1
	),
        clear_context(goal_reification).


/****************************************************************************
  compile_flmetauniv(+Left,+Right,-OidCode,-Code,-Status)
  Compiling =..
****************************************************************************/
compile_flmetauniv(Left,Right,OidCode,Code,Status) :-
	%% Use pathexp translation instead of body translation, because we
	%% don't want module name to be tacked on unless requested
	%% LeftCode becomes bound to the OID code of Left
	%% ObjCode is later conjuncted with the result
	compile_pathexp(Left,LeftCode,OidCodeLeft,ObjCode,S1),
	( no_errors_found(S1) ->
	   compile_pathexp(Right,RightCode,OidCodeRight,RightObjCode,Status),
	    ( no_errors_found(Status) ->
	       metauniv_struct(LeftCode,RightCode,UnivCode),
		conjunct_code([UnivCode,ObjCode,RightObjCode],Code),
		conjunct_code([OidCodeLeft,OidCodeRight],OidCode)
	    ; true
	    )
	;
	    Status=S1
	).


/****************************************************************************
  compile_flcontrolconstruct(+Cond,+Action,+Wrapper,-Code,-Status)

  Handle control stmts while-do,do-until,while-loop,loop-until,unless-do
****************************************************************************/
compile_flcontrolconstruct(Cond,Action,Wrapper,Code,Status) :-
	compile_body(Cond,CondCode,S1),
	( no_errors_found(S1) ->
	    compile_body(Action,ActionCode,Status),
	    ( no_errors_found(Status) -> 
	       controlconstruct_struct(CondCode,ActionCode,Wrapper,Code)
	    ; true
	    )
	; Status = S1
	).


/****************************************************************************
  compile_pathexp(+ParserTerm,+Nesting,-Object,-OidCode,-Code,?BodyHeadList,-Status)

  Handles pathexps that are atoms, numbers, special tokens, like _#, _#123, _@,
  vars, strings

  Nesting - needed for nested user defined functions
  OidCode - conjunction of the code for computing the arguments of
            the pathexp such as a.b[c.d->e.f]
	    Eg, AND(a[b->?X],c[d-?Y],e[f->?Z])
  Code    - code for the actual Boolean expression that corresponds to
            a.b[c.d->e.f], ie, ?X[?Y->?Z]
 ?BodyHeadList - code to add at the beginning of the body
                 (mostly for user defined fnctions),
		 it is output argument, but if it is initialized to empty ([])
		 ignores user defined functions
****************************************************************************/
compile_pathexp(ParserTerm,Object,OidCode,Code,Status) :-
	compile_pathexp(ParserTerm,0,Object,OidCode,Code,[],Status).

compile_pathexp(ParserTerm,Object,OidCode,Code,BodyHeadList,Status) :-
	compile_pathexp(ParserTerm,0,Object,OidCode,Code,BodyHeadList,Status).

%% ParserTerm is a primitive object -- no oid code and no spec code results
compile_pathexp(ParserTerm,Nesting,Object,NULL,NULL,BodyHeadList,Status) :-
	set_context(compiling_body_pathexp),
	( is_flatom(ParserTerm,_A) ->
	    compile_flatomobj(ParserTerm,Nesting,Object,BodyHeadList,Status)

	; is_fltransactionalatom(ParserTerm,_A) ->
	    check_symbol_name_for_clashes(ParserTerm,0,FUNCTION_SYMBOL,TRANSACTIONAL_SYMBOL,Status),
	    BodyHeadList=[],
	    transactionalatomobj_struct(ParserTerm,Object)

	; is_fltoken(ParserTerm,FL_THISMODULE,_Index) ->
	    check_symbol_name_for_clashes(ParserTerm,0,FUNCTION_SYMBOL,
					  NONTRANSACTIONAL_SYMBOL,Status),
	    BodyHeadList=[],
	    thismodule_struct(Object)

	%% Anonymous OIDs can appear in the "body": they can appear
	%% in reified formulas, which are compiled as body literals
	; is_fltoken(ParserTerm,FL_NEWOID,Index) ->
	    /*
	    %% no point checking skolems
	    check_symbol_name_for_clashes(ParserTerm,0,FUNCTION_SYMBOL,
					  NONTRANSACTIONAL_SYMBOL,Status),
	    */
	    BodyHeadList=[],
	    new_oidobj(Index,Object)

	%% A numbered OID, which appears in a reified formula in rule body
	; is_fltoken(ParserTerm,FL_NEWOID,Num,Index) ->
	    /*
	    %% no point checking skolems
	    check_symbol_name_for_clashes(ParserTerm,0,FUNCTION_SYMBOL,
					  NONTRANSACTIONAL_SYMBOL,Status),
	    */
	    BodyHeadList=[],
	    flora_get_counter(RULE_NUM, Rule_num), 
	    new_oidobj(Rule_num,Num,Index,Object)

	; (is_flnumber(ParserTerm,_N) ; number(ParserTerm)) ->
	    BodyHeadList=[],
	    numobj_struct(ParserTerm,Object),
	    Status=[]

	; is_flvariable(ParserTerm,Name,Index) ->
	    flora_get_flatomvar_name(ParserTerm,VName),
	    ( user_defined_function_var_substitute(Nesting,VName,_,Sub,_SIndex) ->
		SNesting is Nesting + 1, 
		compile_pathexp(Sub,SNesting,Object,_SOidCode,_SCode,BodyHeadList,Status)
	    ;
	    	BodyHeadList=[],
	    	compile_flvar(Name,Index,Object),
		Status = []
	    )

	; is_fltransactionalvariable(ParserTerm,Name,Index) ->
	    BodyHeadList=[],
	    compile_fltransactionalvar_without_trans(Name,Index,Object),
	    Status=[]

	; is_flstring(ParserTerm,_S) ->
	    BodyHeadList=[],
	    strobj_struct(ParserTerm,Object),
	    Status=[]

	; is_flbuiltin_identifier(ParserTerm,_Ident) ->
	    check_symbol_name_for_clashes(ParserTerm,0,FUNCTION_SYMBOL,
					  NONTRANSACTIONAL_SYMBOL,Status),
	    BodyHeadList=[],
	    builtin_identifier_struct(ParserTerm,Object)

	; is_fldatatype(ParserTerm,_Sort,_Lit,_Index) ->
	    BodyHeadList=[],
	    datatypeobj_struct(ParserTerm,Object,Status)

	; is_fltransactionalstring(ParserTerm,_S) ->
	    BodyHeadList=[],
	    transactionalstrobj_struct(ParserTerm,Object),
	    Status=[]
	),
	clear_context(compiling_body_pathexp),
	!.

compile_pathexp(ParserTerm,Nesting,Object,OidCode,Code,BodyHeadList,Status) :-
	set_context(compiling_body_pathexp),
        ( is_fldelayquant(ParserTerm,Quant,Condition,Goal,Idx) ->
		compile_fldelayquant(Quant,Condition,Goal,Idx,OidCode,BodyHeadList,Status)

	; is_fltransactionalterm(ParserTerm,Funct,N,Args) ->
	    compile_fltermobj(Funct,N,Args,Nesting,Object,OidCode,Code,BodyHeadList,Status)

	; is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_fltermobj(Funct,N,Args,Nesting,Object,OidCode,Code,BodyHeadList,Status)

	; is_flarith(ParserTerm,StrippdParseTerm) ->
	  set_context(compiling_arithmetics),
	  compile_pathexp(StrippdParseTerm,Object,OidCode,Code,Status),
	  clear_context(compiling_arithmetics)

	; is_flbirelate(ParserTerm,ObjTerm1,RelType,ObjTerm2) ->
	    BodyHeadList=[],
	    compile_flbirelate(ObjTerm1,RelType,ObjTerm2,Object,OidCode,Code,Status)

	; is_flobjspec(ParserTerm,ObjTerm,Spec) ->
	    compile_flobjspec(ObjTerm,Spec,Object,OidCode,Code,BodyHeadList,Status)

	; is_flobjref(ParserTerm,ObjTerm,RefType,AttTerm) ->
	    BodyHeadList=[],
	    compile_flobjref(ObjTerm,RefType,AttTerm,Object,OidCode,Code,Status)

	; is_fllist(ParserTerm,L,T,I) ->
	    compile_fllist(L,T,I,Nesting,Object,OidCode,Code,BodyHeadList,Status)

	; is_flaggregate(ParserTerm,Op,V,GV,SortSpec,B) ->
	    %% Aggregates are treated as OID, so its code would come
	    %% ahead of the code of the literal it occurs in
	    BodyHeadList=[],
	    compile_flaggregate(Op,V,GV,SortSpec,B,Object,OidCode,Status)

	; is_reifyop(ParserTerm,Formula) ->
	    BodyHeadList=[],
	    compile_reifyop(Formula,Object,OidCode,Status),
	    Code=NULL

	; is_flplib(ParserTerm,P) ->
	    compile_prologlibobj(P,Nesting,Object,OidCode,Code,BodyHeadList,Status)
	; is_flplib(ParserTerm,P,Module) ->
	    compile_prologlibobj(P,Module,Nesting,Object,OidCode,Code,BodyHeadList,Status)

	; is_flpliball(ParserTerm,P) ->
	    compile_prologalllibobj(P,Nesting,Object,OidCode,Code,BodyHeadList,Status)
	; is_flpliball(ParserTerm,P,Module) ->
	    compile_prologalllibobj(P,Module,Nesting,Object,OidCode,Code,BodyHeadList,Status)
	
	; is_flfloralib(ParserTerm,P,Module) ->
	    BodyHeadList=[],
	    compile_floralibobj(P,Module,Object,OidCode,Code,Status)

	; is_flworkspace(ParserTerm,P,WS),
	    compile_wspathexp(P,WS,Object,OidCode,Code,BodyHeadList,Status)
	),
	clear_context(compiling_body_pathexp).



/****************************************************************************
check_symbol_name_for_clashes(+Funct,+Arity,+SymbolContext,+Transactional,-SymbolContextStatus)
check_symbol_name_for_clashes(+Funct,+Arity,+WS,+SymbolContext,+Transactional,-SymbolContextStatus)

  The context 'compiling_term_name' is set in rule body responsible
  for compiling a term (e.g. compile_fltermlit).
  It is cleared before compiling arguments of the term.
  It is needed for distinguishing between compiling an atom as a term
  name and atom by itself

****************************************************************************/
check_symbol_name_for_clashes(Funct,Arity,SymbolContext,Transactional,Status) :-
	check_symbol_name_for_clashes(Funct,Arity,NULL,SymbolContext,Transactional,Status).

%% If term name is a variable, do not check 
check_symbol_name_for_clashes(Funct,_Arity,_WS,_SymbolContext,_Transactional,[]):-
	is_flvariable(Funct,_Name,_Index),
	!.

%% Already checked symbol: do not check again and do not record duplicates(!)
check_symbol_name_for_clashes(Funct,Arity,_WS,SymbolContext,Transactional,[]):-
	SymbolContext \== SENSOR_SYMBOL,
	SymbolContext \== UDF_SYMBOL,
	flora_get_flatomvar_name(Funct,Name),
	has_symbol(Name,Arity,_,_SIndex,_SLine,SymbolContext,Transactional),
	!.

check_symbol_name_for_clashes(Funct,Arity,_WS,UDF_SYMBOL,Transactional,[]):-
	flora_get_flatomvar_name(Funct,Name),
	(has_symbol(Name,Arity,_,_SIndex,_SLine,USE_UDF_SYMBOL,Transactional)
	; has_symbol(Name,Arity,_,_SIndex,_SLine,UDF_SYMBOL,Transactional)
	),
	!.

check_symbol_name_for_clashes(Funct,Arity,_WS,SENSOR_SYMBOL,Transactional,[]):-
	flora_get_flatomvar_name(Funct,Name),
	(has_symbol(Name,Arity,_,_SIndex,_SLine,USE_SENSOR_SYMBOL,Transactional)
	; has_symbol(Name,Arity,_,_SIndex,_SLine,SENSOR_SYMBOL,Transactional)
	),
	!.

check_symbol_name_for_clashes(_Funct,_Arity,_WS,_SymbolContext,_Transactional,[]):-
	has_context(compiling_term_name),
	!.

check_symbol_name_for_clashes(_Funct,_Arity,_WS,_SymbolContext,_Transactional,[]):-
	has_context(no_symbol_check),
	!.

check_symbol_name_for_clashes(Funct,Arity,_WS,PREDICATE_SYMBOL,NONTRANSACTIONAL_SYMBOL,[]):-
	flora_get_flatomvar_name(Funct,Name),
	has_symbol(Name,Arity,_,_SIndex,_SLine,PROLOG_SYMBOL,_Transactional),
	!.

check_symbol_name_for_clashes(Funct,Arity,_WS,PREDICATE_SYMBOL,NONTRANSACTIONAL_SYMBOL,[]):-
	flora_get_flatomvar_name(Funct,Name),
	has_context(compiling_sensor_directive(Name,Arity)),
	!.

%% do not check workspace for function symbols
check_symbol_name_for_clashes(Funct,Arity,WS,FUNCTION_SYMBOL,Transactional,[]):-
	flora_get_flatomvar_name(Funct,Name),
	has_nowarn_symbol(Name,Arity,_,FUNCTION_SYMBOL,Transactional),
  	approx_flindex(Funct,Index),
	get_index_line(Index,Line),
	add_symbol(Name,Arity,WS,Index,Line,FUNCTION_SYMBOL,Transactional),
	!.

check_symbol_name_for_clashes(Funct,Arity,WS,SymbolContext,Transactional,[]):-
	flora_get_flatomvar_name(Funct,Name),
	has_nowarn_symbol(Name,Arity,StoredWS,SymbolContext,Transactional),
	%% If StoredWS is an anonymous variable - then ignore warnings
	is_flvariable(StoredWS,VarName,_VarIndex),
	VarName == FL_UNDERSCORE,
  	approx_flindex(Funct,Index),
	get_index_line(Index,Line),
	add_symbol(Name,Arity,WS,Index,Line,SymbolContext,Transactional),
	!.

check_symbol_name_for_clashes(Funct,Arity,NULL,SymbolContext,Transactional,[]):-
	flora_get_flatomvar_name(Funct,Name),
	%% if workspace for symbol is NULL then ignore warnings
	%% only if StoredWS is current module or NULL
	has_nowarn_symbol(Name,Arity,NULL,SymbolContext,Transactional),
  	approx_flindex(Funct,Index),
	get_index_line(Index,Line),
	add_symbol(Name,Arity,NULL,Index,Line,SymbolContext,Transactional),
	!.

check_symbol_name_for_clashes(Funct,Arity,NULL,SymbolContext,Transactional,[]):-
	flora_get_flatomvar_name(Funct,Name),
	%% if workspace for symbol is NULL then we ignore warnings
	%% only if StoredWS is current module or NULL
	has_nowarn_symbol(Name,Arity,FL_THISMODULE,SymbolContext,Transactional),
	!,
  	approx_flindex(Funct,Index),
	get_index_line(Index,Line),
	add_symbol(Name,Arity,NULL,Index,Line,SymbolContext,Transactional).

check_symbol_name_for_clashes(Funct,Arity,WS,SymbolContext,Transactional,[]):-
	flora_get_flatomvar_name(Funct,Name),
	%% if workspace for symbol is not NULL then we ignore warnings
	%% only if StoredWS has the same name as WS
	WS \= NULL,
	flora_get_flatomvar_name(WS,WSName),
	has_nowarn_symbol(Name,Arity,WSName,SymbolContext,Transactional),
	!,
  	approx_flindex(Funct,Index),
	get_index_line(Index,Line),
	add_symbol(Name,Arity,WS,Index,Line,SymbolContext,Transactional).

check_symbol_name_for_clashes(Funct,Arity,WS,SymbolContext,Transactional,SymbolContextStatus):-
	flora_get_flatomvar_name(Funct,Name),
	!,
  	approx_flindex(Funct,Index),
        %% Check if symbol was used before in a different context
	( has_symbol(Name,SArity,_,_SIndex,_SLine,SContext,STransactional),
	    %% Index > 0 ensures that symbols introduced by the compiler
	    %% are not checked
	    integer(Index),
	    Index > 0,
	    make_symbol_context_status(SContext,STransactional,SArity,Arity,
				       Index,SymbolContext,Transactional,
				       SymbolContextStatus),
	    SymbolContextStatus \== [],
	    %% note: we need to backtrack through enough og the symbols to
	    %% get a warning
	    !
	 ;
               	SymbolContextStatus=[]
         ),
	get_index_line(Index,Line),
	add_symbol(Name,Arity,WS,Index,Line,SymbolContext,Transactional).

check_symbol_name_for_clashes(_Funct,_Arity,_WS,_SymbolContext,_Transactional,[]).

/****************************************************************************
make_symbol_context_status(+UsedContext,+UsedTransactional,+UsedArity,+SymbolArity,+SymbolIndex,+SymbolContext,+SymbolTransactional,-Status)
****************************************************************************/
make_symbol_context_status(_UsedContext,UsedTransactional,_UsedArity,_SymbolArity,SymbolIndex,_SymbolContext,SymbolTransactional,ContextStatus) :-
	UsedTransactional\=SymbolTransactional,
	!,
	(SymbolTransactional==TRANSACTIONAL_SYMBOL
	-> compiling_warning(SymbolIndex,WARNING_TRANSACTIONAL_SYMBOL,Err)
	; compiling_warning(SymbolIndex,WARNING_NONTRANSACTIONAL_SYMBOL,Err)
	),
	ContextStatus=[Err].

make_symbol_context_status(UsedContext,_UsedTransactional,UsedArity,SymbolArity,SymbolIndex,FUNCTION_SYMBOL,_SymbolTransactional,ContextStatus) :-
	( UsedContext==UDF_SYMBOL, UsedArity\=SymbolArity ->
	    compiling_warning(SymbolIndex,WARNING_FUNC_UDF_ARITY_SYMBOL,Err),
	    ContextStatus=[Err]
	; UsedContext==FUNCTION_SYMBOL, UsedArity\=SymbolArity ->
	    compiling_warning(SymbolIndex,WARNING_FUNC_ARITY_SYMBOL,Err),
	    ContextStatus=[Err]
	; %% for the following, we warn only if there was prior use as
	  %% hilog predicate, modular prolog predicate, or sensor
	  %% with the ***same*** number of arguments
	  UsedContext==PREDICATE_SYMBOL, UsedArity==SymbolArity ->
	    compiling_warning(SymbolIndex,WARNING_FUNC_PREDICATE_SYMBOL,Err),
	    ContextStatus=[Err]
	; UsedContext==PROLOG_SYMBOL, UsedArity==SymbolArity ->
	    compiling_warning(SymbolIndex,WARNING_FUNC_PROLOG_SYMBOL,Err),
	    ContextStatus=[Err]
	; UsedContext==SENSOR_SYMBOL, UsedArity==SymbolArity ->
	    compiling_warning(SymbolIndex,WARNING_FUNC_SENS_SYMBOL,Err),
	    ContextStatus=[Err]
/*
	; UsedContext==BUILTIN_SYMBOL,
	    (UsedArity==SymbolArity
	    -> compiling_warning(SymbolIndex,WARNING_BUILTIN_SYMBOL,Err)
	    ; compiling_warning(SymbolIndex,WARNING_BUILTIN_ARITY_SYMBOL,Err)
	    ),
	    ContextStatus=[Err]
*/
	;
		ContextStatus=[]
        ).

make_symbol_context_status(UsedContext,_UsedTransactional,UsedArity,SymbolArity,SymbolIndex,PREDICATE_SYMBOL,_SymbolTransactional,ContextStatus) :-
	( UsedContext==UDF_SYMBOL, UsedArity==SymbolArity ->
	    compiling_warning(SymbolIndex,WARNING_PREDICATE_UDF_SYMBOL,Err),
	    ContextStatus=[Err]
	; UsedContext==FUNCTION_SYMBOL, UsedArity==SymbolArity ->
	    compiling_warning(SymbolIndex,WARNING_PREDICATE_FUNC_SYMBOL,Err),
	    ContextStatus=[Err]
	; UsedContext==PREDICATE_SYMBOL, UsedArity\=SymbolArity ->
	    compiling_warning(SymbolIndex,WARNING_PREDICATE_ARITY_SYMBOL,Err),
	    ContextStatus=[Err]
	; UsedContext==PROLOG_SYMBOL, UsedArity\=SymbolArity ->
	    compiling_warning(SymbolIndex,WARNING_PREDICATE_PROLOG_ARITY_SYMBOL,Err),
	    ContextStatus=[Err]
	; UsedContext==SENSOR_SYMBOL, UsedArity==SymbolArity ->
	    (\+compiling_flrshell_command ->
		compiling_error(SymbolIndex,ERROR_PREDICATE_SENS_SYMBOL,Err),
		ContextStatus=[Err]
	    %% do not issue error if querying interactively
	    ; ContextStatus = []
	    )
	;
		ContextStatus=[]
	).

make_symbol_context_status(UsedContext,_UsedTransactional,UsedArity,SymbolArity,SymbolIndex,UDF_SYMBOL,_SymbolTransactional,ContextStatus) :-
	( UsedContext==PROLOG_SYMBOL, UsedArity==SymbolArity ->
	    compiling_warning(SymbolIndex,WARNING_UDF_PROLOG_SYMBOL,Err),
	    ContextStatus=[Err]
	; UsedContext==FUNCTION_SYMBOL,
	    (UsedArity==SymbolArity
	    -> compiling_error(SymbolIndex,WARNING_UDF_FUNC_SYMBOL,Err)
	    ; compiling_warning(SymbolIndex,WARNING_UDF_FUNC_ARITY_SYMBOL,Err)
	    ),
	    ContextStatus=[Err]
	; UsedContext==PREDICATE_SYMBOL,
	    (UsedArity==SymbolArity
	    -> compiling_warning(SymbolIndex,WARNING_UDF_PREDICATE_SYMBOL,Err)
	    ; compiling_warning(SymbolIndex,WARNING_UDF_PREDICATE_ARITY_SYMBOL,Err)
	    ),
	    ContextStatus=[Err]
	; UsedContext==SENSOR_SYMBOL, UsedArity==SymbolArity ->
	    compiling_warning(SymbolIndex,WARNING_UDF_SENSOR_SYMBOL,Err),
	    ContextStatus=[Err]
	; UsedContext==BUILTIN_SYMBOL,
	    (UsedArity==SymbolArity
	    -> compiling_warning(SymbolIndex,WARNING_BUILTIN_SYMBOL,Err)
	    ; compiling_warning(SymbolIndex,WARNING_BUILTIN_ARITY_SYMBOL,Err)
	    ),
	    ContextStatus=[Err]
	;
	    ContextStatus=[]
	).

make_symbol_context_status(UsedContext,_UsedTransactional,UsedArity,SymbolArity,SymbolIndex,SENSOR_SYMBOL,_SymbolTransactional,ContextStatus) :-
	( UsedContext==UDF_SYMBOL, UsedArity==SymbolArity ->
	    compiling_warning(SymbolIndex,WARNING_SENSOR_UDF_SYMBOL,Err),
	    ContextStatus=[Err]
	; UsedContext==FUNCTION_SYMBOL, UsedArity==SymbolArity ->
	    compiling_warning(SymbolIndex,WARNING_SENSOR_FUNC_SYMBOL,Err),
	    ContextStatus=[Err]
	; UsedContext==PREDICATE_SYMBOL, UsedArity\=SymbolArity ->
	    compiling_warning(SymbolIndex,ERROR_SENSOR_PREDICATE_SYMBOL,Err),
	    ContextStatus=[Err]
	; UsedContext==PREDICATE_SYMBOL, UsedArity==SymbolArity ->
	    (\+compiling_flrshell_command ->
		compiling_error(SymbolIndex,ERROR_SENSOR_PREDICATE_SYMBOL,Err)
	    %% in the FLORA shell just give a warning
	    ; compiling_warning(SymbolIndex,ERROR_SENSOR_PREDICATE_SYMBOL,Err)
	    ),
	    ContextStatus=[Err]
	; UsedContext==SENSOR_SYMBOL, UsedArity\=SymbolArity ->
	    compiling_warning(SymbolIndex,WARNING_SENSOR_ARITY_SYMBOL,Err),
	    ContextStatus=[Err]
	; UsedContext==PROLOG_SYMBOL,
	    (UsedArity\=SymbolArity
	    -> compiling_warning(SymbolIndex,ERROR_SENSOR_PROLOG_SYMBOL,Err)
	    ; compiling_error(SymbolIndex,ERROR_SENSOR_PROLOG_SYMBOL,Err)
	    ),
	    ContextStatus=[Err]
	; UsedContext==BUILTIN_SYMBOL,
	    (UsedArity==SymbolArity
	    -> compiling_error(SymbolIndex,WARNING_BUILTIN_SYMBOL,Err)
	    ; compiling_warning(SymbolIndex,WARNING_BUILTIN_ARITY_SYMBOL,Err)
	    ),
	    ContextStatus=[Err]
	;
	    ContextStatus=[]
	).

make_symbol_context_status(UsedContext,_UsedTransactional,UsedArity,SymbolArity,SymbolIndex,PROLOG_SYMBOL,_SymbolTransactional,ContextStatus) :-
	%% MK: can this happen in the FLORA shell?
	( UsedContext==UDF_SYMBOL, UsedArity==SymbolArity ->
		compiling_error(SymbolIndex,ERROR_PROLOG_UDF_SYMBOL,Err),
		ContextStatus=[Err]
	; UsedContext==PROLOG_SYMBOL, UsedArity\=SymbolArity ->
	    compiling_warning(SymbolIndex,WARNING_PROLOG_ARITY_SYMBOL,Err),
	    ContextStatus=[Err]
	; UsedContext==FUNCTION_SYMBOL, UsedArity==SymbolArity ->
		compiling_error(SymbolIndex,ERROR_PROLOG_FUNC_SYMBOL,Err),
		ContextStatus=[Err]
	; UsedContext==PREDICATE_SYMBOL,
	    (UsedArity==SymbolArity
	    -> compiling_error(SymbolIndex,ERROR_PROLOG_PREDICATE_SYMBOL,Err)
	    ; compiling_warning(SymbolIndex,WARNING_PROLOG_PREDICATE_ARITY_SYMBOL,Err)
	    ),
	    ContextStatus=[Err]
	; UsedContext==BUILTIN_SYMBOL,
	    (UsedArity==SymbolArity
	    -> compiling_error(SymbolIndex,WARNING_BUILTIN_SYMBOL,Err)
	    ; compiling_warning(SymbolIndex,WARNING_BUILTIN_ARITY_SYMBOL,Err)
	    ),
	    ContextStatus=[Err]
	;
	    ContextStatus=[]
	).

make_symbol_context_status(_,_,_,_,_,_,_,[]).


/****************************************************************************
  compile_pathexplist(+ParserTermList,Nesting,-ObjectList,-OidCode,-Code,?BodyHeadList,-Status)
  Nesting    - needed for nested user defined functions
  ObjectList - list of codes corresponding to the elements of the list
  OidCode    - code needed to produce the arguments of the terms in the list,
               if they are given as path expressions
  Code       - conjunction of the codes that correspond to the actual Boolean
               expressions in the list (after their arguments are computed)
  BodyHeadList - code to add at the beginning of the body
                 (mostly for user defined fnctions),
		 it is output argument, but if it is initialized
		 to empty ([]) ignores user defined functions
****************************************************************************/
compile_pathexplist([],_,[],NULL,NULL,[],[]) :- !.
%%compile_pathexplist([],[],NULL,NULL,[]) :- !.

compile_pathexplist(ParserTermList,ObjectList,OidCode,Code,Status) :-
	compile_pathexplist(ParserTermList,0,ObjectList,OidCode,Code,[],Status).

compile_pathexplist(ParserTermList,ObjectList,OidCode,Code,BodyHeadList,Status) :-
	compile_pathexplist(ParserTermList,0,ObjectList,OidCode,Code,BodyHeadList,Status).

compile_pathexplist([T|L],Nesting,[TObj|LObj],OidCode,Code,BodyHeadList,Status) :-
	(var(BodyHeadList) -> true; BodyHeadList1=[],BodyHeadList2=[]),
	compile_pathexp(T,Nesting,TObj,OidCodeHead,TCode,BodyHeadList1,S),
	!,
	clear_context(compiling_term_name),
	( no_errors_found(S) ->
	    compile_pathexplist(L,Nesting,LObj,OidCodeTail,LCode,BodyHeadList2,S2),
	    ( var(BodyHeadList) ->
		append(BodyHeadList1,BodyHeadList2,BodyHeadList)
	    ;
		true
	    ),
	    ( no_errors_found(S2) ->
		conjunct_code([TCode,LCode],Code),
		conjunct_code([OidCodeHead,OidCodeTail],OidCode),
		merge_status([S,S2],Status)
	    ;
		Status=S2
	    )
	;
	  Status=S
        ).


/****************************************************************************
  compile_flload(+LoadList,-Code,-Status)
****************************************************************************/
compile_flload(LoadList,Code,Status) :-
	is_fllist(LoadList,L,T,I),
	%% since complex terms aren't allowed in load lists, we ignore OidCode
	compile_fllist(L,T,I,ObjList,_OidCode,OCode,Status),
	( no_errors_found(Status) ->
	    thismodule_struct(Mod),
	    %% This is the file being compiled
	    (flora_compiler_environment(file,ProgramFile), !
	    ; ProgramFile=userin
	    ),
	    %% "I" is a token index
	    flora_nth_token(I,Token),
	    flora_token_text(Token,_TextStr,BLN,BCN,_ELN,_ECN),
	    %% Encode location of the literal [file>>mod]
	    %% Location is used for error checking in flrload.P to make sure
	    %% that loading of a file doesn't override the program
	    %% in which the loading statement occurs
	    list_struct([BLN,BCN],[],PositionCode),
	    florasyslib_struct(I,FLLIBLOAD,
			       4,
			       [ObjList,ProgramFile,Mod,PositionCode],LCode),
	    conjunct_code([OCode,LCode],Code)
	;
	  true
        ).


/****************************************************************************
  compile_flvar(+Name,+Index,-VarObject)
****************************************************************************/
compile_flvar(Name,Index,VarObject) :-
	( Name == FL_UNDERSCORE ->
	    new_dontcare_prvariable(Index,VarObject)
	;
	  varobj_struct(Name,Index,VarObject)
        ).

compile_fltransactionalvar_without_trans(Name,Index,VarObject) :-
	( Name == FL_UNDERSCORE ->
	    new_dontcare_prvariable(Index,VarObject)
	;
	  varobj_struct(Name,Index,VarObject)
        ).

compile_fltransactionalvar(Name,Index,VarObject) :-
	( Name == FL_UNDERSCORE ->
	    new_dontcare_prtransactionalvar(Index,VarObject)
	;
	  transactionalvar_struct(Name,Index,VarObject)
        ).

/****************************************************************************
  compile_flatomobj(+ParserTerm,+Nesting,-Object,?BodyHeadList,-Status)

  +Nesting - needed for nested user defined functions
  ?BodyHeadList - code to add at the beginning of the body
                  (mostly for user defined fnctions),
		  it is output argument, but if it is initialized to empty ([])
		  ignores user defined functions
****************************************************************************/
compile_flatomobj(ParserTerm,Nesting,Object,BodyHeadList,Status):-
	var(BodyHeadList),
	\+ has_context(compiling_arithmetics),
    	flora_get_flatomvar_name(ParserTerm,Name),
	has_user_defined_function(Name,0,[],Predicate,ReturnValue),
	!,
	check_symbol_name_for_clashes(ParserTerm,0,UDF_SYMBOL,
				      NONTRANSACTIONAL_SYMBOL,SymStatus),
	new_prvariable(NO_INDEX,Object),
	prvar_to_flvar_struct(Object,Var),
	approx_flindex(ParserTerm,Index),
	formUDFVarSubstitute([Var],[ReturnValue],Nesting,Index),
	compile_body_literal(Predicate,Nesting,PCode,PBodyHeadList,S),
	clearUDFVarSubstitute(Nesting),
	( no_errors_found(S) -> 
	    append(PBodyHeadList,[PCode],BodyHeadList),
	    append(S,SymStatus,Status)
	;
	    approx_flindex(ParserTerm,Index),
	    compiling_error(Index,ERROR_UDF_COMPILE,Err),
	    Status = [Err|S]
	).

compile_flatomobj(ParserTerm,_Nesting,Object,[],Status):-
	check_symbol_name_for_clashes(ParserTerm,0,FUNCTION_SYMBOL,
				      NONTRANSACTIONAL_SYMBOL,Status),
	atomobj_struct(ParserTerm,Object).


/****************************************************************************
  compile_fltermobj(+FunctorTerm,+Arity,+ArgList,+Nesting,-Object,-OidCode,-Code,?BodyHeadList,-Status)

  Compile term in the OID position.
  +Nesting - needed for nested user defined functions
  ?BodyHeadList - code to add at the beginning of the body
                  (mostly for user defined fnctions),
		  it is output argument, but if it is initialized to empty ([])
		  ignores user defined functions
****************************************************************************/
compile_fltermobj(FunctorTerm,Arity,ArgList,Object,OidCode,Code,Status) :-
	compile_fltermobj(FunctorTerm,Arity,ArgList,0,Object,OidCode,Code,[],Status).

compile_fltermobj(Funct,N,Args,Nesting,Object,OidCode,Code,BodyHeadList,CompileStatus) :-
	var(BodyHeadList),
	!,
	( \+ has_context(compiling_arithmetics),
	    flora_get_flatomvar_name(Funct,Name),
	    has_user_defined_function(Name,N,FArgs,Predicate,ReturnValue)
	-> 
	    OidCode=NULL,
	    Code=NULL,
	    new_prvariable(NO_INDEX,Object),
	    prvar_to_flvar_struct(Object,Var),
	    approx_flindex(Funct,Index),
	    formUDFVarSubstitute([Var|Args],[ReturnValue|FArgs],Nesting,Index),
	    compile_body_literal(Predicate,Nesting,PCode,PBodyHeadList,S),
	    clearUDFVarSubstitute(Nesting),
	    SymbolContext = UDF_SYMBOL,
	    ( no_errors_found(S) -> 
		append(PBodyHeadList,[PCode],BodyHeadList),
		Status = []
	    ;
		approx_flindex(Funct,Index),
		compiling_error(Index,ERROR_UDF_COMPILE,Err),
		Status = [Err|S]
	    )
	;
	    set_context(compiling_term_name),
	    compile_pathexplist([Funct|Args],Nesting,[FObj|AObj],OidCode,Code,BodyHeadList,Status),
	    SymbolContext = FUNCTION_SYMBOL,
	    ( no_errors_found(Status) -> termobj_struct(FObj,N,AObj,Object)
	    ; true)
	),
	(is_fltransactionalatom(Funct,_)
	-> Transactionality = TRANSACTIONAL_SYMBOL
	; Transactionality = NONTRANSACTIONAL_SYMBOL
	),
	check_symbol_name_for_clashes(Funct,N,SymbolContext,
				      Transactionality,SymbolStatus),
	append(SymbolStatus,Status,CompileStatus).

compile_fltermobj(Funct,N,Args,_Nesting,Object,OidCode,Code,[],CompileStatus) :-
	(is_fltransactionalatom(Funct,_)
	-> Transactionality = TRANSACTIONAL_SYMBOL
	; Transactionality = NONTRANSACTIONAL_SYMBOL
	),
	check_symbol_name_for_clashes(Funct,N,FUNCTION_SYMBOL,
				      Transactionality,SymbolStatus),
	set_context(compiling_term_name),
	compile_pathexplist([Funct|Args],[FObj|AObj],OidCode,Code,_BodyHeadList,Status),
	( no_errors_found(Status) -> termobj_struct(FObj,N,AObj,Object)
	; true
	),
	append(SymbolStatus,Status,CompileStatus).


/****************************************************************************
  has_user_defined_function(+Name,+N,-FArgs,-Predicate,-ReturnValue) 

  Compile term in the OID position.
****************************************************************************/
has_user_defined_function(Name,N,FArgs,Predicate,ReturnValue) :-
	has_permaoption(user_defined_function(Name,N,FArgs,Predicate,ReturnValue)),
	!. 
/*
%% registry for UDFs is not used, and this piece is wrong anyway, as it uses
%% FLORA_DEFAULT_WORKSPACE, not the actual module into which the file is loaded
has_user_defined_function(Name,N,FArgs,Predicate,ReturnValue) :-
	flrregistry:flora_user_defined_function(FLORA_DEFAULT_WORKSPACE,Name,N,
						FArgs,Predicate,ReturnValue). 
*/

/****************************************************************************
  FormUDFVarSubstitute(+Args,+FArgs,+Nesting)
	form correspondence between variables in definition of UDF
	and variables in usage of the function
  +Args - arguments in usage of the function
  +FArgs - arguments in definition of the function
****************************************************************************/
formUDFVarSubstitute([],_,_,_):-!.
formUDFVarSubstitute(_,[],_,_):-!.
formUDFVarSubstitute([A|Args],[FA|FArgs],Nesting,Index):-
	flora_get_flatomvar_name(FA,Name),
	asserta(user_defined_function_var_substitute(Nesting,Name,FA,A,Index)),
	formUDFVarSubstitute(Args,FArgs,Nesting,Index).
clearUDFVarSubstitute(Nesting) :-
	flora_retractall_substitute(user_defined_function_var_substitute(Nesting,_,_,_,_)).


/****************************************************************************
  compile_fltermlit(+FunctorTerm,+Arity,+ArgList,+Nesting,-OidCode,-Code,?BodyHeadList,-Status)

  Compile term in a predicate position in rule body.
  +Nesting - needed for nested user defined functions
  ?BodyHeadList - code to add at the beginning of the body
                  (mostly for user defined fnctions),
		  it is output argument, but if it is initialized
		  to empty ([]) ignores user defined functions
****************************************************************************/
%%compile_fltermlit(Funct,N,Args,OidCode,Code,BodyHeadList,Status) :-
%%         compile_fltermlit(Funct,N,Args,0,OidCode,Code,BodyHeadList,Status).
	
%% Terms declared with :- usesensor are treated here
compile_fltermlit(Funct,N,Args,Nesting,OidCode,Code,BodyHeadList,CompileStatus) :-
	is_flatom(Funct, FAtom, FunctIdx),
	(has_permaoption(sensor(FAtom,N))
	; has_permaoption(sensor((FAtom,PlMod),N))
	; compiling_flrshell_command,
	    (flora_delayed_sensor_literal(FAtom,N,FLORA_DEFAULT_WORKSPACE)
	    ; flora_delayed_sensor_literal((FAtom,PlMod),N,
					   FLORA_DEFAULT_WORKSPACE)
	    )
	),
	!,
	check_symbol_name_for_clashes(Funct,N,SENSOR_SYMBOL,NONTRANSACTIONAL_SYMBOL,SymbolStatus),
	is_anonymous_flvariable(Anon,NO_INDEX),
	%% compile_delayed_literal expects FLLIST as Arglist
	is_fllist(ArgsList,[Anon,Anon|Args],[],NO_INDEX),
	(atom(PlMod)
	->
	    is_flatom(ModParserTerm,PlMod,NO_INDEX),
	    compile_delayed_literal(Funct,ArgsList,ModParserTerm,Nesting,Code,OidCode,BodyHeadList,Status)
	;
	    %% if it is a sensor defined in a .flr file, scramble its
	    %% name by adding FLORA_PREFIX
	    flora_scramble_atom(FAtom,ScrambledAtom),
	    is_flatom(ScrambledFunct,ScrambledAtom,FunctIdx),
	    compile_delayed_literal(ScrambledFunct,ArgsList,Nesting,Code,OidCode,BodyHeadList,Status)
	),
	append(SymbolStatus,Status,CompileStatus).

compile_fltermlit(Funct,N,Args,Nesting,OidCode,Code,BodyHeadList,CompileStatus) :-
	(is_fltransactionalatom(Funct,_)
	-> Transactionality = TRANSACTIONAL_SYMBOL
	; Transactionality = NONTRANSACTIONAL_SYMBOL
	),
	check_symbol_name_for_clashes(Funct,N,PREDICATE_SYMBOL,Transactionality,
				      SymbolStatus),
	set_context(compiling_term_name),
	compile_pathexplist([Funct|Args],Nesting,[FObj|AObj],OidCode,ObjCode,BodyHeadList,Status),
	( no_errors_found(Status) ->
		termlit_struct(BODYLITERAL,FObj,N,AObj,TCode),
		conjunct_code([TCode,ObjCode],Code)
	;
		true
	),
	append(SymbolStatus,Status,CompileStatus).

compile_fltransactionaltermlit(Funct,N,Args,Nesting,OidCode,Code,BodyHeadList,CompileStatus) :-
	check_symbol_name_for_clashes(Funct,N,PREDICATE_SYMBOL,TRANSACTIONAL_SYMBOL,SymbolStatus),
	set_context(compiling_term_name),
	compile_pathexplist([Funct|Args],Nesting,[FObj|AObj],OidCode,ObjCode,BodyHeadList,Status),
	( no_errors_found(Status) ->
	    transactionaltermlit_struct(BODYLITERAL,FObj,N,AObj,TCode),
	    conjunct_code([TCode,ObjCode],Code)
	;
	  true
        ),
	append(SymbolStatus,Status,CompileStatus).


/****************************************************************************
  compile_fldelayquant(+Quant,+Condition,+Goal,+Index,-SpecCode,-BodyHeadList,-Status)
****************************************************************************/
compile_fldelayquant(Quant,Condition,Goal,Index,SpecCode,BodyHeadList,Status):-
	collect_flvars(Condition,CondVarList),
	vars_to_var_names(CondVarList,CondVarNames),
	collect_flvars(Goal,GoalVarList),
	vars_to_var_names(GoalVarList,GoalVarNames),
	compile_body_literal(Condition,0,ConditionCode,BodyHeadList,S1),
	(subset(CondVarNames,GoalVarNames) ->
	    ( no_errors_found(S1) ->
		compile_body(Goal,GoalCode,S2),
		( no_errors_found(S2) ->
		    merge_status([S1,S2],Status),
		    delay_struct(Index,FL_DELAYQUANT,
				 [Quant,ConditionCode,GoalCode],
				 SpecCode)
		;
		    Status = S2
		)
	    ;
		Status = S1
	    )
	;
	    approx_flindex(Condition,Idx),
	    compiling_error(Idx,DELAY_QUANT_VARS_NOT_IN_GOAL,Err),
	    Status = [Err]
	).


/****************************************************************************
  compile_fllist(+ObjTermList,+ObjTerm,+Index,+Nesting,-Object,-OidCode,-Code,?BodyHeadList,-Status)

  Index refers to '['.
  Lists are like this: [a,b,c|rest]
  ObjTermList refers to the list [a,b,c] and ObjTerm refers to the rest.

 ?BodyHeadList - code to add at the beginning of the body
                 (mostly for user defined fnctions),
		 it is output argument, but if it is initialized to empty ([])
		 ignores user defined functions
 +Nesting - needed for nested user defined functions
****************************************************************************/
compile_fllist(ObjTermList,ObjTerm,Index,Object,OidCode,Code,Status) :-
	compile_fllist(ObjTermList,ObjTerm,Index,0,Object,OidCode,Code,[],Status).

compile_fllist(ObjTermList,ObjTerm,Index,Nesting,Object,OidCode,Code,BodyHeadList,Status) :-
	(var(BodyHeadList) -> true; BodyHeadList1=[],BodyHeadList2=[]),
	compile_pathexplist(ObjTermList,Nesting,ObjList,OidCodeList,ObjListCode,BodyHeadList1,S),
	( no_errors_found(S) ->
	    ( ObjTerm == [] ->
		BodyHeadList=BodyHeadList1,
		Obj=[],
		OidCodeObj=NULL,
		ObjCode=NULL,
		Status=[]
	    ;
		compile_pathexp(ObjTerm,Nesting,Obj,OidCodeObj,ObjCode,BodyHeadList2,Status),
		( var(BodyHeadList) ->
		    append(BodyHeadList1,BodyHeadList2,BodyHeadList)
		;
		    true
		)
	    ),
	    ( no_errors_found(Status) ->
		list_struct(ObjList,Obj,Index,Object),
		conjunct_code([ObjListCode,ObjCode],Code),
		conjunct_code([OidCodeList,OidCodeObj],OidCode)
	    ;
	      true
	    )
	;
	  Status=S
        ).


/****************************************************************************
  compile_flobjref(+ObjTerm,+RefType,+AttTerm,-Object,-OidCode,-Code,-Status)

  Process an object reference like a.b.c
  An objref can be more complex, e.g., a[f->g].b[h->p].c[k->u]
****************************************************************************/
compile_flobjref(ObjTerm,RefType,AttTerm,Object,OidCode,Code,Status) :-
	compile_pathexplist([ObjTerm,AttTerm],[Obj,Att],OidCodeList,OCode,Status),
	( no_errors_found(Status) ->
	    %% Approximate the textual information for the new variable.
	    approx_flindex(AttTerm,Index),
	    body_objref_struct(Obj,RefType,Att,Index,Object,TCode),
	    Code = OCode,
	    conjunct_code([OidCodeList,TCode],OidCode)
	;
	  true
        ).


/****************************************************************************
  compile_flbirelate(+ObjTerm1,+RelType,+ObjTerm2,-Object,-Code,-Status)

  Compiles binary relationships, like : or ::
****************************************************************************/
compile_flbirelate(ObjTerm1,RelType,ObjTerm2,Obj1,OidCode,Code,Status) :-
	compile_pathexplist([ObjTerm1,ObjTerm2],[Obj1,Obj2],OidCode,OCode,Status),
	( no_errors_found(Status) ->
	    birelate_struct(BODYLITERAL,Obj1,RelType,Obj2,TCode),
	    conjunct_code([TCode,OCode],Code)
	;
	  true
        ).


/****************************************************************************
  compile_flobjspec(+ObjTerm,+SpecBody,-Object,-OidCode,-Code,-BodyHeadList,-Status)

  Code produced by this and similar predicates is divided into
  OidCode and Code. 
  OidCode is the code needed to compute the attribute of molecule
  and the oid, and the oid of the value part (in ->, etc.)
  Code represents the code needed to compute the the attribute specification.
  For instance, in  a.b[c.d->e.f],
      OidCode will represent the computation of c.d and e.d:
	 prand(prmvd(a,b,_newvar1),prand(prmvd(c,d,_newvar2),prmvd(e,d,_newvar3)))
      Code will represent the -> part:
                 prmvd(_newvar1,_newvar2,_newvar3)
****************************************************************************/
compile_flobjspec(ObjTerm,SpecBody,Object,OidCode,Code,BodyHeadList,Status) :-
	( SpecBody == [] ->
	    %% Just objref, no body. Something like a.b.c. Possibly a.b.c[]
	    ( is_flobjref(ObjTerm,OTerm,RefType,ATerm) ->
		compile_pathexplist([OTerm,ATerm],[OObj,AObj],OidCode,ObjCode,BodyHeadList,Status),
		%% This is an optimization, which translates a.b[] as
		%% a[b->?X] as opposed to a[b->?X],?X[].
		%% The alternative case (compile_pathexp below),
		%% compiles a.b[] as in the second, inefficient case above.
		( no_errors_found(Status) -> 
		    approx_flindex(ATerm,Index),
		    body_objref_struct(OObj,RefType,AObj,Index,Object,TCode),
		    conjunct_code([TCode,ObjCode],Code)
		;
		  true
	        )
	    ;
	      compile_pathexp(ObjTerm,Object,OidCode,ObjCode,BodyHeadList,Status),
	      ( no_errors_found(Status) -> 
		  objexists_struct(BODYLITERAL,Object,ECode),
		  conjunct_code([ECode,ObjCode],Code)
	      ;
	        true
	      )
	    )
	; % oid spec plus object spec. something like a.b[c->d]
	    compile_pathexp(ObjTerm,Object,ObjOidCode,ObjCode,BodyHeadList1,S),
	    ( no_errors_found(S) -> 
	        compile_flspecbody(Object,SpecBody,SpecOidCode,SpecCode,BodyHeadList2,Status),
	        ( no_errors_found(Status) -> 
		    conjunct_code([ObjCode,SpecCode],Code),
		    conjunct_code([ObjOidCode,SpecOidCode],OidCode)
		; true
		),
		append(BodyHeadList1,BodyHeadList2,BodyHeadList)
	    ;
		Status=S,
		BodyHeadList = BodyHeadList2
	    )
        ).

/****************************************************************************
  compile_flspecbody(+Object,+SpecTerm,-OidCode,-Code,-BodyHeadList,-Status)

   Compile the specification part of a molecule Object[SpecTerm]
   Object: describes the oid; it is an already compiled term
   SpecTerm: descripes the specification inside the brackets
   Code: the resulting compiled code
****************************************************************************/
compile_flspecbody(Object,SpecTerm,OidCode,Code,BodyHeadList,Status) :-
	is_flconjunct(SpecTerm,L,R),
	!,
	compile_flspecbody(Object,L,OidCode,LCode,BodyHeadList1,S),
	( no_errors_found(S) -> 
	    compile_flspecbody(Object,R,OidCode,RCode,BodyHeadList2,Status),
	    ( no_errors_found(Status) -> 
		conjunct_code([LCode,RCode],Code); true),
	    append(BodyHeadList1,BodyHeadList2,BodyHeadList)
	;
	  BodyHeadList = BodyHeadList1,
	  Status=S
        ).

compile_flspecbody(Object,SpecTerm,OidCode,Code,BodyHeadList,Status) :-
	is_fldisjunct(SpecTerm,L,R),
	!,
	compile_flspecbody(Object,L,OidCode,LCode,BodyHeadList1,S),
	( no_errors_found(S) -> 
	    compile_flspecbody(Object,R,OidCode,RCode,BodyHeadList2,Status),
	    ( no_errors_found(Status) -> 
		disjunct_struct(LCode,RCode,Code); true),
	    append(BodyHeadList1,BodyHeadList2,BodyHeadList)
	;
	  BodyHeadList = BodyHeadList1,
	  Status=S
        ).

compile_flspecbody(Object,SpecTerm,OidCode,Code,BodyHeadList,Status) :-
	is_default_negation(SpecTerm,G,NAFType),
	!,
	set_context(compiling_default_negation),
	compile_flspecbody(Object,G,OidCode,GCode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    (is_prquantifier(GCode,_Quant,FormCode,_FreeVarObjs)
	    -> true
	    ;  FormCode = GCode
	    ),
	    conjunct_code([OidCode,FormCode],CombinedCode),
	    (NAFType == (not) -> flora_naf_struct(CombinedCode,Code)
	    ; prolog_naf_struct(CombinedCode,Code)
	    )
	; true
	),
	clear_context(compiling_default_negation).

compile_flspecbody(Object,SpecTerm,OidCode,Code,BodyHeadList,Status) :-
	is_flneg(SpecTerm,G,Idx),
	!,
	compile_flspecbody(Object,G,OidCode,GCode,BodyHeadList,Status1),
	( no_errors_found(Status1) -> 
	    conjunct_code([OidCode,GCode],CombinedGCode),
	    neg_struct(CombinedGCode,Idx,Code,Status)
	; Status = Status1
	).

%% Quantification under default negation
compile_flspecbody(Object,SpecTerm,OidCode,Code,BodyHeadList,Status) :-
	is_fllogicquantifier(SpecTerm,FL_EXISTS,QuantVarNames,Formula,Idx),
	has_context(compiling_default_negation),
	!,
	%% no quantified don't care vars (?,?_) 
	(memberchk(FL_UNDERSCORE,QuantVarNames) ->
	    compiling_error(Idx,NO_QUANTIFIED_ANONVARS,Err1),
	    S1 = [Err1]
	; S1 = []
	),

	compile_flspecbody(Object,Formula,OidCode,FormCode,BodyHeadList,S2),
	%% We use prvars so that newly introduced vars will be accounted for
	collect_prvars([Object,OidCode,FormCode],AllVarList),
	vars_to_var_names(AllVarList,AllVarList_names),
	%% quantified vars must occur in Formula
	(subset(QuantVarNames,AllVarList_names) -> S3 = []
	; compiling_error(Idx,QUANT_VARS_NOT_SUBSET,Err3),
	    S3 = [Err3]
	),

	subtract_vars(AllVarList,QuantVarNames,FreeVarObjs_aux),
	%% remove don't care vars, since no need to delay because of them
	remove_prdontcare_vars(FreeVarObjs_aux,FreeVarObjs_aux2),
	remove_caller_vars(FreeVarObjs_aux2,FreeVarObjs),

	rename_prvariables(QuantVarNames,FormCode,
			   RenamedFormCode,_RenamedQuantVars),

	merge_status([S1,S2,S3],Status),
	( no_errors_found(Status) -> 
	    %% Create the code for compiled quantification.
	    conjunct_code([OidCode,RenamedFormCode],CombinedCode),
	    quantifier_struct(FL_EXISTS,CombinedCode,FreeVarObjs,Code)
	;
	    true
	).


%% F-molecule with attribute specification.
%% Can be O[M->V], where O,M,V can be any complex F-molecule
%% OidCodeList below gets bound to code needed to produce
%% the attribute (M) and the value (V). We conjunct this code in front of the
%% code for the molecule
%% NULL means that we don't pass OID code out, because we use it right here.

%% No OidCode is passed outside: we consume it here
compile_flspecbody(Object,SpecTerm,NULL,Code,BodyHeadList,Status) :-
	is_flmvdattspec(SpecTerm,AttTerm,RefType,ValTermList),
	!,
	compile_pathexp(AttTerm,AttObj,AOidCode,ACode,BodyHeadList1,S),
	( no_errors_found(S) -> 
	    ( ValTermList == [] ->
		mvdattdef_struct(BODYLITERAL,Object,AttObj,RefType,SCode),
		conjunct_code([AOidCode,ACode,SCode],Code),
		BodyHeadList = BodyHeadList1,
		Status=[]
	    ;
		%% An mvd spec can have several terms in the value set
		%% (represented by ValTermList). This compiles such
		%% a spec into a conjunction.
		compile_mvdattspec(Object,AttObj,RefType,ValTermList,VOidCode,SCode,BodyHeadList2,Status),
		%% ACode: Code to produce attribute
		%% SCode: code to produce pure attr specs and 
		%%         the objects that represents the values
		( no_errors_found(Status) -> 
		  conjunct_code([AOidCode,VOidCode,ACode,SCode],Code)
	      	;
		  true
	      	),
		append(BodyHeadList1,BodyHeadList2,BodyHeadList)
	    )
        ;
	  BodyHeadList = BodyHeadList1,
	  Status=S
        ).

%% signatures: =>, *=>, etc.
compile_flspecbody(Object,SpecTerm,NULL,Code,BodyHeadList,Status) :-
	is_flsigattspec(SpecTerm,AttTerm,RefType,ValTerm),
	!,
	compile_pathexp(AttTerm,AttObj,AOidCode,ACode,BodyHeadList1,S),
	( no_errors_found(S) -> 
	    (is_flemptyterm(ValTerm) ->
		%% This is SIGDEF: occurs when we have a[b=> ()]
		sigattdef_struct(BODYLITERAL,Object,AttObj,RefType,SCode),
		conjunct_code([AOidCode,ACode,SCode],Code),
		BodyHeadList = BodyHeadList1,
		Status=[]
	    ;
		compile_pathexp(ValTerm,ValObj,VOidCode,VCode,BodyHeadList2,Status),
		( no_errors_found(Status) -> 
		    sigattspec_struct(BODYLITERAL,Object,AttObj,RefType,ValObj,SCode),
		    %% SCode: code to produce object ref, attribute, and value
		    %% OCode: code for the pure attribute spec of the object
		    %% AOidCode: code to produce the attribute
		    %% ACode: code for the attribute
		    %% VOidCode: code to produce value of the attribute
		    %% VCode: code for value of the attribute
		    conjunct_code([AOidCode,VOidCode,ACode,VCode,SCode],Code)
		;
		    true
		),
		append(BodyHeadList1,BodyHeadList2,BodyHeadList)
	    )
	;
	    BodyHeadList = BodyHeadList1,
	    Status = S
        ).

%% signatures: =>, *=>, etc.
compile_flspecbody(Object,SpecTerm,NULL,Code,BodyHeadList,Status) :-
	is_flsigattconspec(SpecTerm,AttTerm,ConstrTerm,RefType,ValTerm),
	!,
	compile_pathexp(AttTerm,AttObj,AOidCode,ACode,BodyHeadList1,S),
	( no_errors_found(S) -> 
	    (is_flemptyterm(ValTerm) ->
		%% This is SIGDEF: occurs when we have a[b=> ()]
		sigattdef_struct(BODYLITERAL,Object,AttObj,RefType,SCode),
		conjunct_code([AOidCode,ACode,SCode],Code),
		BodyHeadList = BodyHeadList1,
		Status=[]
	    ;
		is_flsigconstr(ConstrTerm,Lower,Upper),
		compile_pathexplist([Lower,Upper],[OLower,OUpper],COidCode,CCode,BodyHeadList2,S_C),
		( no_errors_found(S_C) -> 
		    compile_pathexp(ValTerm,ValObj,VOidCode,VCode,BodyHeadList3,Status),
		    ( no_errors_found(Status) -> 
			sigattspec_struct(BODYLITERAL,Object,AttObj,RefType,ValObj,SCode),
			sigattconstr_struct(BODYLITERAL,Object,AttObj,OLower,OUpper,RefType,CSCode),
			%% SCode: code to produce object ref, attribute, and value
			%% OCode: code for the pure attribute spec of the object
			%% AOidCode: code to produce the attribute
			%% ACode: code for the attribute
			%% VOidCode: code to produce value of the attribute
			%% VCode: code for value of the attribute
			conjunct_code([AOidCode,VOidCode,ACode,VCode,SCode,COidCode,CCode,CSCode],Code)
		    ;
			true
		    )
		;
		    Status = S_C
		),
		append(BodyHeadList1,BodyHeadList2,BodyHeadList4),
		append(BodyHeadList4,BodyHeadList3,BodyHeadList)
	    )
	;
	    BodyHeadList = BodyHeadList1,
	    Status = S
        ).

%% boolean signatures: =>.
compile_flspecbody(Object,SpecTerm,NULL,Code,BodyHeadList,Status) :-
	is_flboolsig(SpecTerm,AttTerm,_RefType),
	!,
	compile_pathexp(AttTerm,AttObj,AOidCode,ACode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    boolsig_struct(BODYLITERAL,Object,AttObj,SCode),
	    conjunct_code([AOidCode,ACode,SCode],Code)
	;
	    true
	).

%% boolean signatures: *=>.
compile_flspecbody(Object,SpecTerm,NULL,Code,BodyHeadList,Status) :-
	is_fliboolsig(SpecTerm,AttTerm,_RefType),
	!,
	compile_pathexp(AttTerm,AttObj,AOidCode,ACode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    iboolsig_struct(BODYLITERAL,Object,AttObj,SCode),
	    conjunct_code([AOidCode,ACode,SCode],Code)
	;
	    true
	).

%% boolean signatures: =>% for transactional method
compile_flspecbody(Object,SpecTerm,NULL,Code,BodyHeadList,Status) :-
	is_fltransig(SpecTerm,AttTerm,_RefType),
	!,
	compile_pathexp(AttTerm,AttObj,AOidCode,ACode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    transig_struct(BODYLITERAL,Object,AttObj,SCode),
	    conjunct_code([AOidCode,ACode,SCode],Code)
	;
	    true
	).

%% boolean signatures: *=>% for transactional method
compile_flspecbody(Object,SpecTerm,NULL,Code,BodyHeadList,Status) :-
	is_flitransig(SpecTerm,AttTerm,_RefType),
	!,
	compile_pathexp(AttTerm,AttObj,AOidCode,ACode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    itransig_struct(BODYLITERAL,Object,AttObj,SCode),
	    conjunct_code([AOidCode,ACode,SCode],Code)
	;
	    true
	).

%% +>>, *+>>
compile_flspecbody(Object,SpecTerm,NULL,Code,BodyHeadList,Status) :-
	is_flincattspec(SpecTerm,AttTerm,RefType,ValTerm),
	!,
	compile_pathexplist([AttTerm,ValTerm],[AttObj,ValObj],OidCode,OCode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    incattspec_struct(Object,AttObj,RefType,ValObj,SCode),
	    conjunct_code([OidCode,SCode,OCode],Code)
	;
	  true
        ).

%% same for ->->
compile_flspecbody(Object,SpecTerm,NULL,Code,BodyHeadList,Status) :-
	is_fltolistattspec(SpecTerm,AttTerm,RefType,ValTerm),
	!,
	compile_pathexplist([AttTerm,ValTerm],[AttObj,ValObj],OidCode,OCode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    tolistattspec_struct(Object,AttObj,RefType,ValObj,SCode),
	    %% Fold OidCode in front of the molecule
	    conjunct_code([OidCode,SCode,OCode],Code)
	;
	  true
        ).

%% Obj[true], Obj[fail], Obj[!] translate as true, fail, and !
compile_flspecbody(_Object,SpecTerm,NULL,Code,[],Status) :-
	is_flpassthru(SpecTerm,P),
	is_flatom(P, Atom, I),
	!,
	(Atom==FL_CUT
	-> cut_struct(I,Code)
	; atomobj_struct(P,Code)
	),
	Status=[].

%% Obj[X>Y], Obj[X=Y], etc.
compile_flspecbody(_Object,SpecTerm,NULL,Code,BodyHeadList,Status) :-
	is_flpassthru(SpecTerm,P),
	is_flterm(P, Funct, N, Args),
	!,
	compile_prlgterm(Funct,N,Args,0,TCode,_OidCode,ACode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
		conjunct_code([ACode,TCode],Code); true).

%% for O[BoolMeth]
compile_flspecbody(Object,SpecTerm,NULL,Code,BodyHeadList,Status) :-
	is_flmethspec(SpecTerm,MethTerm),
	!,
	compile_pathexp(MethTerm,MethObj,OidCode,MCode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    methspec_struct(BODYLITERAL,Object,MethObj,SCode),
	    %% Fold OidCode in front of the molecule
	    conjunct_code([OidCode,MCode,SCode],Code)
	;
	  true
        ).

%% for O[*BoolMeth]
compile_flspecbody(Object,SpecTerm,NULL,Code,BodyHeadList,Status) :-
	is_flimethspec(SpecTerm,IMethTerm),
	!,
	compile_pathexp(IMethTerm,IMethObj,OidCode,IMCode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    imethspec_struct(BODYLITERAL,Object,IMethObj,SCode),
	    %% Fold OidCode in front of the molecule
	    conjunct_code([OidCode,IMCode,SCode],Code)
	;
	  true
        ).

%% O[%M]
compile_flspecbody(Object,SpecTerm,NULL,Code,BodyHeadList,Status) :-
	is_fltranspec(SpecTerm,TranTerm),
	!,
	compile_pathexp(TranTerm,TranObj,OidCode,TCode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    transpec_struct(BODYLITERAL,Object,TranObj,SCode),
	    conjunct_code([OidCode,TCode,SCode],Code)
	;
	  true
        ).


/****************************************************************************
  compile_mvdattspec(+Object,+AttObj,+RefType,+ValTermList,-OidCode,-Code,-BodyHeadList,-Status)
   Arg 4 is a list representing the value set of the attribute.
   This predicate compiles such a spec into a conjunction.
   Each conjunct corresponds to each member of the value set.
   Assumes that AttObj is already an oid
****************************************************************************/
compile_mvdattspec(Object,AttObj,RefType,[T],OidCode,Code,BodyHeadList,Status) :-
	!,
	compile_pathexp(T,TObj,OidCode,TCode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    mvdattspec_struct(BODYLITERAL,Object,AttObj,RefType,TObj,SCode),
	    conjunct_code([SCode,TCode],Code)
	;
	  true
        ).

compile_mvdattspec(Object,AttObj,RefType,[T|L],OidCode,Code,BodyHeadList,Status) :-
	!,
	compile_mvdattspec(Object,AttObj,RefType,[T],OidCodeHead,TCode,BodyHeadList1,S),
	( no_errors_found(S) -> 
	    compile_mvdattspec(Object,AttObj,RefType,L,OidCodeTail,LCode,BodyHeadList2,Status),
	    ( no_errors_found(Status) -> 
		conjunct_code([TCode,LCode],Code),
		conjunct_code([OidCodeHead,OidCodeTail],OidCode)
	    ;
		true
	    ),
	    append(BodyHeadList1,BodyHeadList2,BodyHeadList)
	;
	  BodyHeadList = BodyHeadList1,
	  Status=S
        ).


/****************************************************************************
  compile_flaggregate(+Op,+Var,+GVars,+SortSpec,+BodyTerm,-Object,-Code,-Status)
****************************************************************************/
compile_flaggregate(Op,Var,GVars,SortSpec,BodyTerm,Object,Code,Status) :-
	compile_body(BodyTerm,BCodeSansDelay,S),
	delay_literals_checking_code([],BodyTerm,DelayCode),
	(is_prvariable(DelayCode) -> BCode = BCodeSansDelay
	; conjunct_struct(BCodeSansDelay,DelayCode,BCode)
	),
	( no_errors_found(S) -> 
            (
	      /* check_aggregate was disabled by changz after adding singleton
	         checks to dynamic rules. Not clear why she did that. None of
	         the tests are affected by this, but such a change prevents
	         checks for grouping/aggregate vars in cases like
		      ?- insertrule{a :- ?x=count{?k|true@?V}}.
		 So, we zap changz's change until we find out why it is needed.
	      */
	    /*
	      has_context(compile_with_var_module),
		\+ has_context(goal_reification) ->
                S1 =[]
            ;
	    */
	        check_aggregate(Var,GVars,BodyTerm,S1)
            ),
	    ( no_errors_found(S1) -> 
		compile_pathexplist([Var|GVars],[VarCode|GVarsCode],NULL,NULL,[]),
		list_struct(GVarsCode,[],GVarsListCode),
		(SortSpec==NULL
		-> aggregate_struct(Op,VarCode,GVarsListCode,BCode,Object,Code),
		    Status = []
		;
		    is_flterm(SortSpec,Funct,N,Args),
		    compile_fltermobj(Funct,N,Args,SpecCode,_,_,Status),
		    ( no_errors_found(Status) -> 
			aggregate_struct(Op,VarCode,GVarsListCode,SpecCode,BCode,Object,Code)
		    ;   true
		    )
		)
	    ;
	      Status = S1
	    )
	;
	  Status=S
        ).


/****************************************************************************
  check_aggregate(+Var,+GroupVars,+BodyTerm,-Status)
  check_repeatedvar(+Vars,-Status,-TailStatus)
  allgvar_notin(+SortedVars,-Status,-TailStatus)
  Checks for any abnormalities with grouping and aggregate variables.
****************************************************************************/
check_aggregate(Var,GVars,BodyTerm,Status) :-
	is_flvariable(Var,VarName,VarIndex),
	%% Check if the aggregate variable is anonymous.
	( VarName == FL_UNDERSCORE ->
	    compiling_error(VarIndex,ERROR_AVAR,M1),
	    Status=[M1|S1]
	;
	  Status=S1
        ),
	%% Check if any grouping variable is anonymous.
	check_gvar(GVars,S1,S2),
	%% Check if the aggregate variable is also used for grouping.
	( VarName \= FL_UNDERSCORE, is_flvariable(U,VarName,_Iu), memberchk(U,GVars) ->
	    compiling_error(VarIndex,AVAR_ASGVAR,M2),
	    S2=[M2|S3]
	;
	  S3=S2
        ),
	%% Check if there are any repeated grouping variables.
	sort(GVars,SVars),
	check_repeatedvar(SVars,S3,S4),
	collect_flvars(BodyTerm,BVars),
	%% Check if aggregate variable is used in the aggregate body.
	( (VarName == FL_UNDERSCORE; is_flvariable(W,VarName,_Iw), memberchk(W,BVars)) ->
	    S5=S4
        ;
	  compiling_error(VarIndex,AVAR_NOTIN,M5),
	  S4=[M5|S5]
        ),
	%% Check if all grouping variables are used in the aggregate body.
	( subtract_vars(GVars,BVars,L), L \== [] ->
	    sort(L,SL),
	    allgvar_notin(SL,S5,[])
	;
	  S5=[]
        ).


check_gvar([],S,S) :- !.

check_gvar([H|L],Status,TS) :-
	( is_flvariable(H,FL_UNDERSCORE,HIndex) ->
	    compiling_error(HIndex,ERROR_GVAR,M),
	    Status=[M|S],
	    check_gvar(L,S,TS)
	;
	  check_gvar(L,Status,TS)
        ).


check_repeatedvar([],S,S) :- !.

check_repeatedvar([H|L],Status,TS) :-
	is_flvariable(H,FL_UNDERSCORE,_I),
	!,
	check_repeatedvar(L,Status,TS).

check_repeatedvar([_H],S,S) :- !.

check_repeatedvar([H1,H2|T],Status,TS) :-
	( is_flvariable(H1,Name,_I1), is_flvariable(H2,Name,I2) ->
	    compiling_error(I2,REPEATED_GVAR,Msg),
	    Status=[Msg|S],
	    check_repeatedvar([H1|T],S,TS)
	;
	  check_repeatedvar([H2|T],Status,TS)
        ).


allgvar_notin([],S,S) :- !.

allgvar_notin([H|L],Status,TS) :-
	is_flvariable(H,FL_UNDERSCORE,_I),
	!,
	allgvar_notin(L,Status,TS).

allgvar_notin([H|T],[Msg|S],TS) :-
	is_flvariable(H,Name,Index),
	compiling_error(Index,GVAR_NOTIN,Msg),
	remove_dupflvars(T,Name,L),
	allgvar_notin(L,S,TS).


/****************************************************************************
  compile_flobjeql(+Obj1,+Obj2,-OidCode,-Code,-Status)
****************************************************************************/
compile_flobjeql(Obj1,Obj2,OidCode,Code,Status) :-
	compile_pathexplist([Obj1,Obj2],[O1,O2],OidCode,OCode,Status),
	( no_errors_found(Status) -> 
	    objeql_struct(BODYLITERAL,O1,O2,OECode),
	    conjunct_code([OCode,OECode],Code)
	;
	  true
	).


/****************************************************************************
  compile_head_fltermobj(+FunctorTerm,+Arity,+ArgList,-Object,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
****************************************************************************/
compile_head_fltermobj(Funct,N,Args,Object,Code,H2BCodeHead,H2BCodeTail,CompileStatus) :-
	( \+ has_context(compiling_arithmetics),
	    flora_get_flatomvar_name(Funct,Name),
	    has_user_defined_function(Name,N,FArgs,Predicate,ReturnValue)
	->
	    Code=NULL,
	    H2BCodeTail=NULL,
	    new_prvariable(NO_INDEX,Object),
	    prvar_to_flvar_struct(Object,Var),
	    approx_flindex(Funct,Index),
	    formUDFVarSubstitute([Var|Args],[ReturnValue|FArgs],0,Index),
	    compile_body_literal(Predicate,0,PCode,PH2BCodeHead,S),
	    clearUDFVarSubstitute(0),
	    SymbolContext = UDF_SYMBOL,
	    ( no_errors_found(S) -> 
		append(PH2BCodeHead,[PCode],List),
		conjunct_code(List,H2BCodeHead),
		Status = []
	    ;
		approx_flindex(Funct,Index),
		compiling_error(Index,ERROR_UDF_COMPILE,Err),
		Status = [Err|S]
	    )
	;
	    set_context(compiling_term_name),
	    compile_head_pathexplist([Funct|Args],[FObj|AObj],Code,H2BCodeHead,H2BCodeTail,Status),
	    SymbolContext = FUNCTION_SYMBOL,
	    ( no_errors_found(Status) -> 
		termobj_struct(FObj,N,AObj,Object); true)
	),
	(is_fltransactionalatom(Funct,_)
	-> Transactionality = TRANSACTIONAL_SYMBOL
	; Transactionality = NONTRANSACTIONAL_SYMBOL
	),
	check_symbol_name_for_clashes(Funct,N,SymbolContext,Transactionality,
				      SymbolStatus),
	append(SymbolStatus,Status,CompileStatus).


/****************************************************************************
  compile_head_fltermlit(+FunctorTerm,+Arity,+ArgList,-Code,-H2BCodeHead,-H2BCodeTail,-Status)

  Compile a term in a rule head in a predicate position.
****************************************************************************/
compile_head_fltermlit(Funct,N,Args,Code,H2BCodeHead,H2BCodeTail,CompileStatus) :-
	(is_fltransactionalatom(Funct,_)
	-> Transactionality = TRANSACTIONAL_SYMBOL
	; Transactionality = NONTRANSACTIONAL_SYMBOL
	),
	check_symbol_name_for_clashes(Funct,N,PREDICATE_SYMBOL,Transactionality,SymbolStatus),
	set_context(compiling_term_name),
	compile_head_pathexplist([Funct|Args],[FObj|AObj],ObjCode,H2BCodeHead_pre,H2BCodeTail,Status),
	((H2BCodeHead_pre \== NULL ; H2BCodeTail \== NULL)
	-> H2BCodeHead = H2BCodeHead_pre
	; has_context(compiling_facts),
	    has_context(compiling_for_addition),
	    get_flatom_name(Funct,AtomName),
	    flora_modular_prlgdef(AtomName,N)
	-> %% FL_TRUE is dummy code, which gets ignored by conjunct_struct/3
	    H2BCodeHead = FL_TRUE
	; H2BCodeHead = H2BCodeHead_pre
	),
	( no_errors_found(Status) -> 
		termlit_struct(HEADLITERAL,FObj,N,AObj,TObj),
		conjunct_struct(ObjCode,TObj,Code)
	;
		true
	),	
	append(SymbolStatus,Status,CompileStatus).

compile_head_fltransactionaltermlit(Funct,N,Args,Code,H2BCodeHead,H2BCodeTail,CompileStatus) :-
	check_symbol_name_for_clashes(Funct,N,PREDICATE_SYMBOL,TRANSACTIONAL_SYMBOL,SymbolStatus),
	set_context(compiling_term_name),
	compile_head_pathexplist([Funct|Args],[FObj|AObj],ObjCode,H2BCodeHead,H2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    transactionaltermlit_struct(HEADLITERAL,FObj,N,AObj,TObj),
	    conjunct_struct(ObjCode,TObj,Code)
	;
	  true
        ),
	append(SymbolStatus,Status,CompileStatus).


/****************************************************************************
  compile_head_fllist(+ObjTermList,+ObjTerm,+Index,-Object,-Code,-H2BCodeHead,-H2BCodeTail,-Status)

  Index refers to '['.
****************************************************************************/
compile_head_fllist(ObjTermList,ObjTerm,Index,Object,Code,H2BCodeHead,H2BCodeTail,Status) :-
	compile_head_pathexplist(ObjTermList,ObjList,ObjListCode,ObjListH2BCodeHead,ObjListH2BCodeTail,S),
	( no_errors_found(S) -> 
	    ( ObjTerm == [] ->
		Obj=[],
		ObjCode=NULL,
		ObjH2BCodeHead=NULL,
		ObjH2BCodeTail=NULL,
		Status=[]
	    ;
	      compile_head_pathexp(ObjTerm,Obj,ObjCode,ObjH2BCodeHead,ObjH2BCodeTail,Status)
	    ),
	    ( no_errors_found(Status) -> 
		list_struct(ObjList,Obj,Index,Object),
		conjunct_struct(ObjListCode,ObjCode,Code),
		conjunct_code([ObjListH2BCodeHead,ObjH2BCodeHead],H2BCodeHead),
		conjunct_code([ObjListH2BCodeTail,ObjH2BCodeTail],H2BCodeTail)
	    ;
	      true
	    )
	;
	  Status=S
        ).


/****************************************************************************
  compile_head_pathexplist(+ParserTermList,-ObjectList,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
****************************************************************************/
compile_head_pathexplist([],[],NULL,NULL,NULL,[]) :- !.

compile_head_pathexplist([T|L],[TObj|LObj],Code,H2BCodeHead,H2BCodeTail,Status) :-
	compile_head_pathexp(T,TObj,TCode,TH2BCodeHead,TH2BCodeTail,S),
	clear_context(compiling_term_name),
	( no_errors_found(S) -> 
	    compile_head_pathexplist(L,LObj,LCode,LH2BCodeHead,LH2BCodeTail,S2),
	    ( no_errors_found(S2) -> 
		    conjunct_struct(TCode,LCode,Code),
		    conjunct_code([TH2BCodeHead,LH2BCodeHead],H2BCodeHead),
		    conjunct_code([TH2BCodeTail,LH2BCodeTail],H2BCodeTail),
		    merge_status([S,S2],Status)
	     ;
	      Status=S2)
	;
	  Status=S
        ).


/****************************************************************************
  compile_head_pathexp(+ParserTerm,-Object,-Code,-H2BCodeHead,-H2BCodeTail,-Status)

  Note: It is for skolemization.
****************************************************************************/
compile_head_pathexp(ParserTerm,Object,NULL,NULL,NULL,Status) :-
        ( is_fltransactionalatom(ParserTerm,_A) ->
	    check_symbol_name_for_clashes(ParserTerm,0,FUNCTION_SYMBOL,TRANSACTIONAL_SYMBOL,Status),
            transactionalatomobj_struct(ParserTerm,Object)

	; is_flnumber(ParserTerm,_N) ->
	    numobj_struct(ParserTerm,Object),
	    Status=[]

	; is_flvariable(ParserTerm,Name,Index) ->
	    compile_flvar(Name,Index,Object),
	    Status=[]

        ; is_fltransactionalvariable(ParserTerm,Name,Index) ->
            compile_fltransactionalvar_without_trans(Name,Index,Object),
	    Status=[]

	; is_flbuiltin_identifier(ParserTerm,_Ident) ->
	    check_symbol_name_for_clashes(ParserTerm,0,FUNCTION_SYMBOL,
					  NONTRANSACTIONAL_SYMBOL,Status),
	    builtin_identifier_struct(ParserTerm,Object)

	; is_fldatatype(ParserTerm,_Sort,_Lit,_Index) ->
	    datatypeobj_struct(ParserTerm,Object,Status)

	; is_flstring(ParserTerm,_S) ->
	    strobj_struct(ParserTerm,Object),
	    Status=[]

	; is_fltransactionalstring(ParserTerm,_S) ->
	    transactionalstrobj_struct(ParserTerm,Object),
	    Status=[]

	; is_fltoken(ParserTerm,Token,Index) ->
	    check_symbol_name_for_clashes(ParserTerm,0,FUNCTION_SYMBOL,
					  NONTRANSACTIONAL_SYMBOL,Status),
	    compile_head_fltoken(Token,Index,Object)

	; is_fltoken(ParserTerm,Token,Num,Index) ->      
	    check_symbol_name_for_clashes(ParserTerm,0,FUNCTION_SYMBOL,
					  NONTRANSACTIONAL_SYMBOL,Status),
	    compile_head_fltoken(Token,Num,Index,Object)
	),
	!.

compile_head_pathexp(ParserTerm,Object,Code,H2BCodeHead,H2BCodeTail,Status) :-
	( is_flatom(ParserTerm,_A) ->
	    Code=NULL,
	    H2BCodeTail=NULL,
	    compile_flatomobj(ParserTerm,0,Object,BodyHeadList,Status),
	    (BodyHeadList==[] ->
		    H2BCodeHead=NULL
	    ;
		    conjunct_code(BodyHeadList,H2BCodeHead)
	    )
	; 
	  is_flbirelate(ParserTerm,OT1,RelType,OT2) ->
	    compile_head_flbirelate(OT1,RelType,OT2,Object,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flobjspec(ParserTerm,ObjTerm,Spec) ->
	    compile_head_flobjspec(ObjTerm,Spec,Object,Code,H2BCodeHead,H2BCodeTail,Status)

        ; is_flobjref(ParserTerm,ObjTerm,RefType,AttTerm) -> 	 
            compile_head_flobjref(ObjTerm,RefType,AttTerm,Object,Code,H2BCodeHead,H2BCodeTail,Status) 	 

	; is_reifyop(ParserTerm,Formula) ->
	    %% Code: code to get Object
	    /* We could push fllibmodobj that creates reified statement
	       to the body. This would allow us to have reified statements with
	       var module in the head. However, this is hard to do: requires
	       changes to fllibmodobj. Test case:
	        p(${a(?X)@?M}) :- a(?X,?M).
		a(1,mmm).
		?- p(${a(?X)@mmm}).
	    %%compile_reifyop(Formula,Object,H2BCodeHead,Status),
	    %%Code = NULL,
	    */
	    compile_reifyop(Formula,Object,Code,Status),
	    H2BCodeHead = NULL,
	    H2BCodeTail = NULL

        ; is_fltransactionalterm(ParserTerm,Funct,N,Args) ->
	    compile_head_fltermobj(Funct,N,Args,Object,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_head_fltermobj(Funct,N,Args,Object,Code,H2BCodeHead,H2BCodeTail,Status)
        
	; is_fllist(ParserTerm,L,T,I) ->
	    compile_head_fllist(L,T,I,Object,Code,H2BCodeHead,H2BCodeTail,Status)
	;
	  is_flworkspace(ParserTerm,P,WS),
	  compile_head_wspathexp(P,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status)
        ).


/****************************************************************************
  compile_head_fltoken(+Token,+Index,-Object)

  Handles _#, _#123, _@, atoms
****************************************************************************/
compile_head_fltoken(Token,Index,Object) :-
	( Token == FL_NEWOID ->
	    new_oidobj(Index,Object)
        ; Token == FL_THISMODULE ->
	    thismodule_struct(Object)
        ;
	  atomobj_struct(Token,Index,Object)
	).

/****************************************************************************
  compile_head_fltoken(+Token,+Num,+Index,-Object)
****************************************************************************/
compile_head_fltoken(Token,Num,Index,Object) :-
        ( Token == FL_NEWOID ->
            flora_get_counter(RULE_NUM, Rule_num), 
	    new_oidobj(Rule_num,Num,Index,Object)
        ;
          atomobj_struct(Token,Index,Object)
        ).


/****************************************************************************
  compile_head_flobjref(+ObjT,+RefType,+AttT,-Object,-Code,-H2BCodeHead,-H2BCodeTail,-Status)

  Objref in the head is object specified by path expression.
  E.g., p(a.b) :- .... Translated as p(?Newvar) :- ..., a[b-> ?Newvar]
****************************************************************************/
compile_head_flobjref(ObjTerm,RefType,AttTerm,Object,Code,H2BCodeHead,H2BCodeTail,Status) :- 
        compile_head_pathexplist([ObjTerm,AttTerm],[Obj,Att],OACode,OAH2BCodeHead,OAH2BCodeTail,Status), 	 
	( no_errors_found(Status) -> 
            %% Approximate the textual information for the new variable.
            approx_flindex(AttTerm,Index), 	 
            head_objref_struct(Obj,RefType,Att,Index,Object,TCode),
	    OAH2BCodeHead = H2BCodeHead,
	    conjunct_code([OAH2BCodeTail,TCode],H2BCodeTail),
	    Code = OACode
        ; 	 
          true 	 
        ). 	 
 	 
 	 
/****************************************************************************
  compile_head_flbirelate(+OT1,+RelType,+OT2,-Object,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
****************************************************************************/
compile_head_flbirelate(ObjTerm1,RelType,ObjTerm2,Obj1,Code,H2BCodeHead,H2BCodeTail,Status) :-
	compile_head_pathexplist([ObjTerm1,ObjTerm2],[Obj1,Obj2],OCode,H2BCodeHead,H2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    birelate_struct(HEADLITERAL,Obj1,RelType,Obj2,TCode),
	    conjunct_struct(OCode,TCode,Code)
	;
	  true
        ).


/****************************************************************************
  compile_head_flobjspec(+ObjTerm,+SpecBody,-Object,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
    Objspec is defined in the BNF at the top of flrparser.P
    It is pathexpression[ specbody ]
****************************************************************************/
compile_head_flobjspec(ObjTerm,SpecBody,Object,Code,H2BCodeHead,H2BCodeTail,Status) :-
	( SpecBody == [] ->
	    compile_head_pathexp(ObjTerm,Object,ObjCode,H2BCodeHead,H2BCodeTail,Status),
	    ( no_errors_found(Status) -> 
		objexists_struct(HEADLITERAL,Object,ECode),
		conjunct_struct(ObjCode,ECode,Code)
	    ;
	      true
	    )
	;
	  compile_head_pathexp(ObjTerm,Object,ObjCode,ObjH2BCodeHead,ObjH2BCodeTail,S),
	  ( no_errors_found(S) -> 
	      compile_head_flspecbody(Object,SpecBody,SCode,SH2BCodeHead,SH2BCodeTail,Status),
	      ( no_errors_found(Status) -> 
		      conjunct_struct(ObjCode,SCode,Code),
		      conjunct_code([ObjH2BCodeHead,SH2BCodeHead],H2BCodeHead),
		      conjunct_code([ObjH2BCodeTail,SH2BCodeTail],H2BCodeTail)
	       ;
	       true)
	  ;
	    Status=S
	  )
        ).


/****************************************************************************
  compile_head_flspecbody(+Object,+SpecTerm,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
  compile_head_mvdattspec(+Object,+AttObj,+RefType,+VL,-Code,-H2BCodeHead,-H2BCodeTail,-Status)

  H2BCodeHead - code passed from head to body, which is supposed to be
                prepended to the code of the body
  H2BCodeTail - code passed from head to body, which is supposed to be
                appended to the code of the body
****************************************************************************/
compile_head_flspecbody(Object,SpecTerm,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flconjunct(SpecTerm,L,R),
	!,
	compile_head_flspecbody(Object,L,LCode,LH2BCodeHead,LH2BCodeTail,S),
	( no_errors_found(S) -> 
	    compile_head_flspecbody(Object,R,RCode,RH2BCodeHead,RH2BCodeTail,Status),
	    ( no_errors_found(Status) -> 
		    conjunct_struct(LCode,RCode,Code),
		    conjunct_code([LH2BCodeHead,RH2BCodeHead],H2BCodeHead),
		    conjunct_code([LH2BCodeTail,RH2BCodeTail],H2BCodeTail)
	     ;
	     true)
	;
	  Status=S
        ).

compile_head_flspecbody(Object,SpecTerm,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flneg(SpecTerm,G,Idx),
	!,
	compile_head_flspecbody(Object,G,GCode,H2BCodeHead,H2BCodeTail,S),
	( no_errors_found(S) -> 
	    neg_struct(GCode,Idx,Code,Status)
	; Status = S
	).

compile_head_flspecbody(Object,SpecTerm,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flmvdattspec(SpecTerm,AttTerm,RefType,VL),
	!,
	compile_head_pathexp(AttTerm,AObj,ACode,AH2BCodeHead,AH2BCodeTail,S),
	( no_errors_found(S) -> 
	    ( VL == [] ->
		mvdattdef_struct(HEADLITERAL,Object,AObj,RefType,SCode),
		conjunct_struct(ACode,SCode,Code),
		H2BCodeHead = AH2BCodeHead,
		H2BCodeTail = AH2BCodeTail,
		Status=[]
	    ;
	      compile_head_mvdattspec(Object,AObj,RefType,VL,VCode,VH2BCodeHead,VH2BCodeTail,Status),
		( no_errors_found(Status) -> 
		      conjunct_struct(ACode,VCode,Code),
		      conjunct_code([AH2BCodeHead,VH2BCodeHead],H2BCodeHead),
		      conjunct_code([AH2BCodeTail,VH2BCodeTail],H2BCodeTail)
	       ; true)
	    )
        ;
	  Status=S
        ).

%% signatures: =>, *=>, etc.
compile_head_flspecbody(Object,SpecTerm,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flsigattspec(SpecTerm,AttTerm,RefType,ValTerm),
	!,
	compile_head_pathexp(AttTerm,AttObj,ACode,AH2BCodeHead,AH2BCodeTail,S),
	( no_errors_found(S) -> 
	    (is_flemptyterm(ValTerm) ->
		%% This is SIGDEF: occurs when we have a[b=> ()]
		sigattdef_struct(HEADLITERAL,Object,AttObj,RefType,SCode),
		conjunct_struct(ACode,SCode,Code),
		H2BCodeHead = AH2BCodeHead,
		H2BCodeTail = AH2BCodeTail,
		Status=[]
	    ;
		compile_head_pathexp(ValTerm,ValObj,VCode,VH2BCodeHead,VH2BCodeTail,Status),
		( no_errors_found(Status) -> 
		    sigattspec_struct(HEADLITERAL,Object,AttObj,RefType,ValObj,SCode),
		    conjunct_code([SCode,ACode,VCode],Code),
		    conjunct_code([AH2BCodeHead,VH2BCodeHead],H2BCodeHead),
		    conjunct_code([AH2BCodeTail,VH2BCodeTail],H2BCodeTail)
		;
		    true
		)
	    )
	;
	    Status = S
        ).

compile_head_flspecbody(Object,SpecTerm,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flsigattconspec(SpecTerm,AttTerm,ConstrTerm,RefType,ValTerm),
	!,
	compile_head_pathexp(AttTerm,AttObj,ACode,AH2BCodeHead,AH2BCodeTail,S),
	( no_errors_found(S) -> 
	    (is_flemptyterm(ValTerm) ->
		%% This is SIGDEF: occurs when we have a[b=> ()]
		sigattdef_struct(HEADLITERAL,Object,AttObj,RefType,SCode),
		conjunct_struct(ACode,SCode,Code),
		H2BCodeHead = AH2BCodeHead,
		H2BCodeTail = AH2BCodeTail,
		Status=[]
	    ;
		is_flsigconstr(ConstrTerm,Lower,Upper),
		compile_head_pathexplist([Lower,Upper],[OLower,OUpper],CCode,CH2BCodeHead,CH2BCodeTail,S_C),
		( no_errors_found(S_C) -> 
		    compile_head_pathexp(ValTerm,ValObj,VCode,VH2BCodeHead,VH2BCodeTail,Status),
		    ( no_errors_found(Status) -> 
			sigattspec_struct(HEADLITERAL,Object,AttObj,RefType,ValObj,SCode),
			sigattcondef_struct(HEADLITERAL,Object,AttObj,OLower,OUpper,RefType,ValObj,CSCode),
			conjunct_code([SCode,CSCode,ACode,CCode,VCode],Code),
			conjunct_code([AH2BCodeHead,CH2BCodeHead,VH2BCodeHead],H2BCodeHead),
			conjunct_code([AH2BCodeTail,CH2BCodeTail,VH2BCodeTail],H2BCodeTail)
		    ;
			true
		    )
		;
		    Status = S_C
		)
	    )
	;
	    Status = S
        ).

%% boolean signatures: =>.
compile_head_flspecbody(Object,SpecTerm,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flboolsig(SpecTerm,AttTerm,_RefType),
	!,
	compile_head_pathexp(AttTerm,AttObj,ACode,H2BCodeHead,H2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    boolsig_struct(HEADLITERAL,Object,AttObj,SCode),
	    conjunct_struct(ACode,SCode,Code)
	;
	    true
	).

%% boolean signatures: *=>.
compile_head_flspecbody(Object,SpecTerm,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_fliboolsig(SpecTerm,AttTerm,_RefType),
	!,
	compile_head_pathexp(AttTerm,AttObj,ACode,H2BCodeHead,H2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    iboolsig_struct(HEADLITERAL,Object,AttObj,SCode),
	    conjunct_struct(ACode,SCode,Code)
	;
	    true
	).

%% boolean signatures: =>% for transactional method
compile_head_flspecbody(Object,SpecTerm,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_fltransig(SpecTerm,AttTerm,_RefType),
	!,
	compile_head_pathexp(AttTerm,AttObj,ACode,H2BCodeHead,H2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    transig_struct(HEADLITERAL,Object,AttObj,SCode),
	    conjunct_struct(ACode,SCode,Code)
	;
	    true
	).

%% boolean signatures: *=>% for transactional method
compile_head_flspecbody(Object,SpecTerm,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flitransig(SpecTerm,AttTerm,_RefType),
	!,
	compile_head_pathexp(AttTerm,AttObj,ACode,H2BCodeHead,H2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    itransig_struct(HEADLITERAL,Object,AttObj,SCode),
	    conjunct_struct(ACode,SCode,Code)
	;
	    true
	).

compile_head_flspecbody(Object,SpecTerm,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flmethspec(SpecTerm,MethTerm),
	!,
	compile_head_pathexp(MethTerm,MethObj,MCode,H2BCodeHead,H2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    methspec_struct(HEADLITERAL,Object,MethObj,SCode),
	    conjunct_struct(MCode,SCode,Code)
	;
	  true
        ).

compile_head_flspecbody(Object,SpecTerm,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flimethspec(SpecTerm,IMethTerm),
	!,
	compile_head_pathexp(IMethTerm,IMethObj,IMCode,H2BCodeHead,H2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    imethspec_struct(HEADLITERAL,Object,IMethObj,SCode),
	    conjunct_struct(IMCode,SCode,Code)
	;
	  true
        ).

compile_head_flspecbody(Object,SpecTerm,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_fltranspec(SpecTerm,TranTerm),
	!,
	compile_head_pathexp(TranTerm,TranObj,TCode,H2BCodeHead,H2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    transpec_struct(HEADLITERAL,Object,TranObj,SCode),
	    conjunct_struct(TCode,SCode,Code)
	;
	  true
        ).


compile_head_mvdattspec(_Object,_AttObj,_RefType,[],NULL,NULL,NULL,[]) :- !.

compile_head_mvdattspec(Object,AttObj,RefType,[T|L],Code,H2BCodeHead,H2BCodeTail,Status) :-
	!,
	compile_head_pathexp(T,TObj,TCode,TH2BCodeHead,TH2BCodeTail,S),
	( no_errors_found(S) -> 
	    compile_head_mvdattspec(Object,AttObj,RefType,L,LCode,LH2BCodeHead,LH2BCodeTail,Status),
	    ( no_errors_found(Status) -> 
		mvdattspec_struct(HEADLITERAL,Object,AttObj,RefType,TObj,SCode),
		conjunct_struct(LCode,SCode,LSCode),
		conjunct_struct(TCode,LSCode,Code),
		conjunct_code([TH2BCodeHead,LH2BCodeHead],H2BCodeHead),
		conjunct_code([TH2BCodeTail,LH2BCodeTail],H2BCodeTail)
	    ;
	      true
	    )
	;
	  Status=S
        ).


/****************************************************************************
  compile_head_flobjeql(+Obj1,+Obj2,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
  X :=: Y found in a rule head

  H2BCodeHead - code passed from head to body, which is supposed to be
                prepended to the code of the body
  H2BCodeTail - code passed from head to body, which is supposed to be
                appended to the code of the body
****************************************************************************/
compile_head_flobjeql(Obj1,Obj2,Code,H2BCodeHead,H2BCodeTail,Status) :-
	compile_head_pathexplist([Obj1,Obj2],[O1,O2],OCode,H2BCodeHead,H2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    objeql_struct(HEADLITERAL,O1,O2,OECode),
	    conjunct_struct(OCode,OECode,Code),
	    approx_flindex(Obj1,Idx),
	    report_option(FLOBJEQLDEF,Idx)
	;
	  true
	).


/****************************************************************************
  compile_head_flneg(+PosLit,+Idx,-Code,-H2BCodeHead,-H2BCodeTail,-Status)

  H2BCodeHead - code passed from head to body, which is supposed to be
                prepended to the code of the body
  H2BCodeTail - code passed from head to body, which is supposed to be
                appended to the code of the body
  neg Lit  found in a rule head
****************************************************************************/
compile_head_flneg(PosLit,Idx,Code,H2BCodeHead,H2BCodeTail,Status) :-
	compile_head_literal(PosLit,PosCode,H2BCodeHead,H2BCodeTail,Status1),
	( no_errors_found(Status1) -> 
	    head_neg_struct(PosCode,Idx,Code,Status)
	;
	  Status = Status1
	).


/****************************************************************************
  compile_floraliblit(+ParserTerm,+Workspace,+Nesting,-OidCode,-Code,?BodyHeadList,-Status)

  This procedure compiles a literal that is associated with a Flora system
  module specification.
 ?BodyHeadList - code to add at the beginning of the body
                 (mostly for user defined fnctions),
		 it is output argument, but if it is initialized to
		 empty ([]) ignores user defined functions
 +Nesting - needed for nested user defined functions
****************************************************************************/
compile_floraliblit(ParserTerm,WS,Nesting,OidCode,Code,BodyHeadList,Status) :-
	%% Flora system modules are like normal user modules except that
	%% users cannot load files into them
	is_flatom(WS,WSName,Index),
	report_option(FLSYSMOD(WSName),Index),
	atomobj_struct(WSName,Index,WSNameCode),
	floralib_struct(WSNameCode,WSCode),
	compile_wsliteral(ParserTerm,WSCode,Nesting,OidCode,Code,BodyHeadList,Status).


/****************************************************************************
  compile_wsliteral(+ParserTerm,+Workspace,+Nesting,-OidCode,-Code,?BodyHeadList,-Status)
  ?BodyHeadList - code to add at the beginning of the body
                  (mostly for user defined fnctions),
		  it is output argument, but if it is initialized to
		  empty ([]) ignores user defined functions
  +Nesting - needed for nested user defined functions
****************************************************************************/
%%compile_wsliteral(ParserTerm,WS,OidCode,WSCode,Status) :-
%%        compile_wsliteral(ParserTerm,WS,0,OidCode,WSCode,[],Status).
compile_wsliteral(ParserTerm,WS,Nesting,OidCode,WSCode,BodyHeadList,Status) :-
	( is_fltransactionalterm(ParserTerm,Funct,N,Args) ->
	    compile_wstransactionaltermlit(Funct,N,Args,WS,Nesting,OidCode,WSCode,BodyHeadList,Status)

	; is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_wstermlit(Funct,N,Args,WS,Nesting,OidCode,WSCode,BodyHeadList,Status)

	; is_flvariable(ParserTerm,VarName,Index) ->
	    BodyHeadList = [],
	    %% Is this possible? Should be taken care by the libmodlit code
	    attach_workspace(WS,
			     compile_flvar(VarName,Index,VarCode),
			     VarCode,WSCode),
	    OidCode = NULL,
	    Status = []

	; is_fltransactionalvariable(ParserTerm,VarName,Index) ->
	    BodyHeadList = [],
	    %% Is this possible? Should be taken care by the libmodlit code
	    attach_workspace(WS,
			     compile_fltransactionalvar(VarName,Index,VarCode),
			     VarCode,WSCode),
	    OidCode = NULL,
	    Status = []

	; is_flbirelate(ParserTerm,ObjTerm1,RelType,ObjTerm2) ->
	    BodyHeadList = [],
	    compile_wsflbirelate(ObjTerm1,RelType,ObjTerm2,WS,_Obj,OidCode,WSCode,Status)

	; is_flobjspec(ParserTerm,ObjTerm,Spec) ->
	    compile_wsflobjspec(ObjTerm,Spec,WS,_Obj,OidCode,WSCode,BodyHeadList,Status)

	; is_flobjeql(ParserTerm,O1,O2) ->
	    BodyHeadList = [],
	    compile_wsflobjeql(O1,O2,WS,OidCode,WSCode,Status)

	; is_fldirective(ParserTerm,DirectList,_Idx) ->
	    BodyHeadList = [],
	    compile_exec_directive(DirectList,WS,WSCode,Status),
	    OidCode=NULL
	;
	    BodyHeadList = [],
	    attach_workspace(WS,
			     atomlit_struct(BODYLITERAL,ParserTerm,Code),
			     Code,WSCode),
	    check_symbol_name_for_clashes(ParserTerm,0,WS,FUNCTION_SYMBOL,
					  NONTRANSACTIONAL_SYMBOL,Status),
	    OidCode=NULL
	;
	    BodyHeadList = [],
	    attach_workspace(WS,
			     transactionalatomlit_struct(BODYLITERAL,ParserTerm,Code),
			     Code,WSCode),
	    check_symbol_name_for_clashes(ParserTerm,0,WS,FUNCTION_SYMBOL,TRANSACTIONAL_SYMBOL,Status),
	    OidCode=NULL
	).


/****************************************************************************
  compile_floralibobj(+ParserTerm,+Workspace,-Object,-OidCode,-Code,-Status)
****************************************************************************/
compile_floralibobj(ParserTerm,WS,Object,OidCode,Code,Status) :-
	is_flatom(WS,WSName,Index),
	report_option(FLSYSMOD(WSName),Index),
	atomobj_struct(WSName,Index,WSNameCode),
	floralib_struct(WSNameCode,WSCode),
	compile_wspathexp(ParserTerm,WSCode,Object,OidCode,Code,Status).


/****************************************************************************
  compile_wspathexp(+ParserTerm,+Workspace,-Object,-OidCode,-Code,-BodyHeadList,-Status)
****************************************************************************/
compile_wspathexp(ParserTerm,WS,Object,OidCode,Code,Status) :-
	compile_wspathexp(ParserTerm,WS,Object,OidCode,Code,[],Status).

compile_wspathexp(ParserTerm,WS,Object,OidCode,Code,BodyHeadList,Status) :-
	(
	  %% case of pred(%pathexp@mod), e.g., p(%a.b.c@foo)
	  is_fltransactionalterm(ParserTerm,Funct,N,Args) ->
	    compile_wstransactionaltermobj(Funct,N,Args,WS,Object,OidCode,Code,BodyHeadList,Status)

	%% case of pred(pathexp@mod), e.g., p(a.b.c@foo)
	; is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_wstermobj(Funct,N,Args,WS,Object,OidCode,Code,BodyHeadList,Status)

	; is_flarith(ParserTerm,StrippdParseTerm) ->
	  set_context(compiling_arithmetics),
	  compile_wspathexp(StrippdParseTerm,WS,Object,OidCode,Code,BodyHeadList,Status),
	  clear_context(compiling_arithmetics)

	%% case like a[b->c:d@foo]
	; is_flbirelate(ParserTerm,ObjTerm1,RelType,ObjTerm2) ->
	    BodyHeadList = [],
	    compile_wsflbirelate(ObjTerm1,RelType,ObjTerm2,WS,Object,OidCode,Code,Status)

	%% case like a[b->c[d->e]@foo]
	; is_flobjspec(ParserTerm,ObjTerm,Spec) ->
	    compile_wsflobjspec(ObjTerm,Spec,WS,Object,OidCode,Code,BodyHeadList,Status)

	%% pred(X@...)
	%% Note: We have to create code to compute X@..., so we put
	%% this code in OidCode so that it would precede the code for pred(...)
	; is_flvariable(ParserTerm,VarName,VarIndex) ->
	    BodyHeadList = [],
	    compile_flvar(VarName,VarIndex,VarCode),
	    workspaceobj_struct(VarCode,WS,Object,OidCode),
	    Code=NULL,
	    Status = []
	;
	  is_flobjref(ParserTerm,ObjTerm,RefType,AttTerm),
	  BodyHeadList = [],
	  compile_wsflobjref(ObjTerm,RefType,AttTerm,WS,Object,OidCode,Code,Status)

	; %% pred(Term@...) in body. Not allowed without explicit reification 
	  approx_flindex(ParserTerm,Index),
	  compiling_error(Index,NO_WORKSPACE,Err),
	  Status = [Err]
	  /*
	  atomlit_struct(BODYLITERAL,ParserTerm,A) ->
	  workspaceobj_struct(A,WS,Object,OidCode),
	  Code=NULL,
	  BodyHeadList = [],
	  Status=[]

	; transactionalatomlit_struct(BODYLITERAL,ParserTerm,A) ->
	    BodyHeadList = [],
	    workspaceobj_struct(A,WS,Object,OidCode),
	    Code=NULL,
	    Status=[]
	*/
	).


/****************************************************************************
  compile_wsflpathexplist(+ParserTermList,+Workspace,+Nesting,-ObjectList,-OidCode,-Code,?BodyHeadList,-Status)
  ?BodyHeadList - code to add at the beginning of the body
                  (mostly for user defined fnctions),
		  it is output argument, but if it is initialized to
		  empty ([]) ignores user defined functions
  +Nesting - needed for nested user defined functions
****************************************************************************/
compile_wsflpathexplist([],_WS,_Nesting,[],NULL,NULL,[],[]).

compile_wsflpathexplist(TermList,WS,ObjectList,OidCode,Code,Status) :-
	compile_wsflpathexplist(TermList,WS,0,ObjectList,OidCode,Code,[],Status).

compile_wsflpathexplist(TermList,WS,ObjectList,OidCode,Code,BodyHeadList,Status) :-
	compile_wsflpathexplist(TermList,WS,0,ObjectList,OidCode,Code,BodyHeadList,Status).

compile_wsflpathexplist([T|L],WS,Nesting,[TObj|LObj],OidCode,Code,BodyHeadList,Status) :-
	(var(BodyHeadList) -> true ; BodyHeadList1=[],BodyHeadList2=[]),
	compile_wsflpathexp(T,WS,Nesting,TObj,OidCodeHead,TCode,BodyHeadList1,S),
	clear_context(compiling_term_name),
	( no_errors_found(S) -> 
	    compile_wsflpathexplist(L,WS,Nesting,LObj,OidCodeTail,LCode,BodyHeadList2,S2),
	    ( var(BodyHeadList) ->
		append(BodyHeadList1,BodyHeadList2,BodyHeadList)
	    ;
		true
	    ),
	    ( no_errors_found(S2) -> 
		conjunct_code([TCode,LCode],Code),
		conjunct_code([OidCodeHead,OidCodeTail],OidCode),
		merge_status([S,S2],Status)
	    ; Status=S2
	    )
	;
	  Status=S
        ).


/****************************************************************************
  compile_wsflpathexp(+ParserTerm,+Workspace,+Nesting,-Object,-OidCode,-Code,?BodyHeadList,-Status)

  Note: The difference between compile_wsflpathexp and compile_wspathexp
        is that compile_wsflpathexp applies workspace only to F-Logic
        constructs.
  ?BodyHeadList - code to add at the beginning of the body
                  (mostly for user defined fnctions),
		  it is output argument, but if it is initialized to
		  empty ([]) ignores user defined functions
  +Nesting - needed for nested user defined functions
****************************************************************************/
compile_wsflpathexp(ParserTerm,WS,Object,OidCode,Code,Status) :-
	compile_wsflpathexp(ParserTerm,WS,0,Object,OidCode,Code,[],Status). 

compile_wsflpathexp(ParserTerm,WS,Object,OidCode,Code,BodyHeadList,Status) :-
	compile_wsflpathexp(ParserTerm,WS,0,Object,OidCode,Code,BodyHeadList,Status). 

compile_wsflpathexp(ParserTerm,WS,Nesting,Object,OidCode,Code,BodyHeadList,Status) :-
	( is_flobjref(ParserTerm,ObjTerm,RefType,AttTerm) ->
	    BodyHeadList = [],
	    compile_wsflobjref(ObjTerm,RefType,AttTerm,WS,Object,OidCode,Code,Status)

	; is_flobjspec(ParserTerm,ObjTerm,Spec) ->
	    compile_wsflobjspec(ObjTerm,Spec,WS,Object,OidCode,Code,BodyHeadList,Status)

	; is_flbirelate(ParserTerm,ObjTerm1,RelType,ObjTerm2) ->
	    BodyHeadList = [],
	    compile_wsflbirelate(ObjTerm1,RelType,ObjTerm2,WS,Object,OidCode,Code,Status)

	; is_fltransactionalterm(ParserTerm,Funct,N,Args) ->
	    compile_wsfltermobj(Funct,N,Args,WS,Nesting,Object,OidCode,Code,BodyHeadList,TRANSACTIONAL_SYMBOL,Status)

	; is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_wsfltermobj(Funct,N,Args,WS,Nesting,Object,OidCode,Code,
				BodyHeadList,NONTRANSACTIONAL_SYMBOL,Status)

	; is_flarith(ParserTerm,StrippdParseTerm) ->
	    set_context(compiling_arithmetics),
	    compile_wsflpathexp(StrippdParseTerm,WS,Object,OidCode,Code,Status),
	    clear_context(compiling_arithmetics)

	; is_fllist(ParserTerm,L,T,I) ->
	    compile_wsfllist(L,T,I,WS,Nesting,Object,OidCode,Code,BodyHeadList,Status)

	; is_flworkspace(ParserTerm,P,NestedWS) ->
	    compile_wspathexp(P,NestedWS,Object,OidCode,Code,BodyHeadList,Status)

	;
	  %% workspace not distributive over nested aggregates
	  compile_pathexp(ParserTerm,Nesting,Object,OidCode,Code,BodyHeadList,Status)
        ).


/****************************************************************************
  compile_wstermobj(+FunctorTerm,+Arity,+ArgList,+Workspace,-Object,-OidCode,-Code,-BodyHeadList,-Status)
****************************************************************************/
compile_wstermobj(Funct,N,Args,WS,Object,OidCode,Code,BodyHeadList,Status) :-
	(is_fltransactionalatom(Funct,_)
	-> Transactionality = TRANSACTIONAL_SYMBOL
	; Transactionality = NONTRANSACTIONAL_SYMBOL
	),
	check_symbol_name_for_clashes(Funct,N,WS,FUNCTION_SYMBOL,Transactionality,SymbolStatus),
	set_context(compiling_term_name),
	compile_wsflpathexplist([Funct|Args],WS,[FObj|AObj],OidCode,TCode,BodyHeadList,CompileStatus),
	( no_errors_found(Status) -> 
	    termlit_struct(BODYLITERAL,FObj,N,AObj,O),
	    workspaceobj_struct(O,WS,Object,WCode),
	    conjunct_code([TCode,WCode],Code)
	;
	  true
        ),
	append(SymbolStatus,Status,CompileStatus).

compile_wstransactionaltermobj(Funct,N,Args,WS,Object,OidCode,Code,BodyHeadList,CompileStatus) :-
	check_symbol_name_for_clashes(Funct,N,WS,FUNCTION_SYMBOL,TRANSACTIONAL_SYMBOL,SymbolStatus),
	set_context(compiling_term_name),
	compile_wsflpathexplist([Funct|Args],WS,[FObj|AObj],OidCode,TCode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    transactionaltermlit_struct(BODYLITERAL,FObj,N,AObj,O),
	    workspaceobj_struct(O,WS,Object,WCode),
	    conjunct_code([TCode,WCode],Code)
	;
	  true
        ),
	append(SymbolStatus,Status,CompileStatus).


/****************************************************************************
  compile_wsfltermobj(+FunctorTerm,+Arity,+ArgList,+Workspace,+Nesting,-Object,-OidCode,-Code,?BodyHeadList,Transactional,-Status)

  Note: The difference between compile_wsfltermobj and compile_wstermobj
        is that compile_wsfltermobj applies workspace only to F-Logic
        constructs.  
  ?BodyHeadList - code to add at the beginning of the body
                  (mostly for user defined fnctions),
		  it is output argument, but if it is initialized to
		  empty ([]) ignores user defined functions
  +Nesting - needed for nested user defined functions
  Transactional - flag if Funct is transactional
			can be TRANSACTIONAL_SYMBOL or NONTRANSACTIONAL_SYMBOL
****************************************************************************/
compile_wsfltermobj(Funct,N,Args,WS,Nesting,Object,OidCode,Code,BodyHeadList,Transactional,CompileStatus) :-
	var(BodyHeadList),
	!,
        ( \+ has_context(compiling_arithmetics),
	    flora_get_flatomvar_name(Funct,Name),
	    has_user_defined_function(Name,N,FArgs,Predicate,ReturnValue)
	->
	    OidCode=NULL,
	    Code=NULL,
	    new_prvariable(NO_INDEX,Object),
	    prvar_to_flvar_struct(Object,Var),
	    approx_flindex(Funct,Index),
	    formUDFVarSubstitute([Var|Args],[ReturnValue|FArgs],Nesting,Index),
	    compile_body_literal(Predicate,Nesting,PCode,PBodyHeadList,S),
	    clearUDFVarSubstitute(Nesting),
	    SymbolContext = UDF_SYMBOL,
	    ( no_errors_found(S) -> 
		append(PBodyHeadList,[PCode],BodyHeadList),
		Status=[]
	    ;
		approx_flindex(Funct,Index),
		compiling_error(Index,ERROR_UDF_COMPILE,Err),
		Status = [Err|S]
	    )
        ;
	    set_context(compiling_term_name),
	    compile_wsflpathexplist([Funct|Args],WS,Nesting,[FObj|AObj],OidCode,Code,BodyHeadList,Status),
	    SymbolContext = FUNCTION_SYMBOL,
	    ( no_errors_found(Status) -> 
		termobj_struct(FObj,N,AObj,Object); true)
        ),
	check_symbol_name_for_clashes(Funct,N,WS,SymbolContext,Transactional,SymbolStatus),
	append(SymbolStatus,Status,CompileStatus).

compile_wsfltermobj(Funct,N,Args,WS,Nesting,Object,OidCode,Code,[],Transactional,CompileStatus) :-
	check_symbol_name_for_clashes(Funct,N,WS,FUNCTION_SYMBOL,Transactional,SymbolStatus),
	set_context(compiling_term_name),
	compile_wsflpathexplist([Funct|Args],WS,Nesting,[FObj|AObj],OidCode,Code,_BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    termobj_struct(FObj,N,AObj,Object); true),
	append(SymbolStatus,Status,CompileStatus).

/****************************************************************************
  compile_wstermlit(+FunctorTerm,+Arity,+ArgList,+Workspace,+Nesting,-OidCode,-Code,?BodyHeadList,-Status)
  ?BodyHeadList - code to add at the beginning of the body
                  (mostly for user defined fnctions),
		  it is output argument, but if it is initialized to
		  empty ([]) ignores user defined functions
  +Nesting - needed for nested user defined functions
****************************************************************************/
compile_wstermlit(_Funct,_N,_Args,WS,_Nesting,_OidCode,_Code,_BHList,Status) :-
	is_flvariable(WS,_Name,VarIndex),
	has_context(compiling_headliteral),
	!,
	compiling_error(VarIndex,VARWSINHEAD,Err),
	Status = [Err].

compile_wstermlit(Funct,N,Args,WS,Nesting,OidCode,Code,BodyHeadList,CompileStatus) :-
	(is_fltransactionalatom(Funct,_)
	-> Transactionality = TRANSACTIONAL_SYMBOL
	; Transactionality = NONTRANSACTIONAL_SYMBOL
	),
	check_symbol_name_for_clashes(Funct,N,WS,PREDICATE_SYMBOL,Transactionality,SymbolStatus),
	set_context(compiling_term_name),
	compile_wsflpathexplist([Funct|Args],WS,Nesting,[FObj|AObj],OidCode,ObjCode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     termlit_struct(BODYLITERAL,FObj,N,AObj,TCode),
			     TCode,WSCode),
	    conjunct_code([WSCode,ObjCode],Code)
	;
	  true
        ),
	append(SymbolStatus,Status,CompileStatus).

compile_wstransactionaltermlit(Funct,N,Args,WS,Nesting,OidCode,Code,BodyHeadList,CompileStatus) :-
	check_symbol_name_for_clashes(Funct,N,WS,PREDICATE_SYMBOL,TRANSACTIONAL_SYMBOL,SymbolStatus),
	set_context(compiling_term_name),
	compile_wsflpathexplist([Funct|Args],WS,Nesting,[FObj|AObj],OidCode,ObjCode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     transactionaltermlit_struct(BODYLITERAL,FObj,N,AObj,TCode),
			     TCode,WSCode),
	    conjunct_code([WSCode,ObjCode],Code)
	;
	  true
        ),
	append(SymbolStatus,Status,CompileStatus).

/****************************************************************************
  compile_wsfllist(+ObjTermList,+ObjTerm,+Index,+WS,+Nesting,-Object,-OidCode,-Code,?BodyHeadList,-Status)
    Lists are like this: [a,b,c|rest]
    ObjTermList refers to the list [a,b,c] and ObjTerm to rest.

 +Nesting - needed for nested user defined functions
 ?BodyHeadList - code to add at the beginning of the body
                 (mostly for user defined fnctions),
		 it is output argument, but if it is initialized to empty ([]) ignores user defined functions
****************************************************************************/
compile_wsfllist(ObjTermList,ObjTerm,Index,WS,Nesting,Object,OidCode,Code,BodyHeadList,Status) :-
	(var(BodyHeadList) -> true; BodyHeadList1=[],BodyHeadList2=[]),
	compile_wsflpathexplist(ObjTermList,WS,Nesting,ObjList,OidCodeList,ObjListCode,BodyHeadList1,S),
	( no_errors_found(S) -> 
	    ( ObjTerm == [] ->
		BodyHeadList=BodyHeadList1,
		Obj=[],
		ObjCode=NULL,
		Status=[]
	    ;
	      compile_wsflpathexp(ObjTerm,WS,Nesting,Obj,OidCodeObj,ObjCode,BodyHeadList2,Status),
	      ( var(BodyHeadList) ->
		append(BodyHeadList1,BodyHeadList2,BodyHeadList)
	      ;
		true
	      )
	    ),
	    ( no_errors_found(Status) -> 
		list_struct(ObjList,Obj,Index,Object),
		conjunct_code([ObjListCode,ObjCode],Code),
		conjunct_code([OidCodeList,OidCodeObj],OidCode)
	    ;
	      true
	    )
	;
	  Status=S
        ).


/****************************************************************************
  compile_wsflobjref(+ObjTerm,+RefType,+AttTerm,+Workspace,-Object,-OidCode,-Code,-Status)

  Process an object reference like a.b.c@module
  An objref can be more complex, e.g., a[f->g].b[h->p].c[k->u]@module
****************************************************************************/
compile_wsflobjref(ObjTerm,RefType,AttTerm,WS,Object,OidCode,Code,Status) :-
	compile_wsflpathexplist([ObjTerm,AttTerm],WS,[Obj,Att],OidCodeList,OACode,Status),
	( no_errors_found(Status) -> 
	    %% Approximate the textual information for the new variable.
	    approx_flindex(AttTerm,Index),
	    attach_workspace(WS,
			    body_objref_struct(Obj,RefType,Att,Index,Object,TCode),
			     TCode,WTCode),
	    Code = OACode,
	    conjunct_code([OidCodeList,WTCode],OidCode)
	;
	  true
        ).


/****************************************************************************
  compile_wsflbirelate(+ObjTerm1,+RelType,+ObjTerm2,+Workdpace,-Object,-OidCode,-Code,-Status)
****************************************************************************/
compile_wsflbirelate(ObjTerm1,RelType,ObjTerm2,WS,Obj1,OidCode,Code,Status) :-
	compile_wsflpathexplist([ObjTerm1,ObjTerm2],WS,[Obj1,Obj2],OidCode,OCode,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     birelate_struct(BODYLITERAL,Obj1,RelType,Obj2,TCode),
			     TCode,WTCode),
	    conjunct_code([WTCode,OCode],Code)
	;
	  true
        ).


/****************************************************************************
  compile_wsflobjspec(+ObjTerm,+SpecBody,+Workspace,-Object,-OidCode,-Code,-BodyHeadList,-Status)

  Code produced by this and similar predicates is divided into
  OidCode and Code. 
  OidCode is the code needed to compute the attribute of molecule
  and the oid, and the oid of the value part (in ->, *->, etc.)
  Code represents the code needed to compute the the attribute specification.
  For instance, in  a.b[c.d->e.f],
      OidCode will represent the computation of a.b, c.d, and e.f:
	 prand(prmvd(a,b,_newvar1),prand(prmvd(c,d,_newvar2),prmvd(e,f,_newvar3)))
      Code will represent the -> part:
                 prmvd(_newvar1,_newvar2,_newvar3)
****************************************************************************/
compile_wsflobjspec(ObjTerm,SpecBody,WS,Object,OidCode,Code,BodyHeadList,Status) :-
	( SpecBody == [] ->
	    ( is_flobjref(ObjTerm,OTerm,RefType,ATerm) ->
		compile_wsflpathexplist([OTerm,ATerm],WS,[OObj,AObj],OidCode,ObjCode,BodyHeadList,Status),
		( Status == [] ->
		    approx_flindex(ATerm,Index),
		    attach_workspace(WS,
				     body_objref_struct(OObj,RefType,AObj,Index,Object,TCode),
				     TCode,WTCode),
		    conjunct_code([WTCode,ObjCode],Code)
		;
		  true
	        )
	    ;
		%% object exists test: a.b.c[]@module
		compile_wsflpathexp(ObjTerm,WS,Object,OidCode,ObjCode,BodyHeadList,Status),
		( no_errors_found(Status) -> 
		    attach_workspace(WS,
				     objexists_struct(BODYLITERAL,Object,ECode),
				     ECode,WSECode),
		    conjunct_code([WSECode,ObjCode],Code)
		;
		    true
		)
	    )
	; % oid spec plus object spec. something like a.b[c->d]@module
	  compile_wsflpathexp(ObjTerm,WS,Object,ObjOidCode,ObjCode,BodyHeadList1,S),
	  ( no_errors_found(S) -> 
	      compile_wsflspecbody(Object,SpecBody,WS,SpecOidCode,SpecCode,BodyHeadList2,Status),
	      ( no_errors_found(Status) -> 
		  conjunct_code([ObjCode,SpecCode],Code),
		  conjunct_code([ObjOidCode,SpecOidCode],OidCode)
	      ; 
		  true
	      ),
	      append(BodyHeadList1,BodyHeadList2,BodyHeadList)
	  ;
	    BodyHeadList = BodyHeadList1,
	    Status=S
          )
        ).


/****************************************************************************
  compile_wsflspecbody(+Object,+SpecTerm,+Workspace,-OidCode,-Code,-BodyHeadList,-Status)
****************************************************************************/
compile_wsflspecbody(Object,SpecTerm,WS,OidCode,Code,BodyHeadList,Status) :-
	is_flconjunct(SpecTerm,L,R),
	!,
	compile_wsflspecbody(Object,L,WS,OidCode,LCode,BodyHeadList1,S),
	( no_errors_found(S) -> 
	    compile_wsflspecbody(Object,R,WS,OidCode,RCode,BodyHeadList2,Status),
	    ( no_errors_found(Status) -> 
		conjunct_code([LCode,RCode],Code); true),
	    append(BodyHeadList1,BodyHeadList2,BodyHeadList)
	;
	  Status=S
        ).

compile_wsflspecbody(Object,SpecTerm,WS,OidCode,Code,BodyHeadList,Status) :-
	is_fldisjunct(SpecTerm,L,R),
	!,
	compile_wsflspecbody(Object,L,WS,OidCode,LCode,BodyHeadList1,S),
	( no_errors_found(S) -> 
	    compile_wsflspecbody(Object,R,WS,OidCode,RCode,BodyHeadList2,Status),
	    ( no_errors_found(Status) -> 
		disjunct_struct(LCode,RCode,Code); true),
	    append(BodyHeadList1,BodyHeadList2,BodyHeadList)
	;
	  Status=S
        ).

compile_wsflspecbody(Object,SpecTerm,WS,OidCode,Code,BodyHeadList,Status) :-
	is_flnaf(SpecTerm,G),
	!,
	compile_wsflspecbody(Object,G,WS,OidCode,GCode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    conjunct_code([OidCode,GCode],CombinedGCode),
	    prolog_naf_struct(CombinedGCode,Code)
	; true
	).

compile_wsflspecbody(Object,SpecTerm,WS,OidCode,Code,BodyHeadList,Status) :-
	is_flneg(SpecTerm,G,Idx),
	!,
	compile_wsflspecbody(Object,G,WS,OidCode,GCode,BodyHeadList,Status1),
	( no_errors_found(Status1) -> 
	    conjunct_code([OidCode,GCode],CombinedGCode),
	    neg_struct(CombinedGCode,Idx,Code,Status)
	; Status = Status1
	).

compile_wsflspecbody(Object,SpecTerm,WS,OidCode,Code,BodyHeadList,Status) :-
	is_flnot(SpecTerm,G),
	!,
	set_context(compiling_default_negation),
	compile_wsflspecbody(Object,G,WS,OidCode,GCode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    conjunct_code([OidCode,GCode],CombinedGCode),
	    flora_naf_struct(CombinedGCode,Code)
	; true
	),
	set_context(compiling_default_negation).

%% Quantification under default negation
compile_wsflspecbody(Object,SpecTerm,WS,OidCode,Code,BodyHeadList,Status) :-
	is_fllogicquantifier(SpecTerm,FL_EXISTS,QuantVarNames,Formula,Idx),
	has_context(compiling_default_negation),
	!,
	%% no quantified don't care vars (?,?_) 
	(memberchk(FL_UNDERSCORE,QuantVarNames) ->
	    compiling_error(Idx,NO_QUANTIFIED_ANONVARS,Err1),
	    S1 = [Err1]
	; S1 = []
	),

	compile_wsflspecbody(Object,Formula,WS,OidCode,FormCode,BodyHeadList,S2),
	%% We use prvars so that newly introduced vars will be accounted for
	collect_prvars([Object,OidCode,FormCode],AllVarList),
	vars_to_var_names(AllVarList,AllVarList_names),
	%% quantified vars must occur in Formula
	(subset(QuantVarNames,AllVarList_names) -> S3 = []
	; compiling_error(Idx,QUANT_VARS_NOT_SUBSET,Err3),
	    S3 = [Err3]
	),

	subtract_vars(AllVarList,QuantVarNames,FreeVarObjs_aux),
	%% remove don't care vars, since no need to delay because of them
	remove_prdontcare_vars(FreeVarObjs_aux,FreeVarObjs_aux2),
	remove_caller_vars(FreeVarObjs_aux2,FreeVarObjs),
	
	rename_prvariables(QuantVarNames,FormCode,
			   RenamedFormCode,_RenamedQuantVars),

	merge_status([S1,S2,S3],Status),
	( no_errors_found(Status) -> 
	    %% Create the code for compiled quantification.
	    conjunct_code([OidCode,RenamedFormCode],CombinedCode),
	    quantifier_struct(FL_EXISTS,CombinedCode,FreeVarObjs,Code)
	;
	    true
	).


%% OidCodeList below gets bound to code needed to produce
%% the attribute (M) and the value (V). We conjunct this code in front of the
%% code for the molecule
%% NULL means tht we don't pass OID code out, because we use it right here.

%% No OidCode is passed outside: we consume it here
compile_wsflspecbody(Object,SpecTerm,WS,NULL,Code,BodyHeadList,Status) :-
	is_flmvdattspec(SpecTerm,AttTerm,RefType,ValTermList),
	!,
	compile_wsflpathexp(AttTerm,WS,AttObj,AOidCode,ACode,BodyHeadList,S),
	( no_errors_found(S) -> 
	    ( ValTermList == [] ->
		attach_workspace(WS,
				 mvdattdef_struct(BODYLITERAL,Object,AttObj,RefType,SCode),
				 SCode,WSCode),
		%% Fold OidCode in front of molecule
		conjunct_code([AOidCode,ACode,WSCode],Code),
		Status=[]
	    ;
	      compile_wsmvdattspec(Object,AttObj,RefType,ValTermList,WS,VOidCode,WSCode,Status),
	      ( no_errors_found(Status) -> 
		  %% ACode: Code to produce attribute
		  %% WSCode: code to produce pure attr specs and 
		  %%         the objects that represents the values
		  conjunct_code([AOidCode,VOidCode,ACode,WSCode],Code)
	      ; true
	      )
	    )
        ;
	  Status=S
        ).

%% signatures: =>, *=>, etc.
compile_wsflspecbody(Object,SpecTerm,WS,NULL,Code,BodyHeadList,Status) :-
	is_flsigattspec(SpecTerm,AttTerm,RefType,ValTerm),
	!,
	compile_wsflpathexp(AttTerm,WS,AttObj,AOidCode,ACode,BodyHeadList1,S),
	( no_errors_found(S) -> 
	    (is_flemptyterm(ValTerm) ->
		%% This is SIGDEF: occurs when we have a[b=> ()]
		attach_workspace(WS,
				 sigattdef_struct(BODYLITERAL,Object,AttObj,RefType,SCode),
				 SCode,WSCode),
		conjunct_code([AOidCode,ACode,WSCode],Code),
		Status=[],
		BodyHeadList = BodyHeadList1
	    ;
		compile_wsflpathexp(ValTerm,WS,ValObj,VOidCode,VCode,BodyHeadList2,Status),
		( no_errors_found(Status) -> 
		    attach_workspace(WS,
				     sigattspec_struct(BODYLITERAL,Object,AttObj,RefType,ValObj,SCode),
				     SCode,WSCode),
		    conjunct_code([AOidCode,VOidCode,ACode,VCode,WSCode],Code)
		;
		    true
		),
		append(BodyHeadList1,BodyHeadList2,BodyHeadList)
	    )
	;
	    BodyHeadList = BodyHeadList1,
	    Status = S
        ).

compile_wsflspecbody(Object,SpecTerm,WS,NULL,Code,BodyHeadList,Status) :-
	is_flsigattconspec(SpecTerm,AttTerm,ConstrTerm,RefType,ValTerm),
	!,
	compile_wsflpathexp(AttTerm,WS,AttObj,AOidCode,ACode,BodyHeadList1,S),
	( no_errors_found(S) -> 
	    (is_flemptyterm(ValTerm) ->
		%% This is SIGDEF: occurs when we have a[b=> ()]
		attach_workspace(WS,
				 sigattdef_struct(BODYLITERAL,Object,AttObj,RefType,SCode),
				 SCode,WSCode),
		conjunct_code([AOidCode,ACode,WSCode],Code),
		Status=[],
		BodyHeadList = BodyHeadList1
	    ;
		is_flsigconstr(ConstrTerm,Lower,Upper),
		compile_wsflpathexplist([Lower,Upper],WS,[OLower,OUpper],COidCode,CCode,BodyHeadList2,S_C),
		( no_errors_found(S_C) -> 
		    compile_wsflpathexp(ValTerm,WS,ValObj,VOidCode,VCode,BodyHeadList3,Status),
		    ( no_errors_found(Status) -> 
			attach_workspace(WS,
					 sigattspec_struct(BODYLITERAL,Object,AttObj,RefType,ValObj,SCode),
					 SCode,WSCode),
			attach_workspace(WS,
					 sigattconstr_struct(BODYLITERAL,Object,AttObj,OLower,OUpper,RefType,CSCode),
					 CSCode,CWSCode),
			conjunct_code([AOidCode,VOidCode,ACode,VCode,WSCode,COidCode,CCode,CWSCode],Code)
		    ;
			true
		    )
		;
		    Status = S_C
		),
		append(BodyHeadList1,BodyHeadList2,BodyHeadList4),
		append(BodyHeadList4,BodyHeadList3,BodyHeadList)
	    )
	;
	    BodyHeadList = BodyHeadList1,
	    Status = S
        ).

%% boolean signatures: =>.
compile_wsflspecbody(Object,SpecTerm,WS,NULL,Code,BodyHeadList,Status) :-
	is_flboolsig(SpecTerm,AttTerm,_RefType),
	!,
	compile_wsflpathexp(AttTerm,WS,AttObj,AOidCode,ACode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     boolsig_struct(BODYLITERAL,Object,AttObj,SCode),
			     SCode,WSCode),
	    conjunct_code([AOidCode,ACode,WSCode],Code)
	;
	    true
	).

%% boolean signatures: *=>.
compile_wsflspecbody(Object,SpecTerm,WS,NULL,Code,BodyHeadList,Status) :-
	is_fliboolsig(SpecTerm,AttTerm,_RefType),
	!,
	compile_wsflpathexp(AttTerm,WS,AttObj,AOidCode,ACode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     iboolsig_struct(BODYLITERAL,Object,AttObj,SCode),
			     SCode,WSCode),
	    conjunct_code([AOidCode,ACode,WSCode],Code)
	;
	    true
	).

%% boolean signatures: =>% for transactional method
compile_wsflspecbody(Object,SpecTerm,WS,NULL,Code,BodyHeadList,Status) :-
	is_fltransig(SpecTerm,AttTerm,_RefType),
	!,
	compile_wsflpathexp(AttTerm,WS,AttObj,AOidCode,ACode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     transig_struct(BODYLITERAL,Object,AttObj,SCode),
			     SCode,WSCode),
	    conjunct_code([AOidCode,ACode,WSCode],Code)
	;
	    true
	).

%% boolean signatures: *=>% for transactional method
compile_wsflspecbody(Object,SpecTerm,WS,NULL,Code,BodyHeadList,Status) :-
	is_flitransig(SpecTerm,AttTerm,_RefType),
	!,
	compile_wsflpathexp(AttTerm,WS,AttObj,AOidCode,ACode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     itransig_struct(BODYLITERAL,Object,AttObj,SCode),
			     SCode,WSCode),
	    conjunct_code([AOidCode,ACode,WSCode],Code)
	;
	    true
	).

%% +>>, *+>>@module
%% NULL means: consume OidCode for attr and val here -- don't pass up the chain
compile_wsflspecbody(Object,SpecTerm,WS,NULL,Code,BodyHeadList,Status) :-
	is_flincattspec(SpecTerm,AttTerm,RefType,ValTerm),
	!,
	compile_wsflpathexplist([AttTerm,ValTerm],WS,[AttObj,ValObj],OidCode,OCode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     incattspec_struct(Object,AttObj,RefType,ValObj,SCode),
			     SCode,WSCode),
	    %% Fold OidCode in front of molecule
	    conjunct_code([OidCode,WSCode,OCode],Code)
	;
	  true
        ).

%% same for ->->@module
%% NULL means: consume OidCode for attr and val here -- don't pass up the chain
compile_wsflspecbody(Object,SpecTerm,WS,NULL,Code,BodyHeadList,Status) :-
	is_fltolistattspec(SpecTerm,AttTerm,RefType,ValTerm),
	!,
	compile_wsflpathexplist([AttTerm,ValTerm],WS,[AttObj,ValObj],OidCode,OCode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     tolistattspec_struct(Object,AttObj,RefType,ValObj,SCode),
			     SCode,WSCode),
	    conjunct_code([OidCode,WSCode,OCode],Code)
	;
	  true
        ).

%% Obj[true], Obj[fail], Obj[!] translate as true, fail, and !
compile_wsflspecbody(_Object,SpecTerm,_WS,NULL,Code,[],Status) :-
	is_flpassthru(SpecTerm,P),
	is_flatom(P, Atom, I),
	!,
	(Atom==FL_CUT
	-> cut_struct(I,Code)
	; atomobj_struct(P,Code)
	),
	Status=[].

%% Obj[X>Y], Obj[X=Y], etc.
compile_wsflspecbody(_Object,SpecTerm,_WS,NULL,Code,BodyHeadList,Status) :-
	is_flpassthru(SpecTerm,P),
	is_flterm(P, Funct, N, Args),
	!,
	compile_prlgterm(Funct,N,Args,0,TCode,_OidCode,ACode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
		conjunct_code([ACode,TCode],Code); true).

%% for O[BoolMeth]@module
%% NULL means: consume OidCode for attr and val here -- don't pass up the chain
compile_wsflspecbody(Object,SpecTerm,WS,NULL,Code,BodyHeadList,Status) :-
	is_flmethspec(SpecTerm,MethTerm),
	!,
	compile_wsflpathexp(MethTerm,WS,MethObj,OidCode,MCode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     methspec_struct(BODYLITERAL,Object,MethObj,SCode),
			     SCode,WSCode),
	    conjunct_code([OidCode,MCode,WSCode],Code)
	;
	  true
        ).

%% for O[*BoolMeth]@module
%% NULL means: consume OidCode for attr and val here -- don't pass up the chain
compile_wsflspecbody(Object,SpecTerm,WS,NULL,Code,BodyHeadList,Status) :-
	is_flimethspec(SpecTerm,IMethTerm),
	!,
	compile_wsflpathexp(IMethTerm,WS,IMethObj,OidCode,IMCode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     imethspec_struct(BODYLITERAL,Object,IMethObj,SCode),
			     SCode,WSCode),
	    %% Fold OidCode in front of molecule
	    conjunct_code([OidCode,IMCode,WSCode],Code)
	;
	  true
        ).

%% O[%M]@module
compile_wsflspecbody(Object,SpecTerm,WS,NULL,Code,BodyHeadList,Status) :-
	is_fltranspec(SpecTerm,TranTerm),
	!,
	compile_wsflpathexp(TranTerm,WS,TranObj,OidCode,TCode,BodyHeadList,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     transpec_struct(BODYLITERAL,Object,TranObj,SCode),
			     SCode,WSCode),
	    conjunct_code([OidCode,TCode,WSCode],Code)
	;
	  true
        ).


/****************************************************************************
  compile_wsmvdattspec(+Object,+AttObj,+RefType,+ValTermList,+Workspace,-OidCode,-Code,-Status)

  Compiles ->, *->, etc., when they have one or more value terms
****************************************************************************/
compile_wsmvdattspec(Object,AttObj,RefType,[T],WS,OidCode,Code,Status) :-
	!,
	compile_wsflpathexp(T,WS,TObj,OidCode,TCode,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     mvdattspec_struct(BODYLITERAL,Object,AttObj,RefType,TObj,SCode),
			     SCode,WSCode),
	    conjunct_code([WSCode,TCode],Code)
	;
	  true
        ).

compile_wsmvdattspec(Object,AttObj,RefType,[T|L],WS,OidCode,Code,Status) :-
	!,
	compile_wsmvdattspec(Object,AttObj,RefType,[T],WS,OidCodeHead,WTCode,S),
	( no_errors_found(S) -> 
	    compile_wsmvdattspec(Object,AttObj,RefType,L,WS,OidCodeTail,WLCode,Status),
	    ( no_errors_found(Status) -> 
		conjunct_code([WTCode,WLCode],Code),
		conjunct_code([OidCodeHead,OidCodeTail],OidCode)
	    ; true
	    )
	;
	  Status=S
        ).


/****************************************************************************
  compile_wsflobjeql(+Obj1,+Obj2,+Workspace,-OidCode,-Code,-Status)
****************************************************************************/
compile_wsflobjeql(Obj1,Obj2,WS,OidCode,Code,Status) :-
	compile_wsflpathexplist([Obj1,Obj2],WS,[O1,O2],OidCode,OCode,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     objeql_struct(BODYLITERAL,O1,O2,OECode),
			     OECode,WSCode),
	    conjunct_code([OCode,WSCode],Code)
	;
	  true
	).


/****************************************************************************
  compile_reifyop(+Formula,-Object,-Status)
  Compiling ${...}
****************************************************************************/
/*
compile_reifyop(Formula,Object,OidCode,Status) :-
	has_context(compiling_body_pathexp),
	\+has_context(compiling_update_literals),
	!,
	%% PrependedCode might come from LIBMODLIT or LIBMODOBJ
	compute_reification_expr(Formula,AttrValCode,PrependedCode,Status),
	( no_errors_found(Status) -> 
	    new_prvariable(NO_INDEX,Object),
	    attrvar_code(Object,AttrValCode,FLSEMANTICUNIFICATION,PutAttrCode),
	    conjunct_code([PrependedCode,PutAttrCode],OidCode)
	;
	    true
	).
*/
compile_reifyop(Formula,Object,OidCode,Status) :-
	compute_reification_expr(Formula,Object,OidCode,Status).

	

compute_reification_expr(Formula,Object,OidCode,Status) :-
	Formula = [Rule|_],
	(is_fldynrule(Rule,_Head,_Body,_Lab)
	; is_flruleworkspace(Rule,_RealRule,_WS)
	),
	!,
	set_context(rule_reification),
        %% singleton/unbound vars are flagged in reified/inserted rules
	compile_fldynrule(FL_INSERTRULE,Rule,Object,Status),
	clear_context(rule_reification),
	OidCode=NULL.

compute_reification_expr(Formula,Object,OidCode,Status) :-
	set_context(goal_reification),
	compile_body(Formula,Object1,Status),
	clear_context(goal_reification),
	(is_florasyslib_struct(Object1, Index,FLLIBMODLIT,_N,Args)
	%% If it is compiled into a LIBMODLIT/3, replace with LIBMODOBJ
	->
            new_prvariable(Index,Object),
	    append(Args,[Object],NewArgs),
	    %% LIBMODLIT/3 already has the caller argument -- no
	    %% need to add it here
	    florasyslib_struct(Index,FLLIBMODOBJ,4,NewArgs,OidCode)
	;
	    reify_struct(Object1,Object),
	    OidCode = NULL
	).

/****************************************************************************
  compile_truthvalue(+Form,+Op,-OidCode,-Code,-Status)
  Compiles true{...}, false{...}, unknown{...}
****************************************************************************/
compile_truthvalue(Formula,Op,Code,Status) :-
	atomobj_struct(Op,OpCode),
	compile_body(Formula,FCode,Status),
	( no_errors_found(Status) -> 
	   truthvalue_struct(FCode,OpCode,Code)
	; true
	).


/****************************************************************************
   compile_labelprimitive(+LabelParserTerm,?HeadList,-Code,-Status)
****************************************************************************/
compile_labelprimitive(LabelParserTerm,HeadList,Code,Status) :-
	compile_pathexp(LabelParserTerm,LabCode,_,_,S1),
	( no_errors_found(S1) -> 
	    set_context(compile_with_var_module),
	    set_context(compiling_headliteral),
	    compile_fldelete_list(HeadList,HLC,Status),
	    clear_context(compiling_headliteral),
	    ( no_errors_found(Status) -> 
		list_struct(HLC,[],HeadListCode),
		labelprimitive_struct(LabCode,HeadListCode,Code)
	    ; true
	    )
	; Status = S1
	).


/****************************************************************************
   compile_prefixprimitive(+Prefix,+Expansion,+Module,-Code,-Status)

   Compiles the prefix{...} primitive.
****************************************************************************/
compile_prefixprimitive(Prefix,Expansion,Module,Code,Status) :-
	(Module == NULL -> thismodule_struct(ModuleCode)
	; compile_flatomvar(Module,ModuleCode)
	),
	compile_pathexplist([Prefix,Expansion],[PrefixCode,ExpansionCode],_,_,Status),
	( no_errors_found(Status) -> 
	    prefixprimitive_struct(PrefixCode,ExpansionCode,ModuleCode,Code)
	; true
	).


/****************************************************************************
  compile_prologliblit(+ParserTerm,+Nesting,-OidCode,-Code,?BodyHeadList,-Status)

  Compiles Prolog library call @_prolog
****************************************************************************/
compile_prologliblit(ParserTerm,Nesting,OidCode,Code,BodyHeadList,Status) :-
	( is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_prlgterm(Funct,N,Args,Nesting,TCode,OidCode,ACode,BodyHeadList,Status),
	    ( no_errors_found(Status) -> 
		conjunct_code([ACode,TCode],Code); true)
	;
	    atomobj_struct(ParserTerm,FObj),
	    N=0,
	    prologterm_struct(FObj,0,[],Code),
	    OidCode=NULL,
	    Status=[]
	),
	!.


/****************************************************************************
  compile_prologliblit(+ParserTerm,+Module,Nesting,-OidCode,-Code,?BodyHeadList,-Status)

  Compiles Prolog library call @_prolog(module)
****************************************************************************/
compile_prologliblit(ParserTerm,Module,Nesting,OidCode,Code,BodyHeadList,Status) :-
	( is_flterm(ParserTerm,Funct,N,Args) ->
	    is_flatom(Funct,FAtom),
	    compile_prlgterm(Funct,N,Args,Module,Nesting,TCode,OidCode,ACode,BodyHeadList,Status)
	;
	    is_flatom(ParserTerm,FAtom),
	    atomobj_struct(ParserTerm,FObj),
	    N=0,
	    prologterm_struct(FObj,0,[],Module,TCode),
	    ACode=NULL,
	    OidCode=NULL,
	    BodyHeadList = [],
	    Status=[]
	),
	( no_errors_found(Status) -> 
	    %% build a special structure for the coder
	    %% prologliblit_struct is NOT added by compile_prologliblit/6 ---
	    %% only by compile_prologliblit/7
	    prologliblit_struct(TCode,PCode),
	    conjunct_code([ACode,PCode],Code)
	;
	  true
	),
	!.


/****************************************************************************
  compile_prologallliblit(+ParserTerm,+Nesting,-OidCode,-Code,-BodyHeadList,-Status)

  Compiles Prolog library call @_prologall
****************************************************************************/
compile_prologallliblit(ParserTerm,Nesting,OidCode,Code,BodyHeadList,Status) :-
	compile_prologliblit(ParserTerm,Nesting,OidCode,PrelimCode,BodyHeadList,Status),
	( % here PrelimCode is bound and we decompose it
	  conjunct_struct(ACode,PrelimTermCode,PrelimCode), !
	; PrelimCode = PrelimTermCode, ACode=NULL
	),
	%% Here PrelimTermCode is bound and we decompose it
	prologterm_struct(FunctCode,N,ArgsCode,PrelimTermCode),
	new_prvarlist(N,NewVarList),
	generate_convert_to_prolog_code(ArgsCode,NewVarList,ToPrologCode),
	prologterm_struct(FunctCode,N,NewVarList,TermCode),
	generate_convert_from_prolog_code(ArgsCode,NewVarList,FromPrologCode),
	conjunct_code([ACode,ToPrologCode,TermCode,FromPrologCode],Code).


/****************************************************************************
  compile_prologallliblit(+ParserTerm,+Module,+Nesting,-OidCode,-Code,-BodyHeadList,-Status)

  Compiles Prolog library call @_prologall(module)
****************************************************************************/
compile_prologallliblit(ParserTerm,Module,Nesting,OidCode,Code,BodyHeadList,Status) :-
	compile_prologliblit(ParserTerm,Module,Nesting,OidCode,PrelimCode,BodyHeadList,Status),
	( % here PrelimCode is bound and we decompose it
	  conjunct_struct(ACode,PrelimTermLitCode,PrelimCode), !
	; PrelimCode = PrelimTermLitCode, ACode=NULL
	),
	%% PrelimTermLitCode is bound and we decompose it
	prologliblit_struct(PrelimTermCode,PrelimTermLitCode),
	%% PrelimTermCode is bound and we decompose it
	prologterm_struct(FunctCode,N,ArgsCode,Module,PrelimTermCode),
	new_prvarlist(N,NewVarList),
	generate_convert_to_prolog_code(ArgsCode,NewVarList,ToPrologCode),
	prologterm_struct(FunctCode,N,NewVarList,Module,TermCode),
	prologliblit_struct(TermCode,TermLitCode),
	generate_convert_from_prolog_code(ArgsCode,NewVarList,FromPrologCode),
	conjunct_code([ACode,ToPrologCode,TermLitCode,FromPrologCode],Code).


/****************************************************************************
  compile_prologlibobj(+ParserTerm,+Nesting,-Object,-OidCode,-Code,?BodyHeadList,-Status)

  Compiles Prolog library call @_prolog in the arguments position
  E.g., f(member(X,[a])@_prolog)
  This feature might be useful for meta-programming.  
****************************************************************************/
compile_prologlibobj(ParserTerm,Nesting,Object,OidCode,Code,BodyHeadList,Status) :-
	( is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_prlgterm(Funct,N,Args,Nesting,Object,OidCode,Code,BodyHeadList,Status)
	;
	    atomobj_struct(ParserTerm,FObj),
	    N=0,
	    prologterm_struct(FObj,0,[],Object),
	    Code=NULL,
	    OidCode=NULL,
	    BodyHeadList=[],
	    Status=[]
	),
	!.


/****************************************************************************
  compile_prologlibobj(+ParserTerm,+Module,+Nesting,-Object,-OidCode,-Code,?BodyHeadList,-Status)

  Compiles Prolog library call @_prolog(module) in the arguments position
****************************************************************************/
compile_prologlibobj(ParserTerm,Module,Nesting,Object,OidCode,Code,BodyHeadList,Status) :-
	( is_flterm(ParserTerm,Funct,N,Args) ->
	    is_flatom(Funct,FAtom),
	    compile_prlgterm(Funct,N,Args,Module,Nesting,Object,OidCode,Code,BodyHeadList,Status)
	;
	    is_flatom(ParserTerm,FAtom),
	    atomobj_struct(ParserTerm,FObj),
	    N=0,
	    prologterm_struct(FObj,0,[],Module,Object),
	    Code=NULL,
	    OidCode=NULL,
	    BodyHeadList=[],
	    Status=[]
	),
	!.


/****************************************************************************
  compile_prologalllibobj(+ParserTerm,+Nesting,-Object,-OidCode,-Code-,?BodyHeadList,-Status)

  Compiles @_prologall in argument position, e.g., foo(f(...)@_prologall
***************************************************************************/
compile_prologalllibobj(ParserTerm,Nesting,Object,OidCode,Code,BodyHeadList,Status) :-
	compile_prologlibobj(ParserTerm,Nesting,PrelimObject,PrelimOidCode,PrelimCode,BodyHeadList,Status),
	%% PrelimObject is bound and we decompose it
	prologterm_struct(FunctCode,N,ArgsCode,PrelimObject),
	new_prvarlist(N,NewVarList),
	generate_convert_to_prolog_code(ArgsCode,NewVarList,ToPrologCode),
	prologterm_struct(FunctCode,N,NewVarList,Object),
	generate_convert_from_prolog_code(ArgsCode,NewVarList,FromPrologCode),
	conjunct_code([ToPrologCode,PrelimOidCode],OidCode),
	conjunct_code([FromPrologCode,PrelimCode],Code).

/****************************************************************************
  compile_prologalllibobj(+ParserTerm,+Module,+Nesting,-Object,-OidCode,-Code,?BodyHeadList,-Status)

  Compiles @_prologall(module) in argument position,
  e.g., foo(f(...)@_prologall(module)
***************************************************************************/
compile_prologalllibobj(ParserTerm,Module,Nesting,Object,OidCode,Code,BodyHeadList,Status) :-
	compile_prologlibobj(ParserTerm,Module,Nesting,PrelimObject,PrelimOidCode,PrelimCode,BodyHeadList,Status),
	%% PrelimObject is bound and we decompose it
	prologterm_struct(FunctCode,N,ArgsCode,PrelimObject),
	new_prvarlist(N,NewVarList),
	generate_convert_to_prolog_code(ArgsCode,NewVarList,ToPrologCode),
	prologterm_struct(FunctCode,N,NewVarList,Object),
	generate_convert_from_prolog_code(ArgsCode,NewVarList,FromPrologCode),
	conjunct_code([ToPrologCode,PrelimOidCode],OidCode),
	conjunct_code([PrelimCode,FromPrologCode],Code).


/****************************************************************************
  compile_prlgterm(+FunctTerm,+Arity,+ArgList,+Nesting,-Object,-OidCode,-Code,?BodyHeadList,-Status)
  compile_prlgterm(+FunctTerm,+Arity,+ArgList,+Nesting,-Object,-OidCode,-Code,?BodyHeadList,-Status)
  
 +Nesting - needed for nested user defined functions
 ?BodyHeadList - code to add at the beginning of the body
                 (mostly for user defined fnctions),
		 it is output argument, but if it is initialized to
		 empty ([]) ignores user defined functions
****************************************************************************/
/*
compile_prlgterm(Funct,N,Args,Object,OidCode,Code,Status) :-
	compile_prlgterm(Funct,N,Args,0,Object,OidCode,Code,[],Status).
*/
compile_prlgterm(Funct,N,Args,Nesting,Object,OidCode,Code,BodyHeadList,Status) :-
	atomobj_struct(Funct,FObj),
	prologterm_struct(FObj,N,AObj,Object),
	set_context(no_symbol_check),
	compile_pathexplist(Args,Nesting,AObj,OidCode,Code,BodyHeadList,Status),
	clear_context(no_symbol_check),
	!.

/*
compile_prlgterm(Funct,N,Args,Object,OidCode,Code,Status) :-
	atomobj_struct(Funct,FObj),
	prologterm_struct(FObj,N,AObj,Object),
	compile_pathexplist(Args,AObj,OidCode,Code,Status),
	!.
*/

%% Generate prolog term with module prefix
compile_prlgterm(Funct,N,Args,Module,Object,OidCode,Code,Status) :-
	compile_prlgterm(Funct,N,Args,Module,0,Object,OidCode,Code,[],Status).
compile_prlgterm(Funct,N,Args,Module,Nesting,Object,OidCode,Code,BodyHeadList,Status) :-
	atomobj_struct(Funct,FObj),
	prologterm_struct(FObj,N,AObj,Module,Object),
	set_context(no_symbol_check),
	compile_pathexplist(Args,Nesting,AObj,OidCode,Code,BodyHeadList,Status),
	clear_context(no_symbol_check),
	!.

/*
compile_prlgterm(Funct,N,Args,Module,Object,OidCode,Code,Status) :-
	atomobj_struct(Funct,FObj),
	prologterm_struct(FObj,N,AObj,Module,Object),
	compile_pathexplist(Args,AObj,OidCode,Code,Status),
	!.
*/


/*************************************************************************
   generate_convert_to_prolog_code(+AObjList,+VarList,-Code)
*************************************************************************/ 
generate_convert_to_prolog_code([],_,NULL).

generate_convert_to_prolog_code([AObjH|AObjT],[VarH|VarT],Code) :-
	atomobj_struct(P2H_PREDICATE,FlP2H),
	%% P2H_DONOT_UNIFY_VARS - do not unify when both arguments are vars
	prologterm_struct(FlP2H,4,[VarH,AObjH,WRAP_HILOG,P2H_DONOT_UNIFY_VARS],CodeH),
	generate_convert_to_prolog_code(AObjT,VarT,CodeT),
	conjunct_code([CodeH,CodeT],Code).

/*************************************************************************
   generate_convert_from_prolog_code(+AObjList,+VarList,-Code)
*************************************************************************/ 
generate_convert_from_prolog_code([],_,NULL).

generate_convert_from_prolog_code([AObjH|AObjT],[VarH|VarT],Code) :-
	atomobj_struct(P2H_PREDICATE,FlP2H),
	%% P2H_UNIFY_VARS - unify when both arguments are vars
	prologterm_struct(FlP2H,4,[VarH,AObjH,WRAP_HILOG,P2H_UNIFY_VARS],CodeH),
	generate_convert_from_prolog_code(AObjT,VarT,CodeT),
	conjunct_code([CodeH,CodeT],Code).
		

/****************************************************************************
  compile_head_wspathexp(+ParserTerm,+Workspace,-Object,-Code,-H2BCodeHead,-H2BCodeTail,-Status)

  This procedure is called from compile_head_pathexp/6 and
  compile_head_wsflpathexp/7 when a workspace is explicitly specified.
****************************************************************************/
compile_head_wspathexp(ParserTerm,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status) :- 
	(
	  is_fltransactionalterm(ParserTerm,Funct,N,Args) ->
	    compile_head_wstransactionaltermobj(Funct,N,Args,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_head_wstermobj(Funct,N,Args,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flbirelate(ParserTerm,ObjTerm1,RelType,ObjTerm2) ->
	    compile_head_wsflbirelate(ObjTerm1,RelType,ObjTerm2,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flobjspec(ParserTerm,ObjTerm,Spec) ->
	    compile_head_wsflobjspec(ObjTerm,Spec,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status)
	;
	  is_flobjref(ParserTerm,ObjTerm,RefType,AttTerm),
	  compile_head_wsflobjref(ObjTerm,RefType,AttTerm,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status)

	 ; atomlit_struct(HEADLITERAL,ParserTerm,A) ->
	    workspaceobj_struct(A,WS,Object,Code),
	    H2BCodeHead=NULL,
	    H2BCodeTail=NULL,
	    Status=[]

	; transactionalatomlit_struct(HEADLITERAL,ParserTerm,A) ->
	    workspaceobj_struct(A,WS,Object,Code),
	    H2BCodeHead=NULL,
	    H2BCodeTail=NULL,
	    Status=[]
	).


/****************************************************************************
  compile_head_floraliblit(+ParserTerm,+Workspace,-Code,-H2BCodeHead,-H2BCodeTail,-Status)

  This procedure compiles a head literal associated with a Flora system
  module specification.
****************************************************************************/
compile_head_floraliblit(ParserTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	%% Flora system modules are like normal user modules except that
	%% users cannot load files into them
	is_flatom(WS,WSName,Index),
	report_option(FLSYSMOD(WSName),Index),
	atomobj_struct(WSName,Index,WSNameCode),
	floralib_struct(WSNameCode,WSCode),
	compile_head_wsliteral(ParserTerm,WSCode,Code,H2BCodeHead,H2BCodeTail,Status).


/****************************************************************************
  compile_head_wsliteral(+ParserTerm,+Workspace,-Code,-H2BCodeHead,-H2BCodeTail,-Status)

  H2BCodeHead - code passed from head to body, which is supposed to be
                prepended to the code of the body
  H2BCodeTail - code passed from head to body, which is supposed to be
                appended to the code of the body
****************************************************************************/
compile_head_wsliteral(ParserTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	( is_fltransactionalterm(ParserTerm,Funct,N,Args) ->
	    compile_head_wstransactionaltermlit(Funct,N,Args,WS,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_head_wstermlit(Funct,N,Args,WS,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flbirelate(ParserTerm,ObjTerm1,RelType,ObjTerm2) ->
	    compile_head_wsflbirelate(ObjTerm1,RelType,ObjTerm2,WS,_Obj,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flobjspec(ParserTerm,ObjTerm,Spec) ->
	    compile_head_wsflobjspec(ObjTerm,Spec,WS,_Obj,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flobjeql(ParserTerm,O1,O2) ->
	    compile_head_wsflobjeql(O1,O2,WS,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flneg(ParserTerm,PosPart,Idx) ->
	    compile_head_wsflneg(PosPart,WS,Idx,Code,H2BCodeHead,H2BCodeTail,Status)

        ; is_flvariable(ParserTerm,VarName,Index) ->
	    %% Is this possible? Should be taken care by the libmodlit code
	    attach_workspace(WS,
			     compile_flvar(VarName,Index,VarCode),
			     VarCode,Code),
	    H2BCodeHead=NULL,
	    H2BCodeTail=NULL,
            Status=[]

        ; is_fltransactionalvariable(ParserTerm,VarName,Index) ->
	    %% Is this possible? Should be taken care by the libmodlit code
	    attach_workspace(WS,
			     compile_fltransactionalvar(VarName,Index,VarCode),
			     VarCode,Code),
	    H2BCodeHead=NULL,
	    H2BCodeTail=NULL,
            Status=[]
	;
	    attach_workspace(WS,
			     atomlit_struct(HEADLITERAL,ParserTerm,ACode),
			     ACode,Code),
	    check_symbol_name_for_clashes(ParserTerm,0,WS,FUNCTION_SYMBOL,NONTRANSACTIONAL_SYMBOL,Status),
	    H2BCodeHead=NULL,
	    H2BCodeTail=NULL
	;
	    attach_workspace(WS,
			     transactionalatomlit_struct(HEADLITERAL,ParserTerm,ACode),
			     ACode,Code),
	    check_symbol_name_for_clashes(ParserTerm,0,WS,FUNCTION_SYMBOL,TRANSACTIONAL_SYMBOL,Status),
	    H2BCodeHead=NULL,
	    H2BCodeTail=NULL
	).


/****************************************************************************
  compile_head_wsflpathexplist(+ParserTermList,+WS,-ObjectList,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
****************************************************************************/
compile_head_wsflpathexplist([],_WS,[],NULL,NULL,NULL,[]) :- !.

compile_head_wsflpathexplist([T|L],WS,[TObj|LObj],Code,H2BCodeHead,H2BCodeTail,Status) :-
	compile_head_wsflpathexp(T,WS,TObj,TCode,TH2BCodeHead,TH2BCodeTail,S),
	clear_context(compiling_term_name),
	( no_errors_found(S) -> 
	    compile_head_wsflpathexplist(L,WS,LObj,LCode,LH2BCodeHead,LH2BCodeTail,S2),
	    ( no_errors_found(S2) -> 
		conjunct_struct(TCode,LCode,Code),
		conjunct_code([TH2BCodeHead,LH2BCodeHead],H2BCodeHead),
		conjunct_code([TH2BCodeTail,LH2BCodeTail],H2BCodeTail),
		merge_status([S,S2],Status)
	    ;
		Status=S2
	    )
	;
	  Status=S
        ).


/****************************************************************************
  compile_head_wsflpathexp(+ParserTerm,+WS,-Object,-Code,-H2BCodeHead,-H2BCodeTail,-Status)

  Note: The difference between compile_head_wsflpathexp and
        compile_head_wspathexp is that compile_head_wsflpathexp
	applies workspace only to F-Logic constructs.
****************************************************************************/
compile_head_wsflpathexp(ParserTerm,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status) :- 
	( is_flbirelate(ParserTerm,OT1,RelType,OT2) ->
	    compile_head_wsflbirelate(OT1,RelType,OT2,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flobjspec(ParserTerm,ObjTerm,Spec) ->
	    compile_head_wsflobjspec(ObjTerm,Spec,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flobjref(ParserTerm,ObjTerm,RefType,AttTerm) ->
	    compile_head_wsflobjref(ObjTerm,RefType,AttTerm,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flterm(ParserTerm,Funct,N,Args) ->
	    compile_head_wsfltermobj(Funct,N,Args,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_fllist(ParserTerm,L,T,I) ->
	    compile_head_wsfllist(L,T,I,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status)

	; is_flworkspace(ParserTerm,P,NestedWS) ->
	    compile_head_wspathexp(P,NestedWS,Object,Code,H2BCodeHead,H2BCodeTail,Status)
	;
	  compile_head_pathexp(ParserTerm,Object,Code,H2BCodeHead,H2BCodeTail,Status)
        ).


/****************************************************************************
  compile_head_wstermobj(+FunctorTerm,+Arity,+ArgList,+WS,-Object,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
****************************************************************************/
compile_head_wstermobj(_Funct,_N,_Args,WS,_Object,_Code,_H2BCodeHead,_H2BCodeTail,Status) :-
	is_flvariable(WS,_Name,VarIndex),
	!,
	%% Workspace in the rule head is not bound at compile time. Currently
	%% this will generate an error. However, this might be solved by moving
	%% the code that generates the workspace predicate to the body
	%% of the rule.
	compiling_error(VarIndex,VARWSINHEAD,Err),
	Status = [Err].

compile_head_wstermobj(Funct,N,Args,WS,Object,Code,H2BCodeHead,H2BCodeTail,CompileStatus) :-
	(is_fltransactionalatom(Funct,_)
	-> Transactionality = TRANSACTIONAL_SYMBOL
	; Transactionality = NONTRANSACTIONAL_SYMBOL
	),
	check_symbol_name_for_clashes(Funct,N,WS,FUNCTION_SYMBOL,Transactionality,SymbolStatus),
	set_context(compiling_term_name),
	compile_head_wsflpathexplist([Funct|Args],WS,[FObj|AObj],Code,H2BCodeHead,H2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    termlit_struct(HEADLITERAL,FObj,N,AObj,O),
	    %% WCode should be NULL here since it is already checked by the rule
	    %% that the workspace is not a variable.
	    workspaceobj_struct(O,WS,Object,_WCodeIsNULL)
	;
	  true
        ),
	append(SymbolStatus,Status,CompileStatus).

compile_head_wstransactionaltermobj(Funct,N,Args,WS,Object,Code,H2BCodeHead,H2BCodeTail,CompileStatus) :-
	check_symbol_name_for_clashes(Funct,N,WS,FUNCTION_SYMBOL,TRANSACTIONAL_SYMBOL,SymbolStatus),
	set_context(compiling_term_name),
	compile_head_wsflpathexplist([Funct|Args],WS,[FObj|AObj],Code,H2BCodeHead,H2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    transactionaltermlit_struct(HEADLITERAL,FObj,N,AObj,O),
	    %% WCode should be NULL here since it is already checked by the rule
	    %% that the workspace is not a variable.
	    workspaceobj_struct(O,WS,Object,_WCodeIsNULL)
	;
	  true
        ),
	append(SymbolStatus,Status,CompileStatus).


/****************************************************************************
  compile_head_wsfltermobj(+FunctorTerm,+Arity,+ArgList,+WS,-Object,-Code,-H2BCodeHead,-H2BCodeTail,-Status)

  Note: The difference between compile_head_wsflpathexp
        and compile_head_wspathexp
        is that compile_head_wsflpathexp applies workspace only to F-Logic
        constructs.
****************************************************************************/
/*
compile_head_wsfltermobj(Funct,N,Args,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status) :-
	compile_head_wsflpathexplist([Funct|Args],WS,[FObj|AObj],Code,H2BCodeHead,H2BCodeTail,Status),
	(Status == [] -> termobj_struct(FObj,N,AObj,Object); true).
*/

compile_head_wsfltermobj(Funct,N,Args,WS,Object,Code,H2BCodeHead,H2BCodeTail,CompileStatus) :-
        ( \+ has_context(compiling_arithmetics),
	    flora_get_flatomvar_name(Funct,Name),
	    has_user_defined_function(Name,N,FArgs,Predicate,ReturnValue)
	->
	    H2BCodeTail=NULL,
	    Code=NULL,
	    new_prvariable(NO_INDEX,Object),
	    prvar_to_flvar_struct(Object,Var),
	    approx_flindex(Funct,Index),
	    formUDFVarSubstitute([Var|Args],[ReturnValue|FArgs],0,Index),
	    compile_body_literal(Predicate,0,PCode,PH2BCodeHead,S),
	    clearUDFVarSubstitute(0),
	    SymbolContext = UDF_SYMBOL,
	    ( no_errors_found(S) -> 
		append(PH2BCodeHead,[PCode],List),
		conjunct_code(List,H2BCodeHead),
		Status = []
	    ;
		approx_flindex(Funct,Index),
		compiling_error(Index,ERROR_UDF_COMPILE,Err),
		Status = [Err|S]
	    )
        ;
	    set_context(compiling_term_name),
	    compile_head_wsflpathexplist([Funct|Args],WS,[FObj|AObj],Code,H2BCodeHead,H2BCodeTail,Status),
	    SymbolContext = FUNCTION_SYMBOL,
	    ( no_errors_found(Status) -> 
		termobj_struct(FObj,N,AObj,Object); true)
        ),
	(is_fltransactionalatom(Funct,_)
	-> Transactionality = TRANSACTIONAL_SYMBOL
	; Transactionality = NONTRANSACTIONAL_SYMBOL
	),
	check_symbol_name_for_clashes(Funct,N,WS,SymbolContext,Transactionality,SymbolStatus),
	append(SymbolStatus,Status,CompileStatus).


/****************************************************************************
  compile_head_wstermlit(+FunctorTerm,+Arity,+ArgList,+WS,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
****************************************************************************/
compile_head_wstermlit(Funct,N,Args,WS,Code,H2BCodeHead,H2BCodeTail,CompileStatus) :-
	(is_fltransactionalatom(Funct,_)
	-> Transactionality = TRANSACTIONAL_SYMBOL
	; Transactionality = NONTRANSACTIONAL_SYMBOL
	),
	check_symbol_name_for_clashes(Funct,N,WS,PREDICATE_SYMBOL,Transactionality,SymbolStatus),
	set_context(compiling_term_name),
	compile_head_wsflpathexplist([Funct|Args],WS,[FObj|AObj],ObjCode,H2BCodeHead,H2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     termlit_struct(HEADLITERAL,FObj,N,AObj,TObj),
			     TObj,WSTObj),
	    conjunct_struct(ObjCode,WSTObj,Code)
	;
	  true
        ),
	append(SymbolStatus,Status,CompileStatus).

compile_head_wstransactionaltermlit(Funct,N,Args,WS,Code,H2BCodeHead,H2BCodeTail,CompileStatus) :-
	check_symbol_name_for_clashes(Funct,N,WS,PREDICATE_SYMBOL,TRANSACTIONAL_SYMBOL,SymbolStatus),
	set_context(compiling_term_name),
	compile_head_wsflpathexplist([Funct|Args],WS,[FObj|AObj],ObjCode,H2BCodeHead,H2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     transactionaltermlit_struct(HEADLITERAL,FObj,N,AObj,TObj),
			     TObj,WSTObj),
	    conjunct_struct(ObjCode,WSTObj,Code)
	;
	  true
        ),
	append(SymbolStatus,Status,CompileStatus).



/****************************************************************************
  compile_head_wsfllist(+ObjTermList,+ObjTerm,+Index,+WS,-Object,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
****************************************************************************/
compile_head_wsfllist(ObjTermList,ObjTerm,Index,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status) :-
	compile_head_wsflpathexplist(ObjTermList,WS,ObjList,ObjListCode,ObjListH2BCodeHead,ObjListH2BCodeTail,S),
	( no_errors_found(S) -> 
	    ( ObjTerm == [] ->
		Obj=[],
		ObjCode=NULL,
		ObjH2BCodeHead=NULL,
		ObjH2BCodeTail=NULL,
		Status=[]
	    ;
	      compile_head_wsflpathexp(ObjTerm,WS,Obj,ObjCode,ObjH2BCodeHead,ObjH2BCodeTail,Status)
	    ),
	    ( no_errors_found(Status) -> 
		list_struct(ObjList,Obj,Index,Object),
		conjunct_struct(ObjListCode,ObjCode,Code),
		conjunct_code([ObjListH2BCodeHead,ObjH2BCodeHead],H2BCodeHead),
		conjunct_code([ObjListH2BCodeTail,ObjH2BCodeTail],H2BCodeTail)
	    ;
	      true
	    )
	;
	  Status=S
        ).


/****************************************************************************
  compile_head_wsflobjref(+ObjT,+RefType,+AttT,+WS,-Object,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
****************************************************************************/
compile_head_wsflobjref(ObjTerm,RefType,AttTerm,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status) :-
	compile_head_wsflpathexplist([ObjTerm,AttTerm],WS,[Obj,Att],OACode,OAH2BCodeHead,OAH2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    %% Approximate the textual information for the new variable.
	    approx_flindex(AttTerm,Index),
	    attach_workspace(WS,
			     head_objref_struct(Obj,RefType,Att,Index,Object,TCode),
			     TCode,WTCode),
	    OAH2BCodeHead = H2BCodeHead,
	    conjunct_code([OAH2BCodeTail,WTCode],H2BCodeTail),
	    Code = OACode
	;
	  true
        ).


/****************************************************************************
  compile_head_wsflbirelate(+OT1,+RelType,+OT2,+WS,-Object,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
****************************************************************************/
compile_head_wsflbirelate(ObjTerm1,RelType,ObjTerm2,WS,Obj1,Code,H2BCodeHead,H2BCodeTail,Status) :-
	compile_head_wsflpathexplist([ObjTerm1,ObjTerm2],WS,[Obj1,Obj2],OCode,H2BCodeHead,H2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     birelate_struct(HEADLITERAL,Obj1,RelType,Obj2,TCode),
			     TCode,WTCode),
	    conjunct_struct(OCode,WTCode,Code)
	;
	  true
        ).


/****************************************************************************
  compile_head_wsflobjspec(+ObjTerm,+SpecBody,+WS,-Object,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
****************************************************************************/
compile_head_wsflobjspec(ObjTerm,SpecBody,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status) :-
	( SpecBody == [] ->
	    ( is_flobjref(ObjTerm,OTerm,RefType,ATerm) ->
		compile_head_wsflobjref(OTerm,RefType,ATerm,WS,Object,Code,H2BCodeHead,H2BCodeTail,Status)
	    ;
	      compile_head_wsflpathexp(ObjTerm,WS,Object,ObjCode,H2BCodeHead,H2BCodeTail,Status),
	      ( no_errors_found(Status) -> 
		  attach_workspace(WS,
				   objexists_struct(HEADLITERAL,Object,ECode),
				   ECode,WSECode),
		  conjunct_struct(ObjCode,WSECode,Code)
	      ;
	        true
	      )
	    )
	;
	  compile_head_wsflpathexp(ObjTerm,WS,Object,ObjCode,ObjH2BCodeHead,ObjH2BCodeTail,S),
	  ( no_errors_found(S) -> 
	      compile_head_wsflspecbody(Object,SpecBody,WS,SCode,SH2BCodeHead,SH2BCodeTail,Status),
	      ( no_errors_found(Status) -> 
		      conjunct_struct(ObjCode,SCode,Code),
	              conjunct_code([ObjH2BCodeHead,SH2BCodeHead],H2BCodeHead),
	              conjunct_code([ObjH2BCodeTail,SH2BCodeTail],H2BCodeTail)
	       ; true)
	  ;
	    Status=S
	  )
        ).


/****************************************************************************
  compile_head_wsflspecbody(+Object,+SpecTerm,+WS,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
  compile_head_wsmvdattspec(+Object,+AttObj,+RefType,+VL,+WS,-Code,-H2BCodeHead,-H2BCodeTail,-Status)
****************************************************************************/
compile_head_wsflspecbody(Object,SpecTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flconjunct(SpecTerm,L,R),
	!,
	compile_head_wsflspecbody(Object,L,WS,LCode,LH2BCodeHead,LH2BCodeTail,S),
	( no_errors_found(S) -> 
	    compile_head_wsflspecbody(Object,R,WS,RCode,RH2BCodeHead,RH2BCodeTail,Status),
	    ( no_errors_found(Status) -> 
		    conjunct_struct(LCode,RCode,Code),
		    conjunct_code([LH2BCodeHead,RH2BCodeHead],H2BCodeHead),
		    conjunct_code([LH2BCodeTail,RH2BCodeTail],H2BCodeTail)
	     ; true)
	;
	  Status=S
        ).

compile_head_wsflspecbody(Object,SpecTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flmvdattspec(SpecTerm,AttTerm,RefType,VL),
	!,
	compile_head_wsflpathexp(AttTerm,WS,AObj,ACode,AH2BCodeHead,AH2BCodeTail,S),
	( no_errors_found(S) -> 
	    ( VL == [] ->
		attach_workspace(WS,
				 mvdattdef_struct(HEADLITERAL,Object,AObj,RefType,SCode),
				 SCode,WSSCode),
		conjunct_struct(ACode,WSSCode,Code),
		H2BCodeHead=AH2BCodeHead,
		H2BCodeTail=AH2BCodeTail,
		Status=[]
	    ;
	      compile_head_wsmvdattspec(Object,AObj,RefType,VL,WS,VCode,VH2BCodeHead,VH2BCodeTail,Status),
	      ( no_errors_found(Status) -> 
	              conjunct_struct(ACode,VCode,Code),
		      conjunct_code([AH2BCodeHead,VH2BCodeHead],H2BCodeHead),
		      conjunct_code([AH2BCodeTail,VH2BCodeTail],H2BCodeTail)
	       
	      ; true
	      )
	    )
        ;
	  Status=S
        ).

compile_head_wsflspecbody(Object,SpecTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flmethspec(SpecTerm,MethTerm),
	!,
	compile_head_wsflpathexp(MethTerm,WS,MethObj,MCode,H2BCodeHead,H2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     methspec_struct(HEADLITERAL,Object,MethObj,SCode),
			     SCode,WSSCode),
	    conjunct_struct(MCode,WSSCode,Code)
	;
	  true
        ).

compile_head_wsflspecbody(Object,SpecTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flimethspec(SpecTerm,IMethTerm),
	!,
	compile_head_wsflpathexp(IMethTerm,WS,IMethObj,IMCode,H2BCodeHead,H2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     imethspec_struct(HEADLITERAL,Object,IMethObj,SCode),
			     SCode,WSSCode),
	    conjunct_struct(IMCode,WSSCode,Code)
	;
	  true
        ).

compile_head_wsflspecbody(Object,SpecTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_fltranspec(SpecTerm,TranTerm),
	!,
	compile_head_wsflpathexp(TranTerm,WS,TranObj,TCode,H2BCodeHead,H2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     transpec_struct(HEADLITERAL,Object,TranObj,SCode),
			     SCode,WSSCode),
	    conjunct_struct(TCode,WSSCode,Code)
	;
	  true
        ).


%% signatures: =>, *=>, etc.
compile_head_wsflspecbody(Object,SpecTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flsigattspec(SpecTerm,AttTerm,RefType,ValTerm),
	!,
	compile_head_wsflpathexp(AttTerm,WS,AttObj,ACode,AH2BCodeHead,AH2BCodeTail,S),
	( no_errors_found(S) -> 
	    (is_flemptyterm(ValTerm) ->
		%% This is SIGDEF: occurs when we have a[b=> ()]
		attach_workspace(WS,
				 sigattdef_struct(HEADLITERAL,Object,AttObj,RefType,SCode),
				 SCode,WSSCode),
		conjunct_struct(ACode,WSSCode,Code),
		H2BCodeHead=AH2BCodeHead,
		H2BCodeTail=AH2BCodeTail,
		Status=[]
	    ;
		compile_head_wsflpathexp(ValTerm,WS,ValObj,VCode,VH2BCodeHead,VH2BCodeTail,Status),
		( no_errors_found(Status) -> 
		    attach_workspace(WS,
				     sigattspec_struct(HEADLITERAL,Object,AttObj,RefType,ValObj,SCode),
				     SCode,WSSCode),
		    conjunct_code([ACode,VCode,WSSCode],Code),
		    conjunct_code([AH2BCodeHead,VH2BCodeHead],H2BCodeHead),
		    conjunct_code([AH2BCodeTail,VH2BCodeTail],H2BCodeTail)
		;
		    true
		)
	    )
	;
	    Status = S
        ).

compile_head_wsflspecbody(Object,SpecTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flsigattconspec(SpecTerm,AttTerm,ConstrTerm,RefType,ValTerm),
	!,
	compile_head_wsflpathexp(AttTerm,WS,AttObj,ACode,AH2BCodeHead,AH2BCodeTail,S),
	( no_errors_found(S) -> 
	    (is_flemptyterm(ValTerm) ->
		%% This is SIGDEF: occurs when we have a[b=> ()]
		attach_workspace(WS,
				 sigattdef_struct(HEADLITERAL,Object,AttObj,RefType,SCode),
				 SCode,WSSCode),
		conjunct_struct(ACode,WSSCode,Code),
		H2BCodeHead = AH2BCodeHead,
		H2BCodeTail = AH2BCodeTail,
		Status=[]
	    ;
		is_flsigconstr(ConstrTerm,Lower,Upper),
		compile_head_wsflpathexplist([Lower,Upper],WS,[OLower,OUpper],CCode,CH2BCodeHead,CH2BCodeTail,S_C),
		( no_errors_found(S_C) -> 
		    compile_head_wsflpathexp(ValTerm,WS,ValObj,VCode,VH2BCodeHead,VH2BCodeTail,Status),
		    ( no_errors_found(Status) -> 
			attach_workspace(WS,
					 sigattspec_struct(HEADLITERAL,Object,AttObj,RefType,ValObj,SCode),
					 SCode,WSSCode),
			attach_workspace(WS,
					 sigattcondef_struct(HEADLITERAL,Object,AttObj,OLower,OUpper,RefType,ValObj,CSCode),
					 CSCode,CWSSCode),
			conjunct_code([ACode,CCode,VCode,WSSCode,CWSSCode],Code),
			conjunct_code([AH2BCodeHead,CH2BCodeHead,VH2BCodeHead],H2BCodeHead),
			conjunct_code([AH2BCodeTail,CH2BCodeTail,VH2BCodeTail],H2BCodeTail)
		    ;
			true
		    )
		;
		    Status = S_C
		)
	    )
	;
	    Status = S
        ).


%% boolean signatures: =>.
compile_head_wsflspecbody(Object,SpecTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flboolsig(SpecTerm,AttTerm,_RefType),
	!,
	compile_head_wsflpathexp(AttTerm,WS,AttObj,ACode,H2BCodeHead,H2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     boolsig_struct(HEADLITERAL,Object,AttObj,SCode),
			     SCode,WSCode),
	    conjunct_struct(ACode,WSCode,Code)
	;
	    true
	).

%% boolean signatures: *=>.
compile_head_wsflspecbody(Object,SpecTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_fliboolsig(SpecTerm,AttTerm,_RefType),
	!,
	compile_head_wsflpathexp(AttTerm,WS,AttObj,ACode,H2BCodeHead,H2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     iboolsig_struct(HEADLITERAL,Object,AttObj,SCode),
			     SCode,WSCode),
	    conjunct_struct(ACode,WSCode,Code)
	;
	    true
	).

%% boolean signatures: =>% for transactional method
compile_head_wsflspecbody(Object,SpecTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_fltransig(SpecTerm,AttTerm,_RefType),
	!,
	compile_head_wsflpathexp(AttTerm,WS,AttObj,ACode,H2BCodeHead,H2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     transig_struct(HEADLITERAL,Object,AttObj,SCode),
			     SCode,WSCode),
	    conjunct_struct(ACode,WSCode,Code)
	;
	    true
	).

%% boolean signatures: *=>% for transactional method
compile_head_wsflspecbody(Object,SpecTerm,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	is_flitransig(SpecTerm,AttTerm,_RefType),
	!,
	compile_head_wsflpathexp(AttTerm,WS,AttObj,ACode,H2BCodeHead,H2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     itransig_struct(HEADLITERAL,Object,AttObj,SCode),
			     SCode,WSCode),
	    conjunct_struct(ACode,WSCode,Code)
	;
	    true
	).

compile_head_wsmvdattspec(_Object,_AttObj,_RefType,[],_WS,NULL,NULL,NULL,[]) :- !.

compile_head_wsmvdattspec(Object,AttObj,RefType,[T|L],WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	!,
	compile_head_wsflpathexp(T,WS,TObj,TCode,TH2BCodeHead,TH2BCodeTail,S),
	( no_errors_found(S) -> 
	    attach_workspace(WS,
			     mvdattspec_struct(HEADLITERAL,Object,AttObj,RefType,TObj,SCode),
			     SCode,WSSCode),
	    conjunct_struct(TCode,WSSCode,TSCode),
	    compile_head_wsmvdattspec(Object,AttObj,RefType,L,WS,LCode,LH2BCodeHead,LH2BCodeTail,Status),
	    ( no_errors_found(Status) -> 
		    conjunct_struct(TSCode,LCode,Code),
		    conjunct_code([TH2BCodeHead,LH2BCodeHead],H2BCodeHead),
		    conjunct_code([TH2BCodeTail,LH2BCodeTail],H2BCodeTail)
	     ; true)
	;
	  Status=S
        ).


/****************************************************************************
  compile_head_wsflobjeql(+Obj1,+Obj2,+Workspace,-Code,-H2BCodeHead,-H2BCodeTail,-Status)

  H2BCodeHead - code passed from head to body, which is supposed to be
                prepended to the code of the body
  H2BCodeTail - code passed from head to body, which is supposed to be
                appended to the code of the body
****************************************************************************/
compile_head_wsflobjeql(Obj1,Obj2,WS,Code,H2BCodeHead,H2BCodeTail,Status) :-
	compile_head_wsflpathexplist([Obj1,Obj2],WS,[O1,O2],OCode,H2BCodeHead,H2BCodeTail,Status),
	( no_errors_found(Status) -> 
	    attach_workspace(WS,
			     objeql_struct(HEADLITERAL,O1,O2,OECode),
			     OECode,WSCode),
	    conjunct_struct(OCode,WSCode,Code)
	;
	  true
	).

/****************************************************************************
  compile_head_wsflneg(+PosPart,+WS,+Idx,-Code,-H2BCodeHead,-H2BCodeTail,-Status)

  H2BCodeHead - code passed from head to body, which is supposed to be
                prepended to the code of the body
  H2BCodeTail - code passed from head to body, which is supposed to be
                appended to the tail of the code of the body
****************************************************************************/
compile_head_wsflneg(PosPart,WS,Idx,Code,H2BCodeHead,H2BCodeTail,Status) :-
	compile_head_wsliteral(PosPart,WS,PosCode,H2BCodeHead,H2BCodeTail,S),
	( no_errors_found(S) -> 
	    attach_workspace(WS,
			     head_neg_struct(PosCode,Idx,NegCode,Status),
			     NegCode,Code)
	; Status = S
	).


/****************************************************************************
  compile_flinsert(+Op,+List,+Cond,-Code,-Status)
****************************************************************************/
compile_flinsert(Op,List,Cond,Code,Status) :-
	compile_flinsert_literals(List,CodeList,S),
	( no_errors_found(S) -> 
	    compile_body(Cond,CondCode,Status),
	    ( no_errors_found(Status) -> 
		list_struct(CodeList,[],ListCode),
		insert_struct(Op,ListCode,CondCode,Code)
	    ;
	      true
	    )
	;
	  Status=S
        ).

/****************************************************************************
  compile_flinsert(+Op,+List,-Code,Status)
****************************************************************************/
compile_flinsert(Op,List,Code,Status) :-
	compile_flinsert_literals(List,CodeList,Status),
	( no_errors_found(Status) -> 
	    list_struct(CodeList,[],ListCode),
	    insert_struct(Op,ListCode,Code)
	;
	  true
        ).


/****************************************************************************
  compile_flinsert_literals(+List,-DBCodeList,-Status)
****************************************************************************/
compile_flinsert_literals(List,DBCodeList,Status) :-
	set_context(compiling_update_literals),
	compile_flinsert_list(List,Code,Status),
	compile_conjunct2list(Code,CodeList),
	( no_errors_found(Status) -> 
		compile_dbupdate_list(CodeList,DBCodeList)
	;
	    true
	),
	clear_context(compiling_update_literals).


/****************************************************************************
  compile_flinsert_list(+List,-Code,-Status)

  Code is the conjunctions of atoms to be inserted.
****************************************************************************/
compile_flinsert_list([],NULL,[]) :- !.

compile_flinsert_list([H|T],Code,Status) :-
	is_flupdaterule(H,Op,List),
	!,
	is_flatom(Op,OpAtom,_Index),
	List = [R],
	compile_fldynrule(OpAtom,R,HCode,S),
	( no_errors_found(S) -> 
	    compile_flinsert_list(T,TCode,Status),
	    ( no_errors_found(Status) -> 
		conjunct_struct(HCode,TCode,Code); true)
	;
	  Status=S
	).

compile_flinsert_list([H|T],Code,Status) :-
	%% regular fact. may have path expression inside
	compile_head_literal(H,HeadCode1,H2BCodeHead1,H2BCodeTail1,S),
	!,
	( no_errors_found(S) -> 
	    ( H2BCodeHead1==NULL, H2BCodeTail1==NULL
	    ->
		compile_flinsert_list(T,TCode,S2),
		( no_errors_found(S2) -> 
		   conjunct_struct(HeadCode1,TCode,Code)
		; true
		),
		merge_status([S,S2],Status)
	    ;
		%% Head literal contains a path expr, so it becomes a rule.
		%% Treat it as a dynamically inserted rule.
		set_context(compile_with_var_module),
		set_context(compiling_dynrule),
		compile_head_literal(H,HeadCode,H2BCodeHead,H2BCodeTail,S),
		compile_conjunct2list(HeadCode,HCode),
		new_prvariable(NO_INDEX,HVL),
		new_prvariable(NO_INDEX,BVL),
		list_struct(HCode,[],HeadCodeList),
		conjunct_code([H2BCodeHead,H2BCodeTail],H2BCode),
		%% only the vars in the fact-term are to be checked
		delay_literals_checking_code([],H,DelayCode),
		%% Since this rule came from a dynamic fact that contains
		%% a path expression, the annotation code is (NULL,NULL,NULL):
		%% there could not have been an explicit tag.
		%% The third NULL is the defeasible condition to be
		%% attached to rule bodies.
		dynrule_struct(HeadCodeList,H2BCode,HVL,BVL,DelayCode,(NULL,NULL,NULL),HDynruleCode),
		collect_name_var_pairs(H,HeadVars),
		list_struct(HeadVars,[],HVLValue),
		report_dynrule_varlist(HVL,HVLValue),
		collect_name_var_pairs([],BodyVars),
		list_struct(BodyVars,[],BVLValue),
		report_dynrule_varlist(BVL,BVLValue),
		clear_context(compiling_dynrule),
		clear_context(compile_with_var_module),
		compile_flinsert_list(T,TCode,S2),
		( no_errors_found(S2) -> 
		    conjunct_struct(HDynruleCode,TCode,Code)
		; true),
		merge_status([S,S2],Status)
	    )
	;
	    Status=S
	).


/****************************************************************************
  compile_fldelete(+Op,+List,+Cond,-Code,-Status)

  for delete operations with a condition.
****************************************************************************/
compile_fldelete(Op,List,Cond,Code,Status) :-
	compile_fldelete_literals(List,CodeList,S),
	( no_errors_found(S) -> 
	    compile_body(Cond,CondCode,Status),
	    ( no_errors_found(Status) -> 
		list_struct(CodeList,[],ListCode),
		delete_struct(Op,ListCode,CondCode,Code)
	    ;
	      true
	    )
	;
	  Status=S
        ).


/****************************************************************************
  compile_fldelete(+Op,+List,-Code,-Status)

  for delete operations without a condition.
****************************************************************************/
compile_fldelete(Op,List,Code,Status) :-
	compile_fldelete_literals(List,CodeList,Status),
	( no_errors_found(Status) -> 
	    list_struct(CodeList,[],ListCode),
	    delete_struct(Op,ListCode,Code)
	;
	  true
        ).


/****************************************************************************
  compile_fldelete_literals(+List,-DBCodeList,-Status)
****************************************************************************/
compile_fldelete_literals(List,DBCodeList,Status) :-
	set_context(compiling_update_literals),
	compile_fldelete_list(List,CodeList,Status),
	( no_errors_found(Status) -> 
		compile_dbupdate_list(CodeList,DBCodeList)
	;
	    true
	),
	clear_context(compiling_update_literals).


/****************************************************************************
  compile_fldelete_list(+List,-CodeList,-Status)
****************************************************************************/
compile_fldelete_list([],[],[]) :- !.

compile_fldelete_list([H|T],CodeList,Status) :-
	%% When delete list contains an object equality definition, the compiler
	%% will prepare to load the basic equality trailer, unless it is
	%% overridden by an explicity directive.
	is_flobjeql(H,O1,O2),
	!,
	compile_flobjeql(O1,O2,OidCode,SpecCode,S),
	conjunct_code([OidCode,SpecCode],HCode),
	approx_flindex(O1,Idx),
	report_option(FLOBJEQLDEF,Idx),
	( no_errors_found(S) -> 
	    compile_conjunct2list(HCode,HCodeList),
	    compile_fldelete_list(T,TCodeList,Status),
	    ( no_errors_found(Status) -> 
		append(HCodeList,TCodeList,CodeList); true)
	;
	  Status=S
        ).

compile_fldelete_list([H|T],CodeList,Status) :-
	is_flupdaterule(H,Op,List),
	!,
	is_flatom(Op,OpAtom,_Index),
	List = [R],
	compile_fldynrule(OpAtom,R,HCode,S),
	( no_errors_found(S) -> 
	    compile_fldelete_list(T,TCodeList,Status),
	    ( no_errors_found(Status) -> 
		CodeList = [HCode|TCodeList]; true)
	;
	  Status=S
	).

compile_fldelete_list([H|T],CodeList,Status) :-
	%% Call compile_body_literal because path expressions should be
	%% compiled into queries.
        set_context(compile_delete),
	compile_body_literal(H,HCode,S),
        clear_context(compile_delete),
	( no_errors_found(S) -> 
	    compile_conjunct2list(HCode,HCodeList),
	    compile_fldelete_list(T,TCodeList,Status),
	    ( no_errors_found(Status) -> 
		append(HCodeList,TCodeList,CodeList); true)
	;
	  Status=S
        ).


/****************************************************************************
  compile_dbupdate_list(+CodeList,-DBCodeList)

  This predicate processes the list of literals in a DB update. For each
  literal, it tries to add the name of the storage trie for the module.

  Note: a DB update can only update a Flora user module or itself. If a
        Flora system module allows update, it must provide an update interface.
****************************************************************************/
compile_dbupdate_list([],[]) :- !.

compile_dbupdate_list([C|CL],[C|DBCodeList]) :-
	( is_prvariable(C)
        ; is_florasyslib_struct(C,_,_,_,_)
	),
	!,
	compile_dbupdate_list(CL,DBCodeList).

compile_dbupdate_list([C|CL],[DBCode|DBCodeList]) :-
	is_prdynrule(C,_Head,_Body,_HeadVars,_BodyVars,_DelayChecker,_Lab),
	!,
	%% Already compiled, don't tack on FLSYSDBUPDATE
	DBCode = C,
	compile_dbupdate_list(CL,DBCodeList).

compile_dbupdate_list([C|CL],[DBCode|DBCodeList]) :-
	( workspace_struct(_P,WS,C) ->
	    %% The name of the module is known.
	    storage_struct(WS,SCode)
	;
	    thisstorage_struct(fdb,SCode),
	    thismodule_struct(WS)
	),
	atomobj_struct(FLSYSDBUPDATE,FCode),
	prologterm_struct(FCode,3,[C,SCode,WS],DBCode),
	compile_dbupdate_list(CL,DBCodeList).

/****************************************************************************
  compile_flupdatetrule(+Op,+List,-Code,-Status)
****************************************************************************/
compile_flupdaterule(Op,List,Code,Status) :-
	is_flatom(Op,OpAtom,Index),
	compile_fldynrule_list(OpAtom,List,CodeList,Status),
	( no_errors_found(Status) -> 
	    list_struct(CodeList,[],ListCode),
	    updaterule_syslib(OpAtom,UpdateruleLib),
	    florasyslib_struct(Index,UpdateruleLib,1,[ListCode],Code)
	;
	    true
        ).

%% compile_fldynrule_list(+Op,+RuleList,-RuleListCode,-Status)
compile_fldynrule_list(_Op,[],[],[]) :- !.
compile_fldynrule_list(Op,[H|L],[HCode|LCode],Status) :-
	compile_fldynrule(Op,H,HCode,S),
	!,
	( no_errors_found(S) -> 
		compile_fldynrule_list(Op,L,LCode,S1),
		merge_status([S,S1],Status)
	; S = Status
	).

%% compile single dynamic rule
%% compile_fldynrule(+Op,+R,-RCode,-Status)
compile_fldynrule(Op,R,RCode,Status) :-
	is_flruleworkspace(R,Rule,WS),
	!,
	workspaceterm_struct(WS,WSTerm),
	set_context(dynruleworkspace(WSTerm)),
	compile_fldynrule(Op,Rule,RCode,Status),
	clear_contextall(dynruleworkspace(_)).

compile_fldynrule(_Op,R,RCode,Status) :-
	is_flvariable(R,Name,Index),
	varobj_struct(Name,Index,RCode),
	Status=[].

%% Note: prolog-headed rules (declared as :- prolog), including sensors,
%%       are not allowed to be dynamic in Flora-2.
compile_fldynrule(Op,R,RCode,Status) :-
	is_fldynrule(R,Head,Body,Label),
        set_context(compile_with_var_module),
	set_context(compiling_dynrule),
	compile_head(Head,HeadCode1,H2BCodeHead,H2BCodeTail,HeadStatusPre),
        new_prvariable(NO_INDEX,HVL),
	compile_conjunct2list(HeadCode1,HeadCode2),
	remove_empty_list(HeadCode2,HeadCode),
	%% no :- prolog predicates in dynamic rule heads
	(has_prologlit(HeadCode,IdxH)
	-> compiling_error(IdxH,NO_PROLOG_IN_DYNRULE_HEAD,DelayStatus1),
	    DelayStatus = [DelayStatus1]
	; DelayStatus = []
	),
	merge_status([HeadStatusPre,DelayStatus],HeadStatus),
	( no_errors_found(HeadStatus) -> 
	    compile_body(Body,BodyCode1,BodyStatus),
	    ( no_errors_found(BodyStatus) -> 
	        collect_prdatatypevars([HeadCode,BodyCode1],DTVarsCode),
		/*
		%% Note: important to use HeadCode1 here, not HeadCode.
		%% HeadCode is a list, while HeadCode1 a conjunct.
		%% HeadCode is not a valid body literal.
		acyclicity_check_for_head(HeadCode1,HeadAcyclicityCheckCode),
		append(DTVarsCode, %% DTVarsCode - datatype code for variables
		       [HeadAcyclicityCheckCode,H2BCodeHead,BodyCode1,
			H2BCodeTail],
		       BCodeList),
		*/
		append(DTVarsCode,[H2BCodeHead,BodyCode1,H2BCodeTail],BCodeList),
		conjunct_code(BCodeList,BodyCodeSansDelay),

	        list_struct(HeadCode,[],HeadCodeList),
                new_prvariable(NO_INDEX,BVL),
		compile_label(Label,TagCodeIn,MetaCode,LblStatus),
		%% Adjust TagCode for the case when compile_label created a
		%% default rule tag when FLDEFEASIBLE_RULE_DEFAULT is on.
		(has_prtransactionallit(HeadCode,_),
		    is_defaultlabel(TagCodeIn)
		-> TagCode = NULL
		; TagCodeIn == FL_SKIP_TAG -> TagCode = NULL
		;  TagCode = TagCodeIn
		),
		( no_errors_found(LblStatus) -> 
		   (has_prtransactionallit(HeadCode,Idx), TagCode \= NULL, TagCode \= FL_SKIP_TAG
		    %% Transactional literals can't be defeasible
		    -> compiling_error(Idx,LABELED_TRANSACTION_NOT_ALLOWED,Err),
			Status1 = [Err]
		    ;  Status1 = []
		    )
		; Status1 = LblStatus
		),
		approx_flindex(Head,HeadIdx),
		construct_defeasible_condition(HeadIdx,TagCode,DefeatCondCode),
		( no_errors_found(Status1) -> 
		    %% Note: Head cannot contain sensors, so no need to check
		    %% multi-headed rules if sensors mix with non-sensors
		    delay_literals_checking_code(Head,Body,DelayCode),
		    %% Note: If TagCode == NULL, a unique rule Id will be
		    %% created by flrcanon:flora_record_rule_signature at
		    %% runtime.
		    dynrule_struct(HeadCodeList,BodyCodeSansDelay,HVL,BVL,DelayCode,(TagCode,MetaCode,DefeatCondCode),RCode),
		    ( is_fldeleteruleop(Op)
		    ->  true
		    ;   collect_name_var_pairs(Head,HeadVars),
			list_struct(HeadVars,[],HVLValue),
			report_dynrule_varlist(HVL,HVLValue),
			collect_name_var_pairs(Body,BodyVars),
			list_struct(BodyVars,[],BVLValue),
			report_dynrule_varlist(BVL,BVLValue)
		    )
		;
		    true
		),
		merge_status([HeadStatus,BodyStatus,Status1],Status)
	    ;
		merge_status([HeadStatus,BodyStatus],Status)
		%% Status = BodyStatus
	    )
	;
	    Status=HeadStatus
	),
	clear_context(compiling_dynrule),
        clear_context(compile_with_var_module).

remove_empty_list([],[]) :- !.
remove_empty_list([[]|L],NL) :- 
	!,
	remove_empty_list(L,NL).
remove_empty_list([H|L],[H|NL]) :- 
	remove_empty_list(L,NL).


/****************************************************************************
             Table maintenance predicates
     refresh{...} removes the corresponding calls from Prolog tables.
****************************************************************************/
compile_flrefresh(List,Code,Status) :-
	compile_fldelete_list(List,CodeList,Status),
	( no_errors_found(Status) -> 
	    list_struct(CodeList,[],ListCode),
	    table_refresh_struct(ListCode,Code)
	;
	  true
        ).

/****************************************************************************
  compile_flclause(+Mode,+HeadList,+Body,-Code,-Status)
****************************************************************************/
compile_flclause(Label,Mode,HeadList,Body,Code,Status) :-
	compile_label(Label,TagCode1,MetaCode,LabStatus),
	%% If Label == NULL, then ignore what construct_default_label(TagCode1)
	%% does inside compile_label. Otherwise, it will make TagCode1
	%% DEFAULT_RULE_TAG and then clause{Head,Body} won't match anything.
	(Label == NULL -> TagCode = NULL
	; TagCode1 == FL_SKIP_TAG -> TagCode = NULL
	; TagCode = TagCode1
	),
	( no_errors_found(LabStatus) -> 
	    (Mode == NULL -> ModeCode = Mode
	    ;
		compile_flatomvar(Mode,ModeCode)
	    ),
	    set_context(compiling_clause_primitive),
	    set_context(compile_with_var_module),
	    set_context(compiling_headliteral),
	    compile_fldelete_list(HeadList,HLC,S),
	    clear_context(compiling_headliteral),
	    ( no_errors_found(S) -> 
		list_struct(HLC,[],HeadListCode),
		compile_body(Body,BodyCode,Status),
		( no_errors_found(Status) -> 
		    clause_struct(TagCode,MetaCode,ModeCode,HeadListCode,BodyCode,Code)
		;
		    true
		)
	    ;
		Status = S
	    )
	;
	    Status = LabStatus
        ),
        clear_context(compile_with_var_module),
	set_context(compiling_clause_primitive).


/****************************************************************************
             Error handling
     catch{Goal,Err,Handler}
****************************************************************************/
compile_flcatch(Goal,Err,Handler,Code,Status) :-
	compile_body(Goal,GoalCode,GoalStatus),
	( no_errors_found(GoalStatus) -> 
	    compile_pathexp(Err,ErrCode,_OidCode,_ObjSpec,ErrStatus),
	    ( no_errors_found(ErrStatus) -> 
		compile_body(Handler,HandlerCode,Status),
		( no_errors_found(Status) -> 
		    catch_struct(GoalCode,ErrCode,HandlerCode,Code)
		; true
		)
	    ; Status = ErrStatus
	    )
	; Status = GoalStatus
	).

/****************************************************************************
     throw{Err}
****************************************************************************/
compile_flthrow(Err,Code,Status) :-
	compile_pathexp(Err,ErrCode,_OidCode,_ObjSpec,Status),
	( no_errors_found(Status) -> 
	    throw_struct(ErrCode,Code)
	; true
	).


/****************************************************************************
     p2h{Prolog,Hilog}
****************************************************************************/
compile_flp2h(Prolog,Hilog,Code,Status) :-
	compile_pathexp(Prolog,PCode,_POidCode,_PObjSpec,PStatus),
	( no_errors_found(PStatus) -> 
	    compile_pathexp(Hilog,HCode,_HOidCode,_HObjSpec,Status),
	    ( no_errors_found(Status) -> 
		p2h_struct(PCode,HCode,Code)
	    ; true
	    )
	; Status = PStatus
	).


/****************************************************************************
  compile_exec_directive(+DirectList,+WS,-Code,-Status)
  compile_execdirect_list(+DirectList,+WS,-DirectCodeList,-Status)
****************************************************************************/
compile_exec_directive(DirectList,WS,Code,Status) :-
	compile_execdirect_list(DirectList,WS,DirectCodeList,Status),
	conjunct_code(DirectCodeList,Code).


compile_execdirect_list([],_,[],[]) :- !.

compile_execdirect_list([D|L],WS,[DCode|LCode],Status) :-
	compile_execdirect(D,WS,DCode,S1),
	( no_errors_found(S1) -> 
		compile_execdirect_list(L,WS,LCode,Status)
	; Status = S1
	).


/****************************************************************************
  compile_execdirect(+Direct,+WS,-Code)
****************************************************************************/
compile_execdirect(DirectTerm,_WS,Code,Status) :-
        %%to compile the export directive
	is_flexport_list(DirectTerm,Term),
        !,
	compile_export(Term,Code,Status).

compile_execdirect(DirectTerm,WS,Code,Status) :-
	(WS == NULL -> thismodule_struct(Mod)
	; compile_flatomvar(WS,Mod)
	),
	( is_flopdef(DirectTerm,Precedence,Associativity,Op) ->
	    florasyslib_struct(FLLIBSHDIRECT,5,[FL_OP,Mod,Precedence,Associativity,Op],Code),
	    Status = []

	; is_flsemantics(DirectTerm,OptionsList) ->
	    is_fllist(OptionsList,L,T,I),
	    %% compile_fllist shouldn't break here: parser checks everything
	    compile_fllist(L,T,I,OptionListCode,_OidCode,_Code,Status),
	    thismodule_struct(ThisModuleName),
	    florasyslib_struct(FLLIBSEMANTICS,3,[ThisModuleName,OptionListCode,Mod],Code)

	; is_flsetsemantics(DirectTerm,OptionsList) ->
	    is_fllist(OptionsList,L,T,I),
	    %% compile_fllist shouldn't break here: parser checks everything
	    compile_fllist(L,T,I,OptionListCode,_OidCode,_Code,Status),
	    thismodule_struct(ThisModuleName),
	    florasyslib_struct(FLLIBSETSEMANTICS,3,[ThisModuleName,OptionListCode,Mod],Code)

	; is_flindex(DirectTerm,A,P) ->
	    %% transactional numbers are used only in :- index %arity-argument
            ( transactionalnumobj_struct(A,ACode)
	    ; is_fltransactionalvariable(A,AN,AI),
		transactionalvar_struct(AN,AI,ACode)
	    ; numobj_struct(A,ACode)
	    ; is_flvariable(A,AN,AI), varobj_struct(AN,AI,ACode)
	    ),
	    (numobj_struct(P,PCode)
	    ; is_flvariable(P,PN,PI), varobj_struct(PN,PI,PCode)
	    ),
            florasyslib_struct(FLLIBSHDIRECT,4,[FL_INDEX,Mod,ACode,PCode],Code),
	    Status = []

	; is_flsensordirect(DirectTerm,SensCall,DelayCond) ->
	    compile_sensor_direct(SensCall,DelayCond,Direct,Status),
	    directive_struct(Direct,Code)

	; is_flusesensordirect(DirectTerm,PairList,Idx) ->
	    check_symbol_pairlist_for_clashes(PairList,Idx, USE_SENSOR_SYMBOL,
					      NONTRANSACTIONAL_SYMBOL,Status),
	    verbatim_struct(PairList,PairListCode),
	    thismodule_struct(ThisMod),
	    florasyslib_struct(FLLIBRECORDSENSORS,2,[ThisMod,PairListCode],Code),
	    report_option(FLSYSLIB(FLLIBRECORDSENSORS),NO_INDEX)

	; is_flusefunctiondirect(DirectTerm,PairList,Idx) ->
	    check_symbol_pairlist_for_clashes(PairList,Idx, USE_UDF_SYMBOL,
					      NONTRANSACTIONAL_SYMBOL,Status),
	    maplist(usefunction_option(_,_),PairList,PermaOptions),
	    set_permaoptions(PermaOptions)

	/*
	%% Executable :- prolog and :- table directives are not allowed!!!
	%% They are used inside files/documents for optimization only
	%% We consider them non-logical and users are not allowed to call
	%% them directly (sensors are also prolog, but are different in
	%% this respect)
	;  is_flprolog_directive(DirectTerm,PairList,Idx) ->
	    ....
	;  is_fltabledirect(DirectTerm,PredSpecList,_Idx) ->
	    ....
	*/

	;   %% Ensure that prefix definition is recorded in the current module
	    %% to be used in other modules. For instance, if somebody make a
	    %% reference to prefix#local@module
	    is_flprefixdef(DirectTerm,PrefixName,PrefixBody) ->
	    florasyslib_struct(FLLIBPREFIXDEF,3,[Mod,PrefixName,PrefixBody],Code),
	    Status = []

	),
	!.


/*******************************************************************************
compile_delayed_literal(+Op,+Args,+Nesting,-SpecCode,-OidCode,-BodyHeadList,-Status)
compile_delayed_literal(+Op,+Args,+Mod,+Nesting,-SpecCode,-OidCode,-BodyHeadList,-Status)
  Args are expected to be FLLIST
*******************************************************************************/
compile_delayed_literal(Op,Args,Nesting,SpecCode,OidCode,BodyHeadList,Status) :-
	is_flatom(Op,_,Index),
	code_line_and_file_by_index(Index,Line,CurrFileName),
	is_flatom(CurrFileParserObj,CurrFileName,NO_INDEX),
	compile_prlgterm(FLLIBDELAYEDLITERAL,4,[Op,CurrFileParserObj,Line,Args],
			 FLDELAYSUPPORTMOD,
			 Nesting,SpecCode,OidCode,_ACode,BodyHeadList,Status).
compile_delayed_literal(Op,Args,Mod,Nesting,SpecCode,OidCode,BodyHeadList,Status) :-
	is_flatom(Op,_,Index),
	code_line_and_file_by_index(Index,Line,CurrFileName),
	is_flatom(CurrFileParserObj,CurrFileName,NO_INDEX),
	is_flplib(OpModTerm,Op,Mod),
	compile_prlgterm(FLLIBDELAYEDLITERAL,4,[OpModTerm,CurrFileParserObj,Line,Args],
			 FLDELAYSUPPORTMOD,
			 Nesting,SpecCode,OidCode,_ACode,BodyHeadList,Status).


/*******************************************************************************
%% Used for reading FLORA terms (including reified formulas) from within
%% FLORA-2 programs
	flora_compile_pathexp(+ParserTerm,-Code,-Status)
*******************************************************************************/
flora_compile_pathexp(ParserTerm,Code,Status) :-
	compile_pathexp(ParserTerm,ObjectCode,OidCode,SpecCode,Status1),
	( no_errors_found(Status1), (OidCode \= NULL ; SpecCode \= NULL) -> 
	    %%conjunct_code([OidCode,SpecCode],Code)
	    approx_flindex(ParserTerm,Index),
	    compiling_error(Index,READING_NONREIFIED_MOLECULE, S),
	    Status = [S|Status1]
	;
	    Code = ObjectCode, Status = Status1
	).


%% list of data type literals
compile_datatype_list([],[],[]) :- !.
compile_datatype_list([H|Tail],[HCode|TailCode],Status) :-
	(integer(H) -> HCode = H, S1=[] %% list of characters inside DATATYPE
	;
	    compile_pathexp(H,HCode,_,_,S1)
	),
	( no_errors_found(S1) -> 
	   compile_datatype_list(Tail,TailCode,Status)
	;
	    Status=S1
	).

%% Check if Goal is negatable by NEG (explicit negation)
%% Only F-logic atoms (except the derived ones) and HiLog
%% predicates are negatable.
is_head_neg_negatable_literal(PRATOMLIT(_,_)) :- !.
is_head_neg_negatable_literal(PRTERMLIT(_,_,_)) :- !.
is_head_neg_negatable_literal(PREXISTS(_,_)) :- !.
is_head_neg_negatable_literal(PRISA(_,_,_)) :- !.
is_head_neg_negatable_literal(PRSUB(_,_,_)) :- !.
is_head_neg_negatable_literal(PRMVD(_,_,_,_)) :- !.
is_head_neg_negatable_literal(PRIMVD(_,_,_,_)) :- !.
is_head_neg_negatable_literal(PRMVDDEF(_,_,_)) :- !.
is_head_neg_negatable_literal(PRIMVDDEF(_,_,_)) :- !.
is_head_neg_negatable_literal(PRMETH(_,_,_)) :- !.
is_head_neg_negatable_literal(PRIMETH(_,_,_)) :- !.
is_head_neg_negatable_literal(PROBJEQL(_,_,_)) :- !.
is_head_neg_negatable_literal(PRMVDSIG(_,_,_,_)) :- !.
is_head_neg_negatable_literal(PRIMVDSIG(_,_,_,_)) :- !.
is_head_neg_negatable_literal(PRBOOLSIG(_,_,_)) :- !.
is_head_neg_negatable_literal(PRIBOOLSIG(_,_,_)) :- !.
is_head_neg_negatable_literal(PRMVDSIGDEF(_,_,_)) :- !.
is_head_neg_negatable_literal(PRIMVDSIGDEF(_,_,_)) :- !.

is_body_neg_negatable_literal(X) :- is_head_neg_negatable_literal(X), !.
is_body_neg_negatable_literal(X) :-
	workspace_struct(L,_WS,X),
	is_head_neg_negatable_literal(L),
	!.
is_body_neg_negatable_literal(X) :-
	prologterm_atom_arity(X,Atm,Arity1),
	%% modularized prolog predicates have extra caller argument
	Arity is Arity1-1,
	flora_negatable_prlgdef(Atm,Arity,_),
	!.
is_body_neg_negatable_literal(X) :-
	(is_florasyslib_struct(X, _I,FLLIBMODLIT,_N,Args)
	; is_florasyslib_struct(X,_I,FLLIBMODOBJ,_N,Args)
	; is_florasyslib_struct(X, _I,FLNEGLIBMODLIT,_N,Args)
	; is_florasyslib_struct(X,_I,FLNEGLIBMODOBJ,_N,Args)
	),
	Args = [P|_],
	is_body_neg_negatable_literal(P),
	!.
is_body_neg_negatable_literal(X) :-
	X = PRVARIABLE(_,_),
	%% Allow variables to be negated so that
	%% ?X = ${a[b->c]}, neg ?X would be possible.
	%%has_context(goal_reification),
	!.

/*
is_unimplemented_neg_negatable_literal(X) :-
	is_florasyslib_struct(X, _I,_F,_N,_Args).
*/


/*
delay_literals_checking_code(_Head,_Body,Code) :-
	has_context(goal_reification),
	!,
	new_prvariable(NO_INDEX,Code).
*/
delay_literals_checking_code(Head,Body,Code) :-
	collect_flvars(Head,HeadVars1),
	collect_flvars(Body,BodyVars1),
	remove_dupflvars(HeadVars1,HeadVars),
	remove_dupflvars(BodyVars1,BodyVars),
	(has_context(rule_reification),
	    has_context(compiling_body_pathexp)
	-> %% use new flvariables
	    is_flvariable(ParserHeadVars,FL_UNDERSCORE,NO_INDEX),
	    is_flvariable(ParserBodyVars,FL_UNDERSCORE,NO_INDEX)
	;
	    is_fllist(ParserHeadVars,HeadVars,[],NO_INDEX),
	    is_fllist(ParserBodyVars,BodyVars,[],NO_INDEX)
	),
	%% Optimization: if HeadVars contains BodyVars, no delay checking is
	%% needed for that rule. Instead, we put a var instead of the delay
	%% checker. In static & dynamic code, this var is ignored in generating
	%% the corresponding rules. However, dynamic rules are encoded as
	%% FLSYSRULEUPDATE(Id,Head,Body,Hvars,Bvars,DelayCode,Meta,Defeat)
	%% To match with reified rules, we make DelayCode into a new var
	(vars_contains(HeadVars,BodyVars) ->
	    new_dontcare_prvariable(NO_INDEX,Code)
	; compile_prlgterm(FLORA_DELAY_CHECKER,2,
			   [ParserBodyVars,ParserHeadVars],
			   FLDELAYSUPPORTMOD,
			   Code,_OidCode,_ACode,_Status)
	).

/*
%% Input: compiled Head code
%% Output: acyclicity check for Head
acyclicity_check_for_head(HeadCode,HeadAcyclicityCheckCode) :-
	atomobj_struct(is_acyclic,IsCyclicStruct),
	prologterm_struct(IsCyclicStruct,1,[HeadCode],HeadAcyclicityCheckCode).
*/

no_mixed_sensor_nonsensor_heads(CompiledHead,ParsedHead,Status) :-
	(no_mixed_sensor_nonsensor_heads(CompiledHead) -> Status = []
	;  
	    approx_flindex(ParsedHead,I),
	    compiling_error(I,MIXED_HEAD_SENSORS,MixStatus),
	    Status = [MixStatus]
	).

%% cannot add delay-checking code for some heads but not others.
%% we check that there is no mixture of sensors (for which delay-checker
%% is NOT added) and non-sensors (for which delay IS added) here.
%% Used in conjunction with delay_literals_checking_code/2 when Head \= []
no_mixed_sensor_nonsensor_heads([]) :- !.
no_mixed_sensor_nonsensor_heads(HeadList) :-
	all_defined_as_sensors(HeadList) -> true
	; \+ some_defined_as_sensors(HeadList),
	!.

all_defined_as_sensors([]) :- !.
all_defined_as_sensors([Head|HeadList]) :-
	is_defined_as_sensor(Head)
	-> all_defined_as_sensors(HeadList).

some_defined_as_sensors([]) :- !, fail.
some_defined_as_sensors([Head|HeadList]) :-
	is_defined_as_sensor(Head) -> true
	; some_defined_as_sensors(HeadList).

%% sensors can't be in the heads of dynamic rules.
%% so we need to check only the permaoptions
is_defined_as_sensor(Head) :-
	prologterm_atom_arity(Head,Funct,Arity),
	is_pratom(Funct,Atom,_),
	!,
	has_permaoption(sensor(Atom,Arity)).

%% Code that generates a prolog liblit with a given name.
%% **** This is PR code that goes to the coder.
%% For instance, to generate "dummy" true code, use:
%%      generate_prolog_liblit(FL_TRUE,0,[],Code)
%% +PrologAtom, +Arity, +ArgsList, -Code
%% generate_prolog_liblit/4
generate_prolog_liblit(Atom,Arity,Args,Code) :-
	atomobj_struct(Atom,AtomCode),
        prologterm_struct(AtomCode,Arity,Args,Code1),
        prologliblit_struct(Code1,Code).
%% generate_prolog_liblit/5
generate_prolog_liblit(Atom,Arity,Args,PrlgModule,Code) :-
	atomobj_struct(Atom,AtomCode),
        prologterm_struct(AtomCode,Arity,Args,PrlgModule,Code1),
        prologliblit_struct(Code1,Code).

list2commalist([A],(A)) :- !.
list2commalist([A|L], (A,LL)) :- list2commalist(L,LL).

/*
commalist2list((A),[A]) :- !.
commalist2list((A,L), [A|LL]) :- commalist2list(L,LL).
*/


get_current_compile_file(CurrFileName) :-
	flora_current_compile_filename(CurrFileName)->true
	; CurrFileName='(interactive)'.

compiling_flrshell_command :- \+ flora_current_compile_filename(_).



%% This can simplify code when there is no dependency in the intervening code
%% on the outcome of the status codes in the Arg 1 list
merge_status([],[]) :- !.
merge_status([S|Rest],T) :-
	(S == [] -> merge_status(Rest,T)
	; T = S
	).


/***************************************************************************
    rename_prvariables(+VarNameList,+OldFormula,-NewFormula,-NewVarList)
       Replaces each occurrence with each variable in VarNameList with
       a newly created variable (the same for different occurrences of the
       same var name. Returns a new formula and the variable objects used
       in the substitutions.
    rename_one_prvariable(+VarName,+NewVarObj,+Body,-NewBody),
       Replaces each occurrence of a a var object having VarName
       as the variable name with NewVarObj. Returns the newly created formula.
***************************************************************************/
rename_prvariables([],Body,Body,[]) :- !.
rename_prvariables([VarName|VarNameList],Body,NewBody,[NewVarObj|NewVarList]) :-
	new_prvariable(NO_INDEX,NewVarObj),
	rename_one_prvariable(VarName,NewVarObj,Body,NewBody1),
	rename_prvariables(VarNameList,NewBody1,NewBody,NewVarList).

rename_one_prvariable(VarName,NewVarObj,Body,NewBody) :-
	(
	  atomic(Body) -> NewBody = Body
	; var(Body) -> NewBody  = Body
	; is_list(Body)
	-> rename_one_prvariable_in_list(VarName,NewVarObj,Body,NewBody)
	; is_prvariable(Body,VarName,_Idx) -> NewBody = NewVarObj
	; is_pratom(Body,_) ->  NewBody = Body
	; is_prnumber(Body) ->  NewBody = Body
	; is_prstring(Body) ->  NewBody = Body
	; is_prbuiltin_identifier(Body,_) ->  NewBody = Body
	; is_prdatatype(Body,_,_,_) ->  NewBody = Body
	; is_prdatatypelist(Body,_) ->  NewBody = Body
	),
	!.

rename_one_prvariable(VarName,NewVarObj,Body,NewBody) :-
	Body =.. [Wrapper|Args],
	rename_one_prvariable_in_list(VarName,NewVarObj,Args,NewArgs),
	NewBody =.. [Wrapper|NewArgs].

rename_one_prvariable_in_list(_,_,[],[]) :- !.
rename_one_prvariable_in_list(VarName,NewVarObj,[T|Terms],[NewT|NewTerms]) :-
	rename_one_prvariable(VarName,NewVarObj,T,NewT),
	rename_one_prvariable_in_list(VarName,NewVarObj,Terms,NewTerms).


%% Get the line number and file name of code represented by a PRTERM
code_line_and_file_by_prterm(_CompiledTerm,Line,File) :-
	%% in reified cases, do not put the line and file, since reified terms
	%% are not used where they are compiled, so the line number
	%% (and likely) file name are going to be wrong.
	%% Also, explicit line number & file name will prevent unification.
	(has_context(goal_reification) ;
	    has_context(compiling_clause_primitive)
	),
	!,
	new_prvariable(NO_INDEX,Line),
	new_prvariable(NO_INDEX,File).
code_line_and_file_by_prterm(CompiledTerm,Line,File) :-
	(approx_prindex(CompiledTerm,Index), Index \= NO_INDEX
	-> flora_token_index_to_line(Index,Line)
	; Line = NULL
	),
	get_current_compile_file(File).

%% Get the line number and file name of code represented by line/position index
code_line_and_file_by_index(NO_INDEX,NULL,NULL) :- !.
code_line_and_file_by_index(Index,Line,File) :-
	flora_token_index_to_line(Index,Line),
	get_current_compile_file(File).

get_index_line(NO_INDEX,NULL) :- !.
get_index_line(Index,Line) :- flora_token_index_to_line(Index,Line).




/****************************************************************************
 add_symbol(+Name,+N,+WS,+Index,+LineNumber,+Context,+Transactional)
 has_symbol(?Name,?N,?WS,?Index,?LineNumber,?Context,?Transactional)
 flora_clear_compilation_symbols
 add_nowarn_symbol(+Name,+N,+Context)
 has_nowarn_symbol(+Name,+N,+Context)

Predicates for checking usage of symbols with the same name and arity
The goal is to generate warnings/errors if the same symbol is used in different
contexts or user defined function is used before it is declared, etc. 
****************************************************************************/
add_symbol(_Name,_N,_WS,Index,_LineNumber,_Context,_Transactional) :-
	%% do not add symbols that are not in the user program
	(var(Index) ; Index == NO_INDEX),
	!.
add_symbol(Name,N,_WS,_Index,_LineNumber,_Context,_Transactional) :-
	%% do not add builtins
	flora_nodefp(Name,N),
	!.
add_symbol(Name,N,WS,_Index,_LineNumber,_Context,_Transactional) :-
	%% do not add delayed builtins
	flora_get_flatomvar_name(WS,WSName),
	flora_delayed_literal(Name,N,WSName),
	!.
add_symbol(Name,N,NULL,Index,LineNumber,Context,Transactional) :-
	!,
	assert(symbol(Name,N,NULL,Index,LineNumber,Context,Transactional)).
add_symbol(Name,N,WS,Index,LineNumber,Context,Transactional) :-
	is_flvariable(WS,_VarName,_VarIndex),
	!,
	assert(symbol(Name,N,WS,Index,LineNumber,Context,Transactional)).
add_symbol(Name,N,WS,Index,LineNumber,Context,Transactional) :-
	is_prfloralib(WS,WSName,_),
	!,
	assert(symbol(Name,N,WSName,Index,LineNumber,Context,Transactional)).
add_symbol(Name,N,WS,Index,LineNumber,Context,Transactional) :-
	flora_get_flatomvar_name(WS,WSName),
	assert(symbol(Name,N,WSName,Index,LineNumber,Context,Transactional)).

add_nowarn_symbol(Name,N,NULL,Context,Transactional) :-
	!,
	assert(nowarn_symbol(Name,N,NULL,Context,Transactional)).
add_nowarn_symbol(Name,N,WS,Context,Transactional) :-
	is_flvariable(WS,_VarName,_VarIndex),
	!,
	assert(nowarn_symbol(Name,N,WS,Context,Transactional)).
add_nowarn_symbol(Name,N,WS,Context,Transactional) :-
	is_prfloralib(WS,WSName,_),
	!,
	assert(nowarn_symbol(Name,N,WSName,Context,Transactional)).
add_nowarn_symbol(Name,N,WS,Context,Transactional) :-
	flora_get_flatomvar_name(WS,WSName),
	assert(nowarn_symbol(Name,N,WSName,Context,Transactional)).

has_symbol(Name,Arity,_,NO_INDEX,-1,BUILTIN_SYMBOL,_) :-
	flora_nodefp(Name,Arity).
has_symbol(Name,Arity,WS,NO_INDEX,-1,BUILTIN_SYMBOL,_) :-
	flora_get_flatomvar_name(WS,WSName),
	flora_delayed_literal(Name,Arity,WSName).
has_symbol(Name,N,WS,Index,LineNumber,Context,Transactional) :-
	symbol(Name,N,WS,Index,LineNumber,Context,Transactional).

has_nowarn_symbol(Name,N,WS,Context,Transactional) :-
	nowarn_symbol(Name,N,WS,Context,Transactional),
	!.

flora_clear_compilation_symbols :-
	retractall(symbol(_,_,_,_,_,_,_)),
	retractall(nowarn_symbol(_,_,_,_,_)).


/****************************************************************************
no_errors_found(+Status)
****************************************************************************/
no_errors_found(Status) :-
	is_list(Status),
	\+ memberchk(error(_,_), Status).


%% Maplist
maplist(_Pred,[],[]) :- !.
maplist(Pred,[X|Rest],[Y|MapRest]) :-
	copy_term(Pred,PredNew),
	arg(1,PredNew,X),
	arg(2,PredNew,Y),
	call(PredNew),
	maplist(Pred,Rest,MapRest).

%% This replaces atoms with scrambled or modularized atoms
%% in case there was a sensor or prolog declaration
atom_replacement(A,N,AA) :-
	has_permaoption(atomreplacement(A,N,AA)),
	!.
atom_replacement(A,_N,A).

%% this applies to pr-objects
termlit_replacement(PRBUILTIN_IDENTIFIER(F,I),N,PRMODULARIZEDATOM(FF,I)) :-
	atom_replacement(F,N,PRMODULARIZEDATOM(FF)),
	!.
termlit_replacement(PRBUILTIN_IDENTIFIER(F,I),N,PRBUILTIN_IDENTIFIER(FF,I)) :-
	atom_replacement(F,N,FF),
	!.
termlit_replacement(PRATOM(F,I),N,PRMODULARIZEDATOM(FF,I)) :-
	atom_replacement(F,N,PRMODULARIZEDATOM(FF)),
	!.
termlit_replacement(PRATOM(F,I),N,PRATOM(FF,I)) :-
	atom_replacement(F,N,FF),
	!.
termlit_replacement(Funct,_N,Funct).


check_symbol_pairlist_for_clashes([],_Index,_Context,_Trans,[]) :- !.
check_symbol_pairlist_for_clashes([(P,A)|PairList],Index,Context,Trans,Status) :-
	!,
	%% P can be either the sensor name or (PrologSensor,PrologModule)
	(P = (PA,_), !; P=PA),
	is_flatom(PObj,PA,Index),
	check_symbol_name_for_clashes(PObj,A,Context,Trans,S1),
	check_symbol_pairlist_for_clashes(PairList,Index,Context,Trans,S2),
	append(S2,S1,S3),
	sort(S3,Status).
check_symbol_pairlist_for_clashes([P/A|PairList],Index,Context,Trans,Status) :-
	!,
	(P = (PA,_), !; P=PA),
	is_flatom(PObj,PA,Index),
	check_symbol_name_for_clashes(PObj,A,Context,Trans,S1),
	check_symbol_pairlist_for_clashes(PairList,Index,Context,Trans,S2),
	append(S2,S1,S3),
	sort(S3,Status).

make_runtime_modular_prolog_declarations(PairList,Code) :-
	maplist(term_to_prologterm_struct(_,_),PairList,PairListCode),
	list_struct(PairListCode,[],PairListCodeList),
	generate_prolog_liblit(flora_define_modular_prolog,1,
			       [PairListCodeList],
			       flrprolog,PreCode),
	query_struct(PreCode,Code).


%% converts prolog terms to PROLOGTERM structures
term_to_prologterm_struct(Term,PTermStruct) :-
	Term =.. [Funct|Args],
	functor(Term,_,N),
	thismodule_struct(ThisMod),
	N1 is N+1,
	append(Args,[ThisMod],Args1), %% add curent module
	prologterm_struct(Funct,N1,Args1,PTermStruct).
