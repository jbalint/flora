/* File:      flrparser.P  -- The Flora Parser
**
** Author(s): Guizhen Yang
**
** Contact:   kifer@cs.stonybrook.edu
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2010;
**      and Vulcan, Inc., 2008 - 2010.
**
** All rights reserved.
**
** For information about licensing terms, please see
** http://silk.projects.semwebcentral.org/flora2-license.html
**
**
*/


:- compiler_options([xpp_on]).

#include "flora_exceptions.flh"

#define CANOTERM	canoterm
#define CANOLIST	canolist
#define CANOBRACE	canobrace
#define CANOEMPTYTERM	canoemptyterm

#define FLINS		flins
#define FLDEL		fldel
#define FLREF           flref
#define FLCLS           flcls

%% @_module - system module
#define FLORASYSMOD	        florasysmod
%% @_prolog(), @_prolog(...)
#define PROLOGMODULE	        prologmodule
%% @_prologall(), @_prologall(...)
#define PROLOGALLMODULE         prologallmodule
#define FLORAUSERMOD	        florausermod
#define FLORARULEWORKSPACE	floraruleworkspace

#define ALLOW_VARIABLES         allow_variables
#define DISALLOW_VARIABLES      disallow_variables

#define ALLOW_TRANS              allow_trans
#define DISALLOW_TRANS           disallow_trans


#include "flora_errors.flh"
#include "flora_terms.flh"

#define PARSER_CONTEXT	        parsecontext

:- dynamic FLORA_SYMBOL('parser_flag')(_).
:- dynamic PARSER_CONTEXT(_).

initialize_work :-
	clear_context(_).


/****************************************************************************
                           AN INFORMAL BNF GRAMMAR

%% To avoid confusion between some language elements and meta-syntax
%% (e.g., parentheses and brackets are part of BNF and also of the language
%% being described), we enclose some symbols in single quotes to make it
%% clear that they are part of the language syntax, not of the grammar.
%% However, FLORA these symbols can be used with or without the quotes.

Statement := (Rule | Query | Directive) '.'

Rule := (Annotation)? Head (':-' Body)?

Query := '?-' Body

Directive := ':-' ExportDirective | OperatorDirective | SetSemanticsDirective
	             | IgnoreDependencyCheckDirective | ImportModuleDirective
                     | PrefixDirective | CompilerDirective | IndexDirective

Annotation := '@{' Label (HeadLiteral| Term '=' Term)* '}'

Head := HeadLiteral
Head := Head (',' | 'and') Head

HeadLiteral := BinaryRelationship | ObjectSpecification | Term

Body := BodyLiteral
Body := BodyConjunct | BodyDisjunct | BodyNegative | ControlFlowStatement
Body := Body '@' ModuleName
Body := BodyConstraint

ModuleName := atom | atom '(' ')' | atom '(' atom ')' | thisModuleName

BodyConjunct := Body (',' | 'and') Body
BodyDisjunct := Body (';' | 'or') Body
BodyNegative := (('not' | '\+') Body)  |  'false{' Body '}'
BodyConstraint := '{' CLPR-style constraint '}'

ControlFlowStatement  := IfThenElse | UnlessDo
                          | WhileDo | WhileLoop
			  | DoUntil | LoopUntil
IfThenElse := 'if' Body 'then' Body  ('else' Body)?  | Body '<-' Body
UnlessDo   := 'unless' Body 'do' Body
WhileDo    := 'while' Body 'do' Body
WhileLoop  := 'while' Body 'loop' Body
DoUntil    := 'do' Body 'until' Body
LoopUntil  := 'loop' Body 'until' Body

BodyLiteral := BinaryRelationship | ObjectSpecification | Term
                | DBUpdate | RuleUpdate | Refresh
		| NewoidOp | Builtin | Loading
                | CatchExpr | ThrowExpr | TruthTest

Builtin := ArithmeticComparison, Unification, MetaUnification, etc.

Loading := '[' LoadingCommand (',' LoadingCommand)* ']'
LoadingCommand := filename ('>>' atom)

BinaryRelationship := PathExpression ':' PathExpression
BinaryRelationship := PathExpression '::' PathExpression

ObjectSpecification := PathExpression '[' SpecBody ']'

SpecBody := ('not')? MethodSpecification
SpecBody := 'neg'    ExplicitlyNegatableMethodSpecification
SpecBody := SpecBody ',' SpecBody
SpecBody := SpecBody ';' SpecBody

MethodSpecification :=  ('%' | '*')? Term
MethodSpecification :=  PathExpression (ValueReferenceConnective | SigReferenceConnective) PathExpression

ValueReferenceConnective :=  '->' | '*->' | '+>' | '*+>' | '->->' | '*->->'

SigReferenceConnective := ('{' (integer|variable) ':' (integer|variable) '}')? ('=>' | '*=>')

ExplicitlyNegatableMethodSpecification := ('*')? Term
ExplicitlyNegatableMethodSpecification := PathExpression ExplicitlyNegatableReferenceConnective PathExpression

ExplicitlyNegatableReferenceConnective := '->' | '*->' | SigReferenceConnective

                                        
PathExpression := atom | number | string | Uri | variable | specialOidToken
PathExpression := Term | List | ReifiedFormula
PathExpression := PathExpression  PathExpressionConnective PathExpression
PathExpression := BinaryRelationship
PathExpression := ObjectSpecification
PathExpression := Aggregate

Uri := SQname | FullUri

SQname := identifier '#' string

FullUri := '_'string

PathExpressionConnective :=  '.' | '!'

specialOidToken :=  anonymousOid | numberedOid | thisModuleName

ReifiedFormula := '${' (Body | '(' Rule ')') '}'

%% No quotes are allowed in the following special tokens!
%% No space alowed between _# and integer
%% anonymousOid & numberedOid can occur only in rule head
%% or in reified formulas
anonymousOid   := '_#'
%% No space between _# and integer
numberedOid    := '_#'integer
thisModuleName := '_@'

List := '[' PathExpression (',' PathExpression)* ('|' PathExpression)? ']'

Term := Functor '(' Arguments ')'

Term := '%' Functor '(' Arguments ')'

Functor := PathExpression

Arguments := PathExpression (',' PathExpression)*

Aggregate := AggregateOperator '{' TargetVariable (GroupingVariables)? '|' Body '}'
AggregateOperator := 'max' | 'min' | 'avg' | 'sum' | 'collectset' | 'collectbag'
%% Note: only one TargetVariable is permitted.
%% It must be a variable, not a term. If you need to aggregate over terms,
%% as for example, in collectset/collectbag, use the following idiom:
%%      S = collectset{ V | ... , V=Term }
TargetVariable := variable
GroupingVariables := '[' variable, (',' variable)* ']'

DBUpdate := DBOp '{' UpdateList ('|' Body)? '}'
DBOp := 'insert' | 'insertall' | 'delete' | 'deleteall' | 'erase' | 'eraseall'
UpdateList := HeadLiteral ('@' atom)?
UpdateList := UpdateList (',' | 'and') UpdateList
Refresh := 'refresh{' UpdateList '}'

RuleUpdate := RuleOp '{' RuleList '}'
RuleOp := 'insertrule' | 'insertrule_a' | 'insertrule_z' |
               'deleterule' | 'deleterule_a' | 'deleterule_z'
RuleList := Rule | '(' Rule ')'  ( (',' | 'and')  '(' Rule ')' )*

NewoidOp := 'newoid{' Variable '}'

CatchExpr := 'catch{' Body, Term, Body '}'
ThrowExpr := 'throw{' Term '}'
TruthTest := 'true{' Body '}' | 'unknown{' Body '}' | 'false{' Body '}'
****************************************************************************/


/****************************************************************************
  canonical_form(+ComposerTerm,-CanoniTerm)
  canonical_form(+ComposerTerm,-CanoniTerm,-PrimaryIndex)
  translates a structure constructed by the composer into an intermediate
  canonical form. That is to make the functor/arguments syntax compatible
  with the operator syntax.

  CANOTERM(CANOTERM,		% can be any CANOTERM
	   Arity,		% is known at compile time
	   ParenthesisType,	% can be '(', '[', or '{'
	   ListOfArguments,	% are CANOTERMs separated by ',' at top level
	   FunctorIndex,	% primary index of the functor (error message)
	   ParenthesisIndex	% index of the parenthesis (error message)
          )

  CANOLIST(ListOfElements,	% are CANOTERMs separated by ',' at top level
	   Tail,		% is separated by '|'
	   NumberOfElements,	% separated by ',' at the top level excluding tail
	   ParenthesisIndex	% index of the bracket '[' (error message)
           BarIndex		% index of the bar '|' if any
          )

  CANOBRACE(ListOfElements,	% are CANOTERMs separated by ',' at top level
	    NumberOfElements,	% number of terms between {...}
	    ParenthesisIndex	% index of the brace '{' (error message)
           )

  CANOEMPTYTERM(Index)          % This is empty term represented as ()

  OBJECT(PrimitiveType,	% primary type as returned by the composer
	 Index		% index (error message)
        )

  Primitive Types:
    IDENTIFIER
    VARIABLE
    NUMBER
    QUOTED_ATOM
    ASCII_STRING
    SYMBOL_TOKEN
    SPECIAL_TOKEN
****************************************************************************/
canonical_form(ComposerTerm,CanoniTerm) :-
	canonical_form(ComposerTerm,CanoniTerm,_Index).

%% This is to handle arguments enclosed by brackets.
canonical_form(INFIX(S,Left,Right,Index),CanoniTerm,Index) :-
	%% Need to break associativity of these F-logic path operators.
	%% For example, a.b[f->g] is sent in like (a).(b[f->g]).
	%% But the real semantics should be ((a).(b))[f->g].
	%% The same to the URI SQName operator as in a#b[f->g].
	(is_pathop(S);is_urisqop(S);is_datatypeop(S)),
	!,
	%% Separate the arguments of the right operator.
	functor_and_arguments(Right,RightFunct,Args),
	canonical_form(Left,LL,_Ileft),
	canonical_form(RightFunct,RR,Iright),
	arrange_arguments(Args,S,Index,LL,RR,Iright,CanoniTerm).

canonical_form(INFIX(S,Left,Right,Index),CanoniTerm,Index) :-
	!,
	Funct=OBJECT(QUOTED_ATOM(S),Index),
	CanoniTerm=CANOTERM(Funct,2,FL_PARENTHESIS,[LL,RR],Index,NO_INDEX),
	canonical_form(Left,LL,_Ileft),
	canonical_form(Right,RR,_Iright).

canonical_form(PREFIX(S,O,Index),CanoniTerm,Index) :-
	!,
	Funct=OBJECT(QUOTED_ATOM(S),Index),
	%% Ambiguity arises when a prefix operator is written as a functor.
	%% E.g., table(p,2). In such a case, it is transformed to a term.
	( O=ARGUMENT(FL_PARENTHESIS,A,I1,_I2) ->
	    CanoniTerm=CANOTERM(Funct,N,FL_PARENTHESIS,Args,Index,I1),
	    comma_separated_list(A,Args,N)
	;
	  CanoniTerm=CANOTERM(Funct,1,FL_PARENTHESIS,[OO],Index,NO_INDEX),
	  canonical_form(O,OO,_I)
        ).

canonical_form(SUFFIX(S,O,Index),CanoniTerm,Index) :-
	!,
	Funct=OBJECT(QUOTED_ATOM(S),Index),
	CanoniTerm=CANOTERM(Funct,1,FL_PARENTHESIS,[OO],Index,NO_INDEX),
	canonical_form(O,OO,_I).

canonical_form(FUNCTION(Funct,Arg),CanoniTerm,Index) :-
	!,
	canonical_form(Funct,F,Index),
	( Arg = ARGUMENT(B,A,I1,_I2) ->
	    (B==FL_BRACE -> replace_synonyms(F,SynF)
	    ; SynF = F ),
	    CanoniTerm=CANOTERM(SynF,N,B,AList,Index,I1),
	    ( B == FL_BRACKET ->
		N=1,
		AList=[T],
		canonical_form(A,T,_I)
	    ;
	      comma_separated_list(A,AList,N)
	    )
	; Arg=ARGUMENT(B,I1,_I2),
	    (B==FL_BRACE -> replace_synonyms(F,SynF)
	    ; SynF = F )
	->
	    CanoniTerm=CANOTERM(SynF,0,B,[],Index,I1)
	).

%% Peel off pairs of `(' and `)'.
canonical_form(ARGUMENT(FL_PARENTHESIS,Arg,_I1,_I2),A,Index) :-
	!,
	canonical_form(Arg,A,Index).

canonical_form(ARGUMENT(FL_BRACKET,Arg,I1,_I2),CANOLIST(AList,T,N,I1,Ib),I1) :-
	!,
	%% a list
	( Arg = INFIX(FL_BAR,Left,Right,Ib) ->
	    comma_separated_list(Left,AList,N),
	    canonical_form(Right,T,_Ir)
	;
	  T=[],
	  Ib=NO_INDEX,
	  comma_separated_list(Arg,AList,N)
        ).

%% empty list
canonical_form(ARGUMENT(FL_BRACKET,I1,_I2),CANOLIST([],[],0,I1,NO_INDEX),I1) :- !.

canonical_form(ARGUMENT(FL_BRACE,Arg,I1,_I2),CANOBRACE(AList,N,I1),I1) :-
	!,
	comma_separated_list(Arg,AList,N).

canonical_form(ARGUMENT(FL_BRACE,I1,_I2),CANOBRACE([],0,I1),I1) :- !.

canonical_form(ARGUMENT(FL_PARENTHESIS,I1,_I2),CANOEMPTYTERM(I1),I1) :- !.

canonical_form(OBJECT(T,I),OBJECT(T,I),I) :- !.

/*****************************************************************************
**
**  Replace functors with synonyms from flora_special_builtin_synonym/2
**  May be extended to do further transformations in the future.
**
**  For now we only apply synonyms to builtins of the form ident{...}
**  (checked in canonical_form/3)
**
*****************************************************************************/
replace_synonyms(Funct,SynoFunct) :-
	is_obj_quoted_atom_struct(Funct,Atom,Index),
	!,
	flora_special_builtin_synonym(Atom,SynoAtom),
	is_obj_quoted_atom_struct(SynoFunct,SynoAtom,Index).
replace_synonyms(Funct,SynoFunct) :-
	is_obj_ascii_string_struct(Funct,Atom,Index),
	!,
	flora_special_builtin_synonym(Atom,SynoAtom),
	is_obj_ascii_string_struct(SynoFunct,SynoAtom,Index).
replace_synonyms(Funct,SynoFunct) :-
	is_obj_identifier_struct(Funct,Atom,Index),
	!,
	flora_special_builtin_synonym(Atom,SynoAtom),
	is_obj_identifier_struct(SynoFunct,SynoAtom,Index).
replace_synonyms(X,X).
	


/****************************************************************************
  comma_separated_list(+ComposerTerm,-ListOfCommaSeparatedArguments,-Arity)

  This procedure produces a list of comma separated terms. Note
  that `,' is defined as right associative. Only the top level commas
  are considered as separating the list.
****************************************************************************/
comma_separated_list(INFIX(FL_COMMA,Left,Right,_I),[LL|RList],N) :-
	!,
	canonical_form(Left,LL,_Ileft),
	comma_separated_list(Right,RList,M),
	N is M+1.

comma_separated_list(ComposerTerm,[CanoniTerm],1) :-
	!,
	canonical_form(ComposerTerm,CanoniTerm,_Index).


/****************************************************************************
  functor_and_arguments(+ComposerTerm,-Functor,-ArgumentsList)

  Flatten HiLog terms like this: F(A,B)(C,D,E) into F and [(A,B),(C,D,E)].
  Each argument is separated out as a single entity. Another example is
  F(a,b)[f->g], which is broken into F and [(a,b), [f->g]].
****************************************************************************/
functor_and_arguments(FUNCTION(Funct,Arg),F,AList) :-
	!,
	functor_and_arguments(Funct,F,L),
	append(L,[Arg],AList).

functor_and_arguments(T,T,[]).


/****************************************************************************
  arrange_arguments(+Args,+Sym,+IndSym,+Left,+Right,+IndRight,-CanoniTerm)

  Args is a list of arguments, e.g., [(a,b), [f->g]].
  Sym is the infix operator and IndSym is its index number.
  Left is the left operand.
  Right is the right operand and IndRight is its index.

  Need to break associativity of these F-logic path operators. For
  example, a.b[f->g] is sent in like (a).(b[f->g]).  But the real
  semantics should be ((a).(b))[f->g]. Note that a.b[f->g] from the top
  level will call:
  arrange_arguments([[f->g]],'.',some_index,a,b,some_index,CanoniTerm).
  When this procedure returns, CanoniTerm should be ((a).(b))[f->g].
****************************************************************************/
arrange_arguments([],S,Index,Left,Right,_Iright,CanoniTerm) :-
	!,
	Funct=OBJECT(QUOTED_ATOM(S),Index),
	CanoniTerm=CANOTERM(Funct,2,FL_PARENTHESIS,[Left,Right],Index,NO_INDEX).

arrange_arguments([A|L],S,Index,Left,Right,_Iright,CanoniTerm) :-
	%% [f->g] is a special case. Note that a.b[f->g] should be read
	%% as (a.b)[f->g].
	( A = ARGUMENT(FL_BRACKET,Arg,I1,_I2) ->
	    canonical_form(Arg,ArgTerm,_Ia),
	    N=1,
	    ArgList=[ArgTerm]
	;
	  A=ARGUMENT(FL_BRACKET,I1,_I2),
	  N=0,
	  ArgList=[]
        ),
	!,
	Funct=OBJECT(QUOTED_ATOM(S),Index),
	FunctTerm=CANOTERM(Funct,2,FL_PARENTHESIS,[Left,Right],Index,NO_INDEX),
	T=CANOTERM(FunctTerm,N,FL_BRACKET,ArgList,Index,I1),
	arrange_arguments(L,T,Index,CanoniTerm).

%% Datatype operator is not treated right by the composer when it appears
%% in the predicate position:  "aaa"^^bbb(f,g)
%% is composed as ^^("aaa",(bbb(f,g))) instead of ^^("aaa",bbb)(f,g).
%% We rectify the associativity here.
arrange_arguments([A|L],S,Index,Left,Right,_Iright,CanoniTerm) :-
	is_datatypeop(S),
	A = ARGUMENT(FL_PARENTHESIS,Arg,I1,_I2),
	comma_separated_list(Arg,ArgList,N),
	!,
	Funct=OBJECT(QUOTED_ATOM(S),Index),
	FunctTerm=CANOTERM(Funct,2,FL_PARENTHESIS,[Left,Right],Index,NO_INDEX),
	T=CANOTERM(FunctTerm,N,FL_PARENTHESIS,ArgList,Index,I1),
	arrange_arguments(L,T,Index,CanoniTerm).

arrange_arguments([A|L],S,Index,Left,Right,Iright,CanoniTerm) :-
	( A = ARGUMENT(B,Arg,I1,_I2) ->
	    comma_separated_list(Arg,ArgList,N)
	;
	  A=ARGUMENT(B,I1,_I2),
	  N=0,
	  ArgList=[]
        ),
	!,
	%% If the argument is not enclosed by [...], then associate
	%% it with the right operand.
	RR=CANOTERM(Right,N,B,ArgList,Iright,I1),
	arrange_arguments(L,S,Index,Left,RR,Iright,CanoniTerm).


/****************************************************************************
  arrange_arguments(+Args,+CanoniTerm,+Index,-CanoniTerm)

  This predicate is called when the associativity of the path operator
  has been resolved.
****************************************************************************/
arrange_arguments([],CanoniTerm,_Index,CanoniTerm) :- !.

arrange_arguments([A|L],Funct,Index,CanoniTerm) :-
	( A = ARGUMENT(B,Arg,I1,_I2) ->
	    ( B == FL_BRACKET ->
		canonical_form(Arg,ArgTerm,_Ia),
		N=1,
		ArgList=[ArgTerm]
	    ;
 	      comma_separated_list(Arg,ArgList,N)
	    )
	;
	  A=ARGUMENT(B,I1,_I2),
	  N=0,
	  ArgList=[]
        ),
	!,
	T=CANOTERM(Funct,N,B,ArgList,Index,I1),
	arrange_arguments(L,T,Index,CanoniTerm).


/****************************************************************************
  is_pathop(+Operator)
****************************************************************************/
is_pathop(FL_ISA)       :- !.
is_pathop(FL_SUB)       :- !.
is_pathop(FL_MVD)	:- !.
is_pathop(FL_INHERIMVD) :- !.


/****************************************************************************
  utilities
****************************************************************************/
get_name(OBJECT(IDENTIFIER(Name),_I),Name)  :- !.
get_name(OBJECT(QUOTED_ATOM(Name),_I),Name) :- !.
get_name(OBJECT(BUILTIN_IDENTIFIER(Name),_I),Name) :- !.

%% This is provided for other modules
get_atomvar_name(FLTOKEN(Name,_),Name) :- !.
get_atomvar_name(FLATOM(Name,_),Name) :- !.
get_atomvar_name(FLTRANSACTIONALATOM(Name,_),Name) :- !.
get_atomvar_name(FLVAR(Name,_),Name1) :-
	!,
	flora_concat_atoms(['?',Name],Name1).
get_atomvar_name(FLTRANSACTIONALVAR(Name,_),Name1) :-
	!,
	flora_concat_atoms(['%?',Name],Name1).

get_flname_struct(OBJECT(IDENTIFIER(Name),I),FLATOM(Name,I))  :- !.
get_flname_struct(OBJECT(QUOTED_ATOM(Name),I),FLATOM(Name,I)) :- !.
%% Don't add  BUILTIN_IDENTIFIER to get_flname_struct. 
%% Gets confused and can't load system modules like @_sys, etc.

get_flbuiltin_identifier_struct(OBJECT(BUILTIN_IDENTIFIER(Name),I),FLATOM(Name,I))  :- !.

%% get_atom/2
get_atom(OBJECT(SYMBOL_TOKEN(Atom),_I),Atom) :- !.
get_atom(OBJECT(IDENTIFIER(Atom),_I),Atom)   :- !.
get_atom(OBJECT(BUILTIN_IDENTIFIER(Atom),_I),Atom)   :- !.
get_atom(OBJECT(QUOTED_ATOM(Atom),_I),Atom)  :- !.
%% get_atom/3
get_atom(OBJECT(SYMBOL_TOKEN(Atom),I),Atom,I) :- !.
get_atom(OBJECT(IDENTIFIER(Atom),I),Atom,I)   :- !.
get_atom(OBJECT(BUILTIN_IDENTIFIER(Atom),I),Atom,I)   :- !.
get_atom(OBJECT(QUOTED_ATOM(Atom),I),Atom,I)  :- !.

get_transactionalatom(OBJECT(TRANSACTIONAL_IDENTIFIER(Atom),_I),Atom)   :- !.
get_transactionalatom(OBJECT(TRANSACTIONAL_QUOTED_ATOM(Atom),_I),Atom)   :- !.
get_transactionalatom(OBJECT(TRANSACTIONAL_SYMBOL_TOKEN(Atom),_I),Atom)   :- !.
get_transactionalatom(OBJECT(TRANSACTIONAL_BUILTIN(Atom),_I),Atom)   :- !.

get_integer(OBJECT(NUMBER(N),_I),N) :- integer(N).
get_transactionalinteger(OBJECT(TRANSACTIONAL_NUMBER(N),_I),N) :- integer(N).

get_index(CANOTERM(_F,_N,B,_L,Ifunct,Ibrace),Index) :-
	!,
	((B == FL_BRACKET; B == FL_BRACE) -> Index=Ibrace; Index=Ifunct).

get_index(CANOLIST(_L,_T,_N,Index,_Ib),Index) :- !.
get_index(CANOBRACE(_L,_N,Index),Index)      :- !.
get_index(CANOEMPTYTERM(Index),Index)      :- !.
get_index(OBJECT(_PrimitiveType,Index),Index) :- !.

get_index(FLATOM(_Name,Index),Index) :- !.
get_index(FLSTRING(_Str,Index),Index) :- !.
get_index(FLVAR(_Name,Index),Index) :- !.
get_index(FLBUILTIN_IDENTIFIER(_Name,Index),Index) :- !.
get_index(FLDATATYPE(_Sort,_Lit,Index),Index) :- !.


get_spectoken(OBJECT(SPECIAL_TOKEN(Atom),_I),Atom) :- !.

/*************************************************************
	support for numbered anon oids
*************************************************************/
get_spectoken(OBJECT(SPECIAL_TOKEN(Atom,_Num),_I),Atom) :- !.


is_rule(CANOTERM(Funct,2,FL_PARENTHESIS,[Head,Body],_If,_Ip),Head,Body) :-
	get_name(Funct,FL_IMPLYOP).

is_directive(CANOTERM(Funct,1,FL_PARENTHESIS,[Directive],_If,_Ip),Directive) :-
	get_name(Funct,FL_IMPLYOP).

is_query(CANOTERM(Funct,1,FL_PARENTHESIS,[Query],_If,_Ip),Query) :-
	get_name(Funct,FL_QUERYOP).

is_rule_or_fact(CanoTerm) :- \+is_query(CanoTerm,_), \+is_directive(CanoTerm,_).

is_labeled_construct(CANOTERM(Funct,2,FL_PARENTHESIS,[Label,Construct],_If,_Ip),Label,Construct) :-
	get_name(Funct,FL_LABELFUNC).

%% Singleton reification
is_reification(CANOTERM(Funct,N,FL_BRACE,Args,_If,Ip),Args,N,Ip) :-
	get_atom(Funct,Atom),
	is_reifyop(Atom).

annotated_construct_struct(LabelCode,ContentCode,FLLABELEDCONSTRUCT(LabelCode,ContentCode)).

annotation_struct(IdPart,MetaPart,Idx,FLLABEL(IdPart,MetaPart,Idx)).

%% Binary relationship, like : or ::
is_birelop(FL_ISA) :- !.
is_birelop(FL_SUB) :- !.

is_urisqop(FL_URISQOP) :- !.

is_datatypeop(FL_DATATYPE_CONNECTOR) :- !.

is_objrefop(A) :- is_mvdobjrefop(A), !.

is_mvdobjrefop(FL_MVD)	     :- !.
is_mvdobjrefop(FL_INHERIMVD) :- !.

%% Note: a[b=>{c,d}], a[b*=>{c,d}], are no longer legal.
%% Use a[b=>(c,d)] instead.
is_sigattspecop(FL_MVDSIGARROW) :- !.
is_sigattspecop(FL_INMVDSIGARR) :- !.

is_mvdattspecop(FL_MVDARROW)   :- !.
is_mvdattspecop(FL_INMVDARROW) :- !.

is_export_spec(FL_MVDARROW) :- !.

is_boolsigop(FL_BOOLSIGARR) :- !.
is_iboolsigop(FL_INBOOLSIGARR) :- !.

is_transigop(FL_TRANSIGARR) :- !.
is_itransigop(FL_INTRANSIGARR) :- !.

%% +>>, *+>>
is_incattspecop(FL_ALLINARROW)   :- !.
is_incattspecop(FL_INALLINARROW) :- !.

%% ->->, *->->
is_tolistattspecop(FL_TOLISTARROW)   :- !.
is_tolistattspecop(FL_INTOLISTARROW) :- !.

is_aggregtop(FL_MIN)        :- !.
is_aggregtop(FL_MAX)        :- !.
is_aggregtop(FL_SUM)        :- !.
is_aggregtop(FL_AVG)        :- !.
is_aggregtop(FL_COUNT)      :- !.
is_aggregtop(FL_COLLECTSET) :- !.
is_aggregtop(FL_COLLECTBAG) :- !.
is_aggregtop(FL_SET) :- !.
is_aggregtop(FL_BAG) :- !.

is_negop(FL_NEG)	:- !.
is_nafop(FL_NAF)	:- !.
is_notop(FL_TNOT)	:- !.
is_notop(FL_NOT)	:- !.

is_emptyterm(CANOEMPTYTERM(_I)) :- !.

emptyterm_struct(Index,FLEMPTYTERM(Index)).

flrule_struct(Head,Body,FLRULE(Head,Body)).
flfact_struct(Head,FLFACT(Head)).
flquery_struct(Body,FLQUERY(Body)).
fldirective_struct(Direct,Index,FLDIRECTIVE(Direct,Index)).

flexport_wrap_term(WS,Term,Modules,UpdTag,Code) :-
	( var(UpdTag) ->
		Code = (WS,Term,Modules,FLEXPORT_READABLE)
	;
		Code = (WS,Term,Modules,FL_UPDATABLE)
	).
flexport_unwrap_term((WS,Term,Modules,Updtag),WS,Term,Modules,Updtag).

flexport_struct(Term,Modules,Updtag,FLEXPORT(Term,Modules,FLATOM(Updtag,_I))).
flexport_struct(DynamicModule,Term,Modules,Updtag,FLEXPORT(DynamicModule,Term,Modules,FLATOM(Updtag,_I))).
flexport_struct_list(TermList,FLEXPORT_LIST(TermList)).

flprefixdef_struct(PrefixName,PrefixStr,FLPREFIXDEF(PrefixName,PrefixStr)).

fldynrule_struct(Head,Body,Label,FLDYNRULE(Head,Body,Label)).

flimportmodule_struct(Module,FLIMPORTMOD(Module)).

flopdef_struct(P,A,O,FLOPDEF(P,A,O)).
flindxdirect_struct(A,P,FLINDEX(A,P)).
flsemanticsdirect_struct(A,FLSEMANTICS(AList)) :-
	fllist_struct(A,[],NO_INDEX,AList).
flsetsemanticsdirect_struct(A,FLSETSEMANTICS(AList)) :-
	fllist_struct(A,[],NO_INDEX,AList).

fldefeasible_struct(TheoryModule,FLDEFEASIBLE(TheoryModule)).
fldefeasible_rule_default_struct(FLDEFEASIBLE_RULE_DEFAULT).
flstrict_rule_default_struct(FLSTRICT_RULE_DEFAULT).

flverbatim_struct(Instruction,FLVERBATIM(Instruction)).

flnewoidop_struct(Var,FLNEWOIDOP(Var)).

fldatatype_struct(Sort,Literal,Idx,FLDATATYPE(Sort,Literal,Idx)).
fldatatype_listvalue_struct(ListLit,FLDATATYPELIST(ListLit)).

%% flora_compiler_options
flcmpoptdirect_struct(OptList,FLCMPOPT(OptList)).

%% ignore dependency checking on hilog predicates
flignoredepdirect_struct(PredList,FLIGNOREDEP(PredList)).


%% primitive structures with index for textual information
flobject_struct(OBJECT(IDENTIFIER(Atom),I),FLATOM(Atom,I))  :- !.
flobject_struct(OBJECT(QUOTED_ATOM(Atom),I),FLATOM(Atom,I)) :- !.
flobject_struct(OBJECT(SYMBOL_TOKEN(Atom),I),FLATOM(Atom,I)) :- !.
flobject_struct(OBJECT(VARIABLE(Name),I),FLVAR(Name,I)) :- !.
flobject_struct(OBJECT(NUMBER(Num),I),FLNUMBER(Num,I)) :- !.
flobject_struct(OBJECT(ASCII_STRING(Str),I),FLSTRING(Str,I)) :- !.
flobject_struct(OBJECT(SPECIAL_TOKEN(Atom),I),FLTOKEN(Atom,I)) :- !.
%%  support for numbered anon oids
flobject_struct(OBJECT(SPECIAL_TOKEN(Atom,Num),I),FLTOKEN(Atom,Num,I)) :- !.
flobject_struct(OBJECT(BUILTIN_IDENTIFIER(Name),I),FLBUILTIN_IDENTIFIER(Name,I)) :- !.


fltransactionalobject_struct(OBJECT(TRANSACTIONAL_IDENTIFIER(Atom),I),FLTRANSACTIONALATOM(Atom,I))   :- !.
%% For now we just translate transactional builtins as transactional atoms
%% Will see is we change it later
fltransactionalobject_struct(OBJECT(TRANSACTIONAL_BUILTIN(Atom),I),FLTRANSACTIONALATOM(Atom,I))   :- !.
fltransactionalobject_struct(OBJECT(TRANSACTIONAL_QUOTED_ATOM(Atom),I),FLTRANSACTIONALATOM(Atom,I))   :- !.
fltransactionalobject_struct(OBJECT(TRANSACTIONAL_SYMBOL_TOKEN(Atom),I),FLTRANSACTIONALATOM(Atom,I))   :- !.
fltransactionalobject_struct(OBJECT(TRANSACTIONAL_VARIABLE(Name),I),FLTRANSACTIONALVAR(Name,I))      :- !.
fltransactionalobject_struct(OBJECT(TRANSACTIONAL_ASCII_STRING(Str),I),FLTRANSACTIONALSTRING(Str,I))   :- !.

%% transactional numbers are used only in :- index %arity-argument
fltransactionalnumber_struct(OBJECT(TRANSACTIONAL_NUMBER(Num),I),FLTRANSACTIONALNUMBER(Num,I))  :- !.

is_fltransactionalobject_struct(FLTRANSACTIONALATOM(_Atom,_I)) :- !.
is_fltransactionalobject_struct(FLTRANSACTIONALVAR(_Name,_I)) :- !.

is_flatom_struct(FLATOM(Atom,_I),Atom).
is_flnumber_struct(FLNUMBER(_Num,_I)).
is_flstring_struct(FLSTRING(_Str,_I)).
is_flstring_struct(FLSTRING(Str,I),Str,I).

%%is_flbuiltin_identifier_struct(FLBUILTIN_IDENTIFIER(_BuiltinName,_I)).

is_fldatatype_struct(FLDATATYPE(_Sort,_Lit,_I)).

flatom_struct(Atom,Index, FLATOM(Atom,Index)).

get_flvar_struct(OBJECT(VARIABLE(Name),I),FLVAR(Name,I)).
get_fltransactionalvar_struct(OBJECT(TRANSACTIONAL_VARIABLE(Name),I),FLTRANSACTIONALVAR(Name,I)).
is_flvar_struct(FLVAR(_Name,_I)).
is_flvar_struct(FLVAR(Name,I),Name,I).
is_fltransactionalvar_struct(FLTRANSACTIONALVAR(_Name,_I)).
is_anonymous_flvar_struct(FLVAR(FL_UNDERSCORE,_I)).
is_anonymous_fltransactionalvar_struct(FLTRANSACTIONALVAR(FL_UNDERSCORE,_I)).

%% In a list, Front is the part before | and Tail the part after |
%% For instance, in [a,b|[c,d]], front=[flatom(a,9),flatom(b,11)]
%% Tail = fllist([flatom(r,14),flatom(v,16)],[],13))
fllist_struct(Front,Tail,Index,FLLIST(Front,Tail,Index)).
is_fllist_struct(FLLIST(_Front,_Tail,_Idx)).
is_fllist_struct(FLLIST(Front,Tail,Idx), Front, Tail, Idx).

flcut_struct(Index,FLCUT(Index)).
%% primitive structures with index for textual information

%% Atoms that are passed down as literals when they appear in an object spec.
%% For instance, Obj[true], Obj[fail], Obj[!].
is_passthru_atom(FL_CUT).
is_passthru_atom(FL_TRUE).
is_passthru_atom(FL_FAIL).
is_passthru_atom(FL_FALSE).
%% The following are prolog predicates with no separate meaning in FLORA-2
is_passthru_pred(FL_UNIVEQ,2).
is_passthru_pred(FL_UNIVNOTEQ,2).
is_passthru_pred(FL_EQ,2).
is_passthru_pred(FL_NOTEQ,2).
is_passthru_pred(FL_ORDERLT,2).
is_passthru_pred(FL_ORDEREQLT,2).
is_passthru_pred(FL_ORDERGT,2).
is_passthru_pred(FL_ORDEREQGT,2).
is_passthru_pred(FL_IS,2).
is_passthru_pred(FL_MATHEQ,2).
is_passthru_pred(FL_MATHNOTEQ,2).
is_passthru_pred(FL_LT,2).
is_passthru_pred(FL_EQLT,2).
is_passthru_pred(FL_GT,2).
is_passthru_pred(FL_EQGT,2).

flpassthru_struct(Struct,FLPASSTRU(Struct)).
is_passthru_struct(FLPASSTRU(_Struct)).


flbirelate_struct(Subject,R,Object,FLBIRELATE(Subject,R,Object)).

flurisq_struct(PrefixName,LocalName,FLURISQ(PrefixName,LocalName)).

%% object specified using a path expression
flobjref_struct(Object,M,Attribute,FLOBJREF(Object,M,Attribute)).

%% Composes PARSED Funct with PARSED args to compose a parsed term
%% Use flobject_struct/2 to parse Funct
flterm_struct(Funct,Arity,Args,FLTERM(Funct,Arity,Args)).
fltransactionalterm_struct(Funct,Arity,Args,FLTRANSACTIONALTERM(Funct,Arity,Args)).
is_fltransactionalterm_struct(FLTRANSACTIONALTERM(_Funct,_Arity,_Args)).

flaggregt_struct(Op,Var,GroupVars,Conds,FLAGGREGATE(Op,Var,GroupVars,Conds)).
is_flaggregt_struct(FLAGGREGATE(_Op,_Var,_GroupVars,_Conds)).

flobjspec_struct(Object,Spec,FLOBJSPEC(Object,Spec)).

%% Spec represents the arrow type: ->, *->, ->, =>, ...
flmvdattspec_struct(Attribute,Spec,Value,FLMVDATTSPEC(Attribute,Spec,Value)).
flsigattspec_struct(Attribute,Spec,Value,FLSIGATTSPEC(Attribute,Spec,Value)).
flsigattconspec_struct(Attribute,Constr,Spec,Value,FLSIGATTCONSPEC(Attribute,Constr,Spec,Value)).
flincattspec_struct(Attribute,Spec,Value,FLINCATTSPEC(Attribute,Spec,Value)).
fltolistattspec_struct(Attribute,Spec,Value,FLTOLISTATTSPEC(Attribute,Spec,Value)).
flboolsig_struct(Attribute,Spec,FLBOOLSIG(Attribute,Spec)).
fliboolsig_struct(Attribute,Spec,FLIBOOLSIG(Attribute,Spec)).
fltransig_struct(Attribute,Spec,FLTRANSIG(Attribute,Spec)).
flitransig_struct(Attribute,Spec,FLITRANSIG(Attribute,Spec)).

flsigconstr_struct(LowerBound,UpperBound,FLSIGCONSTR(LowerBound,UpperBound)). 

is_flattspec_struct(FLMVDATTSPEC(_A,_S,_V))    :- !.
is_flattspec_struct(FLINCATTSPEC(_A,_S,_V))    :- !.
is_flattspec_struct(FLTOLISTATTSPEC(_A,_S,_V)) :- !.

is_obj_identifier_struct(OBJECT(IDENTIFIER(_Str),_Index)) :- !.
is_obj_quoted_atom_struct(OBJECT(QUOTED_ATOM(_Str),_Index)) :- !.
is_obj_ascii_string_struct(OBJECT(ASCII_STRING(_Str),_Index)) :- !.

is_obj_identifier_struct(OBJECT(IDENTIFIER(Str),Index), Str, Index) :- !.
is_obj_quoted_atom_struct(OBJECT(QUOTED_ATOM(Str),Index), Str, Index) :- !.
is_obj_ascii_string_struct(OBJECT(ASCII_STRING(Str),Index), Str, Index) :- !.

flmethspec_struct(Method,FLMETHSPEC(Method)).

flimethspec_struct(IMethod,FLIMETHSPEC(IMethod)).
is_flimethspec_struct(FLIMETHSPEC(_IMethod)).

fltranspec_struct(Tran,FLTRANSPEC(Tran)).
is_fltranspec_struct(FLTRANSPEC(_Tran)).

flobjeql_struct(O1,O2,FLOBJEQL(O1,O2)).

flconjunct_struct(Cond1,Cond2,FLCONJUNCT(Cond1,Cond2)).

fldisjunct_struct(Cond1,Cond2,FLDISJUNCT(Cond1,Cond2)).

flnaf_struct(Goal,FLNAF(Goal)).
flnot_struct(Goal,FLNOT(Goal)).
flneg_struct(Goal,Index,FLNEG(Goal,Index)).

flload_struct(List,FLLOAD(List)).

flconstraint_struct(Constr,FLCONSTRAINT(Constr)).

is_flworkspace_struct(FLWORKSPACE(_G,_N)).

%% Encoding these module specs: @mod @_mod @_prolog(mod) @_prologall(mod)
flmodule_struct(IgnoreWSLit,_,_,IgnoreWSLit) :-
	ignore_workspace_literal(IgnoreWSLit),
	!.
flmodule_struct(Literal,Module,FLORAUSERMOD,FLWORKSPACE(Literal,Module)) :- !.
flmodule_struct(Literal,Module,FLORASYSMOD,FLFLORALIB(Literal,Module)). :- !.
flmodule_struct(Literal,FLORASYSMOD(Mod),FLORARULEWORKSPACE,FLRULEWORKSPACE(Literal,FLFLORALIB(Mod))) :- !.
flmodule_struct(Literal,WSName,FLORARULEWORKSPACE,FLRULEWORKSPACE(Literal,WSName)) :- !.
flmodule_struct(Goal,Name,PROLOGMODULE,FLPLIB(Goal,Name)). :- !.
flmodule_struct(Goal,Name,PROLOGALLMODULE,FLPLIBALL(Goal,Name)). :- !.

%% Encoding module specs of the form @_prolog() and @_prologall()
%% Takes a goal and protects it against hilog conversion
flplib_struct(Goal,FLPLIB(Goal)) :- !.
flpliball_struct(Goal,FLPLIBALL(Goal)) :- !.

%% Given module spec, get back module type and module name
get_module_from_spec(FLORAUSERMOD(Mod),FLORAUSERMOD,Mod) :- !.
get_module_from_spec(FLORASYSMOD(Mod),FLORASYSMOD,Mod) :- !.
get_module_from_spec(PROLOGMODULE(Mod),PROLOGMODULE,Mod) :- !.
get_module_from_spec(PROLOGALLMODULE(Mod),PROLOGALLMODULE,Mod) :- !.
%%get_module_from_spec(PROLOGMODULE,NULL) :- !.
%%get_module_from_spec(PROLOGALLMODULE,NULL) :- !.


is_flmodulespec_struct(FLWORKSPACE(_G,_N)) :- !.
is_flmodulespec_struct(FLPLIB(_G)) :- !.
is_flmodulespec_struct(FLPLIB(_G,_N)) :- !.
is_flmodulespec_struct(FLFLORALIB(_L,_M)) :- !.
is_flmodulespec_struct(FLPLIBALL(_G)) :- !.
is_flmodulespec_struct(FLPLIBALL(_G,_N)) :- !.

is_dbinsertop(FL_INSERT) :- !.
is_dbinsertop(FL_INSERTALL) :- !.

is_dbinsertop(FL_BTINSERT) :- !.
is_dbinsertop(FL_BTINSERTALL) :- !.

is_dbdeleteop(FL_DELETE) :- !.
is_dbdeleteop(FL_DELETEALL) :- !.
is_dbdeleteop(FL_ERASE) :- !.
is_dbdeleteop(FL_ERASEALL) :- !.

is_dbdeleteop(FL_BTDELETE) :- !.
is_dbdeleteop(FL_BTDELETEALL) :- !.
is_dbdeleteop(FL_BTERASE) :- !.
is_dbdeleteop(FL_BTERASEALL) :- !.

is_tablerefreshop(FL_REFRESH) :- !.
%%is_newmoduleop(FL_NEWMODULE) :- !.
%%is_callermoduleop(FL_CALLERMODULE) :- !.

is_catchop(FL_CATCH) :- !.
is_throwop(FL_THROW) :- !.
is_p2hop(FL_P2H) :- !.

is_newoidop(FL_NEWOIDOP) :- !.

is_ruleupdateop(FL_INSERTRULE) :- !.
is_ruleupdateop(FL_INSERTRULE_A) :- !.
is_ruleupdateop(FL_INSERTRULE_Z) :- !.
is_ruleupdateop(FL_DELETERULE_A) :- !.
is_ruleupdateop(FL_DELETERULE_Z) :- !.
is_ruleupdateop(FL_DELETERULE) :- !.

is_clauseop(FL_CLAUSE) :- !.

is_reifyop(FL_REIFYOP) :- !.

%%is_labelingop(FL_LABELINGOP) :- !.

is_truthvalue_op(FL_TRUE) :- !.
is_truthvalue_op(FL_FALSE) :- !.
is_truthvalue_op(FL_FAIL) :- !.
is_truthvalue_op(FL_UNKNOWN) :- !.

is_labelprimitive_op(FL_LABEL_PRIMITIVE) :- !.
is_prefixprimitive_op(FL_PREFIX_PRIMITIVE) :- !.

flrefresh_struct(List,FLREFRESH(List)).

fltruthvalue_struct(Formula,OpName,FLTRUTHVALUE(Formula,OpName)).
fllabelprimitive_struct(Label,Head,FLLABELPRIMITIVE(Label,Head)).
flprefixprimitive_struct(Prefix,Expansion,Module,FLPREFIXPRIMITIVE(Prefix,Expansion,Module)).

flinsert_struct(Op,List,Cond,FLINSERT(Op,List,Cond)).
flinsert_struct(Op,List,FLINSERT(Op,List)).
fldelete_struct(Op,List,Cond,FLDELETE(Op,List,Cond)).
fldelete_struct(Op,List,FLDELETE(Op,List)).

flnewmodule_struct(Op,Mod,FLNEWMODULE(Op,Mod)).
flerasemodule_struct(Op,Mod,FLERASEMODULE(Op,Mod)).
flcallermodule_struct(Op,Var,FLCALLERMODULE(Op,Var)).
flupdaterule_struct(Op,RuleList,FLUPDATERULE(Op,RuleList)).

flclause_struct(Head,Body,FLCLAUSE(Head,Body)).
flclause_struct(Mode,Head,Body,FLCLAUSE(Mode,Head,Body)).
fllabeledclause_struct(Label,Head,Body,FLLABELEDCLAUSE(Label,Head,Body)).
fllabeledclause_struct(Label,Mode,Head,Body,FLLABELEDCLAUSE(Label,Mode,Head,Body)).

is_flcallermodule_struct(FLCALLERMODULE(_,_)).
is_flupdaterule_struct(FLUPDATERULE(_,_)).
is_flnewmodule_struct(FLNEWMODULE(_,_)).
is_flnewmodule_struct(FLERASEMODULE(_,_)).
is_flinsert_struct(FLINSERT(_,_)).
is_flinsert_struct(FLINSERT(_,_,_)).
is_fldelete_struct(FLDELETE(_,_)).
is_fldelete_struct(FLDELETE(_,_,_)).
is_flrefresh_struct(FLREFRESH(_)).
ignore_workspace_literal(Lit) :-
	(is_flcallermodule_struct(Lit)
	; is_flnewmodule_struct(Lit)
	; is_flupdaterule_struct(Lit)
	; is_flinsert_struct(Lit)
	; is_fldelete_struct(Lit)
	; is_flrefresh_struct(Lit)
	).

is_term_struct(CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip),Funct,N,Args) :-
	flobject_struct(Funct,_).

flifthenelse_struct(Cond,Then,Else,FLIFTHENELSE(Cond,Then,Else)).
flifthen_struct(Cond,Then,FLIFTHEN(Cond,Then)).

%% struct for meta ~
fluniveqform_struct(Left,Right,FLUNIVEQFORM(Left,Right)).
%% struct for =..
flmetauniv_struct(Left,Right,FLMETAUNIV(Left,Right)).

%% struct for ${...}
flreify_struct(Formula,FLREIFYOP(Formula)).
is_flreify_struct(FLREIFYOP(_Formula)).

flcatch_struct(Goal,Error,Handler,FLCATCH(Goal,Error,Handler)).
flthrow_struct(Error,FLTHROW(Error)).
flp2h_struct(Prolog,Hilog,FLP2H(Prolog,Hilog)).

flcontrolconstruct_struct(Cond,Action,FLWHILEDO,FLWHILEDO(Cond,Action)).
flcontrolconstruct_struct(Cond,Action,FLWHILELOOP,FLWHILELOOP(Cond,Action)).
flcontrolconstruct_struct(Cond,Action,FLDOUNTIL,FLDOUNTIL(Cond,Action)).
flcontrolconstruct_struct(Cond,Action,FLLOOPUNTIL,FLLOOPUNTIL(Cond,Action)).
flcontrolconstruct_struct(Cond,Action,FLUNLESSDO,FLUNLESSDO(Cond,Action)).

%% Arg 1: parser's wrapper for control construct
%% Arg 2: top-level keyword of control construct
%% Arg 3: second keyword of construct
get_control_construct_definition(FLWHILEDO,FL_WHILE,FL_DO).
get_control_construct_definition(FLWHILELOOP,FL_WHILE,FL_LOOP).
get_control_construct_definition(FLDOUNTIL,FL_DO,FL_UNTIL).
get_control_construct_definition(FLLOOPUNTIL,FL_LOOP,FL_UNTIL).
get_control_construct_definition(FLUNLESSDO,FL_UNLESS,FL_DO).

%% Management of global parser context
clear_context(X) :- retractall(PARSER_CONTEXT(X)).
report_context(X) :- assert(PARSER_CONTEXT(X)).


/****************************************************************************
  parsing_error(+IndexOrTerm,+ErrorMessage,-Status)

  Note on handling the Status parameter in parsing predicates:
  If a call to a parsing predicate comes with non-empty Status,
  DO NOT call parsing_error/3, but rather pass the Status parameter 
  up to the caller.

  Status must ALWAYS be unbound
****************************************************************************/
parsing_error(Index,ErrorMessage,Status) :-
	integer(Index),
	!,
	Status=[error(Index,ErrorMessage)].

parsing_error(CanoniTerm,ErrorMessage,Status) :-
	get_index(CanoniTerm,I),
	Status=[error(I,ErrorMessage)].


/****************************************************************************
  flora_parse(+ComposerTerm,-Code,-Status)
  is the top level dispatcher.
****************************************************************************/
flora_parse(NULL,NULL,[]) :- !.

flora_parse(ComposerTerm,Code,Status) :-
	initialize_work,
	canonical_form(ComposerTerm,CanoniTerm),
	flora_parse_canonical(CanoniTerm,Code,Status),
	!.

%% This rule is for debugging.
flora_parse(_ComposerTerm,_Code,[error(UNKNOWN_ERROR)]).


flora_parse_canonical(CanoniTerm,Code,Status) :-
	( is_rule(CanoniTerm,Head,Body) ->
	    flora_parse_rule(Head,Body,Code,Status)

	; is_directive(CanoniTerm,Directive) ->
	    flora_parse_directive(Directive,Code,Status)

	; is_query(CanoniTerm,Query) ->
	    flora_parse_query(Query,Code,Status)

	; is_labeled_construct(CanoniTerm,Label,Construct) ->
	    flora_parse_labeled_toplevel_construct(Label,Construct,Code,Status)

	; %% flora_parse_fact must be the last one to call.
	  flora_parse_fact(CanoniTerm,Code,Status)
        ).

/****************************************************************************
  flora_parse_directive(+CanoniTerm,-Code,-Status)
  is the dispatcher for directives.
  Code: FLDIRECTIVE([directives+])

  Note: Textual information is not reserved for compiler directives.
****************************************************************************/
flora_parse_directive(CanoniTerm,Code,Status) :-
	(CanoniTerm = CANOTERM(_Funct,_Arity,_,_L,If,_Ip)
	; is_obj_identifier_struct(CanoniTerm,_,If)
	; get_flbuiltin_identifier_struct(CanoniTerm,_)
	),
	(flora_export_directive(CanoniTerm,NULL,CodeList,Status)
	%%; flora_arguments_directive(CanoniTerm,CodeList,Status)
	; flora_operator_directive(CanoniTerm,CodeList,Status)
	; flora_index_directive(CanoniTerm,CodeList,Status)
	; flora_setsemantics_directive(CanoniTerm,CodeList,Status)
	; flora_cmpopt_directive(CanoniTerm,CodeList,Status)
	; flora_prefixdef_directive(CanoniTerm,CodeList,Status)
	; flora_ignoredep_directive(CanoniTerm,CodeList,Status)
	; flora_importmodule_directive(CanoniTerm,CodeList,Status)
	; flora_defeasible_directive(CanoniTerm,CodeList,Status)
	; flora_defeasible_rule_default_directive(CanoniTerm,CodeList,Status)
	; flora_strict_rule_default_directive(CanoniTerm,CodeList,Status)
	; flora_verbatim_directive(CanoniTerm,CodeList,Status)
        ),
	fldirective_struct(CodeList,If,Code),
	!.

flora_parse_directive(CANOTERM(Funct,_N,_F,_Args,If,_Ip),_Code,Status) :-
	get_name(Funct,FL_AT),
	parsing_error(If,DISALLOWED_DIRECT,Status).

flora_parse_directive(CanoniTerm,_Code,Status) :-
	parsing_error(CanoniTerm,UNKNOWN_DIRECT,Status).


/****************************************************************************
  flora_exec_directive(+CanoniTerm,+FloraModSpec,-Code,-Status)
  Code: FLDIRECTIVE([directives])

  Note: This is to parse those executable directives either from a shell
        or inside a program. Normal directives only affect how a single
        program is translated. Executable directives affect the translation
        of all subsequent command entered from the shell.
****************************************************************************/
flora_exec_directive(CanoniTerm,FloraModSpec,Code,Status) :-
	CanoniTerm = CANOTERM(_Funct,_Arity,_,_L,If,_Ip),
	fldirective_struct(CodeList,If,Code),
	( 
	flora_exec_export_directive(CanoniTerm,FloraModSpec,CodeList,Status)
	%%; flora_arguments_directive(CanoniTerm,CodeList,Status)
	; flora_operator_directive(CanoniTerm,CodeList,Status)
	; flora_exec_index_directive(CanoniTerm,CodeList,Status)
	; flora_exec_setsemantics_directive(CanoniTerm,CodeList,Status)
	; flora_exec_semantics_directive(CanoniTerm,CodeList,Status)
	; flora_prefixdef_directive(CanoniTerm,CodeList,Status)
	),
	!.


/****************************************************************************
  flora_comma_separated_list(+CanoniTerm,-CanoniTermList)
  Converts a comma-separated list into a normal list
****************************************************************************/
flora_comma_separated_list(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),[L|RList]) :-
	%% Comma as an operator is right associative.
	get_atom(Funct,FL_COMMA),
	!,
	flora_comma_separated_list(R,RList).

flora_comma_separated_list(CanoniTerm,[CanoniTerm]) :- !.


/***************************************************************************
   flora_list_to_conjunct(+ListOfCanoniTerms,-ConjunctOfCanoniTerms,+If,+Ip)
   Converts list of terms into a comma-separated list
***************************************************************************/

flora_list_to_conjunct([H],H,_If,_Ip) :- !.
flora_list_to_conjunct([H|Tail],
		       CANOTERM(Funct,2,FL_PARENTHESIS,[H,TailConj],If,Ip),
		       If, Ip) :-
	Funct = OBJECT(QUOTED_ATOM(FL_COMMA),If),
	flora_list_to_conjunct(Tail,TailConj,If,Ip).


/*************************************************************************
   Import module directive

   flora_importmodule_directive(+CanoniTerm,-CodeList,-Status)
*************************************************************************/
flora_importmodule_directive(CANOTERM(Funct,_N,FL_PARENTHESIS,[Modules],_If,_Ip),Code,Status) :-
	%% check directive name.
	get_name(Funct,FL_IMPORTMODULE),
	flora_comma_separated_list(Modules,TermList),
	flora_importmodule_parse_termlist(TermList,Code,Status),
	!.
%% error
flora_importmodule_directive(CANOTERM(Funct,_N,FL_PARENTHESIS,_Args,If,_Ip),_Code,Status) :-
	%% check directive name.
	get_name(Funct,FL_IMPORTMODULE),
	!,
	parsing_error(If,ERROR_IMPORTMODULE,Status).

flora_importmodule_parse_termlist([],[],[]) :- !.
flora_importmodule_parse_termlist([H|T],Code,Status) :-
	flora_importmodule_parse_term(H,HCode,HStatus),
	( HStatus == [] ->
	    flora_importmodule_parse_termlist(T,TCode,Status),
	    Code = [HCode|TCode]
	;
		Status = HStatus
	).

flora_importmodule_parse_term(Module,Code,Status) :-
	flora_export_check_module(Module,Status),
	\+get_flvar_struct(Module,_),
	flora_pathexp(Module,DISALLOW_TRANS,NULL,Code1,Status),
	flimportmodule_struct(Code1,Code),
	!.

%% error case
flora_importmodule_parse_term(Term,[],Status) :-
	get_index(Term,Ind),
	parsing_error(Ind,ERROR_IMPORT_MODULE_SYNTAX,Status).



/******************** PARSING FOR EXPORT ********************************/

/************************************************************************
	The canonical term structure is something like this:
		canoterm(export, N, FL_PARENTHESIS, Args, _, _)
	N	-> Indicates the number of terms in the external module (modules exported too) list.
	Args	->[canoterm(>>, N', FL_PARENTHESIS, Args', _, _) | <ExportedModuleList = m2,m3... mn>]
	Args'	->[canoterm(Exported_Term), m1],

	Semantics:
	1.No external modules specified:
	  The particular perdicate has to be exported to all modules.

	2.None of the predicates of a module are exported:
	  The modules does not require any encapsulation.

	When N=1, the difference is the following:

	In the case where there is a module name, the argument Args:
		canoterm(>>, N', FL_PARENTHESIS, Args', _, _)
	and Args' contains the exported term & the first module name.

	In case there is no external module.
	1. there is no >>
	2. the third argument is FL_BRACKET
	3. the canonical term actually represents the exported term

	The exported term list is first regularized and converted to
	a form  = [(ws,term,modules,is_updatable), (ws,term,modules,is_updatable), ...].
	We then individually work with the members of the list, reporting
	any errors if they occur.

****************************************************************************/


/****************************************************************************
 flora_exec_export_directive(+CanoniTerm,+FloraModSpec,-CodeList,-Status)
 Parsing for the executable directive case.
****************************************************************************/
%% Export for a dynamic module.
%% WS = dynamic module name, may or may not be specified.
flora_exec_export_directive(CanoniTerm,WS,CodeList,Status):-
	flora_export_directive(CanoniTerm,WS,CodeList,Status),
	(var(Status) ->
		Status = []
	;
		true
	).


/****************************************************************************
 flora_export_directive(+CanoniTerm,+WorkSpace,-CodeList,-Status)
 The work-horse that does the parsing both in the executable and
 non-executable case.
****************************************************************************/
flora_export_directive(CANOTERM(Funct,_N,FL_PARENTHESIS,Args,_If,_Ip),WS,[Code],Status) :-
	%% check directive name.
	get_name(Funct,FL_EXPORT),
	%% parse the exported terms
	flora_regularize_export_spec(Args,WS,TermList),
	%% parse the list
	flora_export_parse_term_list(TermList,[],TermListCode,Status),
	flexport_struct_list(TermListCode,Code),
	!.

%% error case.
flora_export_directive(CANOTERM(Funct,_N,FL_PARENTHESIS,_Args,If,_Ip),_WS,_Code,Status) :-
	%% check directive name.
	get_name(Funct,FL_EXPORT),
	!,
	parsing_error(If,ERROR_EXPORT,Status).


/****************************************************************************
 flora_regularize_export_spec(+ExportedTerms,+WorkSpace,-CodeList,-Status)
 The work-horse that first regularises and then does the parsing both 
 in the executable and non-executable case.
****************************************************************************/
%% Export as an operator, multiple terms exported.
%% :-(export(','((term>>m1),m2,m3... ))
flora_regularize_export_spec([CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,Ip)],WS,ListCode) :-
	get_name(Funct,FL_COMMA),
	!,
	%% convert a comma-separated list into a normal list
	flora_comma_separated_list(CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,Ip),List),
	%% regularize to a list
	flora_export_compose_term_list(List,[],WS,_IsUpd,ListCode).

%% for all other cases.
%% :-(export( (term1),(term2),(term3) ))
%% One or many terms exported (may be enclosed by paranthesis).
%% typical canonical term = (export((term>>m1),m2,m3...mn))
flora_regularize_export_spec(Args,WS,ListCode) :-
	%% regularize to a list
	flora_export_compose_term_list(Args,[],WS,_IsUpd,ListCode),
	!.


/****************************************************************************
 flora_export_compose_term_list(+Args,+InitTermCode,+WorkSpace,+IsUpdatable,-ExportCode)
 InitTermCode represents the list of terms processed till now.
 It is initally an empty list ([]) and gets populated progressively.
***************************************************************************/
%% single term exported
%% t1>>m1,m2,m3
flora_export_compose_term_list(Args,_InitTermCode,WS,IsUpd,[Code]) :-
	flora_export_check_single_term(Args),
	flora_export_compose_term(Args,WS,IsUpd,Code).

flora_export_compose_term_list([H|T],InitTermCode,WS,IsUpd,Code) :-
	%% The flora_export_compose_term expects the argument to be a list.
	%% That list may contain more than one members in the case where the 
	%% term is exported to more than one modules.
	flora_export_compose_term([H],WS,IsUpd,TermCode),
	%% The Code is usually a single term. However in cases 
	%% like (t1,t2) >> (m1,m2,m3), it is a list. In this case
	%% we need to explicitly append it to a list.
	%% When it is not a list, (t >> m1,m2...), then the append
	%% will fail and hence the second case.
	(	
	  %% If TermCode is a list - append
	  %% Happens when exported things like (t1,t2) >> (m1,m2,m3)
	  append(TermCode,InitTermCode,List)

	;
	  %% in other cases where it is a simple term and not a list.
	  List = [TermCode|InitTermCode]
	),
	flora_export_compose_term_list(T,List,WS,IsUpd,Code).

flora_export_compose_term_list([],InitTermCode,_WS,_IsUpd,Code) :- 
	Code = InitTermCode,
	!.

/****************************************************************************
 flora_export_compose_term(+ExportedTerm,+WorkSpace,+IsUpdatable,-TermCode)
****************************************************************************/
%% with the updatable tag.
flora_export_compose_term([CANOTERM(Funct,_N,FL_PARENTHESIS,Args,_If,_Ip)],WS,_IsUpdatable,ExportCode) :-
	%% check whether the Funct is updatable
	get_name(Funct,FL_UPDATABLE),
	%% single or mutiple terms enclosed.
	(
	  flora_export_compose_term(Args,WS,FL_UPDATABLE,ExportCode),
	  !
	;
	  flora_export_compose_term_list(Args,[],WS,FL_UPDATABLE,ExportCode)
	).


/****************************************************************************
 One or many external modules (or terms) specified.
 ==================================================
 Term >> (Module(s))
 canoterm(RIGHTTO,_,FL_PARANTHESIS, [canoterm(Term),canoterm(ModuleList)],_,_)

 (Term1, Term2, ...) >> (Module(s))
 canoterm(RIGHTTO,N,FL_PARANTHESIS, [ canoterm(comma,_,FL_PARANTHESIS,[canoterm(Term1),canoterm(Term2)...],_,_),
				     canoterm(ModuleList)
				   ],_,_)

 Term >> Module(s)
 canoterm(RIGHTTO,_,FL_PARANTHESIS, [canoterm([Term,FirstModule]),OtherModuleList],_,_)
****************************************************************************/
flora_export_compose_term([CANOTERM(Funct,_N,FL_PARENTHESIS,[Term|FirstModule],_If,_Ip)|OtherModules],WS,IsUpdatable,Code) :- 
	get_name(Funct,FL_RIGHTTO),
	append(FirstModule,OtherModules,Modules),
	(
		%% may be a list of term instead of a sinlge term.
		%% (t1,t2) >> (m1,m2)
		flora_export_wrap_multiple_terms(WS,Term,Modules,IsUpdatable,Code)
	;	
		flexport_wrap_term(WS,Term,Modules,IsUpdatable,Code)
	),
	!.


/****************************************************************************
 First term in case when export is used as an operator.
 ==================================================
 Say the export statement is :- export (_[c1->_]>>m3,m4), _[b1(_,_)->_]>>m1.

 flora_comma_separated_list returns the exported list in the following form:
 [ canoterm(comma,_,FL_PARANTHESIS,[canoterm(FirstExportedTerm)],_,_),
   canoterm(SecondExportedTerm), ....]

 Thus for the first term, we need extract the canonical term by stripping the 
 comma. The predicate below does the same.
****************************************************************************/
flora_export_compose_term([CANOTERM(Funct,_N,FL_PARENTHESIS,Args,_If,_Ip)],WS,IsUpdatable,Code) :- 
	get_name(Funct,FL_COMMA),
	flora_export_compose_term(Args,WS,IsUpdatable,Code),
	!.

/****************************************************************************
 No modules specified (=exported to all modules).
 ================================================
 export(p(_,_)).
 export(_[a->_]).
 Term = canoterm(ExportedTerm)
****************************************************************************/
flora_export_compose_term([CANOTERM(Funct,N,PType,Args,If,Ip)],WS,IsUpdatable,Code) :- 
	flexport_wrap_term(WS,CANOTERM(Funct,N,PType,Args,If,Ip),[],IsUpdatable,Code),
	!.

%% simple atom exported, export(flora2).
flora_export_compose_term([Args],WS,IsUpdatable,Code) :- 
	get_name(Args,_Name),
	flexport_wrap_term(WS,Args,[],IsUpdatable,Code),
	!.

flora_export_compose_term([Args],WS,IsUpdatable,Code) :- 
	get_transactionalatom(Args,_Name),
	flexport_wrap_term(WS,Args,[],IsUpdatable,Code),
	!.

%% variable exported. export(F).
flora_export_compose_term([OBJECT(VARIABLE(Term),N)],WS,IsUpdatable,Code) :- 
	flexport_wrap_term(WS,OBJECT(VARIABLE(Term),N),[],IsUpdatable,Code),
	!.

flora_export_compose_term([OBJECT(TRANSACTIONAL_VARIABLE(Term),N)],WS,IsUpdatable,Code) :- 
	flexport_wrap_term(WS,OBJECT(TRANSACTIONAL_VARIABLE(Term),N),[],IsUpdatable,Code),
	!.

/****************************************************************************
 flora_export_wrap_multiple_terms(+WorkSpace,+Args,+InitTermCode,+Modules,+IsUpdatable,-Code)
 Transfroms (t1,t2) >> (m1,m2,m3) --> [(t1,(m1,m2,m3)) , (t2,(m1,m2,m3))]
***************************************************************************/
flora_export_wrap_multiple_terms(WS,CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,Ip),Modules,IsUpdatable,Code) :-
	get_name(Funct,FL_COMMA),
	%% convert a comma-separated list into a normal list
	flora_comma_separated_list(CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,Ip),List),
	flora_export_wrap_termlist(List,[],WS,Modules,IsUpdatable,Code).


/****************************************************************************
 flora_export_wrap_termlist(+Args,+InitTermCode,+WorkSpace,+Modules,+IsUpdatable,-Code)
***************************************************************************/
flora_export_wrap_termlist([H|T],InitTermCode,WS,Modules,IsUpdatable,Code) :-
	flexport_wrap_term(WS,H,Modules,IsUpdatable,HCode),
	flora_export_wrap_termlist(T,[HCode|InitTermCode],WS,Modules,IsUpdatable,Code).

flora_export_wrap_termlist([],InitTermCode,_WS,_Modules,_IsUpd,Code) :- 
	Code = InitTermCode,
	!.
	

/****************************************************************************
 flora_export_parse_term_list(+TermList,+IntialTermCode,-TermListCode,-Status)
****************************************************************************/
flora_export_parse_term_list([H|T],InitialTerm,Code,Status) :-
	flora_export_parse_term(H,HCode,HStatus),
	( HStatus == [] ->
		flora_export_parse_term_list(T,[HCode|InitialTerm],Code,Status)
	;
		Status = HStatus
	).

flora_export_parse_term_list([],InitialTerm,Code,_Status) :-
	Code = InitialTerm,
	!.


/****************************************************************************
 flora_export_parse_term(+Term,-TermCode,-Status)
 Term = (WS,Term,Modules,IsUpd)
 TermCode = flrexport()
	The parsing of the exported term(s) takes place in two steps. 
 Initially, each exported term is normalized and wrapped in its 
 standard form. This list then gets parsed by unwrapping its members
 one-by-one.
****************************************************************************/
flora_export_parse_term(TermCode,ExportCode,Status) :-
	flexport_unwrap_term(TermCode,WS,Term,Modules,IsUpdatable),
	%% check for errors in the term exported
	flora_export_check_error(Term,Status),
	(var(Status) -> 
	    flora_export_check_module(Modules,Status)
	;
	    true
	),
	(var(Status) -> 
	    (
		flora_export_parse_body_term(Term,WS,TCode,StatusBody),
		flfact_struct(TCode,FactTermCode),
		%% the module(s)
		(StatusBody == [] ->
		    flora_export_parse_modules(Modules,ModuleCode,Status)
		;
		    Status = StatusBody
		),
		fllist_struct(ModuleCode,[],1,ModuleCodeList),
		flora_export_struct(WS,FactTermCode,ModuleCodeList,IsUpdatable,ExportCode)
	)
	;
	    true
	).


/****************************************************************************
 flora_export_parse_body_term(+Args,+WS,-Code,-Status)
 Parses the predicate body by calling the appropriate flora_body predicate.
      WS is initialized through the flora_exec_export_directive call. 
      When the same module exports the term, the variable WS will be NULL.
      Else, it may be an atom or a variable.
 ATOM: ?- (export foo)@bar.
 VARIABLE: ?- (export foo)@?WS.
      In the latter case, the variable WS needs to be instantaited when the
 program is loaded else an error (Attempt to export from an invalid or 
 uninstantiated module/term) will be reported.
****************************************************************************/
flora_export_parse_body_term(Term,WS,Code,Status) :-
	flora_body(Term,WS,WS,Code,Status).


/****************************************************************************
 flora_export_parse_modules(+Args,-ModuleCode,-Status)
***************************************************************************/
%% term >> (m1,m2,m3...mn). Modules enclosed within paranthesis.
flora_export_parse_modules([CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,Ip)],OtherModuleList,Status) :-
        get_name(Funct,FL_COMMA),
        !,
	flora_comma_separated_list(CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,Ip),ModuleList),
	flora_pathexplist(ModuleList,NULL,OtherModuleList,Status).
	
%% general case, term>>m1,m2,m3...mn. Modules NOT enclosed within parentheses.
flora_export_parse_modules(OtherModules,OtherModuleList,Status) :-
        %% the other module names 
	flora_pathexplist(OtherModules,NULL,OtherModuleList,Status).


/****************************************************************************
 flora_export_struct(+WorkSpace,+TermCode,+ModuleListCode,+IsUpdatable,-ExportCode)
**************************************************************************/
flora_export_struct(WS,TermCode,ModuleCodeList,IsUpdatable,ExportCode) :-
	(WS==NULL -> 
		flexport_struct(TermCode,ModuleCodeList,IsUpdatable,ExportCode)
	;
                get_module_from_spec(WS,_ModuleType,Module),
		flexport_struct(Module,TermCode,ModuleCodeList,IsUpdatable,ExportCode)
	).


/**************** start of error handling for export ************************/


/****************************************************************************
 flora_export_check_single_term(+Term)
 %% whether only one term is exported.
 %% [Term,m1,m2...], term and the modules to which it is exported.
****************************************************************************/
%% module name is atom.
flora_export_check_single_term([CANOTERM(_Funct,_N,_FL,_Args,_If,_Ip),OBJECT(IDENTIFIER(_Atom),_)|_T]) :- !.
%% module is system module.
flora_export_check_single_term([CANOTERM(_Funct,_N,_FL,_Args,_If,_Ip),
				CANOTERM(OBJECT(IDENTIFIER(_ATOM),_),_N1,_FL1,_ARGS,_If1,_Ip1)|_T]) 
				:-!.
%% module name is variable.
flora_export_check_single_term([CANOTERM(_Funct,_N,_FL,_Args,_If,_Ip),OBJECT(VARIABLE(_Atom),_)|_T]) :- !.


/****************************************************************************
 flora_export_check_error(+Term,-Status)
****************************************************************************/
%% a simple atom exported.
flora_export_check_error(Atom,_Status) :-
        get_name(Atom,_Name),!.	

flora_export_check_error(Atom,_Status) :-
        get_transactionalatom(Atom,_Name),!.	

%% hilog predicate case, p(_,_) or %p(_,_)
flora_export_check_error(CANOTERM(MethodName,_N,FL_PARENTHESIS,ArgList,_If,_Ip),Status) :-
	flora_export_check_method_name(MethodName,Status),
	(var(Status) -> 
		flora_export_check_attribute_list(ArgList,Status)
	; 
		true
	),
	!.
	
%% Object spec : ...[...]
flora_export_check_error(CANOTERM(ObjectID,_N,FL_BRACKET,[MethodBody],_If,_Ip),Status) :-
	flora_export_check_variable(ObjectID,Status),
	(var(Status) -> 
		flora_export_check_method(MethodBody,Status)
	;
		true
	),
	!.

%% Case when the term is a variable. Let it go through.
%% Term >> m1, m2
flora_export_check_error(OBJECT(VARIABLE(_Term),_),_Status).
flora_export_check_error(OBJECT(TRANSACTIONAL_VARIABLE(_Term),_),_Status).


/****************************************************************************
 flora_export_check_variable(+Term,-Status)
****************************************************************************/
flora_export_check_variable(Term,Status) :-
	( get_flvar_struct(Term,_VariableStruct)
	  ; flora_export_construct_error(Term,ERROR_EXPORT_ATOM,Status)
	).


/****************************************************************************
 flora_export_check_method(+Term,-Status)
****************************************************************************/
%% multiple predicates, separated by commas are exported to a set of modules.
flora_export_check_method([H|T],Status) :-
	flora_export_check_method(H,Status),
	(var(Status) -> 
		flora_export_check_method(T,Status)
	;
		true
	).

flora_export_check_method(CANOTERM(Funct,_N,FL_PARENTHESIS,[H|T],_If,_Ip),Status) :-
	get_atom(Funct,FL_COMMA),
	flora_export_check_method(H,Status),
	(var(Status) -> 
		flora_export_check_method(T,Status)
	;
		true
	),
	!.

flora_export_check_method([],_Status) :- !.

%% _[MethodName(AttrList) -> _]
%% _[MethodName(AttrList) => _]
flora_export_check_method(CANOTERM(MethodSpec,_N1,FL_PARENTHESIS,[CANOTERM(MethodName,_N2,FL_PARENTHESIS,AttributeList,_If2,_Ip2),ReturnVar],_If1,_Ip1),Status) :-
	flora_export_check_spec(MethodSpec,Status),
	(var(Status) ->
		flora_export_check_method_name(MethodName,Status)
	;
		true
	),
	(var(Status) ->
		flora_export_check_attribute_list(AttributeList,Status)
	;
		true
	),
	(var(Status) ->
		flora_export_check_variable(ReturnVar,Status)
	;
		true
	),
	!.

%% method with no attributes.
%% _[MethodName -> _]
%% _[MethodName => _]
flora_export_check_method(CANOTERM(MethodSpec,_N1,FL_PARENTHESIS,[MethodName,ReturnVar],_If1,_Ip1),Status) :-
	flora_export_check_spec(MethodSpec,Status),
	(var(Status) ->
		flora_export_check_method_name(MethodName,Status)
	;
		true
	),
	(var(Status) ->
		flora_export_check_variable(ReturnVar,Status)
	;
		true
	),
	!.

%% tabled Boolean method like _[p(_)]
flora_export_check_method(CANOTERM(MethodName,_N1,FL_PARENTHESIS,AttributeList,_If1,_Ip1),Status) :-
	flora_export_check_method_name(MethodName,Status),
	(var(Status) ->
		flora_export_check_attribute_list(AttributeList,Status)
	;
		true
	),
	!.

%% No arguments & return value (like [p]).
flora_export_check_method(Term,Status) :-
        flora_export_check_method_name(Term,Status).


/****************************************************************************
 flora_export_check_method_name(+Term,-Status)
****************************************************************************/
%% exported terms like p(a,?)[...] are not allowed.
flora_export_check_method_name(CANOTERM(MethodName,_N1,FL_PARENTHESIS,AttributeList,_If1,_Ip1),Status) :-
	flora_export_check_method_name(MethodName,Status),
	(var(Status) ->
		flora_export_check_attribute_list(AttributeList,Status)
	;
		true
	),
	!.

%% only names with constant object ids like p, q allowed.
flora_export_check_method_name(Term,Status) :-
	( get_name(Term,_Name)
        ; get_transactionalatom(Term,_Atom)
	; flora_export_construct_error(Term,ERROR_EXPORT_ATOM_ATTR,Status)
	).
					

/****************************************************************************
 flora_export_check_spec(+Term,-Status)
 The term exported may be one of the following types:
	p ->  _
	p : q
	p :: q
 Thus this predicate checks whether the spec is allowed.
 is_birelop for (:,::), is_export_spec for (->).
****************************************************************************/
flora_export_check_spec(Funct,_Status) :-
	get_atom(Funct,F),
	(
	  is_birelop(F)
	;
	  is_export_spec(F)
	),
	!.

%% error, in case the spec is not one of the above, signal an error.
flora_export_check_spec(OBJECT(QUOTED_ATOM(Name),I),Status) :-
	flora_export_construct_error(OBJECT(QUOTED_ATOM(Name),I),ERROR_EXPORT_SPEC,Status).


/****************************************************************************
 flora_export_check_attribute_list(+Term,-Status)
****************************************************************************/
flora_export_check_attribute_list([H|T],Status) :-
	( 
	  get_flvar_struct(H,_VariableStruct)
	; 
	  %% If H is not a var, then construct error
	  flora_export_construct_error(H,ERROR_EXPORT_ATOM,Status)
	),
	(var(Status) -> 
	    flora_export_check_attribute_list(T,Status)
	;
	    true
	).

flora_export_check_attribute_list([],_Status) :- !.


/****************************************************************************
 flora_export_check_module(+Term,-Status)
****************************************************************************/
%% comma separated values.
flora_export_check_module(CANOTERM(Funct,_N,FL_PARENTHESIS,[H|T],_If,_Ip),Status) :-
	get_atom(Funct,FL_COMMA),
	flora_export_check_module([H|T],Status),
	!.

%% a simple list
flora_export_check_module([H|T],Status) :-
	(
	  flora_export_check_module(H,Status), !
	;
	  flora_workspace(H,_HCode,StatusModule), !
	;
	  flora_export_construct_error(H,ERROR_EXPORT_MODULE,Status)
	),
	(StatusModule ==[] -> 
	    flora_export_check_module(T,Status) 
	;
	    Status = StatusModule
	),
	!.

flora_export_check_module(H,Status) :-
	flora_workspace(H,_HCode,StatusModule),
	(StatusModule == [] -> 
		true
	; 
		flora_export_construct_error(H,ERROR_EXPORT_MODULE,Status)
	),
	!.

flora_export_check_module([],_Status) :- !.


/****************************************************************************
 flora_export_construct_error(+Term,+ErrorMessage,-StatusError)
****************************************************************************/
flora_export_construct_error(Term,ErrMessage,Status) :- 
      get_index(Term,ErrNo),
      parsing_error(ErrNo,ErrMessage,Status).

/**************** end of error handling for export *************************/


/**************** end of parsing for export ********************************/



/****************************************************************************
  flora_operator_directive(CanoniTerm,CodeList,Status)
  flora_operator_definition(+Atom)
  operator_list(+Number,+Associativity,+OperatorList,-CodeList,-Status)
****************************************************************************/
flora_operator_directive(CANOTERM(Funct,3,FL_PARENTHESIS,L,_If,_Ip),CodeList,Status) :-
	get_name(Funct,FL_OP),
	L=[Number,Associativity,Operator],
	( get_integer(Number,Precedence), Precedence > 0 ->
	    ( get_name(Associativity,A), flora_operator_definition(A) ->
		( get_atom(Operator,Op) ->
		    ( flora_conflict_operator(Precedence,A,Op) ->
			parsing_error(Operator,NO_REDEFOP,Status)
		    ;
		      flopdef_struct(Precedence,A,Op,Code),
		      CodeList=[Code],
		      Status=[]
		    )

		;  Operator=CANOLIST(OpList,T,N,_I,Ib), N > 0 ->
		     ( T == [] ->
			 flora_operator_list(OpList,Precedence,A,CodeList,Status)
		     ;
		       parsing_error(Ib,NO_LISTTAIL,Status)
		     )
		;
		  parsing_error(Operator,ERROR_OPERATOR,Status)
	        )
	    ;
	      parsing_error(Associativity,ERROR_OPDEF,Status)
	    )
	;
	  parsing_error(Number,EXP_POSINTEGER,Status)
        ).


flora_operator_definition(xfx) :- !.
flora_operator_definition(yfx) :- !.
flora_operator_definition(xfy) :- !.
flora_operator_definition(fx)  :- !.
flora_operator_definition(fy)  :- !.
flora_operator_definition(yf)  :- !.
flora_operator_definition(xf)  :- !.


flora_operator_list([],_Number,_Associativity,[],[]) :- !.

flora_operator_list([T|L],Number,Associativity,[Code|CodeList],Status) :-
	!,
	( get_atom(T,Op) -> %% symbol tokens allowed as operators
	    ( flora_conflict_operator(Number,Associativity,Op) ->
		parsing_error(T,NO_REDEFOP,Status)
	    ;
		flopdef_struct(Number,Associativity,Op,Code),
		flora_operator_list(L,Number,Associativity,CodeList,Status)
	    )
	;
	  parsing_error(T,ERROR_OPERATOR,Status)
        ).


/****************************************************************************
  flora_index_directive(+CanoniTerm,-CodeList,-Status)
****************************************************************************/
flora_index_directive(CANOTERM(Funct,N,FL_PARENTHESIS,[L|_Rest],_If,_Ip),[Code],Status) :-
    get_name(Funct,FL_INDEX),
    ( N==1 ->
        ( minus_pair(L,Arity,Pos) ->
            Status=[],
            flindxdirect_struct(Arity,Pos,Code)
        ;
            parsing_error(L,ERROR_INDXDIREC,Status)
        )
    ;
        parsing_error(L,ERROR_INDXDIREC,Status)
    ).


minus_pair(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),A,Pos) :-
    get_name(Funct,FL_MINUS),
    ( get_integer(L,Arity),A=Arity, !
    ;
	%% transactional numbers are used only in :- index %arity-argument
	get_transactionalinteger(L,Arity), fltransactionalnumber_struct(L,A)
    ),
    get_integer(R,Pos),
    Pos>0,
    Arity>=Pos.

/****************************************************************************
  flora_exec_index_directive(+CanoniTerm,-CodeList,-Status)
****************************************************************************/
flora_exec_index_directive(CANOTERM(Funct,1,FL_PARENTHESIS,[L],_If,_Ip),[Code],Status) :-
    get_name(Funct,FL_INDEX),
    ( minus_var_pair(L,Arity,Pos) ->
        Status=[],
        flindxdirect_struct(Arity,Pos,Code)
    ;
        parsing_error(L,ERROR_INDXDIREC,Status)
    ).


flora_exec_index_directive(CANOTERM(Funct,_N,FL_PARENTHESIS,_T,_If,Ip),[_Code],Status) :-
    get_name(Funct,FL_INDEX),
    parsing_error(Ip,ERROR_INDXDIREC,Status).

minus_var_pair(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),Arity,Pos) :-
    get_name(Funct,FL_MINUS),
    %% transactional numbers are used only in :- index %arity-argument
    (
      (get_transactionalinteger(L,A), fltransactionalnumber_struct(L,Arity)
      ;
	  get_integer(L,A), flobject_struct(L,Arity)
      )
    ->
      ( get_integer(R,P)
      ->
	  P>0,
	  A>=P,
	  flobject_struct(R,Pos)
      ;
	  get_flvar_struct(R,Pos)
      )
    ;
      (get_fltransactionalvar_struct(L,Arity); get_flvar_struct(L,Arity)),
      ( get_integer(R,P)
      ->
	  flobject_struct(R,Pos)
      ;
	  get_flvar_struct(R,Pos)
      )
    ).
    

/****************************************************************************
  flora_setsemantics_directive(+CanoniTerm,-CodeList,-Status)
****************************************************************************/
flora_setsemantics_directive(CANOTERM(Funct,_N,FL_BRACE,Args,_If,_Ip),[Code],Status) :-
	get_name(Funct,FL_SETSEMANTICS),
	!,
	parse_semantics_directive_args(DISALLOW_VARIABLES,Args,ArgsCode,Status),
	(Status == [] -> flsetsemanticsdirect_struct(ArgsCode,Code)
	;
	  true
	).


/****************************************************************************
  flora_exec_setsemantics_directive(+CanoniTerm,-CodeList,-Status)
****************************************************************************/

flora_exec_setsemantics_directive(CANOTERM(Funct,_N,FL_BRACE,Args,_If,_Ip),
			      [Code],Status) :-
	get_name(Funct,FL_SETSEMANTICS),
	!,
	parse_semantics_directive_args(DISALLOW_VARIABLES,Args,ArgsCode,Status),
	(Status=[] -> flsetsemanticsdirect_struct(ArgsCode,Code)
	;
	  true
	).

/****************************************************************************
  flora_exec_semantics_directive(+CanoniTerm,-CodeList,-Status)
  This is like setsemantics, but it is a query rather than command,
  so variables are allowed.
****************************************************************************/

flora_exec_semantics_directive(CANOTERM(Funct,_N,FL_BRACE,Args,_If,_Ip),
			      [Code],Status) :-
	get_name(Funct,FL_SEMANTICS),
	!,
	parse_semantics_directive_args(ALLOW_VARIABLES,Args,ArgsCode,Status),
	(Status=[] -> flsemanticsdirect_struct(ArgsCode,Code)
	;
	  true
	).


/****************************************************************************
  flora_defeasible_directive(+CanoniTerm,-CodeList,-Status)

      :- use_argumentation_theory.
      :- use_argumentation_theory(module).
   or
      :- use_argumentation_theory{module}.
****************************************************************************/
flora_defeasible_directive(CANOTERM(Funct,1,_,[Arg],_If,_Ip),[Code],[]) :-
	get_name(Funct,FL_DEFEASIBLE_DIRECTIVE),
	(is_obj_identifier_struct(Arg,Atom,Index)
	;
	    get_flbuiltin_identifier_struct(Arg,Atom),
	    get_index(Atom,Index)
	),
	!,
	flatom_struct(Atom,Index,ArgCode),
	fldefeasible_struct(ArgCode,Code).

flora_defeasible_directive(CanoniTerm,[Code],[]) :-
	is_obj_identifier_struct(CanoniTerm,FL_DEFEASIBLE_DIRECTIVE,Idx),
	!,
	flatom_struct(FL_DEFAULT_DEFEASIBLE_THEORY,Idx,ArgCode),
	fldefeasible_struct(ArgCode,Code).

/******************************************************************************
  flora_defeasible_rule_default_directive(+CanoniTerm,-Codelist,-Status)
******************************************************************************/

flora_defeasible_rule_default_directive(CanoniTerm,[Code],[]) :-
	(is_obj_identifier_struct(CanoniTerm,FL_DEFEASIBLE_DEFAULT_DIRECTIVE,_)
	; is_obj_identifier_struct(CanoniTerm,FL_DEFEASIBLE_DEFAULT_DIRECTIVE2,_)),
	!,
	fldefeasible_rule_default_struct(Code).

flora_strict_rule_default_directive(CanoniTerm,[Code],[]) :-
	(is_obj_identifier_struct(CanoniTerm,FL_STRICT_DEFAULT_DIRECTIVE,_)
	; is_obj_identifier_struct(CanoniTerm,FL_STRICT_DEFAULT_DIRECTIVE2,_)),
	!,
	flstrict_rule_default_struct(Code).

/****************************************************************************
   flora_verbatim_directive(+CanoniTerm,-CodeList,-Status)

       :- verbatim(string)

   This passes STRING (which is supposed to be an atom) straight to the output
   (the .P file). Useful when one wants to include something in the output
   file directly.
****************************************************************************/
flora_verbatim_directive(CANOTERM(Funct,1,_,[Arg],_If,Ip),[Code],Status) :-
	get_name(Funct,FL_VERBATIM),
	(get_atom(Arg,Atom,Index) ->
	    flatom_struct(Atom,Index,ArgCode),
	    flverbatim_struct(ArgCode,Code),
	    Status = []
	;
	    parsing_error(Ip,ERROR_VERBATIM_DIRECT,Status)
	).



/****************************************************************************
  flora_cmpopt_directive(+CanoniTerm,-CodeList,-Status)
  Compiling the :- flora_compiler_options directive
****************************************************************************/
flora_cmpopt_directive(CANOTERM(Funct,1,FL_PARENTHESIS,[T],_If,_Ip),
			[Code],Status) :-
	get_name(Funct,FL_CMPOPT),
	( T=CANOLIST(List,[],_N,_I,_Ib) ->
	    flora_cmpoptlist(List,TCode,Status),
	    ( Status == [] ->
		flcmpoptdirect_struct(TCode,Code)
	    ;
		true
	    )
	;
	    parsing_error(T,EXP_OPTLIST,Status)
	).

flora_cmpoptlist([],[],[]) :- !.
flora_cmpoptlist([H|T],[HCode|TCode],Status) :-
	( get_atom(H,HCode) ->	
	    flora_cmpoptlist(T,TCode,Status)
	;
	    parsing_error(H,ERROR_CMPOPT,Status)
	).

/****************************************************************************
  flora_prefixdef_directive(+CanoniTerm,-CodeList,-Status)
  Compiling the prefix directive in the form of
    :- uriprefix A="aaa",B="bbb",....
****************************************************************************/
flora_prefixdef_directive(CANOTERM(Funct,_N,FL_PARENTHESIS,[T],_If,_Ip),Code,Status) :-
	get_name(Funct,FL_PREFIXDEF),
	flora_comma_separated_list(T,TermList),
	flora_prefixdef_parse_term_list(TermList,Code,Status),
	!.

%% error case.
flora_prefixdef_directive(CANOTERM(Funct,_N,FL_PARENTHESIS,_Args,If,_Ip),[],Status) :-
	get_name(Funct,FL_PREFIXDEF),
	!,
	parsing_error(If,ERROR_PREFIX,Status).

/****************************************************************************
 flora_prefixdef_parse_term_list(+TermList,-CodeList,-Status)
***************************************************************************/
flora_prefixdef_parse_term_list([],[],[]) :- !.

flora_prefixdef_parse_term_list([H|T],Code,Status) :-
	flora_prefixdef_parse_term(H,HCode,HStatus),
	( HStatus == [] ->
		flora_prefixdef_parse_term_list(T,TCode,Status),
	        append(HCode,TCode,Code)
	;
		Status = HStatus
	).

/****************************************************************************
 flora_prefixdef_parse_term(+CanoniTerm,-Code,-Status)
 ****************************************************************************/
flora_prefixdef_parse_term(CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip),[Code],Status) :-
	get_name(Funct,FL_UNIVEQ), 
	N==2, 
	!,
	Args=[PrefixHead,PrefixBody],
	%% check that prefix name(the part before '=') is an atom
	( is_obj_identifier_struct(PrefixHead)
	-> %% check that part after '=' is string, quoted atom, or identfier
	    ( ( is_obj_ascii_string_struct(PrefixBody)
	      ; is_obj_identifier_struct(PrefixBody)
	      ; is_obj_quoted_atom_struct(PrefixBody)
	      ) -> 
	          flora_pathexplist(Args,NULL,ArgsCode,Status),
		  ArgsCode=[NameCode,BodyCode],
	          flprefixdef_struct(NameCode,BodyCode,Code)

	    ; get_index(PrefixBody,Index_Body),
	      parsing_error(Index_Body,ERROR_PREFIX_BODY,Status) % need to change the error message
	    )

	; get_index(PrefixHead,Index_Head),
	  parsing_error(Index_Head,ERROR_PREFIX_HEAD,Status)
	).

%% error case
flora_prefixdef_parse_term(CANOTERM(_Funct,_N,_FL_PARENTHESIS,_Args,If,_Ip),[],Status) :-
	parsing_error(If,ERROR_PREFIX,Status).


/****************************************************************************
  flora_ignoredep_directive(+CanoniTerm,-CodeList,-Status)
  Compiling the :- ignore_depchk directive
****************************************************************************/
flora_ignoredep_directive(CANOTERM(Funct,1,FL_PARENTHESIS,[T],_If,_Ip),[Code],Status) :-
	get_name(Funct,FL_IGNOREDEP),
        ( flora_comma_separated_list(T,PreList) ->
            flora_parse_body_template_list(PreList,LCode,Status),
            flignoredepdirect_struct(LCode,Code)
	;
	    parsing_error(T,EXP_SPECLIST,Status)
	).


/****************************************************************************
  flora_parse_fact(+CanoniTerm,-Code,-Status)
****************************************************************************/
flora_parse_fact(CanoniTerm,NULL,Status) :-
	%% Handle special markups for include files that are generated by gpp.
	flora_gpp_markup(CanoniTerm,Status),
	!.

flora_parse_fact(CanoniTerm,Code,Status) :-
	report_context(parsing_fact),
	flora_head(CanoniTerm,CodeList,Status),
	clear_context(parsing_fact),
	flfact_struct(CodeList,Code).


/****************************************************************************
  flora_parse_query(+CanoniTerm,-Code,-Status)
****************************************************************************/
flora_parse_query(CanoniTerm,Code,Status) :-
	flora_body(CanoniTerm,Goal,Status),
	flquery_struct(Goal,Code).


/****************************************************************************
  flora_parse_rule(+Head,+Body,-Code,-Status)
****************************************************************************/
flora_parse_rule(Head,Body,Code,Status) :-
        report_context(parsing_rulehead),
	flora_head(Head,HeadCodeList,S),
        clear_context(parsing_rulehead),
	( S == [] ->
	    flora_body(Body,BodyCode,Status),
	    flrule_struct(HeadCodeList,BodyCode,Code)
	;
	  Status=S
        ).


/****************************************************************************
   flora_parse_labeled_toplevel_construct(+Label,+Construct,-Code,-Status)
****************************************************************************/
flora_parse_labeled_toplevel_construct(Label,Construct,Code,Status) :-
	(is_rule_or_fact(Construct)
	->
	    flora_parse_canonical(Construct,Code1,Status1),
	    (Status1 == []
	    ->
		(is_rule(Construct,_,_)
		-> CodeConstr = Code1
		; % if labeled fact, convert it to a rule:  fact :- true.
		    flfact_struct(Head,Code1), % unwrap flfact
		    flatom_struct(FL_TRUE,NO_INDEX,BodyCode),
		    flrule_struct(Head,BodyCode,CodeConstr)
		),
		flora_parse_label(Label,fail,CodeLab,Status),
		(Status == []
		-> annotated_construct_struct(CodeLab,CodeConstr,Code)
		;  true
		)
	    ; Status = Status1
	    )

	; %%% Ignore labels and metadata for directives and queries.
	  %%% Might use this information later, especially for queries.
	    flora_parse_canonical(Construct,Code,Status)
	).


/****************************************************************************
  flora_gpp_markup(+CanoniTerm,+Status)
****************************************************************************/
flora_gpp_markup(CanoniTerm,[]) :-
	get_name(CanoniTerm,FLORA_GPP_MARKUP),
	%% This is just a delimeter for the purpose of fault tolerance.
	%% Skip it.
	!.

flora_gpp_markup(CANOTERM(Funct,3,FL_PARENTHESIS,[Arg1,Arg2,Arg3],_If,_Ip),Status) :-
	get_name(Funct,FLORA_GPP_MARKUP),
	!,
	( ( get_name(Arg3,'') ->
	      %% This is the top level file name. Reset line number.
	      flora_reset_charpos

	  ; get_name(Arg3,'1') ->
	      %% This is the beginning of a include file.
	      get_name(Arg2,FileName),
	      flora_begin_file(FileName)

	  ; get_name(Arg3,'2') ->
	      %% This is the end of a include file.
	      get_integer(Arg1,LineNumber),
	      flora_end_file(LineNumber)
	  ),
	  Status=[],
	  !
	;
	  Status=[error(ERROR_GPP)]
	).


/****************************************************************************
  flora_head(+CanoniTerm,-CodeList,-Status)

  This predicate is called to parse the head of a rule, which is a canonical
  term. Since only conjunction is allowed in a rule head, the result of parsing
  it is a list of intermidiate terms.

  Note: Module name is not allowed in rule head.
****************************************************************************/
flora_head(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],If,_Ip),CodeList,Status) :-
	get_atom(Funct,F),
	( F == FL_COMMA ->
	    flora_head(L,LCodeList,S),
	    ( S == [] ->
		flora_head(R,RCodeList,Status),
		( Status == [] ->
		    append(LCodeList,RCodeList,CodeList)
		;
		  true
		)
	    ;
	      Status=S
	    )

	; F == FL_SEMICOLON -> % Disjunction is prohibited.
	    parsing_error(If,NO_DISJUNCTION,Status)

	; % Module name in rule head is prohibited.
	  F == FL_AT,
	  parsing_error(If,NO_WSINRULEHEAD,Status)
	),
	!.

flora_head(CANOTERM(Funct,_N,FL_PARENTHESIS,_G,If,_Ip),_CodeList,Status) :-
	get_atom(Funct,F),
	(is_nafop(F); is_notop(F)),
	!,
	parsing_error(If,NO_NEGATION,Status).

flora_head(CanoniTerm,Code,Status) :-
	is_labeled_construct(CanoniTerm,Label,Construct),
	!,
	(is_rule(Construct,_,_)
	->
	    get_index(Label,I),
	    parsing_error(I,LABELING_CONSTR_RULEHEAD,Status)
	;
	    %% currently we ignore labeling & metadata constructs in rule head
	    flora_head(Construct,Code,Status)
	).

flora_head(CanoniTerm,[Code],Status) :-
	flora_head_literal(CanoniTerm,NULL,Code,Status).


/****************************************************************************
  flora_head_literal(+CanoniTerm,+WorkSpace,-HeadLiteral,-Status)

  parses a single literal in the head of a rule. Check the grammar at
  the beginning to see what is allowed.
****************************************************************************/
flora_head_literal(CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,F),
	is_birelop(F),
	!,
	flora_head_pathexplist(Args,DWS,[LCode,RCode],Status),
	(Status == [] -> 
            flbirelate_struct(LCode,F,RCode,TCode),
            (get_module_from_spec(DWS,ModuleType,Module) ->
                flmodule_struct(TCode,Module,ModuleType,Code)
            ;   Code=TCode
            )
        ; true).

flora_head_literal(CANOTERM(Funct,2,FL_PARENTHESIS,_Args,If,_Ip),_DWS,_Code,Status) :-
	get_atom(Funct,F),
	is_objrefop(F),
	!,
	parsing_error(If,ERROR_HDLITERAL,Status).

flora_head_literal(CANOTERM(Funct,N,FL_PARENTHESIS,_Args,If,_Ip),_DWS,_Code,Status) :-
	get_atom(Funct,F),
	flora_nodefp(F,N),
	\+ PARSER_CONTEXT(parsing_label),
	!,
	parsing_error(If,NO_REDEFINITION,Status).

flora_head_literal(CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,FL_OBJEQL),
	!,
	%% equality definition fact/rule
	flora_head_pathexplist(Args,DWS,[LCode,RCode],Status),
	(Status == [] -> 
            flobjeql_struct(LCode,RCode,TCode),
            (get_module_from_spec(DWS,ModuleType,Module) ->
                flmodule_struct(TCode,Module,ModuleType,Code)
            ;   Code=TCode
            )
        ; true).

flora_head_literal(CANOTERM(Funct,1,FL_PARENTHESIS,[Arg],If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,F),
	%% explicit negation
	is_negop(F),
	!,
	%% Using flora_head_literal may result in counterintuitive error
	%% messages in case of, say, neg((p,q)). A better way would be to
	%% check that only meaningful literals can be under neg.
	flora_head_literal(Arg,DWS,ArgCode,S1),
	(S1 == [] -> 
            flneg_struct(ArgCode,If,Code),
            (get_module_from_spec(DWS,ModuleType,Module) ->
                flmodule_struct(NegCode,Module,ModuleType,Code)
            ;   Code=NegCode
            ),
	    Status = S1
        ; parsing_error(Arg,ILLEGAL_NEGHEAD,S2),
	    append(S2,S1,Status)
	).

flora_head_literal(CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,Ip),_DWS,_Code,Status) :-
	get_atom(Funct,F),
	is_negop(F),
	!,
	parsing_error(CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,Ip),NEG_NEGATE_HEAD,Status).

flora_head_literal(CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip),DWS,Code,Status) :-
	!,
	flora_head_term(Funct,N,Args,ALLOW_TRANS,DWS,TCode,Status),
        ( Status ==[] ->
            (get_module_from_spec(DWS,ModuleType,Module) ->
                flmodule_struct(TCode,Module,ModuleType,Code)
            ;   Code=TCode
            )
        ; true).

flora_head_literal(CANOTERM(Funct,N,FL_BRACKET,Args,_If,_Ip),DWS,Code,Status) :-
	!,
	flora_head_objspec(Funct,N,Args,DWS,TCode,Status),
        ( Status ==[] ->
            (get_module_from_spec(DWS,ModuleType,Module) ->
                flmodule_struct(TCode,Module,ModuleType,Code)
            ;   Code=TCode
            )
        ; true).

flora_head_literal(CanoniTerm,DWS,Code,Status) :-
	get_atom(CanoniTerm,A),
	!,
	( flora_nodefp(A,0)
	->
	    parsing_error(CanoniTerm,ERROR_HDLITERAL,Status)
	;
	    flobject_struct(CanoniTerm,TCode),
            (
	      get_module_from_spec(DWS,ModuleType,Module)
	    ->
	      flmodule_struct(TCode,Module,ModuleType,Code)
            ;   Code=TCode
            ),
	    Status = []
        ).

flora_head_literal(CanoniTerm,DWS,Code,Status) :-
        get_transactionalatom(CanoniTerm,_A),
        !,
        fltransactionalobject_struct(CanoniTerm,TCode),
        Status=[],
        (get_module_from_spec(DWS,ModuleType,Module) ->
            flmodule_struct(TCode,Module,ModuleType,Code)
        ;   Code=TCode
        ).

flora_head_literal(CanoniTerm,_DWS,_Code,Status) :-
	!,
	parsing_error(CanoniTerm,ERROR_HDLITERAL,Status).


/****************************************************************************
  flora_head_literal_list(+List,+DWS,-CodeList,-Status)
****************************************************************************/
flora_head_literal_list([],_,[],[]) :- !.
flora_head_literal_list([First|List],DWS,[FirstCode|ListCode],Status) :-
	flora_head_literal(First,DWS,FirstCode,Status1),
	(Status1 == []
	->
	    flora_head_literal_list(List,DWS,ListCode,Status)
	;
	    Status = Status1
	).


/****************************************************************************
  flora_body(+CanoniTerm,-Goal,-Status)

  This predicate is called to parse the *entire* body of a rule. It takes a
  canonical term as input and parses it into an intermediate term to be
  compiled further. "CanoniTerm" can represent any logical formula of
  conjunction, disjunction, and negation. "Goal" is parsed accordingly. If
  success, "Status" is bound to [], or some warning message; otherwise, it
  is a list containing some error message.


  flora_body(+CanoniTerm,+WorkSpace,+DefaultWorkSpace,-Goal,-Status)

  Note: Module name specification is distributive over negation, conjunction
        and disjunction in the rule body. WorkSpace is the inner-most module
        which might be a prolog module. DefaultWorkSpace is the inner-most
        non-prolog module. DefaultWorkSpace is distributed recrusively to reach
        reified formulas. DefaultWorkSpace works like nesting of variable
        scope.

        Moreover, module name specification is also distributive over
        if-then-else statement. For example, (if a then b else c)@mod has
        the same effect as (if a@mod then b@mod else c@mod).
****************************************************************************/
flora_body(CanoniTerm,Goal,Status) :-
	flora_body(CanoniTerm,NULL,NULL,Goal,Status).

flora_body(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),WS,DWS,Code,Status) :-
	get_atom(Funct,F),
	(F == FL_COMMA; F == FL_SEMICOLON),
	!, % Module name is distributive over conjunction or disjunction.
	flora_body(L,WS,DWS,LCode,S),
	( S == [] ->
	    flora_body(R,WS,DWS,RCode,Status),
	    ( Status == [] ->
		( F == FL_COMMA ->
		    flconjunct_struct(LCode,RCode,Code)
		;
		    fldisjunct_struct(LCode,RCode,Code)
	        )
	    ;
	      true
	    )
	;
	  Status=S
        ).

flora_body(CANOTERM(Funct,1,FL_PARENTHESIS,[G],_If,_Ip),WS,DWS,Code,Status) :-
	get_atom(Funct,F),
	(is_nafop(F); is_notop(F)),
	!, % Module name is distributive over negation.
	flora_body(G,WS,DWS,C,Status),
	( Status == [] ->
	    (is_nafop(F) -> flnaf_struct(C,Code); flnot_struct(C,Code))
	;
	    true
        ).

flora_body(CANOTERM(Funct,1,FL_PARENTHESIS,[G],If,_Ip),WS,DWS,Code,Status) :-
	get_atom(Funct,F),
	is_negop(F),
	!, % Module name is distributive over negation.
	%% flora_body is too general here. We do not want to allow
	%% anything but conjunctions/disjunctions of F-logic/first-order
	%% atomic formulas. No update ops, NOT, NAF, etc.
	%% This is taken care of by the compiler in neg_struct/head_neg_struct.
	flora_body(G, WS, DWS,LitCode,Status),
	( Status == [] -> flneg_struct(LitCode,If,Code)
	;
	    true
        ).



flora_body(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),_WS,DWS,Code,Status) :-
	get_atom(Funct,FL_AT),
	!, % nesting of module name scope
	%% The module name needs to be parsed early; otherwise, some
        %% incorrect syntax may be overridden by nested module specification.
	flora_workspace(R,RCode,S),
	( S == [] ->
            ( (RCode==PROLOGMODULE
	      ; RCode==PROLOGALLMODULE
	      ; get_module_from_spec(RCode,PROLOGMODULE,_)
	      ; get_module_from_spec(RCode,PROLOGALLMODULE,_))
	    ->
                flora_body(L,RCode,DWS,Code,Status)
            ;
                flora_body(L,RCode,RCode,Code,Status)
            )
        ; 
            Status=S
        ).

%% reify op ${...} that occurs as a formula
flora_body(CANOTERM(Funct,N,FL_BRACE,Args,If,Ip),WS,DWS,Code,Status) :-
	get_atom(Funct,Atom),
	is_reifyop(Atom),
	!,
	(N > 1
	-> flora_list_to_conjunct(Args, Conjunct, If, Ip),
	    flora_body(Conjunct,WS,DWS,Code,Status)
	;
	    Args = [Arg],
	    flora_body(Arg,WS,DWS,Code,Status)
	).

%% Literal is a rule and we are inside reification
flora_body(CANOTERM(Funct,2,FL_PARENTHESIS,[Head,Body],If,Ip),WS,WS,Code,Status) :-
	get_name(Funct,FL_IMPLYOP),
	if_reifying,
	!,
        ( PARSER_CONTEXT(parsing_reify) ->
            PrevContext = parsing_reify,
            clear_context(parsing_reify)
        ;
            true
        ),
	flora_dynrule(CANOTERM(Funct,2,FL_PARENTHESIS,[Head,Body],If,Ip),
		      WS,Code,Status),
        ( var(PrevContext) -> true; report_context(parsing_reify)).

%% At this point, CanoniTerm is not a logical formula.
flora_body(CANOTERM(Funct,1,FL_PARENTHESIS,Args,If,Ip),WS,DWS,Code,Status) :-
	get_name(Funct,FL_IF),
	!,
	%% Module name is distributive over if-then-else statement.
        flora_body_ifthenelse(CANOTERM(Funct,1,FL_PARENTHESIS,Args,If,Ip),WS,DWS,Code,Status).

flora_body(CANOTERM(Funct,2,FL_PARENTHESIS,_Args,If,_Ip),_WS,_DWS,_Code,Status) :-
	get_name(Funct,FL_THEN),
	!,
        parsing_error(If,ERROR_THENBODY,Status).

flora_body(CANOTERM(Funct,2,FL_PARENTHESIS,_Args,If,_Ip),_WS,_DWS,_Code,Status) :-
	get_name(Funct,FL_ELSE),
	!,
        parsing_error(If,ERROR_ELSEBODY,Status).

%% Parse the a<~~b form of if-then
flora_body(CANOTERM(Funct,2,FL_PARENTHESIS,[ThenPart,IfPart],_If,_Ip),WS,DWS,Code,Status) :-
	get_name(Funct,FL_LEFTNAFIMPLY),
	!,
	flora_leftNAF_implication(IfPart,ThenPart,WS,DWS,Code,Status).

%% Parse the a~~>b form of if-then
flora_body(CANOTERM(Funct,2,FL_PARENTHESIS,[IfPart,ThenPart],_If,_Ip),WS,DWS,Code,Status) :-
	get_name(Funct,FL_RIGHTNAFIMPLY),
	!,
	flora_leftNAF_implication(IfPart,ThenPart,WS,DWS,Code,Status).

%% Parse the a<==b form of if-then (using NEG instead of NAF)
flora_body(CANOTERM(Funct,2,FL_PARENTHESIS,[ThenPart,IfPart],_If,_Ip),WS,DWS,Code,Status) :-
	get_name(Funct,FL_LEFTNEGIMPLY),
	!,
	flora_leftNEG_implication(IfPart,ThenPart,WS,DWS,Code,Status).

%% Parse the a==>b form of if-then (using NEG instead of NAF)
flora_body(CANOTERM(Funct,2,FL_PARENTHESIS,[IfPart,ThenPart],_If,_Ip),WS,DWS,Code,Status) :-
	get_name(Funct,FL_RIGHTNEGIMPLY),
	!,
	flora_leftNEG_implication(IfPart,ThenPart,WS,DWS,Code,Status).

%% Parse the ~ meta predicate
flora_body(CANOTERM(Funct,2,FL_PARENTHESIS,Args,If,Ip),WS,DWS,Code,Status) :-
	get_name(Funct,FL_UNIVEQFORM),
	!,
        flora_body_univeqform(CANOTERM(Funct,2,FL_PARENTHESIS,Args,If,Ip),WS,DWS,Code,Status).

%% Parse the ~ meta predicate
flora_body(CANOTERM(Funct,2,FL_PARENTHESIS,Args,If,Ip),WS,DWS,Code,Status) :-
	get_name(Funct,FL_NOTUNIVEQFORM),
	!,
        flora_body_notuniveqform(CANOTERM(Funct,2,FL_PARENTHESIS,Args,If,Ip),WS,DWS,Code,Status).

%% Parse the =.. meta predicate
%% Workspace as in (A=..B)@foo is illegal.  But (A@foo =.. B) is fine.
flora_body(CANOTERM(Funct,2,FL_PARENTHESIS,Args,If,Ip),WS,DWS,Code,Status) :-
	get_name(Funct,FL_METAUNIV),
	!,
        flora_body_metauniv(CANOTERM(Funct,2,FL_PARENTHESIS,Args,If,Ip),WS,DWS,Code,Status).

%% Process the control constructs while-do/loop, loop/do-until, unless-do
flora_body(CANOTERM(TopWrapper,1,FL_PARENTHESIS,Args,_If,_Ip),WS,DWS,Code,Status) :-
	get_name(TopWrapper,TopName),
	get_control_construct_definition(_CtlWrapper,TopName,_InnerName),
	!,
	%% Args should be [CanonTerm]. If not, will issue a syntax error
	flora_body_controlconstruct(Args,WS,DWS,TopName,Code,Status).

%% If inner keyword of ctl construct occurs at the top level -- error
flora_body(CANOTERM(TopWrapper,2,_Paren,_Args,If,_Ip),_WS,_DWS,_Code,Status) :-
	get_name(TopWrapper,TopName),
	get_control_construct_definition(_,_,TopName),
	!,
	parsing_error(If,UNEXPECTED_CONTROL,Status).

%% @_prolog()
flora_body(CanoniTerm,PROLOGMODULE,DWS,Code,Status) :-
	!,
	%% Prolog builtin
	flora_prlgterm(CanoniTerm,DWS,TCode,Status),
	(Status == [] -> flplib_struct(TCode,Code); true).

%% @_prolog(...)
flora_body(CanoniTerm,PrologModuleSpec,DWS,Code,Status) :-
	get_module_from_spec(PrologModuleSpec,PROLOGMODULE,Mod),
	!,
	%% Prolog module
	flora_prlgterm(CanoniTerm,DWS,TCode,Status),
	(Status == [] -> flmodule_struct(TCode,Mod,PROLOGMODULE,Code); true).

%% @_prologall()
flora_body(CanoniTerm,PROLOGALLMODULE,DWS,Code,Status) :-
	!,
	%% Prolog builtin
	flora_pure_term(CanoniTerm,DWS,TCode,Status1),
	( is_flvar_struct(TCode)
	-> parsing_error(CanoniTerm,ERROR_PRLGLIT,Status2), Status=Status2
	; Status1 == []
	-> flpliball_struct(TCode,Code), Status=Status1
	; Status=Status1
	).

%% @_prologall(...)
flora_body(CanoniTerm,PrologModuleSpec,DWS,Code,Status) :-
	get_module_from_spec(PrologModuleSpec,PROLOGALLMODULE,Mod),
	!,
	%% Prolog module
	flora_pure_term(CanoniTerm,DWS,TCode,Status1),
	( is_flvar_struct(TCode)
	-> parsing_error(CanoniTerm,ERROR_PRLGLIT,Status2), Status=Status2
	; Status1 == []
	-> flmodule_struct(TCode,Mod,PROLOGALLMODULE,Code), Status=Status1
	; Status=Status1
	).

%% @module
flora_body(CanoniTerm,FloraModSpec,FloraModSpec,Code,Status) :-
	get_module_from_spec(FloraModSpec,_ModuleType,Module),
	!,
	%% Flora user or system module
	(PARSER_CONTEXT(parsing_fact),
	    is_flvar_struct(Module)
	-> 
	    %% Variables are not allowed in the module specs in the
	    %% reifications that occur in facts or static rule heads.
	    get_index(Module,Idx),
	    parsing_error(Idx,NO_WS_VAR,Status)
	;
            flora_body_literal(CanoniTerm,FloraModSpec,Code,Status)
	).

flora_body(CanoniTerm,WS,_DWS,Code,Status) :-
	is_labeled_construct(CanoniTerm,_Label,Construct),
	if_reifying,
	is_rule(Construct,_,_),
	!,
	flora_dynrule(CanoniTerm,WS,Code,Status).

flora_body(CanoniTerm,WS,DWS,Goal,Status) :-
	is_labeled_construct(CanoniTerm,_Label,Construct),
	!,
	%% currently we ignore labeling & metadata constructs in rule body
	%% unless reified rule
	flora_body(Construct,WS,DWS,Goal,Status).


%% At this point, CanoniTerm is neither a logical formula nor a 
%% if-then-else statement, nor some other special builtin 
%% (like while-loops or meta operators)
flora_body(CanoniTerm,NULL,NULL,Code,Status) :-
	!,
	%% no module name
	flora_body_literal(CanoniTerm,NULL,Code,Status).


        
/****************************************************************************
  flora_workspace(+CanoniTerm,-WSCode,-Status)

  This predicate is called to parse the module name of a workspace specification.
  Three types of module names are allowed:
  (1) Prolog module, e.g., @_prolog(basics), @_prolog(), @_prolog
                           @_prologall(basics), @_prologall(), @_prologall
      WSCode=PROLOGMODULE(name), or PROLOGMODULE
      WSCode=PROLOGALLMODULE(name), or PROLOGALLMODULE
  (2) Flora system module, e.g., @_io, @_pp.
      WSCode=FLORASYSMOD(name)
  (3) Flora user module, which could be either an atom or a variable.
      WSCode=FLORAUSERMOD(name), or FLORAUSERMOD(var)

  Note: Textual information is reserved for module names.
****************************************************************************/
%% Handle Flora user module specification. (@ ?M)
flora_workspace(CanoniTerm,FLORAUSERMOD(NVCode),[]) :-
	flora_name_or_var(CanoniTerm,NVCode),
	!.

%% @_prolog, @_plg, etc.
flora_workspace(CanoniTerm,PROLOGMODULE,[]) :-
	get_flbuiltin_identifier_struct(CanoniTerm,NVCode),
	is_flatom_struct(NVCode,FL_PLIB),
	!.
%% @_prologall, @_plgall, etc.
flora_workspace(CanoniTerm,PROLOGALLMODULE,[]) :-
	get_flbuiltin_identifier_struct(CanoniTerm,NVCode),
	is_flatom_struct(NVCode,FL_PLIBALL),
	!.

%% Handle THIS MODULE specification, e.g., a[b->c]@ _@.
flora_workspace(CanoniTerm,FLORAUSERMOD(ThisModToken),[]) :-
	%% When _@ is specified as a module, we treat it
	%% as a user module even if _@ occurs in a system module.
	%% This is because _@ doesn't require us to notify flrlibman.P that a
	%% system module needs to be loaded.
	%% However, in case of a system module _@ gets substituted with
	%% FLORA_THIS_MODULE_NAME, so at compile time we get the right module.
	get_spectoken(CanoniTerm,FL_THISMODULE),
	!,
	flobject_struct(CanoniTerm,ThisModToken).

%% Handle a Prolog module specified as @_prolog()
flora_workspace(CANOTERM(Mod,0,FL_PARENTHESIS,[],_Ifu,_Ipa),PROLOGMODULE,[]) :-
	get_flbuiltin_identifier_struct(Mod,NVCode),
	is_flatom_struct(NVCode,FL_PLIB),
	!.

%% A Prolog module given as @_prolog(xsbmod)
flora_workspace(CANOTERM(Mod,1,FL_PARENTHESIS,[M],_Ifu,_Ipa),PROLOGMODULE(MCode),Status) :-
	get_flbuiltin_identifier_struct(Mod,NVCode),
	is_flatom_struct(NVCode,FL_PLIB),
	!,
	( get_flname_struct(M,MCode) -> Status=[]
	; parsing_error(M,ERROR_WSNAME,Status)
	).

%% @_prologall() module
flora_workspace(CANOTERM(Mod,0,FL_PARENTHESIS,[],_Ifu,_Ipa),PROLOGALLMODULE,[]) :-
	get_flbuiltin_identifier_struct(Mod,NVCode),
	is_flatom_struct(NVCode,FL_PLIBALL),
	!.

%% @_prologall(module) module
flora_workspace(CANOTERM(Mod,1,FL_PARENTHESIS,[M],_Ifu,_Ipa),PROLOGALLMODULE(MCode),Status) :-
	get_flbuiltin_identifier_struct(Mod,NVCode),
	is_flatom_struct(NVCode,FL_PLIBALL),
	!,
	( get_flname_struct(M,MCode) -> Status=[]
	; parsing_error(M,ERROR_WSNAME,Status)
	).

%% system module specification @_module
flora_workspace(CanoniTerm,FLORASYSMOD(MCode),Status) :-
	get_flbuiltin_identifier_struct(CanoniTerm,MCode),
	is_flatom_struct(MCode,ModuleName),
	!,
	( flora_system_module(ModuleName) -> Status=[]
	; parsing_error(CanoniTerm,UNREG_SYSMOD,Status)
	).

%% system module specification @_module()
flora_workspace(CANOTERM(Mod,0,FL_PARENTHESIS,[],_Ifu,_Ipa),FLORASYSMOD(MCode),Status) :-
	get_flbuiltin_identifier_struct(Mod,MCode),
	is_flatom_struct(MCode,ModuleName),
	!,
	( flora_system_module(ModuleName) -> Status=[]
	; parsing_error(Mod,UNREG_SYSMOD,Status)
	).


flora_workspace(CanoniTerm,_WSCode,Status) :-
	parsing_error(CanoniTerm,ERROR_WSNAME,Status).


/****************************************************************************
  flora_body_ifthenelse(+CanoniTerm,+Workspace,+DWS,-Code,-Status)

  parses an if-then-else statement. "Workspace" is the module name specified
  for the entire statement and should be distributed over the substatements
  inside.
****************************************************************************/
flora_body_ifthenelse(CanoniTerm,WS,DWS,Code,Status) :-
	flora_body_ifthenelse(CanoniTerm,WS,DWS,NK,_NT,Code,S),
        ( S \== [] ->
	    Status=S

	; NK == [] ->
	    Status=[]

	; NK = then(Index) ->
	    parsing_error(Index,UNEXPECTED_THEN,Status)

        ; NK = else(Index) ->
	    parsing_error(Index,UNEXPECTED_ELSE,Status)
	).


/****************************************************************************
  flora_body_ifthenelse(+CanoniTerm,+Workspace,+DWS,-NextKeyword,-NextTerm,-Code,-Status).

  Takes a canonical term (which represents a stream of tokens) and parses
  a normal statement at the beginning  of it. Moreover, it returns the next
  immediate keyword and the  residual canonical term (which represents the
  rest of the token stream).

  If NextKeyword is [], then NextTerm is []. Otherwise, NextKeyword is
  either then(Index) or else(Index) (here Index is the index number of the
  keyword that can be used to generate an error message).

  Status denotes success/failure when the beginning of the token stream
  is parsed.

  This procedure complements flora_body/5 and handles the distribution of
   module name over if-then-else statements.
****************************************************************************/
flora_body_ifthenelse(CANOTERM(Funct,1,FL_PARENTHESIS,[CTerm],If,_Ip),WS,DWS,
		      NextKeyword,NextTerm,Code,Status) :-
	get_name(Funct,FL_IF),
	!,
	flora_body_ifthenelse(CTerm,WS,DWS,NK1,NT1,CondStruct,S1),
	( S1 == [] ->
	    ( NK1 = then(_IThen) ->
		flora_body_ifthenelse(NT1,WS,DWS,NK2,NT2,ThenStruct,S2), 
		( S2 == [] ->
		    ( NK2 = else(_IElse) ->
			flifthenelse_struct(CondStruct,ThenStruct,ElseStruct,Code),
			flora_body_ifthenelse(NT2,WS,DWS,NextKeyword,NextTerm,ElseStruct,Status)
		    ;
		      flifthen_struct(CondStruct,ThenStruct,Code),
		      NextKeyword=NK2,
		      NextTerm=NT2,
		      Status=[]
		    )
		;
	          Status=S2
	        )

	    ; NK1 == [] ->
	        parsing_error(If,MISSING_THEN,Status)

	    ; NK1 = else(IElse) ->
	        parsing_error(IElse,MISSING_THEN,Status)
	    )
        ;
	  Status=S1
	).

flora_body_ifthenelse(CANOTERM(Funct,2,FL_PARENTHESIS,[STerm,NextTerm],If,_Ip),WS,DWS,
		      NextKeyword,NextTerm,Code,Status) :-
	( get_name(Funct,FL_THEN) ->
	    NextKeyword=then(If)

	; get_name(Funct,FL_ELSE) ->
	    NextKeyword=else(If)
	),
	!,
	flora_body(STerm,WS,DWS,Code,Status).

flora_body_ifthenelse(CanoniTerm,WS,DWS,[],[],Code,Status) :-
	flora_body(CanoniTerm,WS,DWS,Code,Status).


/*****************************************************************************
   flora_leftNAF_implication(+IfPart,+ThenPart,+WS,+DWS,-Code,-Status)
   If-then expressed using <~~ (naf-implication)
*****************************************************************************/
flora_leftNAF_implication(IfPart,ThenPart,WS,DWS,Code,Status) :-
	flora_body(IfPart,WS,DWS,IfCode,Stat1),
	(Stat1==[]
	-> flora_body(ThenPart,WS,DWS,ThenCode,Status),
	    (Status==[]
	    ->
		flifthen_struct(IfCode,ThenCode,Code)
	    ; true
	    )
	;
	    Status = Stat1
	).


/*****************************************************************************
   flora_leftNEG_implication(+IfPart,+ThenPart,+WS,+DWS,-Code,-Status)
   If-then expressed using <== (neg-implication)
*****************************************************************************/
flora_leftNEG_implication(IfPart,ThenPart,WS,DWS,Code,Status) :-
	flora_body(IfPart,WS,DWS,IfCode,Stat1),
	(Stat1==[]
	-> flora_body(ThenPart,WS,DWS,ThenCode,Status),
	    (Status==[]
	    ->
		get_index(IfPart,Idx),
		flneg_struct(IfCode,Idx,NegIfCode),
		fldisjunct_struct(NegIfCode,ThenCode,Code)
	    ; true
	    )
	;
	    Status = Stat1
	).



/****************************************************************************
  flora_body_univeqform(+CanoniTerm,+WS,+DWS,-Code,-Status)
  flora_body_notuniveqform(+CanoniTerm,+WS,+DWS,-Code,-Status)

  Parse the meta ops ~ and !~
****************************************************************************/
flora_body_univeqform(CANOTERM(_Funct,2,FL_PARENTHESIS,Args,_If,_Ip),WS,DWS,Code,Status) :-
	protect_reification(flora_distribute_ws(Args,WS,DWS,[LCode,RCode],Status)),
	(Status == [] -> fluniveqform_struct(LCode,RCode,Code) ; true).

flora_body_notuniveqform(CANOTERM(_Funct,2,FL_PARENTHESIS,Args,_If,_Ip),WS,DWS,Code,Status) :-
	protect_reification(flora_distribute_ws(Args,WS,DWS,[LCode,RCode],Status)),
	(Status == []
	-> fluniveqform_struct(LCode,RCode,Code1),
	    flnaf_struct(Code1,Code)
	; true
	).


/****************************************************************************
  flora_body_metauniv(+CanoniTerm,+WS,+DWS,-Code,-Status)

  Parse the meta op =..
  (_ =.. _)@_prolog(mod) and (_ =.. _)@_prologall(mod)
  are illegal, but
  (_ =.. _)@_prolog() and (_ =.. _)@_prologall() are legal.
****************************************************************************/
flora_body_metauniv(CANOTERM(_Funct,2,FL_PARENTHESIS,_Args,If,_Ip),WS,_DWS,_Code,Status) :-
	%% Only @_prolog() and @_prologall() are allowed;
	%% they don't match get_module_from_spec/3
	%% The test below checks for @_prolog(mod), @_prologall(mod)
	(get_module_from_spec(WS,PROLOGMODULE,_);get_module_from_spec(WS,PROLOGALLMODULE,_)),
	!,
	parsing_error(If,NO_WORKSPACE,Status).

%% If (_ =.. _)@_prolog() or (_ =.. _)@_prologall(), then use Prolog =..
flora_body_metauniv(CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),WS,DWS,Code,Status) :-
	(WS == PROLOGMODULE; WS == PROLOGALLMODULE),
	!,
	Args = [LCode,RCode],
	(WS == PROLOGMODULE
	-> ( (get_flvar_struct(LCode,LCodeParsed), S1=[], !
	     ; flora_prlgterm(LCode,DWS,LCodeParsed,S1)),
	       (S1 == [] -> flora_pathexp(RCode,DISALLOW_TRANS,DWS,RCodeParsed,Status)
	       %% failed to parse the first term
	       ; Status=S1
	       )
	   )
	;  %% PROLOGALLMODULE
	    ( flora_pure_term(LCode,DWS,LCodeParsed,S1),
		(S1 == [] -> flora_pure_term(RCode,DWS,RCodeParsed,Status)
		%% failed to parse the first term
		; Status=S1
		)
	    )
	),
	%% put together parsed terms using =.. (=Funct)
	(Status == [] ->
	    %% FCode is parsed functor code
	    flobject_struct(Funct,FCode),
	    flterm_struct(FCode,2,[LCodeParsed,RCodeParsed],Code1),
	    %% protect predicate code against hilog conversion
	    ( WS == PROLOGMODULE
	     -> flplib_struct(Code1,Code)
	      %% WS == PROLOGALLMODULE
	     ;  flpliball_struct(Code1,Code)
	    ) 
	%% failed to parse the second term
	; true
	).

flora_body_metauniv(CANOTERM(_Funct,2,FL_PARENTHESIS,Args,_If,_Ip),DWS,DWS,Code,Status) :-
	Args = [Left,Right],
	flora_pathexp(Left,DISALLOW_TRANS,DWS,LeftParsed,S1),
	(S1 == [] -> flora_pathexp(Right,DISALLOW_TRANS,DWS,RightParsed,Status)
	%% failed to parse the first term
	; Status=S1
	),
	(Status == [] -> flmetauniv_struct(LeftParsed,RightParsed,Code)
	%% failed to parse the second term
	; true
	).


/****************************************************************************
  flora_body_controlconstruct(+CanoniTermList1,+WS,+DWS,+TopWrapper,-Code,-Status).
   Process control constructs while-do/loop, loop/do-until, unless-do
   CanoniTermList1 represents the inner part of the control construct,
   e.g., the do-part in while(do(Cond,Action)).
   It should be a singleton list that contains a canonic term.
   TopWrapper is the unary wrapper (whole,do,loop,unless) for the construct
****************************************************************************/
flora_body_controlconstruct([CANOTERM(InnerFunct,2,FL_PARENTHESIS,Args,If,_Ip)],WS,DWS,TopWrapper,Code,Status) :-
	get_name(InnerFunct,InnerName),
	!,
	(get_control_construct_definition(StructType,TopWrapper,InnerName), !
	;
	    flora_concat_atoms(['Illegal connective `', InnerName, ''' in `',
			        TopWrapper, ''' construct'],
			       ErrMsg),
	    parsing_error(If,ErrMsg,Status)
	),
	(var(Status)
	-> Args=[Cond,Action],
	    flora_body(Cond,WS,DWS,CondCode,S1),
	    (S1== [] -> flora_body(Action,WS,DWS,ActionCode,Status)
	    ; Status = S1
	    ),
	    (Status==[]
	    -> flcontrolconstruct_struct(CondCode,ActionCode,StructType,Code)
	    ; true
	    )
	; true % error
	).

%% If wrong number of args or wrong parenthesis - issue an error
flora_body_controlconstruct([CANOTERM(_InnerFunct,_Arity,_Parenthesis,_Args,If,_Ip)],_WS,_DWS,TopWrapper,_Code,Status) :-
	flora_concat_atoms(['Illegal syntax in `', TopWrapper, ''' construct'],
			   ErrMsg),
	parsing_error(If,ErrMsg,Status).


flora_body_controlconstruct([SomethingElse],_WS,_DWS,TopWrapper,_Code,Status) :-
	get_index(SomethingElse,Idx),
	flora_concat_atoms(['Illegal syntax in `', TopWrapper, ''' construct'],
			   ErrMsg),
	parsing_error(Idx,ErrMsg,Status).



/****************************************************************************
  flora_distribute_ws(+List,+WS,+DWS,-TransformedList,-Status)

  Distribute the workspace through a list of formulae
****************************************************************************/
flora_distribute_ws([],_WS,_DWS,[],[]) :- !.
flora_distribute_ws([A|Args],WS,DWS,[TA|TArgs],Status) :-
	(get_flvar_struct(A,TA), Status1 = [], !
	;
	    flora_body(A,WS,DWS,TA,Status1)
	),
	(Status1 == [] -> flora_distribute_ws(Args,WS,DWS,TArgs,Status)
	; Status=Status1
	).


/****************************************************************************
  flora_body_literal(+CanoniTerm,+DWS,-Code,-Status)

  This predicate is called to parse a literal in a rule body.
  If DWS=NULL (which is indicated by the failure of get_module_from_spec/3),
  this means that the literal has no module name specification.
****************************************************************************/
flora_body_literal(CanoniTerm,DWS,Code,Status) :-
	flora_exec_directive(CanoniTerm,DWS,TCode,Status),
	!,
        (get_module_from_spec(DWS,ModuleType,Module) ->
            flmodule_struct(TCode,Module,ModuleType,Code)
        ;   Code=TCode
        ).

%% :(_,_), ::(_,_)
flora_body_literal(CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,F),
	is_birelop(F),
	!,
	flora_pathexplist(Args,DWS,[LCode,RCode],Status),
	(Status == [] ->
            flbirelate_struct(LCode,F,RCode,TCode),
            (get_module_from_spec(DWS,ModuleType,Module) ->
                flmodule_struct(TCode,Module,ModuleType,Code)
            ;   Code=TCode      %% DWS is NULL
            )
        ; true).

%% .(_,_), !(_,_),
flora_body_literal(CANOTERM(Funct,2,FL_PARENTHESIS,_Args,If,_Ip),_DWS,_Code,Status) :-
	get_atom(Funct,F),
	is_objrefop(F),
	!,
	parsing_error(If,ERROR_BDLITERAL,Status).

%% catch{...}
flora_body_literal(CANOTERM(Funct,3,FL_BRACE,[Goal,Error,Handler],_If,_Ip),DWS,Code,Status) :-
	get_name(Funct,Atom),
	is_catchop(Atom),
	!,
	flora_parse_catch(Goal,Error,Handler,DWS,Code,Status).

%% throw{...}
flora_body_literal(CANOTERM(Funct,1,FL_BRACE,[Error],_If,_Ip),DWS,Code,Status) :-
	get_name(Funct,Atom),
	is_throwop(Atom),
	!,
	flora_parse_throw(Error,DWS,Code,Status).

%% p2h{...}
flora_body_literal(CANOTERM(Funct,2,FL_BRACE,[Prolog,Hilog],_If,_Ip),DWS,Code,Status) :-
	get_name(Funct,Atom),
	is_p2hop(Atom),
	!,
	flora_parse_p2h(Prolog,Hilog,DWS,Code,Status).

%% newoid{...}
flora_body_literal(CANOTERM(Funct,1,FL_BRACE,[VarTerm],_If,Ip),_DWS,Code,Status) :-
	get_name(Funct,Atom),
	is_newoidop(Atom),
	!,
	(get_flvar_struct(VarTerm,VarCode)
	->
	    flnewoidop_struct(VarCode,Code),
	    Status = []
	; 
	    parsing_error(Ip,EXP_VARIABLE,Status)
	).

%% true{...}, false{...}, unknown{...}
flora_body_literal(CANOTERM(Funct,1,FL_BRACE,[Arg],_If,Ip),DWS,Code,Status) :-
	get_name(Funct,Atom),
	is_truthvalue_op(Atom),
	!,
	flatom_struct(Atom,Ip,AtomCode),
	flora_body(Arg,DWS,DWS,ArgCode,Status),
	(Status == []
	->
	    fltruthvalue_struct(ArgCode,AtomCode,Code)
	;
	    true
	).

%% refresh{...}
flora_body_literal(CANOTERM(Funct,N,FL_BRACE,Args,_If,Ip),DWS,Code,Status) :-
	get_name(Funct,Atom),
	is_tablerefreshop(Atom),
	!,
	(N == 0
	->
	    parsing_error(Ip,EXP_ARGS,Status)
	;
	    flora_tablerefresh(Args,DWS,Code,Status)
	).

%% label{Label, Head}
flora_body_literal(CANOTERM(Funct,N,FL_BRACE,_Args,If,_Ip),DWS,_Code,Status) :-
	get_name(Funct,Atom),
	is_labelprimitive_op(Atom),
	( DWS \== NULL -> parsing_error(If,ERROR_LABELPRIMITIVEMOD,Status)
	; N \= 2 -> parsing_error(If,ERROR_LABELPRIMITIVEARITY,Status)
	).

%% label{?Label,?Head}.  label{...}@Mod is not supported
flora_body_literal(CANOTERM(Funct,2,FL_BRACE,[Label,Head],_If,_Ip),DWS,Code,Status) :-
	get_name(Funct,Atom),
	is_labelprimitive_op(Atom),
	!,
	flora_term_or_var(Label,LabelCode,S1),
	(S1 == [] ->
	    flora_dbliteral_list(FLCLS,[Head],DWS,HeadCodeList,Status),
	    ( Status == []
	    -> fllabelprimitive_struct(LabelCode,HeadCodeList,Code)
	    ; true
	    )
	;
	    Status = S1
	).

%% prefix{?X,?Expansion} and prefix{?X,?Expansion}@Module
flora_body_literal(CANOTERM(Funct,N,FL_BRACE,_Args,If,_Ip),_DWS,_Code,Status) :-
	get_name(Funct,Atom),
	is_prefixprimitive_op(Atom),
	N \= 2,
	!,
	parsing_error(If,ERROR_PREFIXPRIMITIVEARITY,Status).

%% prefix{?X,?Expansion} and prefix{?X,?Expansion}@Module
flora_body_literal(CANOTERM(Funct,2,FL_BRACE,[Prefix,Expansion],If,_Ip),DWS,Code,Status) :-
	get_name(Funct,Atom),
	is_prefixprimitive_op(Atom),
	!,
	(get_module_from_spec(DWS,_ModuleType,ModuleCode) -> true
	; %% Module part is NULL (not specified)
	    ModuleCode = NULL
	),
	(flora_name_or_var(Prefix,PrefixCode),
	    flora_name_or_var(Expansion,ExpansionCode) ->
	    flprefixprimitive_struct(PrefixCode,ExpansionCode,ModuleCode,Code),
	    Status = []
	; parsing_error(If,ERROR_PREFIXPRIMITIVESYNTAX,Status)
	).

%% insert{...}
flora_body_literal(CANOTERM(Funct,N,FL_BRACE,Args,_If,Ip),DWS,Code,Status) :-
	get_name(Funct,Atom),
	is_dbinsertop(Atom),
	!,
	( N == 0 ->
	    parsing_error(Ip,EXP_ARGS,Status)
	;
	    flobject_struct(Funct,FCode),
	    flora_dbinsert(FCode,N,Args,DWS,Code,Status)
        ).

%% delete{...}
flora_body_literal(CANOTERM(Funct,N,FL_BRACE,Args,_If,Ip),DWS,Code,Status) :-
	get_name(Funct,Atom),
	is_dbdeleteop(Atom),
	!,
	( N == 0 ->
	    parsing_error(Ip,EXP_ARGS,Status)
	;
	    flobject_struct(Funct,FCode),
	    flora_dbdelete(FCode,N,Args,DWS,Code,Status)
        ).

%% newmodule{Module}
flora_body_literal(CANOTERM(Funct,1,FL_BRACE,[Arg],_If,Ip),_DWS,Code,Status) :-
	get_name(Funct,FL_NEWMODULE),
	!,
	flobject_struct(Funct,FCode),
	( flora_name_or_normvar(Arg,MCode)
	->
	  flnewmodule_struct(FCode,MCode,Code),
	  Status = []
	;
	    parsing_error(Ip,ERROR_WSNAME,Status)
	).

%% erasemodule{Module}
flora_body_literal(CANOTERM(Funct,1,FL_BRACE,[Arg],_If,Ip),_DWS,Code,Status) :-
	get_name(Funct,FL_ERASEMODULE),
	!,
	flobject_struct(Funct,FCode),
	( flora_name_or_normvar(Arg,MCode)
	->
	  flerasemodule_struct(FCode,MCode,Code),
	  Status = []
	;
	  parsing_error(Ip,ERROR_WSNAME,Status)
	).

%% caller{Module}
flora_body_literal(CANOTERM(Funct,1,FL_BRACE,[Arg],_If,Ip),_DWS,Code,Status) :-
	get_name(Funct,FL_CALLERMODULE),
	!,
	flobject_struct(Funct,FCode),
	(flora_name_or_normvar(Arg,VCode)
	->
	    flcallermodule_struct(FCode,VCode,Code),
	    Status = []
	;
	    parsing_error(Ip,ERROR_WSNAME,Status)
	).


%% insertrule_a{...}, insertrule_z{...}, deleterule_a{...},
%% deleterule_z{...}, or deleterule{...}
flora_body_literal(CANOTERM(Funct,N,FL_BRACE,Args,_If,Ip),DWS,Code,Status) :-
	get_name(Funct,Atom),
	is_ruleupdateop(Atom),
	!,
	( N == 0
	->
	    parsing_error(Ip,EXP_ARGS,Status)
	;
	    flobject_struct(Funct,FCode),
	    flora_ruleupdate(FCode,N,Args,DWS,Code,Status)
        ).

%% clause{[Mode,]Head, Body}
flora_body_literal(CANOTERM(Funct,_N,FL_BRACE,_Args,If,_Ip),DWS,_Code,Status) :-
	get_name(Funct,Atom),
	is_clauseop(Atom),
	DWS \== NULL,
	!,
	parsing_error(If,ERROR_CLAUSEMOD,Status).

%% clause{[Mode,]Head, Body}
flora_body_literal(CANOTERM(Funct,N,FL_BRACE,Args,If,Ip),DWS,Code,Status) :-
	get_name(Funct,Atom),
	is_clauseop(Atom),
	DWS==NULL,
	!,
	report_context(clause_construct),
	(Args = [Arg], is_labeled_construct(Arg,Label,Construct) ->
	    flora_parse_label(Label,true,LabCode,S1),
	    (S1 == []
	    ->
		Construct = CANOTERM(_F,_N,_Par,ClauseArgs,_,_),
		length(ClauseArgs,ClN),
		NewConstruct = CANOTERM(Funct,ClN,FL_BRACE,ClauseArgs,If,Ip),
		flora_body_literal(NewConstruct,DWS,Code1,Status),
		(Status == []
		-> 
		    (flclause_struct(H,B,Code1)
		    -> fllabeledclause_struct(LabCode,H,B,Code)
		    ; flclause_struct(Mode,H,B,Code1)
		    -> fllabeledclause_struct(LabCode,Mode,H,B,Code)
		    )
		; true
		)
	    ; Status =S1
	    )
        ;
	    N==2 ->
            Args = [Head,Body],
	    flora_comma_separated_list(Head,HeadList),
	    flora_dbliteral_list(FLCLS,HeadList,DWS,HeadCodeList,S1),
	    ( S1 == [] ->
		flora_body(Body,DWS,DWS,BodyCode,Status),
		( Status == [] ->
		    flclause_struct(HeadCodeList,BodyCode,Code)
		;
		    true
		)
	    ;
                Status = S1
            )
        ; N==3 ->
            Args = [Mode,Head,Body],
            flobject_struct(Mode,ModeCode),
	    ( is_flatom_struct(ModeCode,ModeAtom),
		valid_clause_mode(ModeAtom)
	    ->
	        flora_comma_separated_list(Head,HeadList),
	        flora_dbliteral_list(FLCLS,HeadList,DWS,HeadCodeList,S1),
                ( S1 == []
		->
                    flora_body(Body,DWS,DWS,BodyCode,Status),
                    ( Status == []
		    ->
                        flclause_struct(ModeCode,HeadCodeList,BodyCode,Code)
                    ;
                        true
                    )
                ;
                    Status = S1
                )
            ;
                parsing_error(Ip,ERROR_CLAUSE,Status)
            )
        ;
            parsing_error(Ip,ERROR_CLAUSE,Status)
        ),
	clear_context(clause_construct).
        
valid_clause_mode(STATIC_CLAUSE) :- !.
valid_clause_mode(DYNAMIC_CLAUSE) :- !.
valid_clause_mode(DYNA_CLAUSE) :- !.
valid_clause_mode(DYNZ_CLAUSE) :- !.

%% :=:
flora_body_literal(CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,FL_OBJEQL),
	!,
	flora_pathexplist(Args,DWS,[LCode,RCode],Status),
	(Status == [] ->
            flobjeql_struct(LCode,RCode,TCode),
            (get_module_from_spec(DWS,ModuleType,Module) ->
                flmodule_struct(TCode,Module,ModuleType,Code)
            ;   Code=TCode      %% DWS is NULL
            )
        ; true).

flora_body_literal(CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip),DWS,Code,Status) :-
	!,
	flora_term(Funct,N,Args,ALLOW_TRANS,DWS,TCode,Status),
        ( Status == [] ->
            ( get_atom(Funct,F), flora_nowsp(F,N) ->
                TCode = Code
            ; DWS == NULL ->
                TCode = Code
            ; get_module_from_spec(DWS,ModuleType,Module),
              flmodule_struct(TCode,Module,ModuleType,Code)
            )
        ; true).

%% ...[...]
flora_body_literal(CANOTERM(Funct,N,FL_BRACKET,Args,_If,_Ip),DWS,Code,Status) :-
	!,
	flora_objspec(Funct,N,Args,DWS,TCode,Status),
	(Status == [] ->
            (get_module_from_spec(DWS,ModuleType,Module) ->
                flmodule_struct(TCode,Module,ModuleType,Code)
            ;   Code=TCode      %% DWS is NULL
            )
        ; true).

flora_body_literal(CANOLIST(L,T,_N,I,_Ib),_DWS,Code,Status) :-
	!,
	( L == []
	-> parsing_error(I,ERROR_LOADLIST,Status)
	;
	  flora_loadlist(L,T,I,C,Status),
	  (Status == [] -> flload_struct(C,Code); true)
	).

%% {...} at the top level -- constraint
flora_body_literal(CANOBRACE(L,_N,I),DWS,Code,Status) :-
	!,
	(L == []
	%% {} at the top level with nothing inside
	-> parsing_error(I, ERROR_BDLITERAL, Status)
	;
	    flora_constraint_list(L,DWS,Code,Status)
	).

flora_body_literal(CANOEMPTYTERM(I),_DWS,_Code,Status) :-
	!,
	%% () at the top level with nothing inside
	parsing_error(I, ERROR_BDLITERAL, Status).

flora_body_literal(CanoniTerm,DWS,Code,[]) :-
	get_atom(CanoniTerm,A),
	!,
	( A == FL_CUT ->
	    get_index(CanoniTerm,I),
	    flcut_struct(I,Code)
	;
	    flobject_struct(CanoniTerm,TCode),
            ( flora_nowsp(A,0)
	    ->
                TCode = Code
            ; DWS == NULL
	    ->
                TCode = Code
            ; get_module_from_spec(DWS,ModuleType,Module),
              flmodule_struct(TCode,Module,ModuleType,Code)
            )
        ).

flora_body_literal(CanoniTerm,DWS,Code,[]) :-
	get_transactionalatom(CanoniTerm,_A),
	!,
	fltransactionalobject_struct(CanoniTerm,TCode),
        (get_module_from_spec(DWS,ModuleType,Module) ->
            flmodule_struct(TCode,Module,ModuleType,Code)
        ;   Code=TCode      %% DWS is NULL
        ).

flora_body_literal(CanoniTerm,DWS,Code,Status) :-
	get_flvar_struct(CanoniTerm,C),
        !,
	( PARSER_CONTEXT(parsing_reify),DWS==NULL ->
            parsing_error(CanoniTerm,NO_REIFY_VAR,Status)
	/*
	%% This happens when we have a predicate with a variable in an argument
	%% declared as BODYLITERAL. Do not flag an error in this case.
	; PARSER_CONTEXT(parsing_fact) ->
            parsing_error(CanoniTerm,NO_PRED_VAR,Status)
	*/
        ;   Status=[],
            ( get_module_from_spec(DWS,ModuleType,Module) ->
                flmodule_struct(C,Module,ModuleType,Code)
            ;
                C=Code
            )
        ).

flora_body_literal(CanoniTerm,DWS,Code,Status) :-
	get_fltransactionalvar_struct(CanoniTerm,C),
        !,
        (PARSER_CONTEXT(clause_construct)
	-> is_anonymous_flvar_struct(ModVar),
	    Status = [],
	    flmodule_struct(C,ModVar,FLORAUSERMOD,Code)
	; DWS==NULL ->
            parsing_error(CanoniTerm,ERROR_TRANSACTIONALVARLIT,Status)
	/*
	%% This happens when we have a predicate with a variable in an argument
	%% declared as BODYLITERAL. Do not flag an error in this case.
        ; PARSER_CONTEXT(parsing_fact) ->
            parsing_error(CanoniTerm,NO_PRED_VAR,Status)
	*/
        ; get_module_from_spec(DWS,ModuleType,Module),
          flmodule_struct(C,Module,ModuleType,Code),
          Status=[]
        ).
        
flora_body_literal(CanoniTerm,_DWS,_Code,Status) :-
	parsing_error(CanoniTerm,ERROR_BDLITERAL,Status).


/****************************************************************************
  flora_parse_body_template_list(+List,-CodeList,-Status)
****************************************************************************/
flora_parse_body_template_list([],[],[]) :- !.
flora_parse_body_template_list([H|T],[HCode|TCode],Status) :- 
        flora_parse_body_template(H,HCode,S),
        (S == [] ->
            flora_parse_body_template_list(T,TCode,Status)
        ;
            Status = S
        ).


/****************************************************************************
  flora_parse_body_template(+CanoniTerm,-CodeList,-Status)
****************************************************************************/
flora_parse_body_template(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),Code,Status) :-
	get_atom(Funct,FL_AT),
        flora_workspace_template(R,RCode,S),
        ( S == [] ->
            flora_parse_body_literal_template(L,RCode,LCode,Status),
	    (Status == [] -> 
                get_module_from_spec(RCode,ModuleType,Module),
                flmodule_struct(LCode,Module,ModuleType,Code)
	    ; 
                true
	    )
	; 
            Status = S
        ).

flora_parse_body_template(CanoniTerm,Code,Status) :-
        flora_parse_body_literal_template(CanoniTerm,Code,Status).

/****************************************************************************
  flora_workspace_template(+CanoniTerm,-Code,-Status)

  Note: There are no prolog modules in export templates
        Module variables can be only anonymous
****************************************************************************/
%% atomic
flora_workspace_template(CanoniTerm,FLORAUSERMOD(MCode),[]) :-
        get_flname_struct(CanoniTerm,MCode),
        !.

%% anonymous variable as module
flora_workspace_template(CanoniTerm,FLORAUSERMOD(MCode),[]) :-
	get_flvar_struct(CanoniTerm,MCode),
        is_anonymous_flvar_struct(MCode),
        !.

%% _@ as module
flora_workspace_template(CanoniTerm,FLORAUSERMOD(MCode),[]) :-
	get_spectoken(CanoniTerm,FL_THISMODULE),
        !,
        flobject_struct(CanoniTerm,MCode).

%% system module specification @_module
flora_workspace_template(CanoniTerm,FLORASYSMOD(MCode),Status) :-
	get_flbuiltin_identifier_struct(CanoniTerm,MCode),
	is_flatom_struct(MCode,ModuleName),
	!,
	( flora_system_module(ModuleName) -> Status=[]
	; parsing_error(CanoniTerm,UNREG_SYSMOD,Status)
	).

%% system module specification @_module()
flora_workspace_template(CANOTERM(Mod,0,FL_PARENTHESIS,[],_Ifu,_Ipa),FLORASYSMOD(MCode),Status) :-
	get_flbuiltin_identifier_struct(Mod,MCode),
	is_flatom_struct(MCode,ModuleName),
	!,
	( flora_system_module(ModuleName) -> Status=[]
	; parsing_error(Mod,UNREG_SYSMOD,Status)
	).

flora_workspace_template(CanoniTerm,_Code,Status) :-
        parsing_error(CanoniTerm,ERROR_WSNAME,Status).


/****************************************************************************
  flora_parse_body_literal_template(+CanoniTerm,-Code,-Status)
****************************************************************************/
%% transactional variables as literals can only appear with module specifications
flora_parse_body_literal_template(CanoniTerm,_WS,Code,Status) :-
	fltransactionalobject_struct(CanoniTerm,Code),
	!,
	(is_fltransactionalvar_struct(Code),
	    \+ is_anonymous_fltransactionalvar_struct(Code)
	->
	    parsing_error(CanoniTerm,ERROR_NAMEDVAR,Status)
	;
	    Status = []
	).

flora_parse_body_literal_template(CanoniTerm,_WS,Code,Status) :-
        flora_parse_body_literal_template(CanoniTerm,Code,Status).
        
%% :(_,_), ::(_,_)
flora_parse_body_literal_template(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),Code,Status) :-
	get_atom(Funct,F),
	is_birelop(F),
	!,
        ( get_flvar_struct(L,LCode), is_anonymous_flvar_struct(LCode) ->
	    flora_term_template(R,DISALLOW_TRANS,RCode,Status),
	    (Status == [] -> flbirelate_struct(LCode,F,RCode,Code); true)
        ;
	    parsing_error(L,EXP_ANONYVAR,Status)
        ).

%% insert{...} or delete{...}
flora_parse_body_literal_template(CANOTERM(Funct,N,FL_BRACE,Args,_If,_Ip),Code,Status) :-
	get_name(Funct,Atom),
	(is_dbinsertop(Atom),Type=FL_INSERT;
         is_dbdeleteop(Atom),Type=FL_DELETE),
	!,
	flobject_struct(Funct,FCode),
	( N == 1,
	    Args = [CANOTERM(Bar,2,FL_PARENTHESIS,[L,R],_Ifb,_Ipb)],
	    get_atom(Bar,FL_BAR)
	->
	    flora_comma_separated_list(L,LList),
            flora_anonymous_varlist(LList,LCode,Status),
            (Status == [] ->
	        ( get_flvar_struct(R,RCode), is_anonymous_flvar_struct(RCode) ->
                    (Type==FL_INSERT ->
	                flinsert_struct(FCode,LCode,RCode,Code)
                    ;
	                fldelete_struct(FCode,LCode,RCode,Code)
                    )
                ;
	            parsing_error(R,EXP_ANONYVAR,Status)
                )
            ;
	        true
            )
        ;
            flora_anonymous_varlist(Args,LCode,Status),
            (Status == [] ->
                (Type==FL_INSERT ->
                    flinsert_struct(FCode,LCode,Code)
                ;
                    fldelete_struct(FCode,LCode,Code)
                )
            ;
	        true
            )
        ).

%% ...[...]
flora_parse_body_literal_template(CANOTERM(Funct,N,FL_BRACKET,Args,_If,_Ip),Code,Status) :-
	!,
        ( get_flvar_struct(Funct,OCode), is_anonymous_flvar_struct(OCode) ->
            ( N == 0 ->
                SpecCode=[],
                Status=[]
            ;
		Args=[Spec],
		flora_attmeth_template(Spec,SpecCode,Status)
	    ),
	    (Status == [] -> flobjspec_struct(OCode,SpecCode,Code); true)
        ;
            parsing_error(Funct,EXP_ANONYVAR,Status)
        ).

flora_parse_body_literal_template(CANOLIST([Term],[],_N,I,_Ib),Code,Status) :-
	!,
        ( Term = CANOTERM(F,2,FL_PARENTHESIS,Args,_,_)
	->
            ( get_name(F,FL_RIGHTTO)
	    ->
                flora_anonymous_varlist(Args,AList,Status),
                (Status == []
		->
	            flobject_struct(F,FCode),
                    flterm_struct(FCode,2,AList,TCode),
                    fllist_struct([TCode],[],I,LCode),
                    flload_struct(LCode,Code)
                ;
                    true
                )
            ;
	        parsing_error(Term,ERROR_TEMPLATE,Status)
            )
        ;
            flora_anonymous_varlist([Term],AList,Status),
            ( Status == []
	    ->
                fllist_struct(AList,[],I,LCode),
                flload_struct(LCode,Code)
            ; 
                true
            )
        ).

%% standalone %_ is not allowed
flora_parse_body_literal_template(CanoniTerm,_Code,Status) :-
	fltransactionalobject_struct(CanoniTerm,_C),
	is_fltransactionalvar_struct(_C),
        !,
	parsing_error(CanoniTerm,ERROR_TRANSACTIONALVARLIT,Status).
        
%% term
flora_parse_body_literal_template(CanoniTerm,Code,Status) :-
        flora_term_template(CanoniTerm,ALLOW_TRANS,Code,Status),
	!.

flora_parse_body_literal_template(CanoniTerm,_Code,Status) :-
	parsing_error(CanoniTerm,ERROR_TEMPLATE,Status).


/****************************************************************************
  flora_attmeth_template(+CanoniTerm,-Code,-Status)
  methods and attributes can be term templates, and all other arguments must
  be anonymous variables
****************************************************************************/
flora_attmeth_template(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),Code,Status) :-
	get_atom(Funct,F),
	( is_mvdattspecop(F) ->
            ( get_flvar_struct(R,RCode), is_anonymous_flvar_struct(RCode) ->
                flora_term_template(L,DISALLOW_TRANS,LCode,Status),
	        (Status == [] -> flmvdattspec_struct(LCode,F,RCode,Code); true)
            ;
                parsing_error(R,EXP_ANONYVAR,Status)
            )

	; is_sigattspecop(F) ->
            ( get_flvar_struct(R,RCode), is_anonymous_flvar_struct(RCode) ->
                flora_term_template(L,DISALLOW_TRANS,LCode,Status),
	        (Status == [] -> flsigattspec_struct(LCode,F,RCode,Code); true)
            ;
                parsing_error(R,EXP_ANONYVAR,Status)
            )

	; is_incattspecop(F) ->
            ( get_flvar_struct(R,RCode), is_anonymous_flvar_struct(RCode) ->
                flora_term_template(L,DISALLOW_TRANS,LCode,Status),
	        (Status == [] -> flincattspec_struct(LCode,F,RCode,Code); true)
            ;
                parsing_error(R,EXP_ANONYVAR,Status)
            )

	; is_tolistattspecop(F) ->
            ( get_flvar_struct(R,RCode), is_anonymous_flvar_struct(RCode) ->
                flora_term_template(L,DISALLOW_TRANS,LCode,Status),
	        (Status == [] -> fltolistattspec_struct(LCode,F,RCode,Code); true)
            ;
                parsing_error(R,EXP_ANONYVAR,Status)
            )
        ),
	!.

flora_attmeth_template(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],If,_Ip),Code,Status) :-
	get_atom(Funct,FL_AT),
	!,
        ( (get_flname_struct(R,RCode)
	  ;
	      get_flvar_struct(R,RCode),
	      is_anonymous_flvar_struct(RCode)
	  )
	->
	    flora_attmeth_template(L,LCode,S),
	    ( S == [] ->
		( ( is_flattspec_struct(LCode)
		  ; is_flimethspec_struct(LCode)
		  ; is_fltranspec_struct(LCode)
		  ; is_passthru_struct(LCode)
		  )
		->
		      parsing_error(L,NO_WORKSPACE,Status)
		;
		    flmethspec_struct(C,LCode),
		    ( is_flworkspace_struct(C) ->
			parsing_error(If,NO_WSNESTING,Status)
		    ;
			flmodule_struct(C,RCode,FLORAUSERMOD,W),
			flmethspec_struct(W,Code),
			Status=[]
		    )
	        )
	    ;
		Status=S
	    )
	;
	    parsing_error(R,ERROR_WSNAME,Status)
        ).

flora_attmeth_template(CANOTERM(Funct,1,FL_PARENTHESIS,[A],_If,_Ip),Code,Status) :-
	get_atom(Funct,F),
	( is_boolsigop(F) ; is_iboolsigop(F)),
	flora_term_template(A,DISALLOW_TRANS,ACode,S1),
	(S1 == [] ->
	    ( is_boolsigop(F) -> flboolsig_struct(ACode,F,Code)
	    ; is_iboolsigop(F) -> fliboolsig_struct(ACode,F,Code)
	    ),
	    Status = []
	;
	    flora_attmeth_template(A,ACode2,S2),
	    (S2 == [] ->
		(fltranspec_struct(ATemp,ACode2) -> 
		    ( is_boolsigop(F) -> fltransig_struct(ATemp,F,Code)
		    ; is_iboolsigop(F) -> flitransig_struct(ATemp,F,Code)
		    ),
		    Status = []
		;
		    parsing_error(A,ERROR_BOOLSIG,Status)
		)
	    ;
		parsing_error(A,ERROR_BOOLSIG,Status)
	    )
	),
	!.

flora_attmeth_template(CANOTERM(Funct,1,FL_PARENTHESIS,[A],_If,_Ip),Code,Status) :-
	get_atom(Funct,F),
	( is_transigop(F) ; is_itransigop(F)),
	!,
	flora_term_template(A,DISALLOW_TRANS,ACode,Status),
	( is_transigop(F) -> fltransig_struct(ACode,F,Code)
	; is_itransigop(F) -> flitransig_struct(ACode,F,Code)
	).

flora_attmeth_template(CANOTERM(Funct,1,FL_PARENTHESIS,[A],_If,_Ip),Code,Status) :-
	get_atom(Funct,FL_INMETH),
	!,
	flora_term_template(A,DISALLOW_TRANS,C,Status),
	(Status == [] -> flimethspec_struct(C,Code); true).

flora_attmeth_template(CanoniTerm,Code,Status) :-
        fltransactionalobject_struct(CanoniTerm,C),
        !,
	(is_fltransactionalvar_struct(C),
	    \+ is_anonymous_fltransactionalvar_struct(C)
	->
	    parsing_error(CanoniTerm,ERROR_NAMEDVAR,Status)
	;
            fltranspec_struct(C,Code),
	    Status = []
	).
 
flora_attmeth_template(CanoniTerm,Code,Status) :-
	flora_term_template(CanoniTerm,ALLOW_TRANS,C,Status),
	(Status == [] -> 
            ((is_fltransactionalterm_struct(C);is_fltransactionalobject_struct(C)) ->
                fltranspec_struct(C,Code)
            ;
                flmethspec_struct(C,Code)
            )
        ;
            true
        ).

/****************************************************************************
  flora_term_template(+CanoniTerm,+TransFlag,-Code,-Status)
  Term template can be defined recursively:
    1) primitive structures except named variables are all term templates
    2) Term(_,_,...) is a term template if Term is a term template
****************************************************************************/
flora_term_template(CANOTERM(Funct,1,FL_PARENTHESIS,[Term],_If,_Ip),_TransFlag,Code,Status) :-
        (get_name(Funct,FL_LOAD); get_name(Funct,FL_ADD)),
	!,
        flobject_struct(Funct,FunctCode),
	( Term = CANOTERM(F,2,FL_PARENTHESIS,Args,_,_)
	->
            ( get_name(F,FL_RIGHTTO)
	    ->
                flora_anonymous_varlist(Args,AList,S1),
                (S1 == []
		->
	            flobject_struct(F,FCode),
                    flterm_struct(FCode,2,AList,TCode),
                    flterm_struct(FunctCode,1,[TCode],Code),
		    Status = []
                ;
                    Status=S1
                )
            ;
	        parsing_error(Term,ERROR_TEMPLATE,Status)
            )
        ;
            flora_anonymous_varlist([Term],AList,Status),
            ( Status == []
	    ->
		flterm_struct(FunctCode,1,AList,Code)
	    ;
		true
	    )
        ).
                
flora_term_template(CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip),TransFlag,Code,Status) :-
	!,
        flora_term_template(Funct,TransFlag,F,S),
        ( S == [] ->
            flora_anonymous_varlist(Args,AList,Status),
	    (Status == [] -> 
                ((is_fltransactionalobject_struct(F);is_fltransactionalterm_struct(F)) ->
                    fltransactionalterm_struct(F,N,AList,Code)
                ;
                    flterm_struct(F,N,AList,Code)
                )
            ;
                true
            )
	;
	  Status=S
        ).

flora_term_template(ObjectTerm,_TransFlag,Code,Status) :-
%%  primitive structures except named variables
	flobject_struct(ObjectTerm,Code),
	!,
	( is_flvar_struct(Code), \+ is_anonymous_flvar_struct(Code)
	->
	    parsing_error(ObjectTerm,ERROR_NAMEDVAR,Status)
	;
	    Status = []
	).

flora_term_template(ObjectTerm,ALLOW_TRANS,Code,Status) :-
	fltransactionalobject_struct(ObjectTerm,Code),
	!,
	(is_fltransactionalvar_struct(Code),
	    \+ is_anonymous_fltransactionalvar_struct(Code)
	->
	    parsing_error(ObjectTerm,ERROR_NAMEDVAR,Status)
	;
	    Status = []
	).

flora_term_template(CanoniTerm,_TransFlag,_Code,Status) :-
	parsing_error(CanoniTerm,ERROR_TEMPLATE,Status).

/****************************************************************************
  flora_anonymous_varlist(+List,-CodeList,-Status)
  parse a list of anonymous variables
****************************************************************************/
flora_anonymous_varlist([],[],[]) :- !.
flora_anonymous_varlist([H|L],[HCode|LCode],Status) :-
        ( get_flvar_struct(H,HCode), is_anonymous_flvar_struct(HCode) ->
            flora_anonymous_varlist(L,LCode,Status)
        ;
            parsing_error(H,EXP_ANONYVAR,Status)
        ).


/****************************************************************************
  flora_loadlist(+ListPrefix,+ListTail,+Index,-FLLIST,-Status)
****************************************************************************/
flora_loadlist([],[],Index,T,[]) :-
	!,
	fllist_struct([],[],Index,T).

flora_loadlist(L,T,Index,Code,Status) :-
	flora_loaditemlist(L,LCode,S),
	( S == [] ->
	    ( T == [] ->
		TCode=[],
		Status=[]

	    ; T=CANOLIST(List,Tail,_N,I,_Ib) ->
	        flora_loadlist(List,Tail,I,TCode,Status)

	    ; get_flvar_struct(T,TCode) ->
	        Status=[]
	    ;
	      parsing_error(T,ERROR_LOADLIST,Status)
	    ),
	    (Status == [] -> fllist_struct(LCode,TCode,Index,Code); true)
	;
	  Status=S
        ).


flora_loaditemlist([],[],[]) :- !.

flora_loaditemlist([T|L],[TCode|LCode],Status) :-
	flora_loaditem(T,TCode,S),
	(S == [] -> flora_loaditemlist(L,LCode,Status); Status=S).


flora_loaditem(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),Code,Status) :-
	get_atom(Funct,FL_RIGHTTO),
	flobject_struct(Funct,FCode),
	!,
	( ( flora_name_or_normvar(L,LCode)
	  ; get_flbuiltin_identifier_struct(L,LCode)
	  )
	->
	    ( flora_name_or_normvar(R,RCode)
	    ->
		flterm_struct(FCode,2,[LCode,RCode],Code),
		Status=[]
	    ;
	      parsing_error(R,ERROR_WSNAME,Status)
	    )
	; flora_addfile(L,LCode,_S)
	-> %% support for adding files to modules
	    ( flora_name_or_normvar(R,RCode)
	    ->
		flterm_struct(FCode,2,[LCode,RCode],Code),
		Status=[]
	    ;
		parsing_error(R,ERROR_WSNAME,Status)
	    )
	;
	    parsing_error(L,ERROR_LOADFILE,Status)
        ).

flora_loaditem(CanoniTerm,Code,[]) :-
	( (flora_name_or_normvar(CanoniTerm,Code)
	  ; get_flbuiltin_identifier_struct(CanoniTerm,Code)
	  ; get_atom(CanoniTerm,FL_INLINEMODULE,Idx),
	      flatom_struct(FL_INLINEMODULE,Idx,Code)
	  ),
	    !
	;
	    flora_addfile(CanoniTerm,Code,_S)
	),
	!.

flora_loaditem(CanoniTerm,_Code,Status) :-
	!,
	parsing_error(CanoniTerm,ERROR_LOADITEM,Status).


flora_name_or_normvar(CanoniTerm,Code) :-
	( get_flname_struct(CanoniTerm,Code)
        ;
	  get_flvar_struct(CanoniTerm,Code),
	  \+ is_anonymous_flvar_struct(Code)
        ),
	!.

flora_name_or_var(CanoniTerm,Code) :-
	( get_flname_struct(CanoniTerm,Code)
        ;
	    get_flvar_struct(CanoniTerm,Code)
        ),
	!.

flora_term_or_var(CanoniTerm,Code,Status) :-
	( get_flname_struct(CanoniTerm,Code), Status = [], !
        ; get_flvar_struct(CanoniTerm,Code), Status = [], !
	; CanoniTerm = CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip),
	    flora_term(Funct,N,Args,DISALLOW_TRANS,NULL,Code,Status) 
        ),
	!.

%% support for adding files to modules
flora_addfile(CANOTERM(Funct,1,FL_PARENTHESIS,[L],_If,_Ip),Code,Status) :-
	get_atom(Funct,FL_PLUS),
	flobject_struct(Funct,FCode),
	!,
	( ( flora_name_or_normvar(L,LCode)
	  ; get_flbuiltin_identifier_struct(L,LCode)
	  )
	->
	    flterm_struct(FCode,1,[LCode],Code),
	    Status=[]
	;
	    parsing_error(L,ERROR_ADDFILE,Status)
        ).

thismodule_token(CanoniTerm,ThisModToken) :-
	get_spectoken(CanoniTerm,FL_THISMODULE),
	flobject_struct(CanoniTerm,ThisModToken). % this always succeeds


/****************************************************************************
    flora_constraint_list(+L,+DWS,-Code,-Status)
    Add brace to delineate constraints
****************************************************************************/

flora_constraint_list(L,DWS,Code,Status) :-
	flora_body_literal_list(L,DWS,Lcode,Status),
	flconstraint_struct(Lcode,Code).

flora_body_literal_list([L],DWS,Code,Status) :-
	!,
	flora_body_literal(L,DWS,Code,Status).

flora_body_literal_list([L|Lits],DWS,Code,Status) :-
	flora_body_literal(L,DWS,Lcode,S),
	(S == []
	-> flora_body_literal_list(Lits,DWS,LitsCode,Status),
	    (Status == [] -> flconjunct_struct(Lcode,LitsCode,Code); true)
	; Status = S
	).


/****************************************************************************
  flora_prlgterm(+CanoniTerm,+DWS,-Code,-Status)

  This predicate is called to parse a Prolog predicate or prolog term.
  Its arguments can be F-logic molecules and path expressions, so the arguments
  are not parsed as Prolog terms.

  ***Why is it using a workspace?
****************************************************************************/
flora_prlgterm(CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,_Ip),DWS,Code,Status) :-
	!,
	( get_atom(Funct,FAtom) ->
	    ( FAtom == FL_AT, N == 2 ->
		parsing_error(If,NO_WSNESTING,Status)
	    ;
		flora_term(Funct,N,Args,DISALLOW_TRANS,DWS,Code,Status)
	    )
	;
	    parsing_error(If,ERROR_PRLGLIT,Status)
        ).

flora_prlgterm(CanoniTerm,_DWS,Code,[]) :-
	get_flname_struct(CanoniTerm,Code),
	!.

flora_prlgterm(CanoniTerm,_DWS,_Code,Status) :-
	parsing_error(CanoniTerm,ERROR_PRLGLIT,Status).


/****************************************************************************
  flora_term(+Funct,+Arity,+Args,+TransFlag,+DSW,-Code,-Status)

  Parse a term Funct-spec(Args). Arguments are parsed according to
  the argument spec in flora_argdef. The final parsed term is composed
  using flterm_struct
****************************************************************************/
flora_term(Funct,N,Args,_TransFlag,DWS,Code,Status) :-
	get_atom(Funct,FAtom),
	flora_argdef(FAtom,N,ArgTypes,DWS),
	!, 
        flobject_struct(Funct,F),
	flora_argpathexplist(Args,ArgTypes,DWS,AList,Status), 
	( Status == []
	-> flterm_struct(F,N,AList,Code)
	;
	    true
	).

flora_term(Funct,_N,Args,_TransFlag,DWS,Code,Status) :-
	get_atom(Funct,F),
	is_datatypeop(F),
	!,
	get_index(Funct,If),
	flora_parse_datatype(Args,If,DWS,Code,Status).

flora_term(Funct,N,Args,TransFlag,DWS,Code,Status) :-
        fltransactionalobject_struct(Funct,F),
        !,
        ( TransFlag == ALLOW_TRANS ->
	    (get_transactionalatom(Funct,FAtom),
		flora_argdef(FAtom,N,ArgTypes,DWS)
	    -> flora_argpathexplist(Args,ArgTypes,DWS,AList,Status)
	    ;
		flora_pathexplist(Args,DWS,AList,Status)
	    ),
            (Status == [] -> fltransactionalterm_struct(F,N,AList,Code) ; true)
        ;
            parsing_error(Funct,ERROR_TRANSACTIONAL_SYMBOL,Status)
        ).

flora_term(Funct,N,Args,TransFlag,DWS,Code,Status) :-
	flora_pathexp(Funct,TransFlag,DWS,F,S),
	( S == [] ->
	    flora_pathexplist(Args,DWS,AList,Status),
	    (Status == [] -> 
                (is_fltransactionalterm_struct(F) ->
                    fltransactionalterm_struct(F,N,AList,Code)
                ;
                    flterm_struct(F,N,AList,Code)
                )
            ; true
            )
	;
	  Status=S
        ).


/****************************************************************************
  flora_pure_term(+Funct,+Arity,+Args,+DWS,-Code,-Status)

  Parse a term Funct-spec(Args). Arguments are parsed as terms as well.
  No molecules are allowed, except reified molecules under ${...} and
  those apearing in meta-arguments.
****************************************************************************/
%% reification ${...}
flora_pure_term(CANOTERM(Funct,N,FL_BRACE,Args,If,Ip),DWS,Code,Status) :-
	get_atom(Funct,Atom),
	is_reifyop(Atom),
	!,
	(N > 1
	-> flora_list_to_conjunct(Args,Conjunct,If,Ip),
	    flora_reify(Conjunct,DWS,Code,Status)
	;
	    Args = [Arg],
	    flora_reify(Arg,DWS,Code,Status)
	).

flora_pure_term(CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,FAtom),
	flora_argdef(FAtom,N,ArgTypes,DWS),
	!,
	flobject_struct(Funct,F),
	flora_pure_term_list_with_argdefs(Args,ArgTypes,DWS,AList,Status),
	(Status == []
	-> flterm_struct(F,N,AList,Code)
	;
	    true
	).

flora_pure_term(CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip),DWS,Code,Status) :-
	!,
	flobject_struct(Funct,F),
	flora_pure_term_list(Args,DWS,AList,Status),
	(Status == []
	-> flterm_struct(F,N,AList,Code)
	;
	    true
	).

flora_pure_term(CANOLIST(L,T,_N,Index,_Ib),DWS,Code,Status) :-
	!,
	flora_pure_term_list(L,DWS,LCode,LStatus),
	(LStatus == [] ->
	    ( T==[] -> TCode = [], Status = []
	    ;
		flora_pure_term(T,DWS,TCode,Status)
	    ),
	    (Status == [] -> fllist_struct(LCode,TCode,Index,Code)
	    ; true
	    )
	;
	  Status=LStatus
        ).

flora_pure_term(CanoniTerm,_DWS,Code,[]) :-
	flobject_struct(CanoniTerm,Code),
	!.

flora_pure_term(CanoniTerm,_DWS,_Code,Status) :-
	parsing_error(CanoniTerm,ERROR_HILGTERM,Status).


%% parse list of pure terms
flora_pure_term_list([],_DWS,[],[]) :- !.
flora_pure_term_list([Arg|Args], DWS,[ArgCode|ArgCodeList], Status) :-
	flora_pure_term(Arg,DWS,ArgCode,Status1),
	(Status1 == []
	-> flora_pure_term_list(Args,DWS,ArgCodeList,Status)
	; Status = Status1
	).

%% parse list of pure terms taking into account argument definitions
%% in which these terms occur (FL_OID or FL_BODYFORMULA)
flora_pure_term_list_with_argdefs([],_,_DWS,[],[]) :- !.
flora_pure_term_list_with_argdefs([Arg|Args],[FL_OID|ArgsDefs],DWS,[ArgCode|ArgCodeList], Status) :-
	flora_pure_term(Arg,DWS,ArgCode,Status1),
	(Status1 == []
	-> flora_pure_term_list_with_argdefs(Args,ArgsDefs,DWS,ArgCodeList,Status)
	; Status = Status1
	).
flora_pure_term_list_with_argdefs([Arg|Args],[FL_BODYFORMULA|ArgsDefs],DWS,[RArgCode|ArgCodeList], Status) :-
	flora_body(Arg,DWS,DWS,ArgCode,Status1),
	(Status1 == []
	-> 
            flreify_struct(ArgCode,RArgCode),
            flora_pure_term_list_with_argdefs(Args,ArgsDefs,DWS,ArgCodeList,Status)
	; Status = Status1
	).


/****************************************************************************
  flora_list(+ListPrefix,+ListTail,+Index,+DWS,-FLLIST,-Status)

  Index is for '['.
****************************************************************************/
flora_list([],[],Index,_DWS,T,[]) :-
	!,
	fllist_struct([],[],Index,T).

flora_list(L,T,Index,DWS,Code,Status) :-
	flora_pathexplist(L,DWS,LCode,S),
	( S == [] ->
	    ( T == [] ->
		TCode=[],
		Status=[]
	    ;
	      flora_pathexp(T,DISALLOW_TRANS,DWS,TCode,Status)
	    ),
	    (Status == [] -> fllist_struct(LCode,TCode,Index,Code); true)
	;
	  Status=S
        ).


/****************************************************************************
  flora_pathexplist(+ListOfCanoniTerms,+DWS,-ListOfPathExpressions,-Status)

  parses a list of path expressions that are supposed to represent oids.
****************************************************************************/
flora_pathexplist([],_DWS,[],[]) :- !.

flora_pathexplist([T|L],DWS,[TCode|LCode],Status) :-
	flora_pathexp(T,DISALLOW_TRANS,DWS,TCode,S),
	( S == [] ->
	    flora_pathexplist(L,DWS,LCode,Status)
	;
	  Status=S
        ).


/****************************************************************************
  flora_argpathexplist(+Terms,+ArgumentTypes,+DWS,-PathExpressions,-Status)

  parses a list of path expressions according to a list of argument
  specification directives.
  FL_OID means the oid represented by a path expression while
  FL_BODYFORMULA means the formula represented by a path expression.
****************************************************************************/
flora_argpathexplist([],[],_DWS,[],[]) :- !.

flora_argpathexplist([T|L],[FL_OID|Arguments],DWS,[TCode|LCode],Status) :-
	flora_pathexp(T,DISALLOW_TRANS,DWS,TCode,S),
	( S == [] ->
	    flora_argpathexplist(L,Arguments,DWS,LCode,Status)
	;
	  Status=S
        ).

flora_argpathexplist([T|L],[FL_BODYFORMULA|Arguments],DWS,[RTCode|LCode],Status) :-
	protect_reification(flora_body(T,DWS,DWS,TCode,S)),
	( S == [] ->
            flreify_struct(TCode,RTCode),
	    flora_argpathexplist(L,Arguments,DWS,LCode,Status)
	;
	  Status=S
        ).


/****************************************************************************
  flora_pathexp(+CanoniTerm,+TransFlag,+DWS,-PathExpression,-Status)

  Parse path expression represented by CanoniTerm. A path expression is
  oid[molecule].oid[molecule]. ... .oid[molecule]
  (molecules are optional)
  Also term:term, term::term, and lists
****************************************************************************/
flora_pathexp(CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),_HF,DWS,Code,Status) :-
	get_atom(Funct,F),
	(is_birelop(F); is_objrefop(F)),
	!,
	flora_pathexplist(Args,DWS,[LCode,RCode],Status),
	( Status == [] ->
	    ( is_birelop(F) ->
		flbirelate_struct(LCode,F,RCode,Code)
	    ; 
	      flobjref_struct(LCode,F,RCode,Code)
	    )
	;
	  true
        ).

%% To handle URI SQname structure like prefix#suffix
flora_pathexp(CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),_HF,DWS,Code,Status) :-
	get_atom(Funct,F),
	is_urisqop(F),
	!,
	Args=[Prefix,Localname],
	( is_obj_identifier_struct(Prefix)
	-> %% prefix (the part before '#') should be an atom
	    ( (is_obj_ascii_string_struct(Localname)
	      ; is_obj_identifier_struct(Localname)
	      ; is_obj_quoted_atom_struct(Localname)
	      )
	    -> %% localname (part after '#') must be string/quotedAtm/identifier
		flora_pathexplist(Args,DWS,ArgsCode,Status),
		ArgsCode=[PrefixCode,LocalnameCode],
	        flurisq_struct(PrefixCode,LocalnameCode,Code)

	    ; get_index(Localname,Index_Localname),
	      parsing_error(Index_Localname,ERROR_SQNAME_LOCAL,Status) % need to change the error message
	    )

	; get_index(Prefix,Index_Prefix),
	  parsing_error(Index_Prefix,ERROR_SQNAME_PREFIX,Status)
	).


% To handle literal^^sort 
flora_pathexp(CANOTERM(Funct,2,FL_PARENTHESIS,Args,If,_Ip),_HF,DWS,Code,Status) :-
	get_atom(Funct,F),
	is_datatypeop(F),
	!,
	flora_parse_datatype(Args,If,DWS,Code,Status).

%% This clause handles module specification @_prolog() and @_prologall()
%% in the argument position.
%% Note that @module (for FLORA modules) is deprecated in the argument position.
%% But aggregate{ ... atom@module} and update{atom@module} are allowed.
flora_pathexp(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],If,_Ip),HF,DWS,Code,Status) :-
	get_atom(Funct,FL_AT),
	!,
	flora_workspace(R,WSCode,S1),
	( S1 == [] ->
	    ( (WSCode = PROLOGMODULE; WSCode = PROLOGMODULE(Mod)) ->
		flora_prlgterm(L,DWS,LCode,S2)
	    
	    ; (WSCode = PROLOGALLMODULE; WSCode = PROLOGALLMODULE(Mod)) ->
		flora_pure_term(L,DWS,LCode,S2)

	    ;   %% aggregate{ ... atom@module} or update{atom@module}
		%% Others (e.g., p(foo@bar)) will be caught in the compiler
		(WSCode = FLORAUSERMOD(Mod); WSCode = FLORASYSMOD(Mod)) ->
	        flora_pathexp(L,HF,WSCode,LCode,S2)
	    ),
	    %% Check if the module specification is valid.
	    ( S2 == [] ->
		( nowspathexp(LCode) ->
                    Code=LCode, Status=[]
		; is_flmodulespec_struct(LCode) ->
	            parsing_error(If,NO_WSNESTING,Status)
		;
		  Status=[],
		  ( WSCode = PROLOGMODULE ->
		      %% Covers: @_prolog()
		      flplib_struct(LCode,Code)
		  
		  ; WSCode = PROLOGALLMODULE ->
		      %% Covers: @_prologall()
		      flpliball_struct(LCode,Code)

		  %% Covers: @mod, @_mod, @_prolog(mod), @_prologall(mod)
		  ; get_module_from_spec(WSCode,ModuleType,Mod) ->
		      flmodule_struct(LCode,Mod,ModuleType,Code)
		  )
	        )
	    ;
	      Status=S2
	    )
	;
	  Status=S1
        ).

flora_pathexp(CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip),TransFlag,DWS,Code,Status) :-
	!,
	flora_term(Funct,N,Args,TransFlag,DWS,Code,Status).

flora_pathexp(CANOTERM(Funct,N,FL_BRACKET,Args,_If,_Ip),_HF,DWS,Code,Status) :-
	!,
	flora_objspec(Funct,N,Args,DWS,Code,Status).

flora_pathexp(CANOLIST(L,T,_N,I,_Ib),_HF,DWS,Code,Status) :-
	!,
	flora_list(L,T,I,DWS,Code,Status).

%% ${...} - reification
flora_pathexp(CANOTERM(Funct,N,FL_BRACE,[Arg|Rest],If,Ip),_HF,DWS,Code,Status) :-
	get_atom(Funct,Atom),
	is_reifyop(Atom),
	!,
	(N > 1 
	-> flora_list_to_conjunct([Arg|Rest], Conjunct, If, Ip),
	    flora_reify(Conjunct,DWS,Code,Status)
	;
	    flora_reify(Arg,DWS,Code,Status)
	).

flora_pathexp(CANOTERM(Funct,N,FL_BRACE,Args,If,Ip),_HF,DWS,Code,Status) :-
	!,
	flora_aggregt(Funct,N,Args,If,Ip,DWS,Code,Status).

flora_pathexp(ObjectTerm,_HF,_DWS,_Code,Status) :-
	%% New oid directive is only allowed in rule heads or reified formulas.
	get_spectoken(ObjectTerm,FL_NEWOID),
	if_not_reifying,
	!,
	parsing_error(ObjectTerm,ERROR_NEWOID,Status).

flora_pathexp(ObjectTerm,_HF,_DWS,Code,[]) :-
	flobject_struct(ObjectTerm,Code),
	!.

flora_pathexp(CANOBRACE(_L,_N,I),_HF,_DWS,_Code,Status) :-
	!,
	parsing_error(I,ERROR_SETNOTE,Status).

flora_pathexp(CanoniTerm,_HF,_DWS,_Code,Status) :-
	parsing_error(CanoniTerm,ERROR_PATHEXP,Status).


%% Define which type of arguments should not have module specification.
nowspathexp(S) :- is_fllist_struct(S), !.
nowspathexp(S) :- is_flaggregt_struct(S), !.
nowspathexp(S) :- is_flreify_struct(S), !.
nowspathexp(S) :- is_flnumber_struct(S), !.
nowspathexp(S) :- is_flstring_struct(S), !.
nowspathexp(S) :- is_fldatatype_struct(S), !.
%%nowspathexp(S) :- is_flbuiltin_identifier_struct(S), !.

nowspathexp(S) :-
	is_flatom_struct(S,FAtom),
	flora_nowsp(FAtom,0),
	!.

nowspathexp(S) :-
	flterm_struct(Funct,N,_Args,S),
	is_flatom_struct(Funct,FAtom),
	flora_nowsp(FAtom,N),
	!.


/****************************************************************************
  flora_objspec(+Obj,+Arity,+Args,+DWS,-Code,-Status)
  flora_objspec(+CanoniTerm,+DWS,-Code,-Status)

  parses ObjectSpecification as described in the BNF grammar at the
  beginning of this file.
****************************************************************************/
flora_objspec(Obj,N,Args,DWS,Code,Status) :-
	flora_pathexp(Obj,DISALLOW_TRANS,DWS,O,S),
	( S == [] ->
	    ( N == 0 ->
		Spec=[],
		Status=[]
	    ;
		Args=[Body],
		flora_objspec(Body,DWS,Spec,Status)
	    ),
	    (Status == [] -> flobjspec_struct(O,Spec,Code); true)
	;
	  Status=S
        ).

flora_objspec(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,F),
	(F == FL_COMMA; F == FL_SEMICOLON),
	!, %% conjunction or disjunction
	flora_objspec(L,DWS,LCode,S),
	( S == [] ->
	    flora_objspec(R,DWS,RCode,Status),
	    ( Status == [] ->
		( F == FL_COMMA ->
		    flconjunct_struct(LCode,RCode,Code)
		;
		  fldisjunct_struct(LCode,RCode,Code)
	        )
	    ;
	      true
	    )
	;
	  Status=S
        ).

flora_objspec(CANOTERM(Funct,1,FL_PARENTHESIS,[G],If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,F),
	(is_nafop(F); is_notop(F); is_negop(F)),
	!, %% negation
	flora_objspec(G,DWS,C,Status),
	( Status == [] ->
	    (is_nafop(F) -> flnaf_struct(C,Code)
	    ; is_notop(F) -> flnot_struct(C,Code)
	    ; flneg_struct(C,If,Code)
	    )
	;
	  true
        ).

flora_objspec(CanoniTerm,DWS,Code,Status) :-
	flora_attmethspec(CanoniTerm,DWS,Code,Status).
	


/****************************************************************************
  flora_attmethspec(+CanoniTerm,+DWS,-Goal,-Status)
  flora_setexp(+CanoniTerm,+DWS,-CodeList,-Status)
****************************************************************************/
flora_attmethspec(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,F),
	( is_mvdattspecop(F) ->
	    flora_pathexp(L,DISALLOW_TRANS,DWS,LCode,S),
	    (S == [] -> flora_setexp(R,DWS,RCode,Status); Status=S),
	    (Status == [] -> flmvdattspec_struct(LCode,F,RCode,Code); true)

	; is_sigattspecop(F) ->
	    (L=CANOTERM(M,1,FL_BRACE,[Constr],_If1,_Ip1)->
		flora_sigconstr(Constr,DWS,CCode,S_C), 
		(S_C==[] ->
		    flora_pathexp(M,DISALLOW_TRANS,DWS,MCode,S1),
		    (S1==[]
		    %% The right hand side 
		    -> (is_emptyterm(R)
		       %% This is SIGDEF: occurs when we have a[b=> ()]
		       -> get_index(R,Ind),
			   emptyterm_struct(Ind,RCode),
			   Status = []
		       ;  flora_pathexp(R,DISALLOW_TRANS,DWS,RCode,Status)
		       )
		    ; Status = S1
		    )
		;
		    Status = S_C
		),
		(Status == [] -> flsigattconspec_struct(MCode,CCode,F,RCode,Code); true)
	    ;
		flora_pathexp(L,DISALLOW_TRANS,DWS,LCode,S1),
		(S1==[]
		%% The right hand side 
		-> (is_emptyterm(R)
		   -> get_index(R,Ind),
		       emptyterm_struct(Ind,RCode),
		       Status = []
		   ;  flora_pathexp(R,DISALLOW_TRANS,DWS,RCode,Status)
		   )
		; Status = S1
		),
		(Status == [] -> flsigattspec_struct(LCode,F,RCode,Code); true)
	    )

	; is_incattspecop(F) ->
	    flora_pathexplist([L,R],DWS,[LCode,RCode],Status),
	    (Status == [] -> flincattspec_struct(LCode,F,RCode,Code); true)

	; is_tolistattspecop(F) ->
	    flora_pathexplist([L,R],DWS,[LCode,RCode],Status),
	    (Status == [] -> fltolistattspec_struct(LCode,F,RCode,Code); true)
        ),
	!.

flora_attmethspec(CANOTERM(Funct,1,FL_PARENTHESIS,[A],_If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,F),
	( is_boolsigop(F) ; is_iboolsigop(F)),
	flora_pathexp(A,DISALLOW_TRANS,DWS,ACode,S1),
	(S1 == [] ->
	    ( is_boolsigop(F) -> flboolsig_struct(ACode,F,Code)
	    ; is_iboolsigop(F) -> fliboolsig_struct(ACode,F,Code)
	    ),
	    Status = []
	;
	    flora_attmethspec(A,DWS,ACode2,S2),
	    (S2 == [] ->
		(fltranspec_struct(ATemp,ACode2) -> 
		    ( is_boolsigop(F) -> fltransig_struct(ATemp,F,Code)
		    ; is_iboolsigop(F) -> flitransig_struct(ATemp,F,Code)
		    ),
		    Status = []
		;
		    parsing_error(A,ERROR_BOOLSIG,Status)
		)
	    ;
		parsing_error(A,ERROR_BOOLSIG,Status)
	    )
	),
	!.

flora_attmethspec(CANOTERM(Funct,1,FL_PARENTHESIS,[A],_If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,F),
	( is_transigop(F) ; is_itransigop(F)),
	!,
	flora_pathexp(A,DISALLOW_TRANS,DWS,ACode,Status),
	( is_transigop(F) -> fltransig_struct(ACode,F,Code)
	; is_itransigop(F) -> flitransig_struct(ACode,F,Code)
	).


flora_attmethspec(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],If,_Ip),_DWS,Code,Status) :-
	get_atom(Funct,FL_AT),
	!,
	( flora_name_or_var(R,RCode) ->
            flora_workspace(R,WSCode,SWS),
	    flora_attmethspec(L,WSCode,LCode,S),
	    ( S == [], SWS == [] ->
		( ( is_flattspec_struct(LCode)
		  ; is_flimethspec_struct(LCode)
		  ; is_fltranspec_struct(LCode)
		  ; is_passthru_struct(LCode)
		  )
		->
		      parsing_error(L,NO_WORKSPACE,Status)
		;
		    flmethspec_struct(C,LCode),
		    ( is_flworkspace_struct(C) ->
			parsing_error(If,NO_WSNESTING,Status)
		    ;
			flmodule_struct(C,RCode,FLORAUSERMOD,W),
			flmethspec_struct(W,Code),
			Status=[]
		    )
	        )
	    ; SWS == []
	    -> Status=S
	    ; Status = SWS
	    )
	;
	    parsing_error(R,ERROR_WSNAME,Status)
        ).

flora_attmethspec(CANOTERM(Funct,1,FL_PARENTHESIS,[A],_If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,FL_INMETH),
	!,
	flora_pathexp(A,DISALLOW_TRANS,DWS,C,Status),
	( Status==[] -> flimethspec_struct(C,Code);true).

flora_attmethspec(CanoniTerm,_DWS,Code,[]) :-
        fltransactionalobject_struct(CanoniTerm,C),
        !,
        fltranspec_struct(C,Code).
        
flora_attmethspec(CanoniTerm,DWS,Code,Status) :-
	flora_pathexp(CanoniTerm,ALLOW_TRANS,DWS,C,Status),
	(Status == [] -> 
            is_fltransactionalterm_struct(C),
	    fltranspec_struct(C,Code)
        ;
            true
        ).

%% Obj[true], Obj[fail], Obj[!] - interpreted as true, false, !
flora_attmethspec(CanoniTerm,DWS,Code,Status) :-
	flora_pathexp(CanoniTerm,DISALLOW_TRANS,DWS,C,Status),
	is_flatom_struct(C,Atom),
	is_passthru_atom(Atom),
        !,
	(Status == [] -> flpassthru_struct(C,Code); true).

%% Obj[X>Y], Obj[X=Y], etc.
flora_attmethspec(CanoniTerm,DWS,Code,Status) :-
	flora_pathexp(CanoniTerm,DISALLOW_TRANS,DWS,C,Status),
	flterm_struct(Funct,Arity,_Args,C), % decompose C
	is_flatom_struct(Funct,Atom),
	is_passthru_pred(Atom,Arity),
        !,
	(Status == [] -> flpassthru_struct(C,Code); true).

flora_attmethspec(CanoniTerm,DWS,Code,Status) :-
	flora_pathexp(CanoniTerm,DISALLOW_TRANS,DWS,C,Status),
	(Status == [] -> flmethspec_struct(C,Code); true).


flora_setexp(CANOBRACE(L,_N,_I),DWS,Code,Status) :-
	!,
	flora_pathexplist(L,DWS,Code,Status).

flora_setexp(CanoniTerm,DWS,[Code],Status) :-
	flora_pathexp(CanoniTerm,DISALLOW_TRANS,DWS,Code,Status).

	

flora_sigconstr(CANOTERM(Funct,2,FL_PARENTHESIS,[Lower,Upper],_If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,FL_CONSTR),
	!,
	flora_pathexplist([Lower,Upper],DWS,[LowerCode,UpperCode],S),
	( S == [] ->
	    ( not(valid_lower_sigconstr(LowerCode)) ->
		Lower = OBJECT(_,If),
		parsing_error(If,ERROR_SIGCONSTR_LOW,Status)
	    ;
		( not(valid_upper_sigconstr(UpperCode)) ->
		        Upper = OBJECT(_,If),
		        parsing_error(If,ERROR_SIGCONSTR_HIGH,Status)
		;
		    Status = []
		)
	    )
	;
	    Status = S
	),
	flsigconstr_struct(LowerCode,UpperCode,Code). 
	
flora_sigconstr(CANOTERM(_Funct,_N,_,_Args,If,_Ip),_DWS,_Code,Status) :-
	parsing_error(If,ERROR_SIGCONSTR,Status).
	

valid_upper_sigconstr(UpperCode):- % H in c[m{L:H}=>v] should be a variable or a non-negative integer or '*'
	is_flatom_struct(UpperCode,UpperAtom),
	UpperAtom == FL_STAR

	; UpperCode = FLNUMBER(N,_),integer(N),N>=0

	; is_flvar_struct(UpperCode)

	; is_anonymous_flvar_struct(UpperCode)

	; is_fltransactionalvar_struct(UpperCode)

	; is_anonymous_fltransactionalvar_struct(UpperCode)
	.

valid_lower_sigconstr(LowerCode):-
	%% L in c[m{L:H}=>v] should be a variable or an integer
	LowerCode = FLNUMBER(N,_),integer(N)
	; is_flvar_struct(LowerCode)
	; is_anonymous_flvar_struct(LowerCode)
	; is_fltransactionalvar_struct(LowerCode)
	; is_anonymous_fltransactionalvar_struct(LowerCode).
	

/****************************************************************************
  flora_aggregt(+Funct,+Arity,+Args,+IndxFunct,+IndxBrace,-Code,-Status)
  aggregt_vars(+CanoniTerm,-Var,-GroupVars,-Status)
  var_list(+List,-GroupVars,-Status)
****************************************************************************/
flora_aggregt(Funct,N,Args,If,Ip,DWS,Code,Status) :-
	( get_name(Funct,FAtom), is_aggregtop(FAtom)
	->
	    flobject_struct(Funct,F),
	    (N == 1,
		Args=[CANOTERM(Bar,2,FL_PARENTHESIS,[L,R],_Il,_Ir)],
		get_atom(Bar,FL_BAR)
	    ->
	        aggregt_vars(L,Var,GroupVars,S1),
		( S1 == []
		->
		    flora_body(R,DWS,DWS,Conds,Status),
		    ( Status == []
		    ->
			flaggregt_struct(F,Var,GroupVars,Conds,Code)
		    ;
			true
		    )
		;
		    Status=S1
	        )
	    ;
		parsing_error(Ip,ERROR_AGGREGT,Status)
	    )

	; get_name(Funct,FAtom),
	    (is_dbinsertop(FAtom); is_dbdeleteop(FAtom); is_ruleupdateop(FAtom))
	->
	    parsing_error(If,ERROR_UPDATEOP,Status)
	;
	    parsing_error(If,UNKNOWN_BRACE_BUILTIN,Status)
        ).


aggregt_vars(Term,Var,[],[]) :-
	get_flvar_struct(Term,Var),
	!.

aggregt_vars(CANOTERM(Funct,N,FL_BRACKET,L,If,_Ip),Var,GroupVars,Status) :-
	!,
	( get_flvar_struct(Funct,Var) ->
	    ( N == 0 ->
		GroupVars=[],
		Status=[]
	    ;
	      L=[T],
	      var_list(T,GroupVars,Status)
	    )
	;
	  parsing_error(If,EXP_AGGREGVAR,Status)
        ).

aggregt_vars(CanoniTerm,_V,_GV,Status) :-
	parsing_error(CanoniTerm,EXP_AGGRGRPVAR,Status).


var_list(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],If,_Ip),[Var|GV],Status) :-
	get_atom(Funct,F),
	!,
	( F == FL_COMMA ->
	    ( get_flvar_struct(L,Var) ->
		var_list(R,GV,Status)
	    ;
	      parsing_error(L,EXP_VARIABLE,Status)
	    )

	; F == FL_BAR ->
	    parsing_error(If,NO_LISTTAIL,Status)

	;
	  parsing_error(If,EXP_VARIABLE,Status)
        ).

var_list(CanoniTerm,[Var],Status) :-
	( get_flvar_struct(CanoniTerm,Var) ->
	    Status=[]
	;
	  parsing_error(CanoniTerm,EXP_VARIABLE,Status)
        ).


/****************************************************************************
  flora_head_term(+Funct,+Arity,+Args,+TransFlag,+DWS,-Code,-Status)

  This predicate is called to parse a term in a rule head. Parsing of its
  arguments is adjusted according to its arguments mode definition.
****************************************************************************/
flora_head_term(Funct,N,Args,_HF,DWS,Code,Status) :-
	get_atom(Funct,FAtom),
	flora_argdef(FAtom,N,ArgTypes,DWS),
	!,
	flobject_struct(Funct,F),
	flora_head_argpathexplist(Args,ArgTypes,DWS,AList,Status),
	(Status == []
	->
	    flterm_struct(F,N,AList,Code)
	;
	    true
	).

flora_head_term(Funct,N,Args,TransFlag,DWS,Code,Status) :-
	fltransactionalobject_struct(Funct,F),
        !,
        (TransFlag == ALLOW_TRANS ->
	    flora_head_pathexplist(Args,DWS,AList,Status),
            (Status == [] -> fltransactionalterm_struct(F,N,AList,Code) ; true)
        ;
            parsing_error(Funct,ERROR_TRANSACTIONAL_SYMBOL,Status)
        ).

flora_head_term(Funct,N,Args,TransFlag,DWS,Code,Status) :-
	flora_head_pathexp(Funct,TransFlag,DWS,F,S),
	( S == [] ->
	    flora_head_pathexplist(Args,DWS,AList,Status),
	    (Status == [] -> 
                ( is_fltransactionalterm_struct(F) ->
                    fltransactionalterm_struct(F,N,AList,Code)
                ;
                    flterm_struct(F,N,AList,Code)
                )
            ;
                true
            )
	;
	  Status=S
        ).


/****************************************************************************
 flora_head_list(+ListPrefix,+ListTail,+Index,+DWS,-FLLIST,-Status)
****************************************************************************/
flora_head_list([],[],Index,_DWS,T,[]) :-
	!,
	fllist_struct([],[],Index,T).

flora_head_list(L,T,Index,DWS,Code,Status) :-
	flora_head_pathexplist(L,DWS,LCode,S),
	( S == [] ->
	    ( T == [] ->
		TCode=[],
		Status=[]
	    ;
	      flora_head_pathexp(T,DISALLOW_TRANS,DWS,TCode,Status)
	    ),
	    (Status == [] -> fllist_struct(LCode,TCode,Index,Code); true)
	;
	  Status=S
        ).


/****************************************************************************
  flora_head_argpathexplist(+Terms,+ArgumentTypes,+DWS,-PathExpressions,-Status)
****************************************************************************/
flora_head_argpathexplist([],[],_DWS,[],[]) :- !.

flora_head_argpathexplist([T|L],[FL_OID|Arguments],DWS,[TCode|LCode],Status) :-
	flora_head_pathexp(T,DISALLOW_TRANS,DWS,TCode,S),
	( S == [] ->
	    flora_head_argpathexplist(L,Arguments,DWS,LCode,Status)
	;
	  Status=S
        ).

flora_head_argpathexplist([T|L],[FL_BODYFORMULA|Arguments],DWS,[RTCode|LCode],Status) :-
	flora_body(T,DWS,DWS,TCode,S),
	( S == [] ->
            flreify_struct(TCode,RTCode),
	    flora_head_argpathexplist(L,Arguments,DWS,LCode,Status)
	;
	  Status=S
        ).


/****************************************************************************
  flora_head_pathexplist(+ListOfCanoniTerms,+DWS,-ListOfPathExpressions,-Status)
****************************************************************************/
flora_head_pathexplist([],_DWS,[],[]) :- !.

flora_head_pathexplist([T|L],DWS,[TCode|LCode],Status) :-
	flora_head_pathexp(T,DISALLOW_TRANS,DWS,TCode,S),
	( S == [] ->
	    flora_head_pathexplist(L,DWS,LCode,Status)
	;
	  Status=S
        ).


/****************************************************************************
  flora_head_pathexp(+CanoniTerm,+TransFlag,+DWS,-HeadPathExpression,-Status)
****************************************************************************/
flora_head_pathexp(CANOTERM(Funct,2,FL_PARENTHESIS,Args,If,_Ip),HF,DWS,Code,Status) :-
	get_atom(Funct,F),
	!,
	( is_birelop(F) ->
	    flora_head_pathexplist(Args,DWS,[LCode,RCode],Status),
	    ( Status == [] ->
		    flbirelate_struct(LCode,F,RCode,Code)
	    ;
	      true
	    )

	; is_mvdobjrefop(F) -> 
	    flora_head_pathexplist(Args,DWS,[LCode,RCode],Status),
	    ( Status == [] ->
		    flobjref_struct(LCode,F,RCode,Code)
	    ;
	      true
	    )

	; F == FL_AT ->
	    %% Module specs for F-logic molecules in the head are not allowed.
	    parsing_error(If,NO_WSINRULEHEAD,Status)

	; is_urisqop(F) ->
	    Args=[Prefix,Localname],
	    ( is_obj_identifier_struct(Prefix)
	    -> % make sure that prefix (the part before '#') is an atom
		((is_obj_ascii_string_struct(Localname)
		 ; is_obj_identifier_struct(Localname)
		 ; is_obj_quoted_atom_struct(Localname)
		 )
		-> %% localname (the part following '#')
		    %% should be a string or quoted atom or an identifier
		    flora_head_pathexplist(Args,DWS,ArgsCode,Status),
		    ArgsCode=[PrefixCode,LocalnameCode],
		    flurisq_struct(PrefixCode,LocalnameCode,Code)

		; get_index(Localname,Index_Localname),
		  parsing_error(Index_Localname,ERROR_SQNAME_LOCAL,Status)
		)

	    ; get_index(Prefix,Index_Prefix),
	      parsing_error(Index_Prefix,ERROR_SQNAME_PREFIX,Status)
	    )

	; is_datatypeop(F) ->
	    flora_parse_datatype(Args,If,DWS,Code,Status)
	    
	; flora_head_term(Funct,2,Args,HF,DWS,Code,Status)
        ).

flora_head_pathexp(CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip),HF,DWS,Code,Status) :-
	!,
	flora_head_term(Funct,N,Args,HF,DWS,Code,Status).

flora_head_pathexp(CANOTERM(Funct,N,FL_BRACKET,Args,_If,_Ip),_HF,DWS,Code,Status) :-
	!,
	flora_head_objspec(Funct,N,Args,DWS,Code,Status).

flora_head_pathexp(CANOLIST(L,T,_N,I,_Ib),_HF,DWS,Code,Status) :-
	!,
	flora_head_list(L,T,I,DWS,Code,Status).

flora_head_pathexp(ObjectTerm,_HF,_DWS,Code,[]) :-
	flobject_struct(ObjectTerm,Code),
	!.

%% ${...} - reification
flora_head_pathexp(CANOTERM(Funct,N,FL_BRACE,Args,If,Ip),_HF,DWS,Code,Status) :-
	get_atom(Funct,Atom),
	is_reifyop(Atom),
	!,
	(N > 1
	-> flora_list_to_conjunct(Args,Conjunct,If,Ip),
	    flora_reify(Conjunct,DWS,Code,Status)
	;
	    Args = [Arg],
	    flora_reify(Arg,DWS,Code,Status)
	).

flora_head_pathexp(CANOTERM(_Funct,_N,FL_BRACE,_Args,_If,Ip),_HF,_DWS,_Code,Status) :-
	!,
	parsing_error(Ip,NO_AGGINHEAD,Status).

flora_head_pathexp(CANOBRACE(_L,_N,I),_HF,_DWS,_Code,Status) :-
	!,
	parsing_error(I,ERROR_SETNOTE,Status).

flora_head_pathexp(CanoniTerm,_HF,_DWS,_Code,Status) :-
	parsing_error(CanoniTerm,ERROR_EXPINHEAD,Status).


/****************************************************************************
  flora_head_objspec(+Obj,+Arity,+Args,+DWS,-Code,-Status)
  flora_head_objspec(+CanoniTerm,+DWS,-Code,-Status)
****************************************************************************/
flora_head_objspec(Obj,N,Args,DWS,Code,Status) :-
	flora_head_pathexp(Obj,DISALLOW_TRANS,DWS,O,S),
	( S == [] ->
	    ( N == 0 ->
		Spec=[],
		Status=[]
	    ;
	      Args=[Body],
	      flora_head_objspec(Body,DWS,Spec,Status)
	    ),
	    (Status == [] -> flobjspec_struct(O,Spec,Code); true)
	;
	  Status=S
        ).


flora_head_objspec(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,F),
	( F == FL_COMMA ->
	    flora_head_objspec(L,DWS,LCode,S),
	    ( S == [] ->
		flora_head_objspec(R,DWS,RCode,Status),
		(Status == [] -> flconjunct_struct(LCode,RCode,Code); true)
	    ;
	      Status=S
	    )
	;
	  F == FL_SEMICOLON,
	  parsing_error(If,NO_DISJUNCTION,Status)
        ),
	!.

flora_head_objspec(CANOTERM(Funct,1,FL_PARENTHESIS,[Arg],If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,F),
	is_negop(F),
	!,
	%% explicit negation
	flora_head_objspec(Arg,DWS,ArgCode,Status),
	(Status == [] -> 
            flneg_struct(ArgCode,If,NegCode),
            (get_module_from_spec(DWS,ModuleType,Module) ->
                flmodule_struct(NegCode,Module,ModuleType,Code)
            ;   Code=NegCode
            )
        ; true).

flora_head_objspec(CANOTERM(Funct,1,FL_PARENTHESIS,[_G],If,_Ip),_DWS,_Code,Status) :-
	get_atom(Funct,F),
	(is_nafop(F); is_notop(F)),
	!,
	parsing_error(If,NO_NEGATION,Status).

flora_head_objspec(CanoniTerm,DWS,Code,Status) :-
	flora_head_attmethspec(CanoniTerm,DWS,Code,Status).


/****************************************************************************
  flora_head_attmethspec(+CanoniTerm,+DWS,-Goal,-Status)
  flora_head_setexp(+CanoniTerm,+DWS,-CodeList,-Status)
****************************************************************************/
flora_head_attmethspec(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,F),
	( is_mvdattspecop(F) ->
	    flora_head_pathexp(L,DISALLOW_TRANS,DWS,LCode,S),
	    (S == [] -> flora_head_setexp(R,DWS,RCode,Status); Status=S),
	    (Status == [] -> flmvdattspec_struct(LCode,F,RCode,Code); true)

	; is_sigattspecop(F) ->
	    (L=CANOTERM(M,1,FL_BRACE,[Constr],_If1,_Ip1)->
		flora_head_sigconstr(Constr,DWS,CCode,S_C),
		(S_C==[] ->
		    flora_head_pathexp(M,DISALLOW_TRANS,DWS,MCode,S1),
		    (S1==[] ->
			%% The right hand side
			(is_emptyterm(R) ->
			    get_index(R,Ind),
			    emptyterm_struct(Ind,RCode),
			    Status = []
			;  flora_head_pathexp(R,DISALLOW_TRANS,DWS,RCode,Status)
			)
		    ; Status = S1
		    )
		; Status = S_C
		),
		(Status == [] -> flsigattconspec_struct(MCode,CCode,F,RCode,Code); true)
	    ;
		flsigconstr_struct(FLNUMBER(0,NO_INDEX),FLATOM(FL_STAR,NO_INDEX),CCode),
		flora_head_pathexp(L,DISALLOW_TRANS,DWS,LCode,S1),
		( S1==[] ->
		    %% The right hand side 
		    (is_emptyterm(R) ->
		        get_index(R,Ind),
			emptyterm_struct(Ind,RCode),
			Status = []
		    ;  flora_head_pathexp(R,DISALLOW_TRANS,DWS,RCode,Status)
		    )
		 ; Status = S1
		 ),
		(Status == [] -> flsigattconspec_struct(LCode,CCode,F,RCode,Code); true)
	    )

	; (is_incattspecop(F); is_tolistattspecop(F)) ->
	    parsing_error(If,ERROR_HDLITERAL,Status)
        ;
	  F == FL_AT,
	  parsing_error(If,NO_WSINRULEHEAD,Status)
        ),
	!.

flora_head_attmethspec(CANOTERM(Funct,1,FL_PARENTHESIS,[A],_If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,F),
	( is_boolsigop(F) ; is_iboolsigop(F)),
	flora_head_pathexp(A,DISALLOW_TRANS,DWS,ACode,S1),
	(S1 == [] ->
	    ( is_boolsigop(F) -> flboolsig_struct(ACode,F,Code)
	    ; is_iboolsigop(F) -> fliboolsig_struct(ACode,F,Code)
	    ),
	    Status = []
	;
	    flora_head_attmethspec(A,DWS,ACode2,S2),
	    (S2 == [] ->
		(fltranspec_struct(ATemp,ACode2) -> 
		    ( is_boolsigop(F) -> fltransig_struct(ATemp,F,Code)
		    ; is_iboolsigop(F) -> flitransig_struct(ATemp,F,Code)
		    ),
		    Status = []
		;
		    parsing_error(A,ERROR_BOOLSIG,Status)
		)
	    ;
		parsing_error(A,ERROR_BOOLSIG,Status)
	    )
	),
	!.

flora_head_attmethspec(CANOTERM(Funct,1,FL_PARENTHESIS,[A],_If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,F),
	( is_transigop(F) ; is_itransigop(F)),
	!,
	flora_head_pathexp(A,DISALLOW_TRANS,DWS,ACode,Status),
	( is_transigop(F) -> fltransig_struct(ACode,F,Code)
	; is_itransigop(F) -> flitransig_struct(ACode,F,Code)
	).

flora_head_attmethspec(CANOTERM(Funct,1,FL_PARENTHESIS,[A],_If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,FL_INMETH),
	!,
	flora_head_pathexp(A,DISALLOW_TRANS,DWS,C,Status),
	(Status == [] -> flimethspec_struct(C,Code);true).

flora_head_attmethspec(CanoniTerm,_DWS,Code,[]) :-
        fltransactionalobject_struct(CanoniTerm,C),
        !,
        fltranspec_struct(C,Code).
        
flora_head_attmethspec(CanoniTerm,DWS,Code,Status) :-
	flora_head_pathexp(CanoniTerm,ALLOW_TRANS,DWS,C,Status),
	(Status == [] -> 
            (is_fltransactionalterm_struct(C) ->
                fltranspec_struct(C,Code)
            ;
                flmethspec_struct(C,Code)
            )
        ;
            true
        ).

flora_head_setexp(CANOBRACE(L,_N,_I),DWS,CodeList,Status) :-
	!,
	flora_head_pathexplist(L,DWS,CodeList,Status).

flora_head_setexp(CanoniTerm,DWS,[Code],Status) :-
	flora_head_pathexp(CanoniTerm,DISALLOW_TRANS,DWS,Code,Status).


flora_head_sigconstr(CANOTERM(Funct,2,FL_PARENTHESIS,[Lower,Upper],_If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,FL_CONSTR),
	!,
	flora_head_pathexplist([Lower,Upper],DWS,[LowerCode,UpperCode],S),
	( S == [] ->
	    ( not(valid_lower_sigconstr(LowerCode)) ->
		Lower = OBJECT(_,If),
		parsing_error(If,ERROR_SIGCONSTR_LOW,Status)
	    ;
		( not(valid_upper_sigconstr(UpperCode)) ->
		        Upper = OBJECT(_,If),
		        parsing_error(If,ERROR_SIGCONSTR_HIGH,Status)
		;
		    Status = []
		)
	    )
	;
	    Status = S
	),
	flsigconstr_struct(LowerCode,UpperCode,Code). 

flora_head_sigconstr(CANOTERM(_Funct,_N,_,_Args,If,_Ip),_DWS,_Code,Status) :-
	parsing_error(If,ERROR_SIGCONSTR,Status).
	

/****************************************************************************
  flora_tablerefresh(+ArgsList,+DWS,-Code,-Status)
****************************************************************************/

flora_tablerefresh(Args,DWS,Code,Status) :-
	flora_dbliteral_list(FLREF,Args,DWS,CodeList,Status),
	(Status == []
	-> flrefresh_struct(CodeList,Code)
	; true
	).


/****************************************************************************
  flora_dbinsert(+OpCode,+N,+ArgsList,+DWS,-Code,-Status)
****************************************************************************/
flora_dbinsert(OpCode,1,[CANOTERM(Bar,2,FL_PARENTHESIS,[L,R],_If,_Ip)],DWS,Code,Status) :-
	get_atom(Bar,FL_BAR),
	!,
	flora_comma_separated_list(L,LList),
	flora_dbliteral_list(FLINS,LList,DWS,LCodeList,S),
	( S == [] ->
	    flora_body(R,DWS,DWS,RCode,Status),
	    (Status == []
	    -> flinsert_struct(OpCode,LCodeList,RCode,Code)
	    ; true
	    )
	;
	  Status=S
        ).

flora_dbinsert(OpCode,_N,Args,DWS,Code,Status) :-
	flora_dbliteral_list(FLINS,Args,DWS,CodeList,Status),
	(Status == []
	-> flinsert_struct(OpCode,CodeList,Code)
	; true
	).


/****************************************************************************
  flora_dbdelete(+OpCode,+N,+Args,+DWS,-Code,-Status)
****************************************************************************/
flora_dbdelete(OpCode,1,[CANOTERM(Bar,2,FL_PARENTHESIS,[L,R],_If,_Ip)],DWS,Code,Status) :-
	get_atom(Bar,FL_BAR),
	!,
	flora_comma_separated_list(L,LList),
	flora_dbliteral_list(FLDEL,LList,DWS,LCodeList,S),
	( S == [] ->
	    flora_body(R,DWS,DWS,RCode,Status),
	    (Status == []
	    ->
		fldelete_struct(OpCode,LCodeList,RCode,Code)
	    ;
		true
	    )
	;
	  Status=S
        ).

flora_dbdelete(OpCode,_N,Args,DWS,Code,Status) :-
	flora_dbliteral_list(FLDEL,Args,DWS,CodeList,Status),
	(Status == []
	->
	    fldelete_struct(OpCode,CodeList,Code)
	; true
	).

/****************************************************************************
  flora_dbliteral_list(+Mode,+ArgsList,+DWS,-CodeList,-Status)

  flora_dbliteral_list/4 is for both insert and delete literals. The
  value of Mode can be either FLINS (insert) or FLDEL (delete). The
  difference between insert and delete literals is that insert literals
  cannot contain multivalued reference whereas delete literals can.
****************************************************************************/
flora_dbliteral_list(_Mode,[],_DWS,[],[]) :- !.

flora_dbliteral_list(Mode,[H|T],DWS,CodeList,Status) :-
	!,
	flora_dbliteral(Mode,H,DWS,HCL,S),
	( S == [] ->
	    flora_dbliteral_list(Mode,T,DWS,TCL,Status),
	    (Status == [] -> append(HCL,TCL,CodeList); true)
	;
	  Status=S
        ).


/****************************************************************************
  flora_dbliteral(+Mode,+CanoniTerm,+DWS,-CodeList,-Status)

  Note: Module names are allowed in insert/delete literals.
****************************************************************************/
flora_dbliteral(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),_DWS,CodeList,Status) :-
	get_atom(Funct,FL_AT),
	!,
        ( flora_workspace(R,RCode,[]),
	    (get_module_from_spec(RCode,FLORAUSERMOD,_)
	    ; get_module_from_spec(RCode,FLORASYSMOD,_)
	    )
	->
	    flora_comma_separated_list(L,LList),
	    flora_dbliteral_list(Mode,LList,RCode,CodeList,Status)
	; % illegal module name
	  parsing_error(R,ERROR_WSNAME,Status)
	).

flora_dbliteral(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),DWS,CodeList,Status) :-
	get_atom(Funct,FL_COMMA),
	!,
	flora_dbliteral(Mode,L,DWS,LCode,S),
	(S==[] ->
	    flora_dbliteral(Mode,R,DWS,RCode,Status),
	    append(LCode,RCode,CodeList)
	; S == Status
	).

flora_dbliteral(Mode,CANOTERM(Funct,1,FL_PARENTHESIS,[Arg],If,_Ip),DWS,[Code],Status) :-
	get_atom(Funct,F),
	is_negop(F),
	flora_dbliteral(Mode,Arg,DWS,[ArgCode],Status),
	!,
	(Status == []
	-> flneg_struct(ArgCode,If,Code)
	;
	    true
	).

flora_dbliteral(_Mode,CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,Ip),_DWS,_Code,Status) :-
	get_atom(Funct,F),
	is_negop(F),
	!,
	parsing_error(CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,Ip),NEG_NEGATE_DB,Status).
	

flora_dbliteral(Mode,CanoniTerm,DWS,[Code],Status) :-
	%% now the literal is stripped of commas and workspaces - do
	%% the main processing of db literal
	flora_dblit(Mode,CanoniTerm,DWS,TCode,Status),
        (DWS == NULL ->
            Code=TCode
        ; 
            get_module_from_spec(DWS,ModuleType,Module),
            flmodule_struct(TCode,Module,ModuleType,Code)
        ).


/****************************************************************************
        flora_reify(+Arg,+DWS,-Code,-Status)
	Handle reification, ${...}
****************************************************************************/
flora_reify(Arg,DWS,Code,Status) :-
        report_context(parsing_reify),
	protect_reification(flora_body(Arg,DWS,DWS,ArgCode,Status)),
        clear_context(parsing_reify),
	(Status == [] -> flreify_struct(ArgCode,Code); true).


/****************************************************************************
        flora_parse_catch(Goal,Error,Handler,DWS,Code,Status)
	Handle catch{Goal,Error,Handler}
****************************************************************************/
flora_parse_catch(Goal,Error,Handler,DWS,Code,Status) :-
	flora_body(Goal,DWS,DWS,GoalCode,GoalStatus),
	(GoalStatus == []
	-> flora_pure_term(Error,DWS,ErrorCode,ErrorStatus),
	    (ErrorStatus == []
	    -> flora_body(Handler,DWS,DWS,HandlerCode,Status),
		(Status == []
		-> flcatch_struct(GoalCode,ErrorCode,HandlerCode,Code)
		; true
		)
	    ; Status = ErrorStatus
	    )
	; Status = GoalStatus
	).

/****************************************************************************
        flora_parse_throw(Error,DWS,Code,Status)
	Handle throw{Error}
****************************************************************************/
flora_parse_throw(Error,DWS,Code,Status) :-
	flora_pure_term(Error,DWS,ErrCode,Status),
	(Status == []
	-> flthrow_struct(ErrCode,Code)
	; true
	).

/****************************************************************************
        flora_parse_p2h(Prolog,Hilog,DWS,Code,Status)
	Handle p2h{Prolog,Hilog}
****************************************************************************/
flora_parse_p2h(Prolog,Hilog,DWS,Code,Status) :-
	flora_pure_term(Prolog,DWS,PrlgCode,PrlgStatus),
	(PrlgStatus == []
	-> flora_pure_term(Hilog,DWS,HlgCode,Status),
	    (Status == []
	    -> flp2h_struct(PrlgCode,HlgCode,Code)
	    ; true
	    )
	; Status = PrlgStatus
	).


/****************************************************************************
   The following flora_check_update_* statements make sure that builtins
   and other inappropriate things don't occur in update statements.
****************************************************************************/

/****************************************************************************
  flora_check_update_builtin(+Mode,+CanoniTerm,-Status)
****************************************************************************/
flora_check_update_builtin(Mode,CANOTERM(Funct,N,FL_PARENTHESIS,_Args,If,_Ip),Status) :-
	get_atom(Funct,F),
	flora_nodefp(F,N),
	( Mode == FLINS ->
	    parsing_error(If,NO_INSERT,Status)
	; Mode == FLDEL ->
	    parsing_error(If,NO_DELETE,Status)
        ; 
          parsing_error(If,ERROR_BUILTIN,Status)
	).


/****************************************************************************
  flora_check_update_ifthenelse(+CanoniTerm,-Status)
****************************************************************************/
/*
flora_check_update_ifthenelse(CANOTERM(Funct,1,FL_PARENTHESIS,_Args,If,_Ip),Status) :-
        get_name(Funct,FL_IF),
        !,
        parsing_error(If,NO_UPDATEIF,Status).

flora_check_update_ifthenelse(CANOTERM(Funct,2,FL_PARENTHESIS,_Args,If,_Ip),Status) :-
        get_name(Funct,FL_THEN),
        !,
        parsing_error(If,NO_UPDATETHEN,Status).

flora_check_update_ifthenelse(CANOTERM(Funct,2,FL_PARENTHESIS,_Args,If,_Ip),Status) :-
        get_name(Funct,FL_ELSE),
        !,
        parsing_error(If,NO_UPDATEELSE,Status).
*/


/****************************************************************************
  flora_dblit(+Mode,+CanoniTerm,+DWS,-Code,-Status)

  This is called to process a single db literal after it was stripped from
  negation (NEG), commas, and workspaces.
****************************************************************************/
flora_dblit(Mode,CanoniTerm,_DWS,_Code,Status) :-
	flora_check_update_builtin(Mode,CanoniTerm,Status),
	!.

flora_dblit(Mode,CanoniTerm,DWS,Code,Status) :-
	CanoniTerm = CANOTERM(Funct,2,FL_PARENTHESIS,_Args,_If,_Ip),
	(get_atom(Funct,FL_IMPLYOP)
	; is_labeled_construct(CanoniTerm,_,_)
	),
	!,
	(Mode == FLINS ->
	    flatom_struct(FL_INSERTRULE_Z,If,OpCode)
	; Mode == FLDEL ->
	    flatom_struct(FL_DELETERULE,If,OpCode)
	; flora_error_line('[Parser] bug: Invalid update mode, ~w', [Mode]),
	    throw(FLORA_TOP_LEVEL)
	),
	flora_dynrule(CanoniTerm,DWS,CodeList,Status),
	(Status == [] -> flupdaterule_struct(OpCode,CodeList,Code); true).

flora_dblit(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,F),
	is_birelop(F),
	!,
	flora_db_pathexplist(Mode,Args,DWS,[LCode,RCode],Status),
	(Status == [] -> flbirelate_struct(LCode,F,RCode,Code); true).

flora_dblit(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,_Args,If,_Ip),_DWS,_Code,Status) :-
	get_atom(Funct,F),
	is_objrefop(F),
	!,
	( Mode == FLINS ->
	    parsing_error(If,ERROR_INSERT,Status)
	; Mode == FLDEL ->
	    parsing_error(If,ERROR_DELETE,Status)
        ; Mode == FLREF ->
	    parsing_error(If,ERROR_REFRESH,Status)
        ; Mode == FLCLS ->
	    parsing_error(If,ERROR_CLAUSELIT,Status)
	).

flora_dblit(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,FL_OBJEQL),
	!,
	flora_db_pathexplist(Mode,Args,DWS,[LCode,RCode],Status),
	(Status == [] ->
	    flobjeql_struct(LCode,RCode,Code)
	;
	    true
	).


flora_dblit(Mode,CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,_Ip),DWS,Code,Status) :-
	!,
	( get_atom(Funct,F), flora_prlgdef(F,N) ->
	    parsing_error(If,NO_PROLOG,Status)
	;
	  flora_db_term(Mode,Funct,N,Args,ALLOW_TRANS,DWS,Code,Status)
	).

flora_dblit(Mode,CANOTERM(Funct,N,FL_BRACKET,Args,_If,_Ip),DWS,Code,Status) :-
	!,
	flora_db_objspec(Mode,Funct,N,Args,DWS,Code,Status).

flora_dblit(Mode,CanoniTerm,_DWS,Code,Status) :-
	get_atom(CanoniTerm,A),
	!,
	( flora_nodefp(A,0) ->
	    ( Mode == FLINS ->
		parsing_error(CanoniTerm,NO_INSERT,Status)
	    ;
	      Mode == FLDEL,
	      parsing_error(CanoniTerm,NO_DELETE,Status)
            ;
              parsing_error(CanoniTerm,ERROR_BUILTIN,Status)
	    )

	; flora_prlgdef(A,0) ->
	    parsing_error(CanoniTerm,NO_PROLOG,Status)
	;
	  flobject_struct(CanoniTerm,Code),
	    Status = []
        ).

flora_dblit(_Mode,CanoniTerm,_DWS,Code,[]) :-
	get_transactionalatom(CanoniTerm,_A),
	!,
	fltransactionalobject_struct(CanoniTerm,Code).

%% Anonymous vars are not allowed in DB literals except in clause{...}
flora_dblit(Mode,CanoniTerm,_DWS,Code,[]) :-
	get_flvar_struct(CanoniTerm,Code),
	%% Allo anon vars for the clause statement
	(Mode == FLCLS, !
	; \+ is_anonymous_flvar_struct(Code)
	),
	!.

flora_dblit(Mode,CanoniTerm,DWS,Code,Status) :-
	get_fltransactionalvar_struct(CanoniTerm,Code1),
        (Mode == FLCLS, DWS == NULL
	-> Status =[],
	    %% If it is a clause{...} statement and we get a transactional var,
	    %% assume that it has a variable module
	    is_anonymous_flvar_struct(ModVar),
	    flmodule_struct(Code1,ModVar,FLORAUSERMOD,Code)
	; DWS == NULL ->
            parsing_error(CanoniTerm,ERROR_TRANSACTIONALVARLIT,Status)
        ;
            \+ is_anonymous_fltransactionalvar_struct(Code1),
	    Code = Code1,
            Status =[]
        ), 
        !.

flora_dblit(Mode,CanoniTerm,_DWS,_Code,Status) :-
	!,
	( Mode == FLINS ->
	    parsing_error(CanoniTerm,ERROR_INSERT,Status)
	; Mode == FLDEL ->
	    parsing_error(CanoniTerm,ERROR_DELETE,Status)
        ; Mode == FLREF ->
	    parsing_error(CanoniTerm,ERROR_REFRESH,Status)
        ; Mode == FLCLS ->
	    parsing_error(CanoniTerm,ERROR_CLAUSELIT,Status)
	).


/****************************************************************************
  flora_db_term(+Mode,+Funct,+Arity,+Args,+TransFlag,+DWS,-Code,-Status)
****************************************************************************/
flora_db_term(Mode,Funct,N,Args,HF,DWS,Code,Status) :-
        fltransactionalobject_struct(Funct,F),
        !,
        (HF == ALLOW_TRANS ->
            flora_db_pathexplist(Mode,Args,DWS,AList,Status),
	    (Status == [] -> fltransactionalterm_struct(F,N,AList,Code); true)
        ;
            parsing_error(Funct,ERROR_TRANSACTIONAL_SYMBOL,Status)
        ).

flora_db_term(Mode,Funct,N,Args,HF,DWS,Code,Status) :-
	flora_db_pathexp(Mode,Funct,HF,DWS,F,S),
	( S == [] ->
	    flora_db_pathexplist(Mode,Args,DWS,AList,Status),
	    (Status == [] -> 
                ( is_fltransactionalterm_struct(F) ->
                    fltransactionalterm_struct(F,N,AList,Code)
                ;
                    flterm_struct(F,N,AList,Code)
                )
            ;
                true
            )
	;
	  Status=S
        ).


/**********************************************.*****************************
  flora_db_list(+Mode,+ListPrefix,+ListTail,+Index,+DWS,-FLLIST,-Status)
****************************************************************************/
flora_db_list(_Mode,[],[],Index,_DWS,T,[]) :-
	!,
	fllist_struct([],[],Index,T).

flora_db_list(Mode,L,T,Index,DWS,Code,Status) :-
	flora_db_pathexplist(Mode,L,DWS,LCode,S),
	( S == [] ->
	    ( T == [] ->
		TCode=[],
		Status=[]
	    ;
	      flora_db_pathexp(Mode,T,DISALLOW_TRANS,DWS,TCode,Status)
	    ),
	    (Status == [] -> fllist_struct(LCode,TCode,Index,Code); true)
	;
	  Status=S
        ).


/****************************************************************************
  flora_db_pathexplist(+Mode,+ListOfCanoniTerms,+DWS,-ListOfPathExpressions,-Status)
****************************************************************************/
flora_db_pathexplist(_Mode,[],_DWS,[],[]) :- !.

flora_db_pathexplist(Mode,[T|L],DWS,[TCode|LCode],Status) :-
	flora_db_pathexp(Mode,T,DISALLOW_TRANS,DWS,TCode,S),
	( S == [] ->
	    flora_db_pathexplist(Mode,L,DWS,LCode,Status)
	;
	  Status=S
        ).


/****************************************************************************
  flora_db_pathexp(+Mode,+CanoniTerm,+TransFlag,+DWS,-InsertPathExpression,-Status)
****************************************************************************/
flora_db_pathexp(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),_HF,DWS,Code,Status) :-
	get_atom(Funct,F),
	is_birelop(F),
	!,
	flora_db_pathexplist(Mode,Args,DWS,[LCode,RCode],Status),
	(Status == [] -> flbirelate_struct(LCode,F,RCode,Code); true).

flora_db_pathexp(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),_HF,DWS,Code,Status) :- 	 
         get_atom(Funct,F), 	 
         is_mvdobjrefop(F), 	 
         !, 	 
         flora_db_pathexplist(Mode,Args,DWS,[LCode,RCode],Status), 	 
         (Status == [] -> flobjref_struct(LCode,F,RCode,Code); true).

%% To handle URI SQname structure like prefix#suffix
flora_db_pathexp(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,Args,_If,_Ip),_HF,DWS,Code,Status) :-
	get_atom(Funct,F),
	is_urisqop(F),
	!,
	Args=[Prefix,Localname],
	( is_obj_identifier_struct(Prefix)
	-> %% prefix (the part before '#') should be an identifier
	    ( (is_obj_ascii_string_struct(Localname)
	       ; is_obj_identifier_struct(Localname)
	       ; is_obj_quoted_atom_struct(Localname)
	      )
	    ->
		%% localname (the part following '#') should be a string
		%% or a quoted atom or an identifier
		flora_db_pathexplist(Mode,Args,DWS,ArgsCode,Status),
		ArgsCode=[PrefixCode,LocalnameCode],
	        flurisq_struct(PrefixCode,LocalnameCode,Code)

	    ; get_index(Localname,Index_Localname),
	      parsing_error(Index_Localname,ERROR_SQNAME_LOCAL,Status)
	    )

	; get_index(Prefix,Index_Prefix),
	  parsing_error(Index_Prefix,ERROR_SQNAME_PREFIX,Status)
	).

flora_db_pathexp(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],If,_Ip),HF,_DWS,Code,Status) :-
	get_atom(Funct,FL_AT),
	!,
	( (flora_name_or_var(R,RCode) ; thismodule_token(R,RCode))
	->
	    flora_db_pathexp(Mode,L,HF,RCode,LCode,S),
	    ( S == [] ->
		( is_flworkspace_struct(LCode) ->
		    parsing_error(If,NO_WSNESTING,Status)

		; nowspathexp(LCode) ->
		  Code=LCode,Status=[]
		;
		  flmodule_struct(LCode,RCode,FLORAUSERMOD,Code),
		  Status=[]
	        )
	    ;
	      Status=S
	    )
	;
	  parsing_error(R,ERROR_WSNAME,Status)
        ).

flora_db_pathexp(_Mode,CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],If,_Ip),_HF,DWS,Code,Status) :-
	get_atom(Funct,F),
	is_datatypeop(F),
	!,
	flora_parse_datatype([L,R],If,DWS,Code,Status).


flora_db_pathexp(Mode,CANOTERM(Funct,N,FL_PARENTHESIS,Args,_If,_Ip),HF,DWS,Code,Status) :-
	!,
	flora_db_term(Mode,Funct,N,Args,HF,DWS,Code,Status).

flora_db_pathexp(Mode,CANOTERM(Funct,N,FL_BRACKET,Args,_If,_Ip),_HF,DWS,Code,Status) :-
	!,
	flora_db_objspec(Mode,Funct,N,Args,DWS,Code,Status).

%% Reification in insert/delete seems to be blocked elsewhere.
%% This clause is here in case we decide to unblock later.
flora_db_pathexp(_Mode,CANOTERM(Funct,N,FL_BRACE,Args,If,Ip),_HF,DWS,Code,Status) :-
	get_atom(Funct,Atom),
	is_reifyop(Atom),
	!,
	(N > 1
	-> flora_list_to_conjunct(Args,Conjunct,If,Ip),
	    flora_reify(Conjunct,DWS,Code,Status)
	;
	    Args = [Arg],
	    flora_reify(Arg,DWS,Code,Status)
	).

flora_db_pathexp(Mode,CANOLIST(L,T,_N,I,_Ib),_HF,DWS,Code,Status) :-
	!,
	flora_db_list(Mode,L,T,I,DWS,Code,Status).


%% Anonymous oid IS allowed in insert/delete
flora_db_pathexp(_Mode,ObjectTerm,_HF,_DWS,Code,[]) :-
	flobject_struct(ObjectTerm,Code),
	!.

flora_db_pathexp(Mode,CanoniTerm,_HF,_DWS,_Code,Status) :-
	( Mode == FLINS ->
	    parsing_error(CanoniTerm,ERROR_EXPINSERT,Status)
	; Mode == FLDEL ->
	    parsing_error(CanoniTerm,ERROR_EXPDELETE,Status)
	; Mode == FLREF ->
	    parsing_error(CanoniTerm,ERROR_EXPREFRESH,Status)
	; Mode == FLCLS ->
	    parsing_error(CanoniTerm,ERROR_EXPCLAUSE,Status)
	).


/****************************************************************************
  flora_db_objspec(+Mode,+Obj,+Arity,+Args,+DWS,-Code,-Status)
  flora_db_objspec(+Mode,+CanoniTerm,+DWS,-Code,-Status)
****************************************************************************/
flora_db_objspec(Mode,Obj,N,Args,DWS,Code,Status) :-
	flora_db_pathexp(Mode,Obj,DISALLOW_TRANS,DWS,O,S),
	( S == [] ->
	    ( N == 0 ->
		Spec=[],
		Status=[]
	    ;
	      Args=[Body],
	      flora_db_objspec(Mode,Body,DWS,Spec,Status)
	    ),
	    (Status == [] -> flobjspec_struct(O,Spec,Code); true)
	;
	  Status=S
        ).


flora_db_objspec(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,F),
	( F == FL_COMMA ->
	    flora_db_objspec(Mode,L,DWS,LCode,S),
	    ( S == [] ->
		flora_db_objspec(Mode,R,DWS,RCode,Status),
		(Status == [] -> flconjunct_struct(LCode,RCode,Code); true)
	    ;
	      Status=S
	    )
	;
	  F == FL_SEMICOLON,
	  ( Mode == FLINS ->
	      parsing_error(If,NO_INSERTDISJUN,Status)
	  ;
	    Mode == FLDEL,
	    parsing_error(If,NO_DELETEDISJUN,Status)
          ; parsing_error(If,NO_DISJUNCTION,Status)
	  )
	).


%% something like a[neg p->q] or a[ neg p] in a db update
flora_db_objspec(Mode,CANOTERM(Funct,1,FL_PARENTHESIS,[G],If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,F),
	is_negop(F),
	!,
	flora_db_objspec(Mode,G,DWS,GCode,Status),
	( Status == [] ->
	    flneg_struct(GCode,If,Code)
	;
	    true
	).



flora_db_objspec(Mode,CANOTERM(Funct,1,FL_PARENTHESIS,[_G],If,_Ip),_DWS,_Code,Status) :-
	get_atom(Funct,F),
	(is_nafop(F); is_notop(F)),
	!,
	( Mode == FLINS ->
	    parsing_error(If,NO_INSERTNEG,Status)
	; Mode == FLDEL ->
	    parsing_error(If,NO_DELETENEG,Status)
	; Mode == FLREF ->
	    parsing_error(If,ERROR_REFRESH,Status)
	; Mode == FLCLS ->
	    parsing_error(If,ERROR_CLAUSELIT,Status)
	).

flora_db_objspec(Mode,CanoniTerm,DWS,Code,Status) :-
	flora_db_attmethspec(Mode,CanoniTerm,DWS,Code,Status).


/****************************************************************************
  flora_db_attmethspec(+Mode,+CanoniTerm,+DWS,-Goal,-Status)
  flora_db_setexp(+Mode,+CanoniTerm,+DWS,-CodeList,-Status)
****************************************************************************/
flora_db_attmethspec(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,F),
	( is_mvdattspecop(F) ->
	    flora_db_pathexp(Mode,L,DISALLOW_TRANS,DWS,LCode,S),
	    (S == [] -> flora_db_setexp(Mode,R,DWS,RCode,Status); Status=S),
	    (Status == [] -> flmvdattspec_struct(LCode,F,RCode,Code); true)

	; is_sigattspecop(F) ->
	    (L=CANOTERM(M,1,FL_BRACE,[Constr],_If1,_Ip1)->
	       flora_db_sigconstr(Mode,Constr,DWS,CCode,S_C), 
		(S_C==[] ->
		    flora_db_pathexp(Mode,M,DISALLOW_TRANS,DWS,MCode,S1),
		    (S1==[] ->
			%% The right hand side
			(is_emptyterm(R) ->
			    %% This is SIGDEF: occurs when we have a[b=> ()]
			    get_index(R,Ind),
			    emptyterm_struct(Ind,RCode),
			    Status = []
			;  flora_db_pathexp(Mode,R,DISALLOW_TRANS,DWS,RCode,Status)
			)
		    ; Status = S1
		    )
		; Status = S_C
		),
		(Status == [] -> flsigattconspec_struct(MCode,CCode,F,RCode,Code); true)
	    ;
		flora_db_pathexp(Mode,L,DISALLOW_TRANS,DWS,LCode,S1),
		(S1==[]
		%% The right hand side 
		-> (is_emptyterm(R)
		   %% This is SIGDEF: occurs when we have a[b=> ()]
		   -> get_index(R,Ind),
		       emptyterm_struct(Ind,RCode),
		       Status = []
		   ;  flora_db_pathexp(Mode,R,DISALLOW_TRANS,DWS,RCode,Status)
		   )
		; Status = S1
		),
		(Status == [] -> flsigattspec_struct(LCode,F,RCode,Code); true)
	    )

	; (is_incattspecop(F); is_tolistattspecop(F)) ->
	    ( Mode == FLINS ->
		parsing_error(If,ERROR_INSERT,Status)
	    ; Mode == FLDEL ->
	      parsing_error(If,ERROR_DELETE,Status)
	    ; Mode == FLREF ->
	      parsing_error(If,ERROR_REFRESH,Status)
	    ; Mode == FLCLS ->
	      parsing_error(If,ERROR_CLAUSELIT,Status)
	    )
        ;
	  F == FL_AT,
	  parsing_error(If,NO_WORKSPACE,Status)
        ),
	!.

flora_db_attmethspec(Mode,CANOTERM(Funct,1,FL_PARENTHESIS,[A],_If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,F),
	( is_boolsigop(F) ; is_iboolsigop(F)),
	flora_db_pathexp(Mode,A,DISALLOW_TRANS,DWS,ACode,S1),
	(S1 == [] ->
	    ( is_boolsigop(F) -> flboolsig_struct(ACode,F,Code)
	    ; is_iboolsigop(F) -> fliboolsig_struct(ACode,F,Code)
	    ),
	    Status = []
	;
	    flora_db_attmethspec(Mode,A,DWS,ACode2,S2),
	    (S2 == [] ->
		(fltranspec_struct(ATemp,ACode2) -> 
		    ( is_boolsigop(F) -> fltransig_struct(ATemp,F,Code)
		    ; is_iboolsigop(F) -> flitransig_struct(ATemp,F,Code)
		    ),
		    Status = []
		;
		    parsing_error(A,ERROR_BOOLSIG,Status)
		)
	    ;
		parsing_error(A,ERROR_BOOLSIG,Status)
	    )
	),
	!.

flora_db_attmethspec(Mode,CANOTERM(Funct,1,FL_PARENTHESIS,[A],_If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,F),
	( is_transigop(F) ; is_itransigop(F)),
	!,
	flora_db_pathexp(Mode,A,DISALLOW_TRANS,DWS,ACode,Status),
	( is_transigop(F) -> fltransig_struct(ACode,F,Code)
	; is_itransigop(F) -> flitransig_struct(ACode,F,Code)
	).

flora_db_attmethspec(Mode,CANOTERM(Funct,1,FL_PARENTHESIS,[A],_If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,FL_INMETH),
	!,
	flora_db_pathexp(Mode,A,DISALLOW_TRANS,DWS,C,Status),
        (Status == [] -> flimethspec_struct(C,Code);true).

flora_db_attmethspec(_Mode,CanoniTerm,_DWS,Code,[]) :-
        fltransactionalobject_struct(CanoniTerm,C),
        !,
        fltranspec_struct(C,Code).

flora_db_attmethspec(Mode,CanoniTerm,DWS,Code,Status) :-
	flora_db_pathexp(Mode,CanoniTerm,ALLOW_TRANS,DWS,C,Status),
	(Status == [] -> 
            (is_fltransactionalterm_struct(C) ->
                fltranspec_struct(C,Code)
            ;
                flmethspec_struct(C,Code)
            )
        ;
            true
        ).

flora_db_setexp(Mode,CANOBRACE(L,_N,_I),DWS,CodeList,Status) :-
	!,
	flora_db_pathexplist(Mode,L,DWS,CodeList,Status).

flora_db_setexp(Mode,CanoniTerm,DWS,[Code],Status) :-
	flora_db_pathexp(Mode,CanoniTerm,DISALLOW_TRANS,DWS,Code,Status).

flora_db_sigconstr(Mode,CANOTERM(Funct,2,FL_PARENTHESIS,[Lower,Upper],_If,_Ip),DWS,Code,Status) :-
	get_atom(Funct,FL_CONSTR),
	!,
	flora_db_pathexplist(Mode,[Lower,Upper],DWS,[LowerCode,UpperCode],S),
	( S == [] ->
	    ( not(valid_lower_sigconstr(LowerCode)) ->
		Lower = OBJECT(_,If),
		parsing_error(If,ERROR_SIGCONSTR_LOW,Status)
	    ;
		( not(valid_upper_sigconstr(UpperCode)) ->
		        Upper = OBJECT(_,If),
		        parsing_error(If,ERROR_SIGCONSTR_HIGH,Status)
		;
		    Status = []
		)
	    )
	;
	    Status = S
	),
	flsigconstr_struct(LowerCode,UpperCode,Code). 

flora_db_sigconstr(_Mode,CANOTERM(_Funct,_N,_,_Args,If,_Ip),_DWS,_Code,Status) :-
	parsing_error(If,ERROR_SIGCONSTR,Status).


/****************************************************************************
  flora_ruleupdate(+OpCode,+N,+ArgsList,+DWS,-Code,-Status)
****************************************************************************/
flora_ruleupdate(OpCode,_N,Args,DWS,Code,Status) :-
	flora_dynrule_list(Args,DWS,CodeList,Status),
	(Status == [] -> flupdaterule_struct(OpCode,CodeList,Code); true).

/****************************************************************************
  flora_dynrule_list(+RuleList,+DWS,-CodeList,-Status)
****************************************************************************/
flora_dynrule_list([],_DWS,[],[]) :- !.
flora_dynrule_list([H|T],DWS,CodeList,Status) :-
	!,
	flora_dynrule(H,DWS,HCL,S),
	( S == [] ->
	    flora_dynrule_list(T,DWS,TCL,Status),
	    (Status == [] -> append(HCL,TCL,CodeList); true)
	;
	    Status=S
	).

/****************************************************************************
  flora_dynrule(+CanoniTerm,+DWS,-CodeList,-Status)
****************************************************************************/
flora_dynrule(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],_If,_Ip),_DWS,CodeList,Status) :-
	%% insertion of ((rule), ..., (rule))@module
	get_atom(Funct,FL_AT),
	!,
        ( flora_workspace(R,RCode,[]),
	    (get_module_from_spec(RCode,FLORAUSERMOD,_)
	    ; get_module_from_spec(RCode,FLORASYSMOD,_)
	    )
	->
	    flora_comma_separated_list(L,LList),
	    flora_dynrule_list(LList,RCode,CodeList,Status)
	; % illegal module name
	  parsing_error(R,ERROR_WSNAME,Status)
	).

flora_dynrule(CanoniTerm,DWS,[Code],Status) :-
	%% insertion of a rule without workspace, NULL is nitial label code
	flora_dynrule_no_module(CanoniTerm,DWS,NULL,Code,Status).


/****************************************************************************
  flora_dynrule_no_module(+CanoniTerm,+DWS,+Label,-Code,-Status)
****************************************************************************/
flora_dynrule_no_module(CanoniTerm,DWS,Label,Code,Status) :-
        ( is_rule(CanoniTerm,Head,Body) ->
	    flora_dynhead(Head,DWS,HCL,S),
	    ( S == [] ->
		flora_body(Body,DWS,DWS,BodyCode,Status),
		fldynrule_struct(HCL,BodyCode,Label,RuleCode),
		%% add default workspace, if any
                (get_module_from_spec(DWS,_ModuleType,Module) ->
                    flmodule_struct(RuleCode,Module,FLORARULEWORKSPACE,Code)
                ;
                    Code=RuleCode
                )
	    ;
		Status=S
            )

	; is_rule_or_fact(CanoniTerm), Label \== NULL ->
	    %% means: it is a labeled fact, since the preious cond failed
	    flora_dynhead(CanoniTerm,DWS,HCL,Status),
	    ( Status == [] ->
		%% convert labeled fact to rule by adding ":- true"
		flatom_struct(FL_TRUE,NO_INDEX,BodyCode),
		fldynrule_struct(HCL,BodyCode,Label,RuleCode),
		%% add default workspace, if any
                (get_module_from_spec(DWS,_ModuleType,Module) ->
                    flmodule_struct(RuleCode,Module,FLORARULEWORKSPACE,Code)
                ;
                    Code=RuleCode
                )
	    ;
		true
            )

	; is_labeled_construct(CanoniTerm,NewLabel,Construct) ->
	    flora_parse_label(NewLabel,fail,NewLabCode,S),
	    (S == [] ->
		flora_dynrule_no_module(Construct,DWS,NewLabCode,Code,Status)
	    ;
		Status = S
	    )
	; is_reification(CanoniTerm,_,_,_) ->
	    parsing_error(CanoniTerm, NO_REIFICATION, Status) 
	;
	    get_flvar_struct(CanoniTerm,Code) -> Status = []
        ;
            parsing_error(CanoniTerm, EXP_RULES, Status) 
        ).


/****************************************************************************
  flora_dynhead(+CanoniTerm,+DWS,-CodeList,-Status)

  Similar to flora_head, but each element of the conjuction may be a
  normal variable or flora_head_literal
****************************************************************************/
flora_dynhead(CANOTERM(Funct,2,FL_PARENTHESIS,[L,R],If,_Ip),DWS,CodeList,Status) :-
	get_atom(Funct,F),
	( F == FL_COMMA ->
	    flora_dynhead(L,DWS,LCodeList,S),
	    ( S == [] ->
		flora_dynhead(R,DWS,RCodeList,Status),
		( Status == [] ->
		    append(LCodeList,RCodeList,CodeList)
		;
		  true
		)
	    ;
	      Status=S
	    )

	; F == FL_SEMICOLON ->	% Disjunction is prohibited.
	    parsing_error(If,NO_DISJUNCTION,Status)

	; % Module name in rule head is prohibited.
	  F == FL_AT,
	  parsing_error(If,NO_WSINRULEHEAD,Status)
	),
	!.

flora_dynhead(CANOTERM(Funct,1,FL_PARENTHESIS,[_G],If,_Ip),_DWS,_CodeList,Status) :-
	get_atom(Funct,F),
	(is_nafop(F); is_notop(F)),
	!,
	parsing_error(If,NO_NEGATION,Status).

flora_dynhead(CANOTERM(Funct,1,FL_PARENTHESIS,[Arg],If,_Ip),DWS,[Code],Status) :-
	get_atom(Funct,F),
	is_negop(F),
	!,
	flora_dynhead(Arg,DWS,[ArgCode],Status),
	(Status == []
	-> flneg_struct(ArgCode,If,Code)
	;
	    true
	).

flora_dynhead(CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,Ip),_DWS,_Code,Status) :-
	get_atom(Funct,F),
	is_negop(F),
	!,
	parsing_error(CANOTERM(Funct,N,FL_PARENTHESIS,Args,If,Ip),NEG_NEGATE_DB,Status).
	


flora_dynhead(CanoniTerm,DWS,[Code],Status) :-
        ( get_flvar_struct(CanoniTerm, C) ->
            ( is_anonymous_flvar_struct(C) ->
                parsing_error(I,ERROR_HDLITERAL,Status)
            ;
                Status=[],
                ( get_module_from_spec(DWS,ModuleType,Module)
		->
                    flmodule_struct(C,Module,ModuleType,Code)
                ;
                    C=Code
                )
            )
        ; get_fltransactionalvar_struct(CanoniTerm,Code)
	->
            ( is_anonymous_fltransactionalvar_struct(Code)
	    ->
                parsing_error(I,ERROR_HDLITERAL,Status)
            ;
                (DWS == NULL
		->
                    parsing_error(CanoniTerm,ERROR_TRANSACTIONALVARLIT,Status)
                ;
                    get_module_from_spec(DWS,ModuleType,Module),
                    flmodule_struct(C,Module,ModuleType,Code),
                    Status=[]
                )
            )
        ;
	    flora_head_literal(CanoniTerm,DWS,Code,Status)
        ).

%%% semantics directive
parse_semantics_directive_args(_,[],[],[]).

parse_semantics_directive_args(AllowVariables,[CANOTERM(F,1,FL_PARENTHESIS,[Arg],If,_Ip)|Rest],[HCode|RestCode],Status) :-
	get_atom(F,FAtom),
	flobject_struct(Arg,ArgStruct),
	is_valid_semantics_direct_option(AllowVariables,FAtom,ArgStruct),
	!,
	( flora_prlgterm(CANOTERM(F,1,FL_PARENTHESIS,[Arg],If,_Ip),
			 NULL,CodeHilog,S1),
	    %% Check if S1 can be a var. Otherwise, can substitute [] for S1
	    S1 == [],
	    flplib_struct(CodeHilog,HCode)
	-> 
	    parse_semantics_directive_args(AllowVariables,Rest,RestCode,Status)
	;
	    get_index(Arg,Ind),
	    (AllowVariables == ALLOW_VARIABLES
	    ->
		parsing_error(Ind,ERROR_SEMOPT,Status)
	    ;
		parsing_error(Ind,ERROR_SETSEMOPT,Status)
	    )
	).

parse_semantics_directive_args(AllowVariables, [Arg|_], _, Status) :-
	get_index(Arg,Ind),
	!,
	(AllowVariables == ALLOW_VARIABLES
	->
	    parsing_error(Ind,ERROR_SEMOPT,Status)
	;
	    parsing_error(Ind,ERROR_SETSEMOPT,Status)
	).


is_valid_semantics_direct_option(ALLOW_VARIABLES,Opt,Val) :-
	!,
	valid_semantics_direct_opt_name(Opt),
	( is_flvar_struct(Val), !
	; is_flatom_struct(Val,Atom),
	    valid_semantics_direct_option(Opt,Atom)
	).
is_valid_semantics_direct_option(DISALLOW_VARIABLES,Opt,Val) :-
	!,
	is_flatom_struct(Val,Atom),
	valid_semantics_direct_option(Opt,Atom).

valid_semantics_direct_opt_name(FL_EQUALITY).
valid_semantics_direct_opt_name(FL_INHERITANCE).
valid_semantics_direct_opt_name(FL_CUSTOM).
valid_semantics_direct_opt_name(FL_TABLING).
valid_semantics_direct_option(FL_EQUALITY,NONE).
valid_semantics_direct_option(FL_EQUALITY,BASIC).
%%valid_semantics_direct_option(FL_EQUALITY,FLOGIC).
valid_semantics_direct_option(FL_INHERITANCE,NONE).
valid_semantics_direct_option(FL_INHERITANCE,FLOGIC).
valid_semantics_direct_option(FL_TABLING,FL_SUBSUMPTIVE).
valid_semantics_direct_option(FL_TABLING,FL_VARIANT).
valid_semantics_direct_option(FL_TABLING,FL_INCREMENTAL).
valid_semantics_direct_option(FL_CUSTOM,NONE).
valid_semantics_direct_option(FL_CUSTOM,X) :- atom(X).


%%% Misc
protect_reification(Call) :-
	assert(FLORA_SYMBOL('parser_flag')(reifying)),
	call(Call),
	(retract(FLORA_SYMBOL('parser_flag')(reifying))
	; true).

if_reifying :-
	FLORA_SYMBOL('parser_flag')(reifying).
if_not_reifying :-
	\+ FLORA_SYMBOL('parser_flag')(reifying).


%% Used for reading FLORA terms (incl. reified formulas) from within
%% FLORA-2 programs
flora_parse_term_external(ComposerTerm,ParsedTerm,Status) :-
	canonical_form(ComposerTerm,CanoniTerm),
	flora_pathexp(CanoniTerm,ALLOW_TRANS,NULL,ParsedTerm,Status),
	!.


%% Parse the annotation construct
flora_parse_label(CANOTERM(_Funct,_N,FL_BRACE,Args,If,_Ip),VarsOK,Code,Status) :-
	report_context(parsing_label),
	( Args = [First|Rest],
	    ((is_obj_identifier_struct(First) ; get_spectoken(First,FL_NEWOID))
	    %% First element in list is Id const
	    ->
		flobject_struct(First,IdCode),
		IdStat = []
	    ;  %% or a term
		is_term_struct(First,IdFunc,IdArity,IdArgs)
	    ->
		flora_term(IdFunc,IdArity,IdArgs,DISALLOW_TRANS,NULL,
			   IdCode,IdStat)
	    ;   %% VarsOK is set if we have a variable in Id position
		%% in clause{@{?Var,...} ...}
		VarsOK, get_flvar_struct(First,IdCode)
	    ->
		IdStat = []
	    ;   %% just a variable in the Id position in meta (and not
		%% in clause{...}) means it is a placeholder that skips the Id
		get_flvar_struct(First,_),
		IdCode = FL_SKIP_LABEL,
		IdStat = []
	    )
	;
	    %% only metapart or nothing
	    IdCode = NULL,
	    Rest = Args,
	    IdStat = []
	),
	(Rest == []
	-> Status1 = [], MetaCode = NULL
	;
	    (VarsOK,
		flora_dbliteral_list(FLCLS,Rest,NULL,MetaCode,Status1),
		!
	    ; flora_head_literal_list(Rest,NULL,MetaCode,Status1)
	    )
	),
	(IdStat == [], Status1 == []
	-> 
	    annotation_struct(IdCode,MetaCode,If,Code),
	    Status = []
	;
	    parsing_error(If,INVALID_META_IN_LABEL,Status)
	),
	clear_context(parsing_label).


flora_parse_datatype(Args,If,DWS,Code,Status) :-
	flora_pathexplist(Args,DWS,ArgsCode,Status1),
	(Status1==[]
	->
	    ArgsCode=[LiteralCode,SortCode],
	    (is_flstring_struct(LiteralCode,Literal,Idx)
	    ->  fldatatype_struct(SortCode,Literal,Idx,Code),
		Status = []
	    ; is_flvar_struct(LiteralCode,_,Idx)
	    ->  fldatatype_struct(SortCode,LiteralCode,Idx,Code),
		Status = []
	    %% In datatype lists allow only explicit enumerations, no [...|...]
	    ; is_fllist_struct(LiteralCode, FrontCode, [], Idx)
	    ->
		fldatatype_listvalue_struct(FrontCode,FrontCodeListval),
		fldatatype_struct(SortCode,FrontCodeListval,Idx,Code),
		Status = []
	    ;
		parsing_error(If,ERROR_DATATYPE_LITERAL,Status)
	    )
	; Status = Status1
	).
