/* File:      flrarguments.P -- Flora argument type definitions
**
** Author(s): Guizhen Yang
**
** Contact:   kifer@cs.stonybrook.edu
**
** Copyright (C) by
**      The Research Foundation of the State University of New York, 1999-2010.
**
** All rights reserved.
**
** For information about licensing terms, please see
** http://silk.projects.semwebcentral.org/flora2-license.html
**
**
*/


:- compiler_options([xpp_on]).

#include "flora_terms.flh"
#include "flora_exceptions.flh"


%%flora_arguments_spec((findall),3,[FL_OID,FL_BODYFORMULA,FL_OID]) :- !.
%%flora_arguments_spec(call,1,[FL_BODYFORMULA]) :- !.
%%flora_arguments_spec(get_residual,2,[FL_BODYFORMULA,FL_OID]) :- !.

%% Arg1 - func name; Arg2 - arity; Arg3 - argument specs: FL_BODYFORMULA/FL_OID;
%% Arg4: module: Var (e.g., _All) means all modules)
flora_arguments_spec('check',1,[FL_BODYFORMULA],FLSYSMODTYPECHECK) :- !.
flora_arguments_spec('check',2,[FL_BODYFORMULA,FL_OID],FLSYSMODTYPECHECK) :- !.
flora_arguments_spec('mustDefine',2,[FL_OID,FL_BODYFORMULA],FLSYSMODSYSTEM) :- !.
flora_arguments_spec('flora_dump_tables',2,[FL_OID,FL_BODYFORMULA],_) :- !.
flora_arguments_spec('flora_dump_tables',3,[FL_OID,FL_BODYFORMULA,FL_OID],_) :- !.
%% This is not needed any more, since flrgclp/ogclp, etc.,
%% convert status' arg 2 to formulas.
%%flora_arguments_spec(status,2,[FL_OID,FL_BODYFORMULA],FLSYSMODGCLP) :- !.
flora_arguments_spec('_isbasefact',1,[FL_BODYFORMULA],_All) :- !.
flora_arguments_spec(FL_OPPOSES,2,[FL_BODYFORMULA,FL_BODYFORMULA],_All) :- !.
flora_arguments_spec(FL_OPPOSES,4,[FL_OID,FL_BODYFORMULA,FL_OID,FL_BODYFORMULA],_All) :- !.
flora_arguments_spec(FL_OVERRIDES,4,[FL_OID,FL_BODYFORMULA,FL_OID,FL_BODYFORMULA],_All) :- !.
flora_arguments_spec(FL_CANCEL,2,[FL_OID,FL_BODYFORMULA],_All) :- !.

%% Prolog arguments
flora_arguments_spec(FL_IS_INTERNAL,2,[FL_OID,FL_ARITH],_All) :- !.
flora_arguments_spec(FL_MATHEQ,2,[FL_ARITH,FL_ARITH],_All) :- !.
flora_arguments_spec(FL_MATHNOTEQ,2,[FL_ARITH,FL_ARITH],_All) :- !.
flora_arguments_spec(FL_LT,2,[FL_ARITH,FL_ARITH],_All) :- !.
flora_arguments_spec(FL_EQLT,2,[FL_ARITH,FL_ARITH],_All) :- !.
flora_arguments_spec(FL_GT,2,[FL_ARITH,FL_ARITH],_All) :- !.
flora_arguments_spec(FL_EQGT,2,[FL_ARITH,FL_ARITH],_All) :- !.


%% The dynamic part
flora_arguments_spec(Pred,Arity,ArgTypes,Module) :-
	flora_arguments_spec_dyn(Pred,Arity,ArgTypes,Module).

/****************************************************************************
  flora_argdef(+Functor,+Arity,-ArgsTypes,+Module)
  Module: has the form used by the parser
  Asserts argument specifications
****************************************************************************/
flora_argdef(X,Y,Z,ModSpec) :-
	(ModSpec == NULL -> ModName = ModSpec
	;
	    flora_get_module_from_spec(ModSpec,_,ModStruct),
	    flora_get_flatomvar_name(ModStruct,ModName)
	),
	flora_arguments_spec(X,Y,Z,ModName),
	(basics:length(Z,LZ), Y \= LZ
	-> flrprint:flora_error_line('Internal error: function symbol ~w/~w is defined with special argument modes, but the number of modes ~w does not match the arity ~w',
				     [X,Y,LZ,Y]),
	    flrutils:flora_abort('', FLORA_SILENT_ABORT)
	; true
	),
	!.


/****************************************************************************
  flora_set_argdef(+Functor,+Arity,+ArgsTypes,+Module)
  Module: has the form used by the parser
  Sets argument specifications
****************************************************************************/
flora_set_argdef(Pred,Arity,ArgTypes,Module) :-
	(basics:length(ArgTypes,L), Arity \= L
	-> flrprint:flora_error_line('Internal error: function symbol ~w/~w is defined with special argument modes, but the number of modes ~w does not match the arity ~w',
				     [Pred,Arity,L,Arity]),
	    flrutils:flora_abort('', FLORA_SILENT_ABORT)
	; true
	),
	assert(flora_arguments_spec_dyn(Pred,Arity,ArgTypes,Module)).

